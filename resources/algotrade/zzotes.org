algotrading is trading using algorhythms via either computer or manually.
* TODO
which hours make the biggest moves
are there established patterns of movements?
how to determine new day's direction

nuances.py, paderv.py
redo in consistent form

oc.py, dsr.py
develop ideas

ploch.py
figure out what this was supposed to do

ticktalk.py
find plateaus, then launch from them
* sring theory
axioms:
- only many trades produce anything  meaningful
- low sltp ensures overall gains
- pa follows the law of trending inertia
- the invisible becomes visible in lower tf
- if you can't beat em, join em
- noise never annoys

pairs:
sorted l->h by margin and spread
| name   | margin | spread |

| usdcad |   2.0% |    2.0 |
| eurcad |   3.0% |    2.5 |
| audcad |   3.0% |    2.2 |
| audusd |   4.6% |    1.5 |
| eurusd |   4.6% |    1.5 |
| gbpusd |   4.6% |    2.0 |
| nzdusd |   4.6% |    1.7 |
| usdjpy |   5.3% |    1.4 |
| eurgbp |   6.0% |    1.6 |

| usdjpy |   5.3% |    1.4 |
| audusd |   4.6% |    1.5 |
| eurusd |   4.6% |    1.5 |
| eurgbp |   6.0% |    1.6 |
| nzdusd |   4.6% |    1.7 |
| usdcad |   2.0% |    2.0 |
| gbpusd |   4.6% |    2.0 |
| audcad |   3.0% |    2.2 |
| eurcad |   3.0% |    2.5 |

** code
(defn adjacent-confluence
  "
  determines oc confluence behavior of adjacent bars

  (map adjacent-confluence truefx-filepaths)
  (map adjacent-confluence (take 15 truefx-filepaths))
  (mean (map adjacent-confluence (drop 30 truefx-filepaths)))
  "
  [fp]
  (let [[ops his los cls fn pf] (instrument-info fp)
        co (map pips cls ops (repeat pf))
        pn (map #(pos? (* %1 %2)) co (drop 1 co))
        p% (Math/round (/ (count (filter true? pn)) (float (count pn)) 0.01))]
    (printf "%s %d %n" fn p%)
    p%))

(defn nu-finderV1
  "finds a nu given seq, maxmin, midpt of seq"
  [sq maxmin midpt]
  (let [midval (nth sq midpt)]
    (when (= (apply maxmin sq) midval)
      midval)))

(defn anulysisV1
  "analyzes pa near nu"
  [fp]
  (let [[ops his los cls fnm pf] (instrument-info fp)
        buffer (/ 12 pf)
        bounsr? (fn [nus hilos cls >< -+]
                  (count (remove nil?
                                 (for [nu nus [hilo cl] (zip hilos cls)]
                                   (let [nu-buffer (-+ nu buffer)]
                                     (if (and (btn? hilo [nu nu-buffer])
                                              (>< nu-buffer cl))
                                       true))))))
        bpsr? (fn [nus hilos ops cls >< -+]
                (for [nu nus [hilo op cl] (zip hilos ops cls)]
                  (let [b-buffer (-+ nu buffer)
                        p-buffer (-+ nu (- buffer))]
                    (cond (and (btn? hilo [nu b-buffer])
                               (>< b-buffer cl))
                          :bounsr
                          (and (btn? nu [op cl])
                               )
                          :penesr))))
        part-size 5
        midpt (quot part-size 2)
        hi-partition (partition part-size 1 his)
        lo-partition (partition part-size 1 los)
        nn (remove nil? (map #(nu-finder % max midpt) hi-partition))
        uu (remove nil? (map #(nu-finder % min midpt) lo-partition))
        boun-s (bounsr? uu los cls < +)
        boun-r (bounsr? nn his cls > -)

        isbounsr #(= :bounsr %)        
        ispenesr #(= :penesr %)
        bpu (bpsr? uu los ops cls < +)
        bpn (bpsr? nn his ops cls > -)
        ]
    [fnm boun-s boun-r
     (count (filter isbounsr bpu))
     (count (filter isbounsr bpn))
     (count (filter ispenesr bpu))
     (count (filter ispenesr bpn))]))


(map anulysis (take 1 truefx-filepaths))
;; => (["audjpy1D.csv" 3829 3607])
;; => (["audjpy1D.csv" 4167 4035])


* Dynamic SRing theory (DSR)
** intro
1. sr by definition are barriers and therefore should cause bounsr.
2. difficult to know:
   - whether sr will hold (despite 2:1)
   - whether bounsr is in progress or not
   - whether penesr is fake or not
dsr utilizes several concepts from sring theory to create a trading system that is simultaneously robust and active.
** mechanism
dsr chooses maxmin values for c bars to establish sr (similar to donchian channel indicator). understandably, these sr will be dynamic and do not require the formation of nu. rather, we mostly search for horizontal sr (hsr).

types of trades from hsr:
1. bounsr within sr channel
   - en anywhere 6p ahead sr
   - sl 3p beyond sr
   - advance sl to 2p past en to locking brkevn
   - advance sr by fib ratios as each level broken?
2. penesr beyond sr channel
   - en 6p beyond sr
   - sl 3p before sr

** trend determination
calculate strength by difference of successive midpts between sr
calculate intention by difference of the difference

* six candles SIB
to be used with sring theory
orientation of last six to determine direction on 4h
B>S => B
S>B => S
I set breakouts
* comb sring
comb sr formations
these are done on the go though we should keep track of existing 1D, 4H, 1H sr

we look for combs:
1. single wick
   - bars with min hilo 12p
   - c more than 60% from hilo regardless of o
2. dual tower
   - adjacent ud candle combo where hilo almost same for both
   - likely to show as double top in lower tf
3. multiple prongs
   - a price level hit many times
   - the hits may not be adjacent
4. hit imbalance
- an sr can be hit more times above|below indicating direction
- the sr count need not be adjacent

these form sr levels as do the fib particularly r50
- should be used as en points
- they are not necessarily indicators of direction
- ex can be fixed eg 6p or at sr

sltp rule:
sl|tp behind|ahead sr as per comb|nu|fib instead of some abitrary ratio

** algo implementation plan
1. pattern recognition for combs - tfx
2. mock trade pip count - tfx
3. manual entry orders - api prac
4. auto detection and entry orders - api prac
* sring theory original 
utilize sr to enex
** TODO sr should be re-examined
| type   | description                                 | frequency |
| bounsr | bounces off sr reversing original direction | hi 80%    |
| penesr | penetrates sr continuing original direction | lo 20%    |
| meansr | acts as a mean to pa ranging around it      | ra        |

*criteria*
boun-s b>s: b>lo>s cl>b 
boun-r b<r: b<hi<r cl<b
pene-s b<s: lo<b cl<s
pene-r b>r: hi>b cl>r

sr are levels of repellent by definition, causing bounsr primarily.
hit majority, s>r | r>s, can cause penesr and happens in trends
rarely, they will act as meansr causing pa to wobble around the level.

1. horizontal: 
- primarily nu-formed (00100)
- multiple attempts (>2)
- grid levels (whole-numbered)

2. angled tl: 
- channel
- wedge
- triangle

multiple hits strengthen sr, especially if not in close proximity.
dojis can be precursor to breaking sr.
** pa movement
| movement | description                                     | frequency |
| stayer   | maintains same direction after bounsr or penesr | hi        |
| turner   | changes direction that stayer was going in      | me        |
| pusher   | raging pa in one direction often after news     | ra        |

1. most en at sr will bounsr
the 4:1 bounsr-penesr ratio is valid for horizontal sr, but is likely even higher for angled sr. however, with channels, we will obviously have penesr in direction of trend.

2. a penesr en should be considered for
- sr hit majority
  - channel/wedge in direction of trend
  - asc|des triangles
- a plunge in direction of dominant trend followed by lengthy pullback

3. trend determination
mlines 6, 36, 216
can their interplay predict trend change?

4. nuvement
every move involves nunu or unun. these may not be as well-defined in strong trends with higher tf, but can be seen to be taking place in lower ones. these are formed just as ripples by contrarian initiatives as well as profit taking. sometimes sr can shift as a result of nu forming just beyond the sr so the new setup is just as valid as the broken old one was. in these situations, the expected s<->r does not hold.

5. news 
headlines can have major effects on trend, but don't just accept someone's interpretation of it. generally, headlines can be used to confirm a trend.

6. law of trending inertia
price will continue moving in same direction unless forced to do otherwise. therefore, unless we find influences to the contrary in the immediate vicinity, it should be sensible to en in the same direction preferably (though not necessarily) on a pullback.

this concept involves mob psycho behaviors resulting in three types of characters jumpers, swingers, retailers:
- jumpers want to jump on board a trend and thereby keep it going.
- swingers try to pick turning points, but do so at sr and with some rationale thereby not affecting the inertial movement except at specific levels.
- retailers appropriately (re)enter thinking they've found the tail of the trend or (re)enter the actual tail of the trend without realizing it. due to the somewhat random nature and their relative lack of influence, they will primarily add only noise to any trend.
** enex
1d > 4h > 1h sr in same direction as higher tf directional decision
ex losing trade quickly to re-enter optimally
avoid trading btn 14:00-16:00 by removing nearby open orders at 13:00

1. en
- bounsr (most will be these)
- bounsr after penesr because s<->r
- stayer after bounsr or penesr but never near destination sr
- turner once new sr has been established
- pusher if opportunity presents itself
modify sltp appropriately by existing sr
ts protected by newly formed sr

2. ex
use tight sl because since en should be good
don't stay in for long haul because prices fluctuate
make sl stand each day depending on pa
ex trade mostly near suitable sr via tp|ts or on fridays

** zzesearch
*** TODO bounsr and penesr ratio (bpr)
uses bpr.py
bounsr properties
- definition: cl < rm < hi | lo < sm < cl
- strength: number of hits, horizontal + angled
- seems to travel most on bar1

penesr properties
- definition: op < r < cl | op > s > cl
- seems to travel further over 6bars (may be breakout factor?)

the nonesr
how to enter when pa btn sr?
fib layout btn sr.


why bounsr why penesr?
penesr: pa penetrates sr
**** manual stats
 get numbers across current pairs manually btn midjul-midsep
 results below show about 4:1 ratio
 should test this more extensively with truefx
 | pair   | bounsr | penesr |
 | audcad |      7 |      3 |
 | audjpy |      9 |      2 |
 | audnzd |      8 |      2 |
 | audusd |      4 |      2 |
 | cadjpy |      8 |      2 |
 | euraud |     12 |      4 |
 | eurcad |     11 |      1 |
 | eurgbp |      7 |      4 |
 | eurjpy |     11 |      3 |
 | eurnzd |      9 |      1 |
 | eurusd |     11 |      3 |
 | gbpaud |     10 |      2 |
 | gbpcad |     12 |      3 |
 | gbpjpy |      8 |      4 |
 | gbpnzd |     12 |      1 |
 | nzdcad |      9 |      0 |
 | nzdjpy |      6 |      1 |
 | nzdusd |      6 |      1 |
 | usdcad |     10 |      3 |
 | usdjpy |     10 |      4 |
 | totals |    180 |     46 |
**** tfx premature nu 
nu assumed to haved formed first
issue with this is that the nu candle bounces off itself as do the next two thus skewing the ratio in favor of bounsr. on the other hand, the idea is not totally illegitimate because there are multiple bounces before a nu is officially declared.

tfx single candle leave penesr in
1D
| pair   | bounsr | penesr | ratio |
| AUDJPY |   1140 |    292 |     4 |
| AUDNZD |   1203 |    315 |     4 |
| AUDUSD |   1201 |    341 |     4 |
| CADJPY |   1151 |    315 |     4 |
| CHFJPY |   1173 |    302 |     4 |
| EURCHF |   1206 |    247 |     5 |
| EURGBP |   1225 |    349 |     4 |
| EURJPY |   1107 |    298 |     4 |
| EURUSD |   1200 |    329 |     4 |
| GBPJPY |   1115 |    314 |     4 |
| GBPUSD |   1147 |    343 |     3 |
| NZDUSD |   1237 |    322 |     4 |
| USDCAD |   1130 |    316 |     4 |
| USDCHF |   1225 |    345 |     4 |
| USDJPY |   1204 |    295 |     4 |

4H
| pair   | bounsr | penesr | ratio |
| AUDJPY |   7164 |   1615 |     4 |
| AUDNZD |   7441 |   1641 |     5 |
| AUDUSD |   7074 |   1747 |     4 |
| CADJPY |   7121 |   1562 |     5 |
| CHFJPY |   7277 |   1616 |     5 |
| EURCHF |   5948 |   1436 |     4 |
| EURGBP |   6556 |   1433 |     5 |
| EURJPY |   7143 |   1603 |     4 |
| EURUSD |   6943 |   1444 |     5 |
| GBPJPY |  13823 |   3354 |     4 |
| GBPUSD |   6964 |   1421 |     5 |
| NZDUSD |   7239 |   1671 |     4 |
| USDCAD |   6814 |   1488 |     5 |
| USDCHF |   6903 |   1416 |     5 |
| USDJPY |   6889 |   1472 |     5 |

1H
| pair   | bounsr | penesr | ratio |
| AUDJPY |  24551 |   6657 |     4 |
| AUDNZD |  24243 |   6584 |     4 |
| AUDUSD |  21934 |   6600 |     3 |
| CADJPY |  23012 |   6804 |     3 |
| CHFJPY |  24993 |   6528 |     4 |
| EURCHF |  14742 |   5922 |     2 |
| EURGBP |  16008 |   6163 |     3 |
| EURJPY |  26159 |   6237 |     4 |
| EURUSD |  22437 |   6230 |     4 |
| GBPJPY |  27664 |   6330 |     4 |
| GBPUSD |  24081 |   6082 |     4 |
| NZDUSD |  21934 |   6476 |     3 |
| USDCAD |  20547 |   6879 |     3 |
| USDCHF |  19665 |   6162 |     3 |
| USDJPY |  21149 |   6031 |     4 |


tfx single candle take penelimit 2
1D

| AUDJPY | 1113 | 275 | 4 |
| AUDNZD | 1147 | 285 | 4 |
| AUDUSD | 1135 | 313 | 4 |
| CADJPY | 1112 | 308 | 4 |
| CHFJPY | 1115 | 283 | 4 |
| EURCHF | 1160 | 234 | 5 |
| EURGBP | 1167 | 360 | 3 |
| EURJPY | 1061 | 272 | 4 |
| EURUSD | 1130 | 297 | 4 |
| GBPJPY | 1075 | 310 | 3 |
| GBPUSD | 1101 | 308 | 4 |
| NZDUSD | 1175 | 290 | 4 |
| USDCAD | 1062 | 290 | 4 |
| USDCHF | 1157 | 299 | 4 |
| USDJPY | 1116 | 277 | 4 |



4H

| AUDJPY |  6880 | 1535 | 4 |
| AUDNZD |  7161 | 1604 | 4 |
| AUDUSD |  6763 | 1720 | 4 |
| CADJPY |  6888 | 1536 | 4 |
| CHFJPY |  7010 | 1586 | 4 |
| EURCHF |  5905 | 1627 | 4 |
| EURGBP |  6384 | 1456 | 4 |
| EURJPY |  6941 | 1500 | 5 |
| EURUSD |  6685 | 1405 | 5 |
| GBPJPY | 13349 | 3112 | 4 |
| GBPUSD |  6787 | 1367 | 5 |
| NZDUSD |  6916 | 1601 | 4 |
| USDCAD |  6612 | 1479 | 4 |
| USDCHF |  6724 | 1431 | 5 |
| USDJPY |  6682 | 1438 | 5 |



1H

| AUDJPY | 23991 | 6797 | 4 |
| AUDNZD | 23810 | 6699 | 4 |
| AUDUSD | 21501 | 7226 | 3 |
| CADJPY | 22618 | 7301 | 3 |
| CHFJPY | 24216 | 6753 | 4 |
| EURCHF | 15184 | 6721 | 2 |
| EURGBP | 16138 | 7111 | 2 |
| EURJPY | 25543 | 6417 | 4 |
| EURUSD | 21953 | 6824 | 3 |
| GBPJPY | 26578 | 6302 | 4 |
| GBPUSD | 23663 | 6558 | 4 |
| NZDUSD | 21457 | 6994 | 3 |
| USDCAD | 20366 | 7527 | 3 |
| USDCHF | 19478 | 6968 | 3 |
| USDJPY | 21093 | 6743 | 3 |


tfx single candle simple
bounsr: hilo penetrates sr-10p and closes inside sr
penesr: sr isbtn oc; s<->r, then sr->nstack

1D
| pair   | boun | pene | ratio |
| AUDJPY |  897 |  143 |     6 |
| AUDNZD |  945 |  166 |     6 |
| AUDUSD |  919 |  168 |     5 |
| CADJPY |  897 |  165 |     5 |
| CHFJPY |  875 |  155 |     6 |
| EURCHF | 1274 |  130 |    10 |
| EURGBP |  989 |  179 |     6 |
| EURJPY |  871 |  150 |     6 |
| EURUSD |  892 |  157 |     6 |
| GBPJPY |  818 |  159 |     5 |
| GBPUSD |  837 |  165 |     5 |
| NZDUSD |  958 |  161 |     6 |
| USDCAD |  879 |  149 |     6 |
| USDCHF |  898 |  159 |     6 |
| USDJPY |  940 |  154 |     6 |

4H
| pair   |  boun | pene | ratio |
| AUDJPY |  6985 |  864 |     8 |
| AUDNZD |  7716 |  879 |     9 |
| AUDUSD |  7317 |  935 |     8 |
| CADJPY |  7182 |  861 |     8 |
| CHFJPY |  7094 |  889 |     8 |
| EURCHF |  9710 |  914 |    11 |
| EURGBP |  8391 |  866 |    10 |
| EURJPY |  6541 |  881 |     7 |
| EURUSD |  7077 |  831 |     9 |
| GBPJPY | 11981 | 1776 |     7 |
| GBPUSD |  6614 |  833 |     8 |
| NZDUSD |  7425 |  897 |     8 |
| USDCAD |  7423 |  860 |     9 |
| USDCHF |  7890 |  853 |     9 |
| USDJPY |  7778 |  858 |     9 |

1H
| pair   |  boun | pene | ratio |
| AUDJPY | 37896 | 3629 |    10 |
| AUDNZD | 40911 | 3526 |    12 |
| AUDUSD | 38749 | 3748 |    10 |
| CADJPY | 38910 | 3795 |    10 |
| CHFJPY | 38027 | 3562 |    11 |
| EURCHF | 47720 | 3723 |    13 |
| EURGBP | 46031 | 3826 |    12 |
| EURJPY | 35407 | 3476 |    10 |
| EURUSD | 37956 | 3655 |    10 |
| GBPJPY | 32218 | 3391 |    10 |
| GBPUSD | 36602 | 3511 |    10 |
| NZDUSD | 39352 | 3635 |    11 |
| USDCAD | 39240 | 3927 |    10 |
| USDCHF | 41625 | 3721 |    11 |
| USDJPY | 41367 | 3698 |    11 |


bounsr: hilo penetrates sr-10p and closes inside sr-10p
penesr: sr isbtn oc; s<->r, then sr->nstack

1D
| pair   | boun | pene | ratio |
| AUDJPY |  832 |  143 |     6 |
| AUDNZD |  858 |  166 |     5 |
| AUDUSD |  840 |  168 |     5 |
| CADJPY |  819 |  164 |     5 |
| CHFJPY |  811 |  155 |     5 |
| EURCHF |  931 |  129 |     7 |
| EURGBP |  863 |  179 |     5 |
| EURJPY |  813 |  150 |     5 |
| EURUSD |  835 |  157 |     5 |
| GBPJPY |  782 |  159 |     5 |
| GBPUSD |  788 |  164 |     5 |
| NZDUSD |  879 |  161 |     5 |
| USDCAD |  797 |  148 |     5 |
| USDCHF |  813 |  158 |     5 |
| USDJPY |  852 |  154 |     6 |

4H
| pair   |  boun | pene | ratio |
| AUDJPY |  5508 |  864 |     6 |
| AUDNZD |  5953 |  879 |     7 |
| AUDUSD |  5476 |  935 |     6 |
| CADJPY |  5529 |  861 |     6 |
| CHFJPY |  5694 |  889 |     6 |
| EURCHF |  5225 |  914 |     6 |
| EURGBP |  5396 |  866 |     6 |
| EURJPY |  5458 |  881 |     6 |
| EURUSD |  5508 |  831 |     7 |
| GBPJPY | 10465 | 1776 |     6 |
| GBPUSD |  5471 |  833 |     7 |
| NZDUSD |  5539 |  897 |     6 |
| USDCAD |  5484 |  860 |     6 |
| USDCHF |  5671 |  853 |     7 |
| USDJPY |  5558 |  858 |     6 |

1H
| pair   |  boun | pene | ratio |
| AUDJPY | 21207 | 3629 |     6 |
| AUDNZD | 21928 | 3526 |     6 |
| AUDUSD | 19098 | 3748 |     5 |
| CADJPY | 20048 | 3795 |     5 |
| CHFJPY | 21413 | 3562 |     6 |
| EURCHF | 14845 | 3723 |     4 |
| EURGBP | 15769 | 3826 |     4 |
| EURJPY | 21868 | 3476 |     6 |
| EURUSD | 19351 | 3655 |     5 |
| GBPJPY | 22280 | 3391 |     7 |
| GBPUSD | 20578 | 3511 |     6 |
| NZDUSD | 19427 | 3635 |     5 |
| USDCAD | 18125 | 3927 |     5 |
| USDCHF | 17965 | 3721 |     5 |
| USDJPY | 19026 | 3698 |     5 |

***** code srmanager v1
def srmanager(fil, df, pcf):
    '''
    manages sr from nu in df

    sr stacks of indices from df to track whether nu s<->r or disappears
    properties:
    1. df.nu[i] gives value of sr
    2. df.bounsr tracks how many bounces
    3. df.penesr tracks penetrations 0 -> 1 => move to other -> 2 => remove
    '''

    # set up r and s stacks
    rstack = deque()  # resistance
    sstack = deque()  # support
    nstack = deque()  # nulled
    m = 10/pcf

    for i in df.index:
        if df.n[i] != 0.0:  # add n to rstack
            rstack.append(i)
        if df.u[i] != 0.0:  # add u to sstack
            sstack.append(i)

        if rstack and sstack:
            hi = df.high[i]
            lo = df.low[i]
            cl = df.close[i]
            op = df.open[i]

            if rstack:
                # r boun
                ri = rstack[-1]
                r = df.n[ri]
                rm = r-m
                if (hi > rm) and (cl < rm):
                    df.loc[ri, 'rboun'] += 1
                # r pene
                if (op < r < cl):
                    df.loc[ri, 'rpene'] += 1  # rpene set to 1
                    if df.spene[ri] == 1:  # if spene also 1
                        nstack.append(rstack.pop())  # remove to null
                    else:  # otherwise
                        sstack.append(rstack.pop())  # move index to sstack
            if sstack:
                si = sstack[-1]
                s = df.u[si]
                sm = s+m
                # s boun
                if (lo < sm) and (cl > sm):
                    df.loc[si, 'sboun'] += 1
                # s pene
                if (op > s > cl):
                    df.loc[si, 'spene'] += 1  # spene set to 1
                    if df.rpene[si] == 1:  # if rpene also 1
                        nstack.append(sstack.pop())  # remove to null
                    else:
                        rstack.append(sstack.pop())  # move index to rstack

    rboun = sum(df.rboun)
    sboun = sum(df.sboun)
    tboun = rboun + sboun
    rpene = sum(df.rpene)
    spene = sum(df.spene)
    tpene = rpene + spene

    # print('tboun:tpene : {}:{} = {}'.format(tboun, tpene, round(tboun/tpene)))
    prnt(fil, tboun, tpene, round(tboun/tpene))

**** tfx official nu
Timeframe = 1D

AUDJPY 658 342 2 
AUDNZD 670 368 2 
AUDUSD 660 393 2 
CADJPY 641 374 2 
CHFJPY 644 376 2 
EURCHF 715 331 2 
EURGBP 686 402 2 
EURJPY 607 381 2 
EURUSD 626 369 2 
GBPJPY 652 377 2 
GBPUSD 642 384 2 
NZDUSD 706 382 2 
USDCAD 609 329 2 
USDCHF 607 353 2 
USDJPY 676 380 2 


Timeframe = 4H

AUDJPY 4279 2023 2 
AUDNZD 4646 1982 2 
AUDUSD 4294 2081 2 
CADJPY 4328 2043 2 
CHFJPY 4303 2086 2 
EURCHF 4250 1975 2 
EURGBP 4249 1936 2 
EURJPY 4138 2063 2 
EURUSD 4054 2024 2 
GBPJPY 7756 4186 2 
GBPUSD 3964 2043 2 
NZDUSD 4358 2082 2 
USDCAD 4142 1988 2 
USDCHF 4320 1962 2 
USDJPY 4384 2050 2 


Timeframe = 1H

AUDJPY 17690 7997 2 
AUDNZD 18763 7679 2 
AUDUSD 16517 8277 2 
CADJPY 17048 8258 2 
CHFJPY 17955 8014 2 
EURCHF 12714 7223 2 
EURGBP 13469 7487 2 
EURJPY 17979 7973 2 
EURUSD 16487 7941 2 
GBPJPY 17725 7997 2 
GBPUSD 16953 7970 2 
NZDUSD 16754 8064 2 
USDCAD 15750 8105 2 
USDCHF 15441 7712 2 
USDJPY 16432 7907 2 

**** tfx offical nu with 6bar summaries
Timeframe = 1D

AUDJPY 658 342 2 

bounsr summary
             bar1        bar2        bar3        bar4        bar5        bar6
count  658.000000  658.000000  658.000000  658.000000  658.000000  658.000000
mean    84.646809   93.994605   96.241983   95.624696   90.979255   88.791489
std     52.448659   66.442712   93.546442  112.991151  127.761753  138.384995
min     14.550000 -101.750000 -208.900000 -425.650000 -514.100000 -601.100000
25%     52.262500   53.200000   41.425000   31.650000   19.062500    3.487500
50%     74.200000   76.900000   86.475000   88.000000   88.600000   81.800000
75%    101.425000  120.175000  136.675000  151.262500  160.425000  164.750000
max    578.950000  777.950000  811.900000  665.850000  759.050000  773.550000

penesr summary
             bar1        bar2        bar3        bar4        bar5        bar6
count  342.000000  342.000000  342.000000  342.000000  342.000000  342.000000
mean    63.289766   94.484357   98.389766   97.462865   95.648684   94.333772
std     45.913169   77.070822  103.782248  127.683572  144.407592  153.685528
min      1.250000  -24.000000 -120.800000 -284.750000 -393.250000 -425.650000
25%     30.900000   46.987500   30.500000   20.487500    0.612500   -8.825000
50%     50.925000   79.775000   84.525000   89.775000   91.525000   89.925000
75%     83.862500  120.075000  146.675000  158.900000  169.187500  178.012500
max    295.150000  817.650000  614.600000  811.900000  759.050000  773.550000


AUDNZD 670 368 2 

bounsr summary
             bar1        bar2        bar3        bar4        bar5        bar6
count  670.000000  670.000000  670.000000  670.000000  670.000000  670.000000
mean    72.087463   79.726418   79.038209   79.644328   79.375373   79.949403
std     35.650895   50.536839   68.251836   82.368538   93.917460  109.945672
min     13.700000 -100.500000 -134.300000 -174.800000 -285.400000 -307.200000
25%     47.700000   43.900000   35.475000   28.375000   12.375000    1.100000
50%     63.300000   67.700000   71.850000   74.500000   75.450000   75.900000
75%     88.200000  107.250000  118.800000  127.350000  138.150000  147.000000
max    280.300000  331.400000  322.900000  441.600000  467.800000  690.500000

penesr summary
             bar1        bar2        bar3        bar4        bar5        bar6
count  368.000000  368.000000  368.000000  368.000000  368.000000  368.000000
mean    53.139402   73.358424   69.047283   70.711957   69.116304   73.700000
std     37.304816   50.827061   65.812464   80.825489   94.034511  109.115501
min      2.600000 -100.500000 -120.400000 -213.900000 -242.100000 -245.200000
25%     28.700000   38.575000   26.450000   17.575000    8.575000    1.600000
50%     46.250000   62.800000   66.350000   72.350000   71.100000   73.450000
75%     69.025000   99.875000  103.825000  120.250000  129.625000  141.475000
max    393.900000  288.500000  331.600000  357.800000  369.900000  441.100000


AUDUSD 660 393 2 

bounsr summary
             bar1        bar2        bar3        bar4        bar5        bar6
count  660.000000  660.000000  660.000000  660.000000  660.000000  660.000000
mean    74.683636   79.974242   76.295909   74.776970   74.054394   74.870606
std     37.232187   47.286328   71.864143   88.405502  105.428431  116.863818
min     13.600000  -61.700000 -158.100000 -313.000000 -342.600000 -330.700000
25%     48.800000   44.175000   29.700000   21.075000   10.975000   -1.000000
50%     68.150000   69.700000   69.000000   72.200000   69.400000   71.600000
75%     90.225000  107.125000  115.925000  122.850000  137.100000  148.450000
max    282.800000  281.400000  356.000000  417.800000  672.800000  606.300000

penesr summary
             bar1        bar2        bar3        bar4        bar5        bar6
count  393.000000  393.000000  393.000000  393.000000  393.000000  393.000000
mean    53.520865   71.345802   70.002799   67.500254   66.844784   68.860305
std     37.617340   51.062888   74.390041   84.113371   96.853190  112.132229
min      1.600000  -59.000000 -158.100000 -152.200000 -193.800000 -320.600000
25%     28.100000   37.000000   22.900000    9.400000    7.800000    4.700000
50%     46.700000   63.100000   62.700000   60.000000   64.200000   62.600000
75%     67.500000   95.500000  105.400000  112.200000  123.100000  132.600000
max    282.800000  488.500000  511.200000  424.500000  557.800000  691.500000


CADJPY 641 374 2 

bounsr summary
             bar1        bar2        bar3        bar4        bar5        bar6
count  641.000000  641.000000  641.000000  641.000000  641.000000  641.000000
mean    79.622699   93.178861   90.144228   91.327067   89.882293   86.050546
std     45.695820   63.558826   86.270274  102.865615  121.301507  132.515276
min     14.850000   -2.150000 -199.450000 -274.600000 -357.200000 -357.200000
25%     50.950000   50.350000   36.350000   27.000000   14.150000    7.750000
50%     70.850000   78.500000   80.600000   83.250000   80.500000   76.350000
75%     96.000000  118.700000  130.750000  143.350000  149.950000  157.950000
max    605.350000  605.350000  605.350000  550.400000  803.100000  650.800000

penesr summary
             bar1        bar2        bar3        bar4        bar5        bar6
count  374.000000  374.000000  374.000000  374.000000  374.000000  374.000000
mean    59.830481   85.797594   85.879011   84.556150   89.260561   91.999198
std     44.094846   70.297597   84.307605   97.975245  117.771851  131.725266
min      4.900000  -29.450000  -99.900000 -128.100000 -162.400000 -202.650000
25%     32.562500   39.575000   29.162500   17.575000    2.612500    6.775000
50%     49.225000   72.800000   78.250000   80.525000   77.975000   80.950000
75%     76.387500  116.125000  131.175000  143.275000  153.037500  163.675000
max    348.950000  665.700000  532.250000  525.950000  693.100000  803.100000


CHFJPY 644 376 2 

bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count   644.000000   644.000000   644.000000   644.000000   644.000000   644.000000
mean     90.948098    96.361724    92.226941    93.751630    89.955978    86.863199
std     201.568519   108.925585   116.393441   148.531643   181.104642   192.796800
min      15.100000   -46.400000  -226.700000 -1516.200000 -1660.550000 -1678.650000
25%      50.975000    47.362500    34.362500    26.000000    14.762500    -1.862500
50%      72.450000    78.750000    80.350000    82.975000    81.525000    79.325000
75%     102.525000   122.050000   131.725000   148.462500   156.450000   163.875000
max    5007.575000  2195.400000  2018.850000  1938.100000  2131.750000  2136.950000

penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count   376.000000   376.000000   376.000000   376.000000   376.000000   376.000000
mean     82.771210    95.279787    93.260638    95.896941    96.645612    90.263963
std     266.597735   132.519961   138.927544   156.195802   175.964215   201.134744
min       0.550000    -7.400000  -154.300000  -376.200000  -576.300000 -1516.200000
25%      33.287500    43.437500    30.887500    22.637500    19.900000     3.675000
50%      49.800000    71.900000    72.650000    77.175000    77.075000    77.600000
75%      76.837500   114.762500   128.687500   142.250000   151.537500   159.175000
max    5007.575000  2195.400000  2018.850000  1938.100000  2131.750000  2136.950000


EURCHF 715 331 2 

bounsr summary
             bar1        bar2        bar3         bar4         bar5         bar6
count  715.000000  715.000000  715.000000   715.000000   715.000000   715.000000
mean    55.419720   58.672308   58.515804    59.648112    59.265874    58.722797
std     44.038019   49.823871   59.859478    80.845496    88.622705    93.907372
min     12.700000 -134.700000 -153.100000  -236.200000  -443.700000  -528.600000
25%     30.000000   29.950000   24.250000    21.200000    17.850000    15.250000
50%     45.500000   46.200000   46.000000    45.200000    43.300000    42.400000
75%     67.800000   71.000000   75.850000    79.100000    84.550000    91.200000
max    638.300000  599.200000  604.700000  1205.700000  1122.900000  1191.600000

penesr summary
             bar1        bar2        bar3        bar4        bar5        bar6
count  331.000000  331.000000  331.000000  331.000000  331.000000  331.000000
mean    40.858912   52.438066   50.628701   49.094260   47.027190   42.669184
std     51.673617   71.000417   81.771804   90.607507   96.592192  106.715214
min      1.000000  -80.300000 -114.200000 -205.400000 -365.200000 -475.000000
25%     14.900000   17.800000    8.750000    4.800000    1.300000   -2.250000
50%     27.900000   34.000000   30.100000   29.100000   29.000000   26.200000
75%     47.300000   63.150000   62.150000   63.800000   65.200000   67.850000
max    635.700000  638.300000  621.600000  626.800000  690.400000  644.700000


EURGBP 686 402 2 

bounsr summary
             bar1        bar2        bar3        bar4        bar5        bar6
count  686.000000  686.000000  686.000000  686.000000  686.000000  686.000000
mean    56.888484   62.215743   60.894169   60.231924   59.631050   60.907580
std     29.495548   39.695806   59.980908   64.409673   74.806965   85.340346
min     14.100000  -68.900000 -106.400000 -163.000000 -193.000000 -243.900000
25%     37.925000   36.025000   25.800000   19.500000    8.725000    1.825000
50%     50.050000   53.700000   50.850000   54.600000   58.950000   59.600000
75%     67.350000   78.650000   89.175000   97.875000  103.775000  109.475000
max    326.400000  389.700000  775.000000  381.400000  392.400000  421.900000

penesr summary
             bar1        bar2        bar3        bar4        bar5        bar6
count  402.000000  402.000000  402.000000  402.000000  402.000000  402.000000
mean    38.869652   54.674627   54.088308   52.874876   49.312189   49.204726
std     26.962707   39.869384   63.545289   66.815906   76.693605   83.884736
min      3.000000  -45.600000 -106.400000 -163.000000 -193.000000 -191.800000
25%     22.000000   28.425000   18.425000   11.400000   -1.450000   -9.350000
50%     33.350000   47.650000   48.550000   50.100000   48.850000   48.550000
75%     50.075000   74.550000   81.100000   89.125000   93.425000   98.375000
max    326.400000  389.700000  775.000000  381.400000  392.400000  421.900000


EURJPY 607 381 2 

bounsr summary
             bar1         bar2        bar3        bar4        bar5        bar6
count  607.000000   607.000000  607.000000  607.000000  607.000000  607.000000
mean   105.109638   117.074053  114.414662  115.870923  108.839292  105.078830
std     57.551625    90.999851  113.809605  138.456809  157.754923  165.254207
min     17.100000   -41.450000 -161.850000 -213.450000 -342.850000 -342.850000
25%     65.175000    58.325000   42.575000   27.225000    2.600000   -3.700000
50%     93.900000    95.900000   93.700000   99.350000   94.150000   88.800000
75%    128.450000   150.025000  174.775000  192.450000  192.900000  207.800000
max    427.450000  1130.650000  942.150000  887.450000  800.400000  760.650000

penesr summary
             bar1        bar2        bar3        bar4        bar5        bar6
count  381.000000  381.000000  381.000000  381.000000  381.000000  381.000000
mean    81.738976  105.877165  103.757612  104.070210  108.969554  107.609580
std     68.999805   78.476318  111.978186  138.363318  157.001007  172.330909
min      1.250000  -41.750000 -334.550000 -337.250000 -387.950000 -409.300000
25%     40.100000   47.000000   32.550000   18.500000   11.950000   -9.900000
50%     66.350000   90.150000   82.900000   97.900000  105.100000  106.050000
75%    102.900000  143.200000  169.100000  180.000000  192.100000  202.300000
max    600.650000  443.100000  525.950000  621.900000  770.400000  800.400000


EURUSD 626 369 2 

bounsr summary
             bar1        bar2        bar3        bar4        bar5        bar6
count  626.000000  626.000000  626.000000  626.000000  626.000000  626.000000
mean    87.973802   94.950639   92.124441   90.724920   93.092492   96.336102
std     45.314403   62.935663   91.468640  111.755774  129.093866  144.146385
min     15.200000  -55.700000 -223.700000 -437.000000 -365.500000 -320.400000
25%     57.325000   52.450000   36.500000   18.200000   11.400000   -0.450000
50%     77.950000   80.000000   81.050000   80.350000   89.350000   90.000000
75%    109.075000  122.675000  137.250000  150.250000  172.225000  178.750000
max    348.500000  468.600000  539.100000  625.800000  625.800000  707.500000

penesr summary
             bar1        bar2        bar3        bar4        bar5        bar6
count  369.000000  369.000000  369.000000  369.000000  369.000000  369.000000
mean    65.240379   85.729539   87.112195   85.247696   86.696206   88.560163
std     45.718757   60.414818   84.158349  108.014570  120.796748  137.739742
min      4.500000  -89.200000 -135.800000 -437.000000 -365.500000 -320.400000
25%     34.300000   46.500000   33.300000   18.000000   13.300000    0.200000
50%     54.200000   72.200000   76.500000   76.000000   77.800000   75.800000
75%     84.600000  115.400000  129.400000  144.200000  156.000000  164.500000
max    338.500000  432.700000  506.400000  604.600000  506.400000  565.000000


GBPJPY 652 377 2 

bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count   652.000000   652.000000   652.000000   652.000000   652.000000   652.000000
mean    139.737813   159.892100   161.816495   147.413494   153.272399   154.444167
std     350.086718   366.642078   380.271002   211.963052   250.792329   269.514226
min      17.600000   -29.450000  -309.899000 -1554.450000 -1584.350000 -1584.350000
25%      73.450000    71.200000    54.700000    39.637500    25.237500     9.550000
50%     106.500000   114.150000   123.050000   129.875000   131.925000   140.550000
75%     154.837500   181.412500   212.000000   243.262500   262.600000   279.412500
max    8796.650000  8796.650000  8796.650000  2370.750000  2212.400000  2209.050000

penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count   377.000000   377.000000   377.000000   377.000000   377.000000   377.000000
mean    106.858881   153.470292   149.452658   149.475724   153.311944   159.354109
std     105.587011   159.631643   185.718860   211.329226   246.125946   267.950054
min       7.700000   -21.750000  -240.750000  -280.800000 -1554.450000 -1584.350000
25%      52.500000    67.400000    46.950000    27.600000     7.850000    13.850000
50%      84.400000   116.900000   117.100000   129.850000   141.400000   152.450000
75%     130.850000   188.400000   223.850000   250.700000   275.000000   301.600000
max    1210.850000  2000.850000  1995.600000  1900.750000  1742.400000  1739.050000


GBPUSD 642 384 2 

bounsr summary
             bar1        bar2        bar3         bar4         bar5         bar6
count  642.000000  642.000000  642.000000   642.000000   642.000000   642.000000
mean    96.653271  106.809657  105.473364   103.052336   100.789408    97.566822
std     48.649867   63.976492   93.361849   138.825753   152.609325   171.803393
min     18.300000  -26.300000 -205.800000 -1255.000000 -1310.100000 -1196.300000
25%     62.750000   59.600000   39.650000    25.550000    16.700000    -0.375000
50%     86.350000   91.450000  103.200000   105.400000   100.600000    98.950000
75%    121.100000  140.700000  162.650000   174.525000   182.025000   192.950000
max    472.200000  441.000000  440.000000  1501.100000  1609.700000  1510.500000

penesr summary
             bar1         bar2         bar3         bar4         bar5         bar6
count  384.000000   384.000000   384.000000   384.000000   384.000000   384.000000
mean    73.146354   105.457031   102.141667    98.389062    97.576562    95.008073
std     49.484066    99.698882   122.444422   168.206431   173.052511   193.569152
min      6.700000   -52.200000  -205.800000 -1255.000000 -1310.100000 -1196.300000
25%     38.575000    53.700000    39.750000    19.525000     9.575000   -19.300000
50%     64.350000    87.700000    94.950000   100.950000   106.950000   103.200000
75%     95.425000   136.825000   157.875000   164.300000   182.350000   203.000000
max    440.000000  1501.100000  1609.700000  1510.500000  1442.500000  1523.600000


NZDUSD 706 382 2 

bounsr summary
             bar1        bar2        bar3        bar4        bar5        bar6
count  706.000000  706.000000  706.000000  706.000000  706.000000  706.000000
mean    73.654108   81.242635   78.777054   79.528470   78.070963   78.203399
std     36.403235   46.680554   69.216773   84.091464   95.579229  105.896518
min     14.800000  -44.000000 -110.000000 -167.600000 -192.900000 -251.800000
25%     47.400000   46.475000   33.500000   24.250000   11.000000    7.800000
50%     65.800000   70.750000   73.850000   74.050000   77.700000   75.950000
75%     93.275000  104.750000  114.950000  128.625000  132.275000  138.725000
max    389.200000  327.500000  423.000000  433.100000  416.200000  418.400000

penesr summary
             bar1        bar2        bar3        bar4        bar5        bar6
count  382.000000  382.000000  382.000000  382.000000  382.000000  382.000000
mean    52.599215   69.710471   65.856021   63.178534   65.319110   64.653141
std     35.178645   48.874793   66.581853   80.349672   96.119789  104.221729
min      2.800000 -148.400000 -164.500000 -172.700000 -223.600000 -212.100000
25%     30.075000   37.900000   24.150000   14.725000    3.575000   -2.400000
50%     45.150000   61.800000   61.250000   59.850000   64.500000   63.800000
75%     66.550000   93.800000  104.900000  108.725000  119.325000  129.100000
max    276.800000  366.900000  395.500000  398.900000  545.100000  446.200000


USDCAD 609 329 2 

bounsr summary
             bar1        bar2        bar3        bar4        bar5        bar6
count  609.000000  609.000000  609.000000  609.000000  609.000000  609.000000
mean    75.183087   85.484401   85.100657   88.866174   90.444499   89.628079
std     37.669254   50.665233   75.832757   95.395774  109.710516  122.255858
min     14.600000  -32.700000 -205.800000 -167.900000 -195.900000 -245.700000
25%     47.100000   47.300000   38.200000   19.900000   19.200000    5.000000
50%     69.500000   76.800000   77.400000   84.100000   84.200000   82.600000
75%     94.400000  111.200000  132.200000  150.400000  159.500000  174.500000
max    370.900000  331.500000  350.900000  531.500000  519.200000  520.000000

penesr summary
             bar1        bar2        bar3        bar4        bar5        bar6
count  329.000000  329.000000  329.000000  329.000000  329.000000  329.000000
mean    57.461094   81.365957   77.760486   76.455015   78.606991   77.845897
std     41.841074   57.787855   79.222536  100.074021  117.429280  128.664554
min      2.300000  -37.300000 -150.700000 -169.000000 -245.300000 -285.700000
25%     29.600000   39.000000   23.800000   10.000000    5.400000   -3.600000
50%     45.200000   70.400000   69.500000   70.600000   73.200000   76.200000
75%     77.400000  109.700000  120.200000  135.200000  157.400000  157.400000
max    243.000000  360.600000  319.200000  531.500000  519.200000  477.000000


USDCHF 607 353 2 

bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count   607.000000   607.000000   607.000000   607.000000   607.000000   607.000000
mean     78.892998    89.230560    88.376359    85.099671    83.130643    82.212685
std     170.798268   185.682403   202.155836   139.615823   148.407019   155.907312
min      13.800000     5.600000  -144.800000  -158.600000  -275.800000  -275.800000
25%      45.400000    45.450000    34.900000    25.450000    13.250000     4.400000
50%      64.600000    69.300000    70.200000    71.600000    71.400000    73.100000
75%      86.750000   100.950000   112.350000   123.950000   133.950000   136.750000
max    4152.050000  4152.050000  4152.050000  1767.600000  1720.800000  1720.800000

penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count   353.000000   353.000000   353.000000   353.000000   353.000000   353.000000
mean     61.180878    72.074221    68.288669    71.406232    72.766572    77.724646
std     216.924650   102.510555   110.326033   116.539018   131.207723   143.526147
min       1.400000   -38.100000  -144.800000  -186.100000  -246.200000  -260.800000
25%      26.000000    32.600000    19.800000    13.600000     8.400000    -0.900000
50%      40.000000    55.400000    57.600000    58.000000    64.500000    69.400000
75%      63.800000    90.600000    98.200000   112.400000   125.500000   136.300000
max    4052.050000  1667.600000  1577.900000  1432.300000  1620.800000  1599.900000


USDJPY 676 380 2 

bounsr summary
             bar1        bar2        bar3        bar4        bar5        bar6
count  676.000000  676.000000  676.000000  676.000000  676.000000  676.000000
mean    72.666124   81.099408   79.269601   79.538905   78.589497   80.385429
std     46.960615   61.390663   86.209334  102.772859  118.919970  129.865087
min     14.150000  -21.650000 -225.550000 -479.300000 -508.900000 -541.450000
25%     43.875000   42.800000   30.450000   23.675000    8.075000   -0.725000
50%     62.400000   65.100000   66.975000   67.225000   67.900000   70.325000
75%     87.500000   99.962500  113.912500  123.600000  137.162500  144.137500
max    408.500000  552.000000  616.450000  625.050000  683.850000  725.750000

penesr summary
             bar1        bar2        bar3        bar4        bar5        bar6
count  380.000000  380.000000  380.000000  380.000000  380.000000  380.000000
mean    59.329605   75.719211   75.324079   77.433421   75.591316   73.327500
std     51.592860   58.461237   89.090061  103.284885  119.743353  131.314815
min      3.600000  -13.600000 -187.900000 -308.900000 -331.750000 -479.300000
25%     27.462500   36.837500   24.600000   17.587500    6.300000   -6.537500
50%     46.750000   57.575000   64.225000   62.300000   63.050000   62.325000
75%     75.050000  100.050000  107.212500  119.225000  135.925000  139.050000
max    459.900000  433.850000  739.250000  600.600000  645.150000  711.750000




Timeframe = 4H

AUDJPY 4279 2023 2 

bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  4279.000000  4279.000000  4279.000000  4279.000000  4279.000000  4279.000000
mean     41.597558    46.265786    45.454312    45.653237    45.272529    44.976688
std      22.810774    28.696131    38.288074    46.618147    53.707513    61.095213
min      12.500000   -64.050000  -240.100000  -258.250000  -211.050000  -240.100000
25%      27.575000    27.900000    22.575000    18.300000    14.350000    10.075000
50%      36.350000    39.300000    39.750000    40.700000    40.500000    40.250000
75%      49.250000    55.975000    62.525000    67.500000    71.275000    74.800000
max     477.950000   451.900000   344.450000   344.450000   448.950000   757.650000

penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  2023.000000  2023.000000  2023.000000  2023.000000  2023.000000  2023.000000
mean     28.004572    37.336209    36.429338    37.653164    36.445897    37.676718
std      28.070830    32.494869    41.199680    50.315484    56.002547    62.707065
min       0.650000   -51.750000   -98.300000  -162.750000  -249.050000  -240.100000
25%      12.425000    16.925000    12.100000     7.700000     2.675000     2.100000
50%      21.400000    29.900000    29.650000    30.400000    30.600000    31.900000
75%      35.450000    48.900000    54.525000    61.300000    64.250000    68.525000
max     647.950000   526.750000   451.900000   322.000000   302.650000   403.150000


AUDNZD 4646 1982 2 

bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  4646.000000  4646.000000  4646.000000  4646.000000  4646.000000  4646.000000
mean     37.836634    41.697460    41.750581    42.081489    41.951356    41.714851
std      21.340621    23.271565    31.582260    38.150104    42.960919    48.938603
min      12.800000   -80.500000   -96.200000   -90.800000  -165.200000  -204.600000
25%      26.300000    26.900000    23.025000    19.425000    16.425000    12.800000
50%      33.300000    36.600000    37.900000    38.400000    38.900000    38.800000
75%      43.500000    50.000000    56.200000    60.600000    63.875000    67.100000
max     539.900000   363.400000   539.900000   539.900000   272.100000   539.900000

penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  1982.000000  1982.000000  1982.000000  1982.000000  1982.000000  1982.000000
mean     23.706054    30.812109    30.840212    31.184813    31.084460    30.921847
std      22.685748    24.027149    31.784979    39.124933    43.472456    48.261601
min       0.400000   -80.500000  -104.900000  -174.600000  -154.200000  -179.600000
25%      10.600000    14.600000    11.200000     7.500000     4.600000     2.400000
50%      18.100000    24.900000    25.400000    27.750000    28.050000    28.400000
75%      30.275000    40.500000    44.575000    49.200000    54.575000    58.800000
max     443.900000   259.900000   270.500000   363.400000   252.100000   256.000000


AUDUSD 4294 2081 2 

bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  4294.000000  4294.000000  4294.000000  4294.000000  4294.000000  4294.000000
mean     37.061667    41.609967    41.590359    41.498020    40.518910    40.295203
std      19.191940    23.913328    33.923008    41.430722    46.957776    52.136135
min      12.400000   -71.700000  -108.600000  -137.400000  -205.000000  -264.700000
25%      24.700000    25.400000    21.500000    17.600000    13.000000     9.200000
50%      32.200000    35.400000    36.550000    37.300000    36.100000    36.500000
75%      43.400000    51.200000    56.800000    62.500000    64.800000    68.400000
max     262.000000   234.400000   630.500000   630.500000   452.200000   357.900000

penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  2081.000000  2081.000000  2081.000000  2081.000000  2081.000000  2081.000000
mean     24.944882    32.451321    31.770159    32.792119    32.609899    33.125324
std      20.565471    26.206448    34.956979    42.700810    48.884655    55.420223
min       0.100000   -22.800000   -97.300000  -255.700000  -268.700000  -216.800000
25%      11.700000    14.600000    10.400000     7.200000     3.600000    -0.300000
50%      19.500000    25.700000    26.800000    28.800000    28.200000    28.500000
75%      31.600000    43.600000    47.600000    55.000000    58.400000    61.600000
max     242.800000   234.400000   372.200000   296.800000   344.500000   620.500000


CADJPY 4328 2043 2 

bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  4328.000000  4328.000000  4328.000000  4328.000000  4328.000000  4328.000000
mean     39.480360    43.944640    42.728408    43.164545    43.181747    43.710513
std      21.701302    27.902264    36.222258    42.727120    47.868189    54.335620
min      12.050000   -58.750000  -176.900000  -198.750000  -187.800000  -266.900000
25%      25.900000    26.650000    21.700000    17.587500    14.300000    11.750000
50%      34.200000    37.100000    36.800000    38.025000    38.650000    39.450000
75%      46.500000    53.462500    59.150000    64.550000    67.800000    73.350000
max     377.150000   735.350000   645.200000   523.450000   496.550000   485.050000

penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  2043.000000  2043.000000  2043.000000  2043.000000  2043.000000  2043.000000
mean     26.837249    35.593172    32.935928    33.476921    33.600612    35.232477
std      25.658782    31.067541    37.811932    44.844594    50.084880    56.592666
min       0.250000  -127.100000  -161.550000  -198.750000  -187.800000  -273.750000
25%      12.025000    15.700000     9.875000     6.000000     3.975000     1.900000
50%      21.100000    28.250000    27.550000    28.900000    29.000000    30.100000
75%      34.000000    46.925000    49.525000    54.900000    57.500000    65.825000
max     505.350000   415.200000   443.100000   338.950000   294.500000   363.650000


CHFJPY 4303 2086 2 

bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  4303.000000  4303.000000  4303.000000  4303.000000  4303.000000  4303.000000
mean     43.910237    48.268824    46.933686    46.202463    46.078410    46.855659
std      69.497767    43.081718    49.826508    58.168397    61.191829    65.746856
min      12.600000  -285.800000  -299.000000  -337.950000  -356.750000  -347.400000
25%      28.425000    28.750000    23.850000    20.325000    16.425000    13.150000
50%      37.300000    40.300000    41.050000    41.300000    41.900000    43.250000
75%      50.425000    57.650000    62.650000    68.000000    70.625000    76.875000
max    4282.600000  1830.000000  1756.650000  2326.400000  2046.650000  1843.550000

penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  2086.000000  2086.000000  2086.000000  2086.000000  2086.000000  2086.000000
mean     31.427852    39.793696    37.613255    36.725695    37.146261    39.066491
std      97.838611    55.603830    62.823691    71.497868    71.813208    74.348817
min       0.450000   -22.150000  -151.550000  -186.950000  -243.350000  -326.550000
25%      13.000000    16.850000    10.750000     7.212500     4.562500     2.112500
50%      22.400000    29.900000    28.950000    28.700000    30.850000    33.200000
75%      35.500000    49.387500    52.650000    57.250000    61.100000    67.437500
max    4282.600000  1830.000000  1756.650000  2326.400000  2046.650000  1843.550000


EURCHF 4250 1975 2 

bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  4250.000000  4250.000000  4250.000000  4250.000000  4250.000000  4250.000000
mean     32.724529    35.692659    34.964424    34.425976    34.758753    35.333929
std      70.090096    41.091958    45.358844    52.264347    53.418916    55.570270
min      12.400000   -62.500000  -156.800000  -295.100000  -253.900000  -179.200000
25%      20.000000    20.800000    18.100000    16.425000    14.800000    13.400000
50%      26.500000    28.300000    27.800000    28.000000    28.000000    28.250000
75%      36.400000    39.900000    41.800000    43.400000    45.700000    47.800000
max    4350.650000  1839.900000  1882.700000  2302.600000  2118.600000  1953.800000

penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  1975.000000  1975.000000  1975.000000  1975.000000  1975.000000  1975.000000
mean     18.592405    24.991646    22.575797    21.294228    22.320051    23.440000
std      28.468733    38.546877    42.171403    44.039591    48.705661    54.781738
min       0.100000   -42.700000  -119.000000  -272.500000  -229.600000  -296.800000
25%       5.350000     7.000000     3.600000     1.900000     1.100000     0.650000
50%      11.400000    15.600000    13.800000    12.600000    13.300000    13.300000
75%      22.850000    30.750000    30.700000    31.450000    33.250000    36.200000
max     795.700000   975.700000   827.800000   860.500000   856.900000   856.200000


EURGBP 4249 1936 2 

bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  4249.000000  4249.000000  4249.000000  4249.000000  4249.000000  4249.000000
mean     30.512003    34.160979    32.888256    32.241139    32.358014    33.479478
std      16.549735    19.559642    25.752542    32.468653    36.518781    40.908093
min      12.200000   -34.200000   -94.800000  -107.000000  -304.400000  -260.700000
25%      21.200000    21.800000    18.800000    16.200000    13.400000    11.700000
50%      27.000000    29.400000    29.200000    29.200000    30.200000    31.300000
75%      36.000000    40.900000    43.500000    45.500000    49.100000    53.200000
max     655.000000   503.800000   596.400000   715.000000   676.400000   715.000000

penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  1936.000000  1936.000000  1936.000000  1936.000000  1936.000000  1936.000000
mean     19.762862    25.473295    23.081302    21.477376    21.981353    24.405475
std      21.826363    23.237181    29.114316    31.160576    34.411560    38.046836
min       0.200000   -45.600000   -88.400000  -118.200000  -121.200000  -136.400000
25%       8.400000    10.500000     6.475000     4.200000     2.175000     1.800000
50%      14.950000    19.900000    18.200000    18.250000    19.150000    22.400000
75%      25.425000    34.200000    35.200000    35.100000    38.600000    43.600000
max     655.000000   503.800000   596.400000   379.600000   461.400000   474.000000


EURJPY 4138 2063 2 

bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  4138.000000  4138.000000  4138.000000  4138.000000  4138.000000  4138.000000
mean     48.421194    54.476486    53.787289    53.701958    54.000991    54.983205
std      28.662335    39.939996    49.321755    57.384030    64.975205    72.500757
min      12.700000  -240.000000  -264.250000  -283.350000  -390.650000  -396.450000
25%      30.900000    30.850000    25.612500    21.550000    17.312500    12.862500
50%      41.600000    45.350000    47.125000    48.150000    49.300000    50.025000
75%      57.600000    66.887500    74.650000    80.900000    85.650000    94.537500
max     460.950000  1140.650000  1062.100000   818.550000   819.450000   753.850000

penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  2063.000000  2063.000000  2063.000000  2063.000000  2063.000000  2063.000000
mean     35.227170    46.529254    45.628551    46.101236    45.913767    48.575982
std      34.019357    41.524020    53.145708    62.009869    68.983605    78.815224
min       0.300000   -78.950000  -332.400000  -357.250000  -345.550000  -324.250000
25%      16.525000    20.675000    14.500000     9.875000     5.775000     2.925000
50%      27.950000    37.100000    37.050000    38.100000    41.950000    45.150000
75%      43.275000    62.150000    68.925000    77.275000    81.625000    88.200000
max     790.650000   712.100000   540.400000   469.450000   449.100000   920.650000


EURUSD 4054 2024 2 

bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  4054.000000  4054.000000  4054.000000  4054.000000  4054.000000  4054.000000
mean     43.079428    48.642797    46.048619    44.615392    44.427405    45.990947
std      25.387252    34.024488    42.778499    49.383675    55.437314    62.828057
min      12.700000   -80.900000  -144.800000  -187.600000  -195.800000  -217.700000
25%      26.800000    27.000000    22.200000    17.600000    13.925000    10.325000
50%      36.600000    39.500000    38.400000    39.500000    40.900000    42.350000
75%      51.000000    59.275000    64.000000    68.700000    73.375000    79.200000
max     343.400000   508.600000   484.400000   406.300000   396.300000   446.500000

penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  2024.000000  2024.000000  2024.000000  2024.000000  2024.000000  2024.000000
mean     32.405731    41.183943    37.006670    35.051779    35.696443    39.170257
std      29.006616    37.451636    46.662227    53.862475    59.334473    65.910134
min       0.700000   -23.000000  -297.700000  -364.600000  -349.600000  -320.900000
25%      14.400000    17.800000    10.200000     6.000000     3.075000     1.775000
50%      24.900000    31.750000    30.150000    30.050000    31.800000    35.200000
75%      41.000000    53.525000    56.400000    60.200000    64.625000    71.950000
max     408.600000   427.400000   431.200000   406.300000   396.300000   400.000000


GBPJPY 7756 4186 2 

bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  7756.000000  7756.000000  7756.000000  7756.000000  7756.000000  7756.000000
mean     59.325085    66.258658    64.467300    63.329093    64.891842    66.501578
std      47.971222    65.448693    74.879107    82.925871    93.036030   103.607518
min      12.500000  -215.150000 -1263.400000 -1295.450000 -1299.300000 -1343.400000
25%      36.800000    36.050000    27.700000    21.287500    16.000000    10.950000
50%      51.100000    54.400000    55.050000    55.350000    57.749000    59.525000
75%      70.950000    82.500000    89.200000    96.100000   104.600000   112.200000
max    1935.400000  2455.400000  2480.850000  1851.950000  1931.650000  1946.600000

penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  4186.000000  4186.000000  4186.000000  4186.000000  4186.000000  4186.000000
mean     45.837757    61.554862    57.917834    56.597502    58.571776    62.348340
std      58.163487    75.388629    80.824038    91.372966    97.478561   118.849267
min       0.600000   -20.100000  -193.100000  -213.600000  -266.900000 -1343.400000
25%      20.800000    25.712500    17.450000     9.975000     7.762500     4.050000
50%      35.450000    46.275000    45.100000    42.725000    46.925000    52.325000
75%      57.050000    79.650000    83.050000    88.625000    98.262500   107.612500
max    1815.400000  1935.400000  1960.850000  1446.100000  1411.650000  2085.400000


GBPUSD 3964 2043 2 

bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  3964.000000  3964.000000  3964.000000  3964.000000  3964.000000  3964.000000
mean     48.011075    53.748638    50.678280    48.480323    48.922780    51.709258
std      33.956249    47.028487    53.426614    58.095976    65.178465    74.177228
min      12.200000   -57.200000  -138.400000  -181.600000  -278.400000  -981.300000
25%      30.100000    30.000000    23.875000    18.500000    14.600000    10.700000
50%      41.100000    44.350000    43.400000    44.000000    45.700000    48.300000
75%      57.500000    66.325000    70.625000    74.200000    79.850000    89.425000
max    1326.600000  1646.600000  1721.100000  1294.000000  1355.200000  1387.000000

penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  2043.000000  2043.000000  2043.000000  2043.000000  2043.000000  2043.000000
mean     36.365051    47.205727    43.501273    41.095056    42.114097    45.949290
std      28.499410    45.682069    56.444106    69.489754    72.676212    78.206884
min       0.600000   -57.200000  -137.800000  -217.600000  -195.500000  -981.300000
25%      16.400000    20.600000    13.200000     8.150000     6.150000     4.750000
50%      28.700000    38.300000    35.400000    34.700000    37.000000    42.200000
75%      48.300000    63.300000    66.200000    67.350000    73.100000    83.550000
max     340.000000  1326.600000  1401.100000  1546.600000  1621.100000  1194.000000


NZDUSD 4358 2082 2 

bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  4358.000000  4358.000000  4358.000000  4358.000000  4358.000000  4358.000000
mean     36.119160    40.308284    38.829004    39.302157    38.747223    38.738045
std      16.863828    22.420243    30.951561    37.689896    43.402135    48.358277
min      13.000000   -85.000000  -116.200000  -108.200000  -156.400000  -199.800000
25%      25.200000    25.300000    20.600000    17.200000    13.725000     9.600000
50%      32.100000    34.800000    35.200000    36.100000    35.250000    36.100000
75%      42.400000    49.200000    53.500000    58.200000    61.375000    65.075000
max     173.200000   220.100000   237.400000   228.200000   239.000000   321.100000

penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  2082.000000  2082.000000  2082.000000  2082.000000  2082.000000  2082.000000
mean     23.745485    31.452498    30.623247    30.927474    31.256820    30.600672
std      20.212291    25.013508    32.722487    38.658671    44.667285    49.481924
min       0.700000   -19.300000  -133.000000  -144.800000  -151.200000  -156.400000
25%      11.000000    15.000000    10.225000     7.625000     3.250000     0.225000
50%      18.100000    25.000000    26.100000    27.400000    27.600000    27.400000
75%      29.875000    41.400000    45.775000    51.875000    55.000000    57.400000
max     217.600000   285.100000   345.100000   260.500000   293.200000   393.600000


USDCAD 4142 1988 2 

bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  4142.000000  4142.000000  4142.000000  4142.000000  4142.000000  4142.000000
mean     38.443602    42.784838    40.761347    40.515717    40.781386    41.706736
std      20.989505    26.171493    35.058391    41.573890    46.367636    51.924317
min      12.600000   -38.400000  -165.800000  -215.400000  -229.200000  -240.700000
25%      24.500000    25.500000    21.025000    17.225000    14.600000    11.600000
50%      32.800000    36.050000    35.450000    36.250000    36.600000    38.000000
75%      46.000000    51.800000    55.600000    59.300000    64.775000    69.400000
max     248.700000   286.600000   370.900000   370.900000   376.400000   454.500000

penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  1988.000000  1988.000000  1988.000000  1988.000000  1988.000000  1988.000000
mean     27.835664    35.912726    32.497736    31.430433    31.469215    34.568511
std      25.456910    31.163832    37.417246    43.060959    48.354884    54.940006
min       0.200000   -38.400000  -145.000000  -181.800000  -200.500000  -197.300000
25%      11.400000    15.100000     9.400000     6.400000     3.200000     1.600000
50%      20.250000    27.700000    26.900000    27.200000    27.800000    29.500000
75%      36.000000    48.000000    48.800000    52.925000    56.800000    65.250000
max     248.700000   300.900000   243.600000   286.400000   364.500000   331.800000


USDCHF 4320 1962 2 

bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  4320.000000  4320.000000  4320.000000  4320.000000  4320.000000  4320.000000
mean     36.604456    41.256273    39.862616    38.946875    39.091597    41.229780
std      57.675655    35.177039    40.077424    47.838523    51.142267    77.114196
min      12.300000   -33.100000   -82.300000  -161.600000  -161.600000  -238.300000
25%      23.800000    24.600000    20.800000    17.800000    14.800000    12.700000
50%      31.200000    33.850000    33.900000    34.400000    35.000000    36.650000
75%      41.800000    48.800000    53.300000    56.200000    60.225000    64.800000
max    3616.650000  1544.500000  1522.700000  1898.800000  1739.600000  3596.650000

penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  1962.000000  1962.000000  1962.000000  1962.000000  1962.000000  1962.000000
mean     28.081524    34.032824    31.068858    29.322834    30.091641    32.481906
std      83.271051    46.916084    52.483795    60.010841    60.365119    61.738341
min       0.200000   -27.200000  -118.200000  -140.500000  -139.600000  -203.600000
25%      11.100000    14.000000     9.200000     5.600000     3.200000     3.300000
50%      19.400000    25.400000    23.650000    23.800000    25.000000    27.350000
75%      32.575000    42.900000    44.400000    46.700000    51.200000    57.500000
max    3516.650000  1444.500000  1422.700000  1798.800000  1639.600000  1500.200000


USDJPY 4384 2050 2 

bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  4384.000000  4384.000000  4384.000000  4384.000000  4384.000000  4384.000000
mean     36.416994    40.496156    39.896727    40.255885    39.814291    39.910960
std      22.381506    28.271148    35.446555    41.729017    47.308862    52.929737
min      12.400000  -106.150000  -118.750000  -159.100000  -195.800000  -253.650000
25%      23.650000    24.237500    20.087500    17.087500    13.750000    10.950000
50%      30.900000    33.400000    33.950000    35.050000    34.800000    34.850000
75%      42.562500    48.200000    53.800000    58.412500    61.212500    64.712500
max     609.900000   609.900000   459.100000   383.400000   355.000000   396.600000

penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  2050.000000  2050.000000  2050.000000  2050.000000  2050.000000  2050.000000
mean     26.134488    32.920171    32.636049    33.001659    32.237293    32.807341
std      27.976277    31.893486    38.915154    44.745904    51.032318    56.292478
min       0.250000  -106.150000  -128.000000  -210.850000  -303.650000  -276.700000
25%      11.450000    14.362500     9.500000     7.175000     3.400000     0.700000
50%      19.150000    25.175000    25.325000    26.450000    25.675000    26.400000
75%      31.887500    41.637500    45.700000    51.025000    54.300000    58.475000
max     499.900000   353.400000   390.700000   341.800000   363.350000   361.500000




Timeframe = 1H

AUDJPY 17690 7997 2 

bounsr summary
               bar1          bar2          bar3         bar4          bar5          bar6
count  17690.000000  17690.000000  17690.000000  17690.00000  17690.000000  17690.000000
mean      26.330687     29.530079     29.149333     28.84316     28.678599     28.665557
std       12.720578     16.487793     21.395569     25.44432     28.886249     31.871266
min       12.100000    -98.100000   -153.550000   -332.65000   -405.950000   -405.950000
25%       19.250000     19.900000     17.412500     15.35000     13.550000     11.800000
50%       23.450000     25.550000     25.550000     25.65000     25.750000     26.000000
75%       29.900000     34.450000     37.250000     39.55000     41.350000     43.237500
max      637.950000    585.750000    516.750000    473.15000    372.200000    410.850000

penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  7997.000000  7997.000000  7997.000000  7997.000000  7997.000000  7997.000000
mean     14.593779    20.000757    19.149794    18.621289    18.448618    18.753248
std      15.971268    20.962311    25.236268    28.693523    31.092029    33.482216
min       0.050000   -40.100000  -134.500000  -257.000000  -372.000000  -421.050000
25%       6.200000     8.400000     5.500000     3.250000     1.600000     0.150000
50%      10.800000    15.050000    14.450000    14.450000    14.550000    14.800000
75%      18.250000    25.500000    27.500000    29.500000    31.500000    33.900000
max     577.950000   637.950000   585.750000   516.750000   496.000000   437.100000


AUDNZD 18763 7679 2 

bounsr summary
               bar1         bar2          bar3          bar4          bar5          bar6
count  18763.000000  18763.00000  18763.000000  18763.000000  18763.000000  18763.000000
mean      25.054991     27.46912     27.223829     27.113841     27.069925     27.093365
std       12.228691     14.16049     17.322601     20.634381     22.892307     25.128816
min       12.200000   -132.80000   -156.100000   -167.200000   -176.800000   -176.800000
25%       18.900000     19.60000     17.600000     15.900000     14.200000     12.900000
50%       22.600000     24.40000     24.800000     25.000000     25.000000     25.300000
75%       28.100000     31.70000     34.100000     36.000000     37.600000     39.200000
max      590.500000    590.50000    529.900000    600.500000    334.400000    309.900000

penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  7679.000000  7679.000000  7679.000000  7679.000000  7679.000000  7679.000000
mean     12.168694    15.816799    15.282875    15.148926    15.120966    14.927451
std      12.858021    14.003861    18.225030    23.617798    24.769254    26.088829
min       0.100000   -90.600000  -122.200000  -164.600000  -196.200000  -187.300000
25%       5.200000     7.300000     4.900000     3.000000     1.600000     0.150000
50%       8.800000    12.300000    12.200000    12.300000    12.600000    12.800000
75%      14.600000    20.000000    22.250000    23.850000    25.800000    27.200000
max     313.400000   184.700000   244.100000   590.500000   494.800000   243.200000


AUDUSD 16517 8277 2 

bounsr summary
               bar1          bar2          bar3          bar4          bar5          bar6
count  16517.000000  16517.000000  16517.000000  16517.000000  16517.000000  16517.000000
mean      24.425410     27.406442     27.165278     26.768802     26.617485     26.466089
std       10.318177     13.895039     19.265171     22.537931     25.434016     27.988236
min       12.100000    -83.600000   -122.100000   -148.000000   -202.000000   -180.200000
25%       18.000000     18.600000     16.400000     14.500000     12.600000     11.000000
50%       22.000000     23.900000     24.100000     24.000000     24.200000     24.200000
75%       27.600000     31.900000     34.300000     36.400000     38.100000     39.600000
max      259.000000    262.000000    620.500000    620.500000    318.200000    306.800000

penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  8277.000000  8277.000000  8277.000000  8277.000000  8277.000000  8277.000000
mean     12.694128    17.263235    16.527329    16.159466    15.866087    15.910970
std      12.338808    16.322354    20.799830    23.746640    26.223900    28.678277
min       0.200000   -91.300000  -212.100000  -238.000000  -248.600000  -216.000000
25%       5.200000     7.100000     4.600000     2.900000     1.000000    -0.400000
50%       9.200000    13.100000    12.800000    12.600000    12.900000    13.000000
75%      16.200000    22.400000    24.400000    26.300000    27.400000    29.400000
max     259.000000   255.500000   352.800000   320.400000   318.200000   306.800000


CADJPY 17048 8258 2 

bounsr summary
               bar1          bar2          bar3          bar4          bar5          bar6
count  17048.000000  17048.000000  17048.000000  17048.000000  17048.000000  17048.000000
mean      25.232769     28.387113     28.093700     28.016316     27.894853     27.914776
std       11.384631     14.923466     19.819825     23.710842     26.866718     29.939625
min       12.100000    -50.050000   -161.550000   -184.900000   -217.500000   -266.950000
25%       18.450000     19.100000     16.700000     15.150000     13.450000     11.900000
50%       22.400000     24.500000     24.500000     24.700000     24.850000     25.000000
75%       28.500000     33.150000     35.550000     37.400000     39.400000     41.062500
max      282.950000    317.300000    321.950000    327.300000    293.300000    295.500000

penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  8258.000000  8258.000000  8258.000000  8258.000000  8258.000000  8258.000000
mean     13.304662    18.311244    17.735015    17.385269    17.340997    17.474594
std      15.012740    19.564021    23.263915    27.588386    31.086247    33.056935
min       0.050000  -130.750000  -127.850000  -124.000000  -158.200000  -200.450000
25%       5.350000     7.350000     4.700000     2.650000     1.250000    -0.150000
50%       9.400000    13.400000    13.350000    13.150000    13.425000    13.550000
75%      16.450000    23.400000    26.100000    27.387500    29.000000    31.550000
max     505.350000   565.350000   542.900000   645.350000   735.350000   712.900000


CHFJPY 17955 8014 2 

bounsr summary
               bar1          bar2          bar3          bar4          bar5          bar6
count  17955.000000  17955.000000  17955.000000  17955.000000  17955.000000  17955.000000
mean      27.027080     30.189290     29.744818     29.529137     29.449028     29.197608
std       38.754726     24.308867     27.648108     31.544381     36.511211     40.387082
min       12.050000    -48.150000  -1347.150000  -1583.600000  -1628.150000  -1615.400000
25%       19.350000     19.850000     17.450000     15.700000     13.900000     12.500000
50%       23.750000     25.650000     25.750000     25.750000     26.100000     26.100000
75%       30.350000     35.000000     37.750000     39.650000     41.650000     43.250000
max     4904.325000   2243.500000   1800.650000   1889.200000   1940.000000   1687.950000

penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  8014.000000  8014.000000  8014.000000  8014.000000  8014.000000  8014.000000
mean     15.204264    20.182337    19.161948    18.994329    19.069391    19.057244
std      56.801589    32.740274    35.903939    40.223240    43.643720    45.870725
min       0.050000  -173.750000 -1367.150000 -1603.600000 -1648.150000 -1635.400000
25%       6.150000     8.400000     5.412500     3.300000     1.950000     0.212500
50%      11.000000    14.900000    14.400000    14.500000    14.900000    14.900000
75%      18.100000    24.850000    27.050000    29.450000    31.400000    33.600000
max    4874.325000  2213.500000  1770.650000  1859.200000  1910.000000  1657.950000


EURCHF 12714 7223 2 

bounsr summary
               bar1          bar2          bar3          bar4          bar5          bar6
count  12714.000000  12714.000000  12714.000000  12714.000000  12714.000000  12714.000000
mean      23.543248     25.642599     25.271834     25.064991     24.862113     24.970890
std       42.256022     23.817048     26.710905     28.374881     30.601330     34.423218
min       12.100000   -142.300000   -145.800000   -149.200000   -195.300000   -950.200000
25%       16.800000     17.200000     15.500000     14.500000     13.500000     12.900000
50%       20.000000     21.300000     20.800000     20.600000     20.400000     20.500000
75%       25.900000     28.700000     29.600000     30.600000     31.600000     32.700000
max     4596.450000   2018.600000   1775.500000   1793.900000   1839.900000   1711.600000

penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  7223.000000  7223.000000  7223.000000  7223.000000  7223.000000  7223.000000
mean      9.502146    12.687235    12.100540    12.408258    11.887374    11.669057
std      12.389577    16.817031    24.382192    59.738114    35.642199    40.038636
min       0.100000  -174.900000  -174.900000  -177.000000  -215.300000 -1272.200000
25%       3.000000     3.900000     2.000000     1.100000     0.600000     0.100000
50%       5.900000     8.100000     7.000000     6.800000     6.700000     6.600000
75%      11.500000    15.800000    16.500000    17.600000    18.100000    19.000000
max     214.500000   365.800000  1155.700000  4596.450000  2018.600000  1775.500000


EURGBP 13469 7487 2 

bounsr summary
               bar1          bar2          bar3          bar4          bar5          bar6
count  13469.000000  13469.000000  13469.000000  13469.000000  13469.000000  13469.000000
mean      21.547977     23.945957     23.637805     23.344510     23.221033     23.207870
std        9.862896     11.313954     14.768511     17.764428     20.212498     22.357544
min       12.100000    -34.600000   -140.400000   -135.700000   -134.800000   -141.200000
25%       16.400000     16.900000     15.200000     14.000000     13.100000     12.200000
50%       19.400000     20.700000     20.400000     20.200000     20.400000     20.500000
75%       24.200000     27.400000     29.000000     30.100000     31.400000     32.500000
max      645.000000    297.600000    273.000000    460.400000    550.400000    606.400000

penesr summary
             bar1         bar2         bar3         bar4         bar5         bar6
count  7487.00000  7487.000000  7487.000000  7487.000000  7487.000000  7487.000000
mean      9.61170    13.216455    12.768759    12.361413    12.255550    12.124162
std      12.05328    12.567763    16.270644    19.241953    21.366913    23.566075
min       0.10000   -61.600000  -140.400000  -135.700000  -134.800000  -141.200000
25%       3.70000     5.000000     3.200000     2.000000     1.000000    -0.100000
50%       6.80000     9.600000     9.100000     8.900000     8.900000     9.200000
75%      12.40000    17.400000    19.000000    20.000000    21.500000    22.700000
max     645.00000   168.600000   273.000000   460.400000   513.800000   606.400000


EURJPY 17979 7973 2 

bounsr summary
               bar1          bar2          bar3          bar4          bar5          bar6
count  17979.000000  17979.000000  17979.000000  17979.000000  17979.000000  17979.000000
mean      29.070404     32.803048     32.562006     32.360674     32.502778     32.615896
std       14.275760     19.465504     25.578228     30.285400     34.943170     39.000119
min       12.100000   -107.500000   -187.000000   -226.350000   -300.700000   -357.700000
25%       20.500000     20.950000     18.100000     15.700000     13.700000     11.800000
50%       25.750000     27.850000     27.850000     28.000000     28.350000     28.550000
75%       33.300000     38.650000     41.850000     44.950000     47.550000     49.950000
max      384.100000    424.100000    461.550000    461.550000    439.100000    647.100000

penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  7973.000000  7973.000000  7973.000000  7973.000000  7973.000000  7973.000000
mean     17.883037    24.507569    23.416336    22.905393    22.936053    22.942173
std      17.369509    23.763148    29.302256    35.494324    40.983476    44.265159
min       0.050000  -181.850000  -168.900000  -262.150000  -297.400000  -332.400000
25%       7.450000    10.050000     6.250000     4.100000     2.250000     0.400000
50%      13.550000    18.450000    17.750000    17.450000    17.700000    18.250000
75%      22.750000    32.200000    34.100000    36.650000    39.300000    41.450000
max     384.100000   437.450000   441.650000  1050.650000  1140.650000  1136.500000


EURUSD 16487 7941 2 

bounsr summary
               bar1          bar2          bar3          bar4          bar5          bar6
count  16487.000000  16487.000000  16487.000000  16487.000000  16487.000000  16487.000000
mean      26.526366     30.002808     29.653333     29.488834     29.380603     29.428623
std       12.992262     17.844050     23.572333     28.177568     31.787946     34.581846
min       12.100000    -97.700000   -135.800000   -176.400000   -206.600000   -229.100000
25%       18.400000     18.800000     16.400000     14.800000     13.400000     11.800000
50%       23.100000     24.800000     24.600000     24.500000     24.800000     25.100000
75%       30.400000     35.200000     37.600000     39.900000     41.900000     44.200000
max      204.900000    353.600000    396.600000    428.600000    430.600000    404.400000

penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  7941.000000  7941.000000  7941.000000  7941.000000  7941.000000  7941.000000
mean     15.291324    20.780141    20.061957    19.494736    19.328750    19.492835
std      14.862870    20.835930    26.179528    30.395039    34.094985    38.098518
min       0.100000   -81.700000   -96.200000  -239.000000  -261.300000  -297.700000
25%       5.900000     7.600000     5.100000     2.800000     1.000000    -0.300000
50%      10.900000    15.200000    14.400000    14.200000    14.200000    14.500000
75%      19.500000    26.700000    28.600000    30.800000    32.800000    34.800000
max     176.000000   343.400000   306.500000   408.600000   428.600000   508.600000


GBPJPY 17725 7997 2 

bounsr summary
               bar1          bar2          bar3          bar4          bar5          bar6
count  17725.000000  17725.000000  17725.000000  17725.000000  17725.000000  17725.000000
mean      33.832337     38.938028     38.264063     38.023144     37.996487     37.994701
std       17.993323     70.888599     32.095846     39.345442     47.019447     51.852689
min       12.050000   -131.200000   -137.101000   -374.250000   -495.800000   -619.500000
25%       22.800000     23.400000     20.000000     17.250000     14.850000     12.300000
50%       29.500000     31.950000     32.300000     32.400000     32.700000     32.900000
75%       39.400000     46.100000     50.251000     53.300000     56.000000     58.700000
max      480.000000   8846.650000    640.949000   1281.899000   2303.050000   2455.400000

penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  7997.000000  7997.000000  7997.000000  7997.000000  7997.000000  7997.000000
mean     22.720534    30.892607    29.792422    29.232702    30.319117    29.224037
std      26.691897    31.336938    38.501027    50.041908   114.631575    64.156777
min       0.250000   -71.700000  -111.750000  -374.250000  -495.800000  -619.500000
25%       9.500000    12.500000     8.000000     4.900000     2.650000     0.150000
50%      16.700000    23.050000    22.350000    21.950000    21.800000    22.300000
75%      28.400000    40.200000    42.650000    45.950000    48.100000    51.050000
max    1016.800000  1063.001000  1111.899000  2133.050000  8786.650000  2445.400000


GBPUSD 16953 7970 2 

bounsr summary
               bar1          bar2          bar3          bar4          bar5          bar6
count  16953.000000  16953.000000  16953.000000  16953.000000  16953.000000  16953.000000
mean      28.332891     32.046381     31.799658     31.348847     31.138642     31.167758
std       15.406795     18.168311     24.421536     29.188170     33.414922     37.020388
min       12.200000    -89.800000   -130.000000   -295.500000   -368.500000   -463.800000
25%       19.400000     20.200000     17.400000     15.300000     13.400000     11.800000
50%       24.600000     26.800000     26.600000     26.800000     27.000000     27.000000
75%       33.000000     38.200000     41.300000     43.400000     45.500000     47.700000
max      940.000000    247.700000    432.200000    258.600000    275.200000    285.500000

penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  7970.000000  7970.000000  7970.000000  7970.000000  7970.000000  7970.000000
mean     17.530740    23.640314    23.009649    22.747867    22.695922    22.810013
std      20.200496    23.016495    29.594513    36.630865    42.907277    48.586850
min       0.100000   -43.400000  -130.000000  -295.500000  -368.500000  -463.800000
25%       6.800000     8.800000     5.600000     3.500000     2.000000    -0.400000
50%      12.600000    17.400000    16.900000    16.600000    17.300000    17.400000
75%      22.500000    31.400000    34.600000    36.500000    38.300000    41.300000
max     920.000000   660.000000   773.100000  1264.200000  1486.600000  1646.600000


NZDUSD 16754 8064 2 

bounsr summary
               bar1          bar2          bar3          bar4          bar5          bar6
count  16754.000000  16754.000000  16754.000000  16754.000000  16754.000000  16754.000000
mean      23.807610     26.636367     26.517351     26.414295     26.482828     26.517763
std       10.064091     13.296014     17.623479     20.820998     23.682329     26.031089
min       12.000000   -108.000000   -117.200000   -128.600000   -146.200000   -135.000000
25%       18.000000     18.500000     16.500000     14.800000     13.300000     11.900000
50%       21.500000     23.500000     23.600000     23.900000     24.200000     24.400000
75%       26.700000     30.800000     33.500000     35.400000     37.200000     38.900000
max      329.200000    329.200000    329.200000    243.700000    296.200000    272.800000

penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  8064.000000  8064.000000  8064.000000  8064.000000  8064.000000  8064.000000
mean     11.778646    15.713852    15.142485    14.939063    14.787463    14.836223
std      11.963234    14.645016    18.893078    21.739739    23.991976    26.292481
min       0.100000   -70.300000  -186.700000  -214.000000  -214.200000  -195.100000
25%       5.000000     6.800000     4.400000     2.500000     1.200000    -0.400000
50%       8.600000    12.100000    11.900000    12.100000    12.200000    12.200000
75%      14.600000    19.800000    22.200000    23.825000    25.800000    27.400000
max     299.200000   231.800000   254.800000   329.200000   244.000000   226.600000


USDCAD 15750 8105 2 

bounsr summary
               bar1          bar2          bar3          bar4          bar5          bar6
count  15750.000000  15750.000000  15750.000000  15750.000000  15750.000000  15750.000000
mean      24.653263     27.854165     27.611695     27.388857     27.171968     27.068552
std       11.495206     15.171455     19.929525     23.430236     26.606002     29.670134
min       12.100000   -111.500000   -113.900000   -181.400000   -203.300000   -221.000000
25%       17.600000     18.400000     16.200000     14.600000     13.300000     11.500000
50%       21.700000     23.700000     23.600000     23.600000     23.700000     23.800000
75%       27.800000     32.600000     34.600000     36.500000     38.000000     39.500000
max      250.000000    277.600000    284.000000    288.700000    330.900000    282.400000

penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  8105.000000  8105.000000  8105.000000  8105.000000  8105.000000  8105.000000
mean     12.618125    17.563701    17.180666    16.602110    16.416965    16.364911
std      13.529029    17.771882    22.252264    25.988667    28.936393    31.521968
min       0.100000   -36.800000  -118.400000  -159.700000  -166.000000  -174.000000
25%       4.600000     6.600000     4.400000     2.600000     1.200000    -0.200000
50%       8.700000    12.700000    12.500000    12.100000    12.400000    12.800000
75%      15.500000    22.300000    24.700000    26.000000    27.800000    29.600000
max     270.000000   277.600000   284.000000   266.900000   288.700000   330.900000


USDCHF 15441 7712 2 

bounsr summary
               bar1          bar2          bar3          bar4          bar5          bar6
count  15441.000000  15441.000000  15441.000000  15441.000000  15441.000000  15441.000000
mean      24.153190     26.953287     26.547031     26.209229     26.131662     26.153429
std       32.194766     22.131554     24.247147     27.753321     30.796468     32.673904
min       12.000000    -41.100000  -1106.700000  -1299.000000  -1359.800000  -1312.800000
25%       17.400000     18.000000     16.000000     14.600000     13.400000     12.100000
50%       21.200000     22.900000     22.800000     22.600000     22.800000     22.900000
75%       27.000000     31.000000     33.000000     34.400000     35.800000     37.100000
max     3783.200000   2107.900000   1450.200000   1470.600000   1504.500000   1345.700000

penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  7712.000000  7712.000000  7712.000000  7712.000000  7712.000000  7712.000000
mean     12.473846    16.765716    16.419554    15.724170    15.604487    15.820773
std      44.670220    29.191433    52.670871    41.006501    39.368047    42.400497
min       0.100000   -53.200000 -1116.700000 -1309.000000 -1369.800000 -1322.800000
25%       4.400000     6.200000     3.800000     2.200000     1.200000     0.200000
50%       8.400000    11.800000    11.300000    11.200000    11.400000    11.800000
75%      15.000000    21.200000    23.100000    24.800000    26.200000    28.800000
max    3773.200000  2097.900000  3783.200000  2107.900000  1494.500000  1470.600000


USDJPY 16432 7907 2 

bounsr summary
               bar1          bar2          bar3          bar4          bar5          bar6
count  16432.000000  16432.000000  16432.000000  16432.000000  16432.000000  16432.000000
mean      24.054093     26.859025     26.466687     26.164673     26.122876     26.144648
std       11.223618     15.000275     19.829976     23.124919     26.125796     28.698820
min       12.050000   -314.950000   -320.150000   -320.150000   -319.250000   -332.200000
25%       17.500000     17.950000     15.800000     14.250000     12.750000     11.250000
50%       21.350000     23.250000     23.050000     22.900000     23.000000     23.200000
75%       27.100000     30.850000     33.200000     34.800000     36.650000     38.550000
max      318.300000    373.600000    389.250000    341.150000    373.950000    398.900000

penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
count  7907.000000  7907.000000  7907.000000  7907.000000  7907.000000  7907.000000
mean     12.795713    17.206564    16.594157    16.177925    15.983951    15.890812
std      14.180187    17.821550    21.858865    25.890059    28.199032    30.535191
min       0.050000   -71.250000   -85.700000  -221.700000  -303.800000  -332.200000
25%       4.950000     6.500000     4.350000     2.850000     1.500000     0.150000
50%       9.050000    12.550000    11.900000    11.450000    11.600000    11.900000
75%      16.000000    22.450000    23.950000    25.350000    26.650000    28.350000
max     399.900000   373.600000   373.950000   699.900000   606.550000   549.100000

**** tfx offical nu with 6bar summaries abbreviated
Timeframe = 1D
AUDJPY 658 342 2 
bounsr summary
             bar1        bar2        bar3        bar4        bar5        bar6
mean    84.646809   93.994605   96.241983   95.624696   90.979255   88.791489
std     52.448659   66.442712   93.546442  112.991151  127.761753  138.384995
penesr summary
             bar1        bar2        bar3        bar4        bar5        bar6
mean    63.289766   94.484357   98.389766   97.462865   95.648684   94.333772
std     45.913169   77.070822  103.782248  127.683572  144.407592  153.685528
AUDNZD 670 368 2 
bounsr summary
             bar1        bar2        bar3        bar4        bar5        bar6
mean    72.087463   79.726418   79.038209   79.644328   79.375373   79.949403
std     35.650895   50.536839   68.251836   82.368538   93.917460  109.945672
penesr summary
             bar1        bar2        bar3        bar4        bar5        bar6
mean    53.139402   73.358424   69.047283   70.711957   69.116304   73.700000
std     37.304816   50.827061   65.812464   80.825489   94.034511  109.115501
AUDUSD 660 393 2 
bounsr summary
             bar1        bar2        bar3        bar4        bar5        bar6
mean    74.683636   79.974242   76.295909   74.776970   74.054394   74.870606
std     37.232187   47.286328   71.864143   88.405502  105.428431  116.863818
penesr summary
             bar1        bar2        bar3        bar4        bar5        bar6
mean    53.520865   71.345802   70.002799   67.500254   66.844784   68.860305
std     37.617340   51.062888   74.390041   84.113371   96.853190  112.132229
CADJPY 641 374 2 
bounsr summary
             bar1        bar2        bar3        bar4        bar5        bar6
mean    79.622699   93.178861   90.144228   91.327067   89.882293   86.050546
std     45.695820   63.558826   86.270274  102.865615  121.301507  132.515276
penesr summary
             bar1        bar2        bar3        bar4        bar5        bar6
mean    59.830481   85.797594   85.879011   84.556150   89.260561   91.999198
std     44.094846   70.297597   84.307605   97.975245  117.771851  131.725266
CHFJPY 644 376 2 
bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     90.948098    96.361724    92.226941    93.751630    89.955978    86.863199
std     201.568519   108.925585   116.393441   148.531643   181.104642   192.796800
penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     82.771210    95.279787    93.260638    95.896941    96.645612    90.263963
std     266.597735   132.519961   138.927544   156.195802   175.964215   201.134744
EURCHF 715 331 2 
bounsr summary
             bar1        bar2        bar3         bar4         bar5         bar6
mean    55.419720   58.672308   58.515804    59.648112    59.265874    58.722797
std     44.038019   49.823871   59.859478    80.845496    88.622705    93.907372
penesr summary
             bar1        bar2        bar3        bar4        bar5        bar6
mean    40.858912   52.438066   50.628701   49.094260   47.027190   42.669184
std     51.673617   71.000417   81.771804   90.607507   96.592192  106.715214
EURGBP 686 402 2 
bounsr summary
             bar1        bar2        bar3        bar4        bar5        bar6
mean    56.888484   62.215743   60.894169   60.231924   59.631050   60.907580
std     29.495548   39.695806   59.980908   64.409673   74.806965   85.340346
penesr summary
             bar1        bar2        bar3        bar4        bar5        bar6
mean    38.869652   54.674627   54.088308   52.874876   49.312189   49.204726
std     26.962707   39.869384   63.545289   66.815906   76.693605   83.884736
EURJPY 607 381 2 
bounsr summary
             bar1         bar2        bar3        bar4        bar5        bar6
mean   105.109638   117.074053  114.414662  115.870923  108.839292  105.078830
std     57.551625    90.999851  113.809605  138.456809  157.754923  165.254207
penesr summary
             bar1        bar2        bar3        bar4        bar5        bar6
mean    81.738976  105.877165  103.757612  104.070210  108.969554  107.609580
std     68.999805   78.476318  111.978186  138.363318  157.001007  172.330909
EURUSD 626 369 2 
bounsr summary
             bar1        bar2        bar3        bar4        bar5        bar6
mean    87.973802   94.950639   92.124441   90.724920   93.092492   96.336102
std     45.314403   62.935663   91.468640  111.755774  129.093866  144.146385
penesr summary
             bar1        bar2        bar3        bar4        bar5        bar6
mean    65.240379   85.729539   87.112195   85.247696   86.696206   88.560163
std     45.718757   60.414818   84.158349  108.014570  120.796748  137.739742
GBPJPY 652 377 2 
bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean    139.737813   159.892100   161.816495   147.413494   153.272399   154.444167
std     350.086718   366.642078   380.271002   211.963052   250.792329   269.514226
penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean    106.858881   153.470292   149.452658   149.475724   153.311944   159.354109
std     105.587011   159.631643   185.718860   211.329226   246.125946   267.950054
GBPUSD 642 384 2 
bounsr summary
             bar1        bar2        bar3         bar4         bar5         bar6
mean    96.653271  106.809657  105.473364   103.052336   100.789408    97.566822
std     48.649867   63.976492   93.361849   138.825753   152.609325   171.803393
penesr summary
             bar1         bar2         bar3         bar4         bar5         bar6
mean    73.146354   105.457031   102.141667    98.389062    97.576562    95.008073
std     49.484066    99.698882   122.444422   168.206431   173.052511   193.569152
NZDUSD 706 382 2 
bounsr summary
             bar1        bar2        bar3        bar4        bar5        bar6
mean    73.654108   81.242635   78.777054   79.528470   78.070963   78.203399
std     36.403235   46.680554   69.216773   84.091464   95.579229  105.896518
penesr summary
             bar1        bar2        bar3        bar4        bar5        bar6
mean    52.599215   69.710471   65.856021   63.178534   65.319110   64.653141
std     35.178645   48.874793   66.581853   80.349672   96.119789  104.221729
USDCAD 609 329 2 
bounsr summary
             bar1        bar2        bar3        bar4        bar5        bar6
mean    75.183087   85.484401   85.100657   88.866174   90.444499   89.628079
std     37.669254   50.665233   75.832757   95.395774  109.710516  122.255858
penesr summary
             bar1        bar2        bar3        bar4        bar5        bar6
mean    57.461094   81.365957   77.760486   76.455015   78.606991   77.845897
std     41.841074   57.787855   79.222536  100.074021  117.429280  128.664554
USDCHF 607 353 2 
bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     78.892998    89.230560    88.376359    85.099671    83.130643    82.212685
std     170.798268   185.682403   202.155836   139.615823   148.407019   155.907312
penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     61.180878    72.074221    68.288669    71.406232    72.766572    77.724646
std     216.924650   102.510555   110.326033   116.539018   131.207723   143.526147
USDJPY 676 380 2 
bounsr summary
             bar1        bar2        bar3        bar4        bar5        bar6
mean    72.666124   81.099408   79.269601   79.538905   78.589497   80.385429
std     46.960615   61.390663   86.209334  102.772859  118.919970  129.865087
penesr summary
             bar1        bar2        bar3        bar4        bar5        bar6
mean    59.329605   75.719211   75.324079   77.433421   75.591316   73.327500
std     51.592860   58.461237   89.090061  103.284885  119.743353  131.314815


Timeframe = 4H
AUDJPY 4279 2023 2 
bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     41.597558    46.265786    45.454312    45.653237    45.272529    44.976688
std      22.810774    28.696131    38.288074    46.618147    53.707513    61.095213
penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     28.004572    37.336209    36.429338    37.653164    36.445897    37.676718
std      28.070830    32.494869    41.199680    50.315484    56.002547    62.707065
AUDNZD 4646 1982 2 
bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     37.836634    41.697460    41.750581    42.081489    41.951356    41.714851
std      21.340621    23.271565    31.582260    38.150104    42.960919    48.938603
penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     23.706054    30.812109    30.840212    31.184813    31.084460    30.921847
std      22.685748    24.027149    31.784979    39.124933    43.472456    48.261601
AUDUSD 4294 2081 2 
bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     37.061667    41.609967    41.590359    41.498020    40.518910    40.295203
std      19.191940    23.913328    33.923008    41.430722    46.957776    52.136135
penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     24.944882    32.451321    31.770159    32.792119    32.609899    33.125324
std      20.565471    26.206448    34.956979    42.700810    48.884655    55.420223
CADJPY 4328 2043 2 
bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     39.480360    43.944640    42.728408    43.164545    43.181747    43.710513
std      21.701302    27.902264    36.222258    42.727120    47.868189    54.335620
penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     26.837249    35.593172    32.935928    33.476921    33.600612    35.232477
std      25.658782    31.067541    37.811932    44.844594    50.084880    56.592666
CHFJPY 4303 2086 2 
bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     43.910237    48.268824    46.933686    46.202463    46.078410    46.855659
std      69.497767    43.081718    49.826508    58.168397    61.191829    65.746856
penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     31.427852    39.793696    37.613255    36.725695    37.146261    39.066491
std      97.838611    55.603830    62.823691    71.497868    71.813208    74.348817
EURCHF 4250 1975 2 
bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     32.724529    35.692659    34.964424    34.425976    34.758753    35.333929
std      70.090096    41.091958    45.358844    52.264347    53.418916    55.570270
penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     18.592405    24.991646    22.575797    21.294228    22.320051    23.440000
std      28.468733    38.546877    42.171403    44.039591    48.705661    54.781738
EURGBP 4249 1936 2 
bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     30.512003    34.160979    32.888256    32.241139    32.358014    33.479478
std      16.549735    19.559642    25.752542    32.468653    36.518781    40.908093
penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     19.762862    25.473295    23.081302    21.477376    21.981353    24.405475
std      21.826363    23.237181    29.114316    31.160576    34.411560    38.046836
EURJPY 4138 2063 2 
bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     48.421194    54.476486    53.787289    53.701958    54.000991    54.983205
std      28.662335    39.939996    49.321755    57.384030    64.975205    72.500757
penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     35.227170    46.529254    45.628551    46.101236    45.913767    48.575982
std      34.019357    41.524020    53.145708    62.009869    68.983605    78.815224
EURUSD 4054 2024 2 
bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     43.079428    48.642797    46.048619    44.615392    44.427405    45.990947
std      25.387252    34.024488    42.778499    49.383675    55.437314    62.828057
penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     32.405731    41.183943    37.006670    35.051779    35.696443    39.170257
std      29.006616    37.451636    46.662227    53.862475    59.334473    65.910134
GBPJPY 7756 4186 2 
bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     59.325085    66.258658    64.467300    63.329093    64.891842    66.501578
std      47.971222    65.448693    74.879107    82.925871    93.036030   103.607518
penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     45.837757    61.554862    57.917834    56.597502    58.571776    62.348340
std      58.163487    75.388629    80.824038    91.372966    97.478561   118.849267
GBPUSD 3964 2043 2 
bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     48.011075    53.748638    50.678280    48.480323    48.922780    51.709258
std      33.956249    47.028487    53.426614    58.095976    65.178465    74.177228
penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     36.365051    47.205727    43.501273    41.095056    42.114097    45.949290
std      28.499410    45.682069    56.444106    69.489754    72.676212    78.206884
NZDUSD 4358 2082 2 
bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     36.119160    40.308284    38.829004    39.302157    38.747223    38.738045
std      16.863828    22.420243    30.951561    37.689896    43.402135    48.358277
penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     23.745485    31.452498    30.623247    30.927474    31.256820    30.600672
std      20.212291    25.013508    32.722487    38.658671    44.667285    49.481924
USDCAD 4142 1988 2 
bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     38.443602    42.784838    40.761347    40.515717    40.781386    41.706736
std      20.989505    26.171493    35.058391    41.573890    46.367636    51.924317
penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     27.835664    35.912726    32.497736    31.430433    31.469215    34.568511
std      25.456910    31.163832    37.417246    43.060959    48.354884    54.940006
USDCHF 4320 1962 2 
bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     36.604456    41.256273    39.862616    38.946875    39.091597    41.229780
std      57.675655    35.177039    40.077424    47.838523    51.142267    77.114196
penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     28.081524    34.032824    31.068858    29.322834    30.091641    32.481906
std      83.271051    46.916084    52.483795    60.010841    60.365119    61.738341
USDJPY 4384 2050 2 
bounsr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     36.416994    40.496156    39.896727    40.255885    39.814291    39.910960
std      22.381506    28.271148    35.446555    41.729017    47.308862    52.929737
penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     26.134488    32.920171    32.636049    33.001659    32.237293    32.807341
std      27.976277    31.893486    38.915154    44.745904    51.032318    56.292478


Timeframe = 1H
AUDJPY 17690 7997 2 
bounsr summary
               bar1          bar2          bar3         bar4          bar5          bar6
mean      26.330687     29.530079     29.149333     28.84316     28.678599     28.665557
std       12.720578     16.487793     21.395569     25.44432     28.886249     31.871266
penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     14.593779    20.000757    19.149794    18.621289    18.448618    18.753248
std      15.971268    20.962311    25.236268    28.693523    31.092029    33.482216
AUDNZD 18763 7679 2 
bounsr summary
               bar1         bar2          bar3          bar4          bar5          bar6
mean      25.054991     27.46912     27.223829     27.113841     27.069925     27.093365
std       12.228691     14.16049     17.322601     20.634381     22.892307     25.128816
penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     12.168694    15.816799    15.282875    15.148926    15.120966    14.927451
std      12.858021    14.003861    18.225030    23.617798    24.769254    26.088829
AUDUSD 16517 8277 2 
bounsr summary
               bar1          bar2          bar3          bar4          bar5          bar6
mean      24.425410     27.406442     27.165278     26.768802     26.617485     26.466089
std       10.318177     13.895039     19.265171     22.537931     25.434016     27.988236
penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     12.694128    17.263235    16.527329    16.159466    15.866087    15.910970
std      12.338808    16.322354    20.799830    23.746640    26.223900    28.678277
CADJPY 17048 8258 2 
bounsr summary
               bar1          bar2          bar3          bar4          bar5          bar6
mean      25.232769     28.387113     28.093700     28.016316     27.894853     27.914776
std       11.384631     14.923466     19.819825     23.710842     26.866718     29.939625
penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     13.304662    18.311244    17.735015    17.385269    17.340997    17.474594
std      15.012740    19.564021    23.263915    27.588386    31.086247    33.056935
CHFJPY 17955 8014 2 
bounsr summary
               bar1          bar2          bar3          bar4          bar5          bar6
mean      27.027080     30.189290     29.744818     29.529137     29.449028     29.197608
std       38.754726     24.308867     27.648108     31.544381     36.511211     40.387082
penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     15.204264    20.182337    19.161948    18.994329    19.069391    19.057244
std      56.801589    32.740274    35.903939    40.223240    43.643720    45.870725
EURCHF 12714 7223 2 
bounsr summary
               bar1          bar2          bar3          bar4          bar5          bar6
mean      23.543248     25.642599     25.271834     25.064991     24.862113     24.970890
std       42.256022     23.817048     26.710905     28.374881     30.601330     34.423218
penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean      9.502146    12.687235    12.100540    12.408258    11.887374    11.669057
std      12.389577    16.817031    24.382192    59.738114    35.642199    40.038636
EURGBP 13469 7487 2 
bounsr summary
               bar1          bar2          bar3          bar4          bar5          bar6
mean      21.547977     23.945957     23.637805     23.344510     23.221033     23.207870
std        9.862896     11.313954     14.768511     17.764428     20.212498     22.357544
penesr summary
             bar1         bar2         bar3         bar4         bar5         bar6
mean      9.61170    13.216455    12.768759    12.361413    12.255550    12.124162
std      12.05328    12.567763    16.270644    19.241953    21.366913    23.566075
EURJPY 17979 7973 2 
bounsr summary
               bar1          bar2          bar3          bar4          bar5          bar6
mean      29.070404     32.803048     32.562006     32.360674     32.502778     32.615896
std       14.275760     19.465504     25.578228     30.285400     34.943170     39.000119
penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     17.883037    24.507569    23.416336    22.905393    22.936053    22.942173
std      17.369509    23.763148    29.302256    35.494324    40.983476    44.265159
EURUSD 16487 7941 2 
bounsr summary
               bar1          bar2          bar3          bar4          bar5          bar6
mean      26.526366     30.002808     29.653333     29.488834     29.380603     29.428623
std       12.992262     17.844050     23.572333     28.177568     31.787946     34.581846
penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     15.291324    20.780141    20.061957    19.494736    19.328750    19.492835
std      14.862870    20.835930    26.179528    30.395039    34.094985    38.098518
GBPJPY 17725 7997 2 
bounsr summary
               bar1          bar2          bar3          bar4          bar5          bar6
mean      33.832337     38.938028     38.264063     38.023144     37.996487     37.994701
std       17.993323     70.888599     32.095846     39.345442     47.019447     51.852689
penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     22.720534    30.892607    29.792422    29.232702    30.319117    29.224037
std      26.691897    31.336938    38.501027    50.041908   114.631575    64.156777
GBPUSD 16953 7970 2 
bounsr summary
               bar1          bar2          bar3          bar4          bar5          bar6
mean      28.332891     32.046381     31.799658     31.348847     31.138642     31.167758
std       15.406795     18.168311     24.421536     29.188170     33.414922     37.020388
penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     17.530740    23.640314    23.009649    22.747867    22.695922    22.810013
std      20.200496    23.016495    29.594513    36.630865    42.907277    48.586850
NZDUSD 16754 8064 2 
bounsr summary
               bar1          bar2          bar3          bar4          bar5          bar6
mean      23.807610     26.636367     26.517351     26.414295     26.482828     26.517763
std       10.064091     13.296014     17.623479     20.820998     23.682329     26.031089
penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     11.778646    15.713852    15.142485    14.939063    14.787463    14.836223
std      11.963234    14.645016    18.893078    21.739739    23.991976    26.292481
USDCAD 15750 8105 2 
bounsr summary
               bar1          bar2          bar3          bar4          bar5          bar6
mean      24.653263     27.854165     27.611695     27.388857     27.171968     27.068552
std       11.495206     15.171455     19.929525     23.430236     26.606002     29.670134
penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     12.618125    17.563701    17.180666    16.602110    16.416965    16.364911
std      13.529029    17.771882    22.252264    25.988667    28.936393    31.521968
USDCHF 15441 7712 2 
bounsr summary
               bar1          bar2          bar3          bar4          bar5          bar6
mean      24.153190     26.953287     26.547031     26.209229     26.131662     26.153429
std       32.194766     22.131554     24.247147     27.753321     30.796468     32.673904
penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     12.473846    16.765716    16.419554    15.724170    15.604487    15.820773
std      44.670220    29.191433    52.670871    41.006501    39.368047    42.400497
USDJPY 16432 7907 2 
bounsr summary
               bar1          bar2          bar3          bar4          bar5          bar6
mean      24.054093     26.859025     26.466687     26.164673     26.122876     26.144648
std       11.223618     15.000275     19.829976     23.124919     26.125796     28.698820
penesr summary
              bar1         bar2         bar3         bar4         bar5         bar6
mean     12.795713    17.206564    16.594157    16.177925    15.983951    15.890812
std      14.180187    17.821550    21.858865    25.890059    28.199032    30.535191
*** TODO market close
use 1H to see what happens in the last hours of the week. is there a pullback on big moves?

this is particularly important for the weekly close.

*** TODO nu properties
nuances.py determines some of these, specifically what the distances between nu is, since this gives us an idea of how much travelling in pips pa does within nu.

after nu is formed how far does pa move in either direction

notice that some pairs have tight std around the mean.


./tfx/AUDJPY/audjpy1D.csv
count     539.000000
mean      232.986827
std       304.832808
min         0.450000
25%       118.375000
50%       183.800000
75%       267.900000
max      4673.550000
Name: diffs, dtype: float64
./tfx/AUDNZD/audnzd1D.csv
count    564.000000
mean     168.999291
std      111.989231
min        0.000000
25%       99.325000
50%      147.400000
75%      211.075000
max      717.800000
Name: diffs, dtype: float64
./tfx/AUDUSD/audusd1D.csv
count     572.000000
mean      178.275000
std       130.967858
min         0.000000
25%        99.000000
50%       154.650000
75%       227.725000
max      1152.500000
Name: diffs, dtype: float64
./tfx/CADJPY/cadjpy1D.csv
count    535.000000
mean     197.068037
std      142.536907
min        0.000000
25%      108.950000
50%      166.750000
75%      244.175000
max      954.050000
Name: diffs, dtype: float64
./tfx/CHFJPY/chfjpy1D.csv
count     540.000000
mean      219.551111
std       165.419156
min         0.000000
25%       121.025000
50%       184.800000
75%       277.000000
max      1324.400000
Name: diffs, dtype: float64
./tfx/EURCHF/eurchf1D.csv
count     555.000000
mean      141.052432
std       338.274130
min         0.000000
25%        44.350000
50%        90.500000
75%       153.100000
max      6237.400000
Name: diffs, dtype: float64
./tfx/EURGBP/eurgbp1D.csv
count    549.000000
mean     132.327140
std       92.864499
min        0.300000
25%       75.100000
50%      118.200000
75%      171.100000
max      905.500000
Name: diffs, dtype: float64
./tfx/EURJPY/eurjpy1D.csv
count     551.000000
mean      255.907441
std       175.841129
min         0.100000
25%       148.350000
50%       226.000000
75%       326.725000
max      1251.600000
Name: diffs, dtype: float64
./tfx/EURUSD/eurusd1D.csv
count    554.000000
mean     211.207220
std      137.036065
min        1.000000
25%      124.125000
50%      182.000000
75%      286.275000
max      789.500000
Name: diffs, dtype: float64
./tfx/GBPJPY/gbpjpy1D.csv
count     572.000000
mean      332.614878
std       264.293192
min         0.300000
25%       179.275000
50%       271.700000
75%       402.062500
max      2687.350000
Name: diffs, dtype: float64
./tfx/GBPUSD/gbpusd1D.csv
count     546.000000
mean      247.778388
std       176.830470
min         0.800000
25%       145.200000
50%       220.100000
75%       320.450000
max      2050.700000
Name: diffs, dtype: float64
./tfx/NZDUSD/nzdusd1D.csv
count    587.000000
mean     168.093186
std      107.241932
min        1.400000
25%       97.600000
50%      151.700000
75%      214.350000
max      715.200000
Name: diffs, dtype: float64
./tfx/USDCAD/usdcad1D.csv
count    539.000000
mean     182.626531
std      128.745226
min        1.600000
25%       97.100000
50%      157.300000
75%      243.650000
max      996.400000
Name: diffs, dtype: float64
./tfx/USDCHF/usdchf1D.csv
count     540.000000
mean      182.074815
std       244.158124
min         0.000000
25%        90.375000
50%       140.500000
75%       225.450000
max      4973.700000
Name: diffs, dtype: float64
./tfx/USDJPY/usdjpy1D.csv
count     564.000000
mean      173.602837
std       132.926701
min         0.000000
25%        87.387500
50%       145.400000
75%       224.062500
max      1270.650000
Name: diffs, dtype: float64
*** TODO hopp
handling opposing price progression
sometimes price suddenly goes against expected trend usually due to unexpected news event. examine ways to deal with these situations.

1. ex and reverse direction
2. ex and nightingale
3. ex and re-enter in same direction elsewhere
4. en with averaging intention

merits of these should be quantitatively ascertained
*** TODO analysis of pa
1. why bounsr or penesr
2. how to effectively trade stayer turner btn sr levels 
3. trends may be stable if there is initial pullback confirming no hh|ll
4. tl can prevent pa from reaching sr, thereby forming a new sr
5. intersection of tl and sr (even a weak-looking one) can be very strong
6. strong trends off strong sr will likely cause multiple penesr
*** TODO strength of trends
can be measured by pips/hr
the following isn't particularly quantitative, but qualitatively
strong trend -> weak return
weak trend -> strong return
just a quick survey
|         | s-return | w-return |
| s-trend |        4 |        5 |
| w-trend |        4 |        1 |

what happens at sr with strong/weak trends?
which approaches produce penesr vs bounsr?

*** TODO news
main reason to be aware of the news is to understand what is influencing a trend. it is not so much predictive as confirmative - eg the huge 500p move by gbpusd between 191010-11.

a study of pa during specific events such as nfp, would likely be useful. there are likely patterns that remain consistent. (see nfp in notes <2019-12-06 Fri>)

glossary of news events and codings
[[https://www.dailyfx.com/economic-calendar][dailyfx economic calendar]]
[[https://www.fxstreet.com/education/5-forex-news-events-you-need-to-know-201504240000][5fx events to know]]
1. Central Bank Rate Decision
2. GDP
3. CPI
4. Unemployment Rate
5. FOMC

*** DONE pair characteristics
these are the pairs with the lowest spreads (usually).
understand their nature and their correlations when possible.
the key one that's not there is usdchf.

the 12 below have the lowest spreads mostly <2p.
| pair   | nickname | margin | spread |
| audjpy | aussie   |    7.0 |    1.6 |
| audusd |          |    4.6 |    1.3 |
| cadjpy |          |    4.0 |    1.8 |
| euraud |          |    6.0 |    1.9 |
| eurgbp |          |    6.0 |    1.8 |
| eurjpy |          |    7.0 |    1.6 |
| eurusd |          |    4.6 |    1.3 |
| gbpusd | cable    |    4.6 |    1.9 |
| nzdjpy |          |    7.0 |    1.9 |
| nzdusd |          |    4.6 |    1.5 |
| usdcad | loonie   |    2.0 |    1.7 |
| usdjpy | gopher   |    5.6 |    1.3 |

*** DONE loch
prior co influence on present candle.
can get 6 or 12 pips in same direction of co?
are results improved with mline confluence?
**** results
audjpy1D.csv  @  6
co_rate = 88% hop mean = 21.8 lon mean = -23.6
com_rate = 87% hopm mean = 10.7 lonm mean = -12.4

audjpy1D.csv  @  12
co_rate = 78% hop mean = 21.3 lon mean = -23.2
com_rate = 77% hopm mean = 10.4 lonm mean = -12.2


audnzd1D.csv  @  6
co_rate = 89% hop mean = 19.4 lon mean = -19.9
com_rate = 89% hopm mean = 8.6 lonm mean = -11.4

audnzd1D.csv  @  12
co_rate = 80% hop mean = 18.9 lon mean = -19.5
com_rate = 79% hopm mean = 8.4 lonm mean = -11.2


audusd1D.csv  @  6
co_rate = 87% hop mean = 19.6 lon mean = -19.3
com_rate = 87% hopm mean = 8.8 lonm mean = -9.9

audusd1D.csv  @  12
co_rate = 76% hop mean = 19.1 lon mean = -18.8
com_rate = 75% hopm mean = 8.5 lonm mean = -9.7


cadjpy1D.csv  @  6
co_rate = 86% hop mean = 19.5 lon mean = -22.7
com_rate = 87% hopm mean = 10.1 lonm mean = -12.5

cadjpy1D.csv  @  12
co_rate = 76% hop mean = 19.1 lon mean = -22.2
com_rate = 77% hopm mean = 9.9 lonm mean = -12.3


chfjpy1D.csv  @  6
co_rate = 89% hop mean = 23.3 lon mean = -23.2
com_rate = 88% hopm mean = 11.7 lonm mean = -11.5

chfjpy1D.csv  @  12
co_rate = 78% hop mean = 22.8 lon mean = -22.7
com_rate = 78% hopm mean = 11.5 lonm mean = -11.3


eurchf1D.csv  @  6
co_rate = 76% hop mean = 13.3 lon mean = -14.0
com_rate = 79% hopm mean = 6.3 lonm mean = -7.0

eurchf1D.csv  @  12
co_rate = 59% hop mean = 12.5 lon mean = -13.2
com_rate = 61% hopm mean = 6.0 lonm mean = -6.6


eurgbp1D.csv  @  6
co_rate = 83% hop mean = 14.9 lon mean = -13.3
com_rate = 82% hopm mean = 7.1 lonm mean = -6.1

eurgbp1D.csv  @  12
co_rate = 68% hop mean = 14.2 lon mean = -12.6
com_rate = 67% hopm mean = 6.8 lonm mean = -5.7


eurjpy1D.csv  @  6
co_rate = 89% hop mean = 27.1 lon mean = -27.6
com_rate = 88% hopm mean = 13.7 lonm mean = -14.3

eurjpy1D.csv  @  12
co_rate = 80% hop mean = 26.7 lon mean = -27.2
com_rate = 80% hopm mean = 13.5 lonm mean = -14.1


eurusd1D.csv  @  6
co_rate = 88% hop mean = 23.5 lon mean = -21.8
com_rate = 88% hopm mean = 10.8 lonm mean = -10.4

eurusd1D.csv  @  12
co_rate = 78% hop mean = 23.0 lon mean = -21.4
com_rate = 78% hopm mean = 10.6 lonm mean = -10.2


gbpjpy1D.csv  @  6
co_rate = 91% hop mean = 33.8 lon mean = -38.2
com_rate = 92% hopm mean = 18.7 lonm mean = -20.0

gbpjpy1D.csv  @  12
co_rate = 84% hop mean = 33.4 lon mean = -37.9
com_rate = 85% hopm mean = 18.6 lonm mean = -19.8


gbpusd1D.csv  @  6
co_rate = 91% hop mean = 25.9 lon mean = -26.2
com_rate = 92% hopm mean = 13.0 lonm mean = -12.6

gbpusd1D.csv  @  12
co_rate = 82% hop mean = 25.5 lon mean = -25.8
com_rate = 83% hopm mean = 12.8 lonm mean = -12.4


nzdusd1D.csv  @  6
co_rate = 87% hop mean = 18.7 lon mean = -18.3
com_rate = 87% hopm mean = 8.9 lonm mean = -9.1

nzdusd1D.csv  @  12
co_rate = 76% hop mean = 18.2 lon mean = -17.8
com_rate = 76% hopm mean = 8.6 lonm mean = -8.8


usdcad1D.csv  @  6
co_rate = 88% hop mean = 21.7 lon mean = -19.1
com_rate = 90% hopm mean = 11.2 lonm mean = -8.9

usdcad1D.csv  @  12
co_rate = 77% hop mean = 21.1 lon mean = -18.6
com_rate = 77% hopm mean = 10.8 lonm mean = -8.7


usdchf1D.csv  @  6
co_rate = 86% hop mean = 18.5 lon mean = -20.4
com_rate = 87% hopm mean = 8.9 lonm mean = -9.2

usdchf1D.csv  @  12
co_rate = 74% hop mean = 18.0 lon mean = -19.9
com_rate = 73% hopm mean = 8.6 lonm mean = -8.9


usdjpy1D.csv  @  6
co_rate = 84% hop mean = 18.5 lon mean = -20.5
com_rate = 82% hopm mean = 9.0 lonm mean = -10.0

usdjpy1D.csv  @  12
co_rate = 72% hop mean = 17.9 lon mean = -20.0
com_rate = 71% hopm mean = 8.7 lonm mean = -9.8


audjpy4H.csv  @  6
co_rate = 75% hop mean = 9.1 lon mean = -9.6
com_rate = 76% hopm mean = 4.4 lonm mean = -4.8

audjpy4H.csv  @  12
co_rate = 55% hop mean = 8.1 lon mean = -8.8
com_rate = 55% hopm mean = 3.9 lonm mean = -4.4


audnzd4H.csv  @  6
co_rate = 74% hop mean = 7.8 lon mean = -7.9
com_rate = 75% hopm mean = 3.6 lonm mean = -3.9

audnzd4H.csv  @  12
co_rate = 50% hop mean = 6.8 lon mean = -6.7
com_rate = 50% hopm mean = 3.1 lonm mean = -3.3


audusd4H.csv  @  6
co_rate = 71% hop mean = 7.7 lon mean = -8.0
com_rate = 71% hopm mean = 3.6 lonm mean = -3.9

audusd4H.csv  @  12
co_rate = 49% hop mean = 6.7 lon mean = -7.1
com_rate = 50% hopm mean = 3.2 lonm mean = -3.5


cadjpy4H.csv  @  6
co_rate = 72% hop mean = 8.1 lon mean = -8.6
com_rate = 72% hopm mean = 3.9 lonm mean = -4.2

cadjpy4H.csv  @  12
co_rate = 50% hop mean = 7.0 lon mean = -7.7
com_rate = 50% hopm mean = 3.4 lonm mean = -3.8


chfjpy4H.csv  @  6
co_rate = 76% hop mean = 9.7 lon mean = -9.4
com_rate = 76% hopm mean = 4.9 lonm mean = -4.4

chfjpy4H.csv  @  12
co_rate = 55% hop mean = 8.7 lon mean = -8.5
com_rate = 55% hopm mean = 4.4 lonm mean = -4.0


eurchf4H.csv  @  6
co_rate = 52% hop mean = 5.2 lon mean = -5.6
com_rate = 56% hopm mean = 2.3 lonm mean = -2.4

eurchf4H.csv  @  12
co_rate = 30% hop mean = 4.2 lon mean = -4.7
com_rate = 33% hopm mean = 1.9 lonm mean = -2.0


eurgbp4H.csv  @  6
co_rate = 58% hop mean = 5.4 lon mean = -4.9
com_rate = 58% hopm mean = 2.6 lonm mean = -2.2

eurgbp4H.csv  @  12
co_rate = 32% hop mean = 4.3 lon mean = -3.8
com_rate = 33% hopm mean = 2.1 lonm mean = -1.7


eurjpy4H.csv  @  6
co_rate = 78% hop mean = 11.2 lon mean = -11.1
com_rate = 77% hopm mean = 5.6 lonm mean = -5.2

eurjpy4H.csv  @  12
co_rate = 59% hop mean = 10.3 lon mean = -10.3
com_rate = 59% hopm mean = 5.2 lonm mean = -4.9


eurusd4H.csv  @  6
co_rate = 71% hop mean = 9.1 lon mean = -8.8
com_rate = 71% hopm mean = 4.4 lonm mean = -4.2

eurusd4H.csv  @  12
co_rate = 50% hop mean = 8.2 lon mean = -7.9
com_rate = 51% hopm mean = 4.0 lonm mean = -3.7


gbpjpy4H.csv  @  6
co_rate = 83% hop mean = 14.4 lon mean = -14.6
com_rate = 82% hopm mean = 7.2 lonm mean = -7.3

gbpjpy4H.csv  @  12
co_rate = 67% hop mean = 13.6 lon mean = -13.9
com_rate = 66% hopm mean = 6.8 lonm mean = -6.9


gbpusd4H.csv  @  6
co_rate = 75% hop mean = 10.1 lon mean = -10.3
com_rate = 74% hopm mean = 4.7 lonm mean = -5.0

gbpusd4H.csv  @  12
co_rate = 55% hop mean = 9.1 lon mean = -9.4
com_rate = 55% hopm mean = 4.3 lonm mean = -4.6


nzdusd4H.csv  @  6
co_rate = 71% hop mean = 7.4 lon mean = -7.5
com_rate = 71% hopm mean = 3.4 lonm mean = -3.6

nzdusd4H.csv  @  12
co_rate = 48% hop mean = 6.4 lon mean = -6.4
com_rate = 48% hopm mean = 3.0 lonm mean = -3.1


usdcad4H.csv  @  6
co_rate = 68% hop mean = 7.7 lon mean = -7.3
com_rate = 68% hopm mean = 3.7 lonm mean = -3.3

usdcad4H.csv  @  12
co_rate = 45% hop mean = 6.7 lon mean = -6.3
com_rate = 45% hopm mean = 3.3 lonm mean = -2.9


usdchf4H.csv  @  6
co_rate = 66% hop mean = 6.9 lon mean = -7.3
com_rate = 66% hopm mean = 3.3 lonm mean = -3.4

usdchf4H.csv  @  12
co_rate = 42% hop mean = 5.9 lon mean = -6.3
com_rate = 43% hopm mean = 2.8 lonm mean = -3.0


usdjpy4H.csv  @  6
co_rate = 67% hop mean = 7.4 lon mean = -7.7
com_rate = 67% hopm mean = 3.6 lonm mean = -3.8

usdjpy4H.csv  @  12
co_rate = 45% hop mean = 6.4 lon mean = -6.8
com_rate = 46% hopm mean = 3.1 lonm mean = -3.4


audjpy1H.csv  @  6
co_rate = 54% hop mean = 4.2 lon mean = -4.3
com_rate = 55% hopm mean = 1.9 lonm mean = -2.0

audjpy1H.csv  @  12
co_rate = 27% hop mean = 3.0 lon mean = -3.2
com_rate = 29% hopm mean = 1.3 lonm mean = -1.6


audnzd1H.csv  @  6
co_rate = 50% hop mean = 3.3 lon mean = -3.4
com_rate = 51% hopm mean = 1.4 lonm mean = -1.5

audnzd1H.csv  @  12
co_rate = 21% hop mean = 2.1 lon mean = -2.2
com_rate = 22% hopm mean = 0.9 lonm mean = -1.0


audusd1H.csv  @  6
co_rate = 47% hop mean = 3.4 lon mean = -3.4
com_rate = 49% hopm mean = 1.5 lonm mean = -1.6

audusd1H.csv  @  12
co_rate = 22% hop mean = 2.3 lon mean = -2.3
com_rate = 24% hopm mean = 1.0 lonm mean = -1.1


cadjpy1H.csv  @  6
co_rate = 49% hop mean = 3.6 lon mean = -3.8
com_rate = 52% hopm mean = 1.6 lonm mean = -1.8

cadjpy1H.csv  @  12
co_rate = 24% hop mean = 2.5 lon mean = -2.7
com_rate = 26% hopm mean = 1.1 lonm mean = -1.3


chfjpy1H.csv  @  6
co_rate = 53% hop mean = 4.3 lon mean = -4.3
com_rate = 55% hopm mean = 1.9 lonm mean = -1.9

chfjpy1H.csv  @  12
co_rate = 27% hop mean = 3.1 lon mean = -3.2
com_rate = 29% hopm mean = 1.4 lonm mean = -1.5


eurchf1H.csv  @  6
co_rate = 30% hop mean = 2.1 lon mean = -2.2
com_rate = 36% hopm mean = 0.9 lonm mean = -0.9

eurchf1H.csv  @  12
co_rate = 13% hop mean = 1.4 lon mean = -1.5
com_rate = 17% hopm mean = 0.6 lonm mean = -0.7


eurgbp1H.csv  @  6
co_rate = 32% hop mean = 2.1 lon mean = -2.0
com_rate = 36% hopm mean = 0.9 lonm mean = -0.8

eurgbp1H.csv  @  12
co_rate = 12% hop mean = 1.2 lon mean = -1.1
com_rate = 14% hopm mean = 0.5 lonm mean = -0.5


eurjpy1H.csv  @  6
co_rate = 58% hop mean = 5.2 lon mean = -5.2
com_rate = 60% hopm mean = 2.4 lonm mean = -2.4

eurjpy1H.csv  @  12
co_rate = 33% hop mean = 4.0 lon mean = -4.2
com_rate = 35% hopm mean = 1.9 lonm mean = -2.0


eurusd1H.csv  @  6
co_rate = 48% hop mean = 4.0 lon mean = -3.8
com_rate = 51% hopm mean = 1.8 lonm mean = -1.7

eurusd1H.csv  @  12
co_rate = 25% hop mean = 3.0 lon mean = -2.9
com_rate = 28% hopm mean = 1.4 lonm mean = -1.3


gbpjpy1H.csv  @  6
co_rate = 66% hop mean = 6.8 lon mean = -7.0
com_rate = 67% hopm mean = 3.1 lonm mean = -3.3

gbpjpy1H.csv  @  12
co_rate = 42% hop mean = 5.7 lon mean = -6.0
com_rate = 44% hopm mean = 2.6 lonm mean = -2.9


gbpusd1H.csv  @  6
co_rate = 53% hop mean = 4.7 lon mean = -4.6
com_rate = 55% hopm mean = 2.0 lonm mean = -2.1

gbpusd1H.csv  @  12
co_rate = 29% hop mean = 3.7 lon mean = -3.5
com_rate = 32% hopm mean = 1.6 lonm mean = -1.7


nzdusd1H.csv  @  6
co_rate = 46% hop mean = 3.2 lon mean = -3.2
com_rate = 48% hopm mean = 1.5 lonm mean = -1.5

nzdusd1H.csv  @  12
co_rate = 20% hop mean = 2.1 lon mean = -2.1
com_rate = 22% hopm mean = 1.0 lonm mean = -1.0


usdcad1H.csv  @  6
co_rate = 45% hop mean = 3.3 lon mean = -3.3
com_rate = 46% hopm mean = 1.5 lonm mean = -1.4

usdcad1H.csv  @  12
co_rate = 21% hop mean = 2.3 lon mean = -2.3
com_rate = 23% hopm mean = 1.1 lonm mean = -1.0


usdchf1H.csv  @  6
co_rate = 41% hop mean = 2.9 lon mean = -3.1
com_rate = 44% hopm mean = 1.3 lonm mean = -1.4

usdchf1H.csv  @  12
co_rate = 18% hop mean = 1.9 lon mean = -2.1
com_rate = 20% hopm mean = 0.9 lonm mean = -1.0


usdjpy1H.csv  @  6
co_rate = 44% hop mean = 3.2 lon mean = -3.4
com_rate = 47% hopm mean = 1.4 lonm mean = -1.6

usdjpy1H.csv  @  12
co_rate = 20% hop mean = 2.1 lon mean = -2.5
com_rate = 23% hopm mean = 1.0 lonm mean = -1.2
*** DONE ma
setup below applies to 1da charts:
- maS wma6 cyan, shows 1 wk|da trend
- maM ema36 orange, shows 1 mo|wk trend
- maL sma216 brown, functions as the standard 200ma

sr can be particularly strong when there are multiple coincidences.

because ma lag, they can be utilized as confirmations:
- horizontal ma can be used as a mean-reversion mechanism for ranger
- maS often acts as a sr guide on steep slope
- maSxM and ma nu can signal trend beginning

maSM combo can guide en with the direction given by M and pullback by S.
*** DONE adjacent confluence
NOT WORTH PURSUING at this stage:
does move in one direction on candlestick continue on the next one?
apparently not.
Auu/Aud or Add/Adu ratios are usually 1 on 1D or 4H
suggesting that it's a 50% proposition whether a prior candle's influence has much bearing.
minor improvement when we insist that on prior 2 candles for
uu we have hh 
dd we have ll

confirmed by adjbar results:
| audjpy1D.csv |   46 |
| audnzd1D.csv |   49 |
| audusd1D.csv |   47 |
| cadjpy1D.csv |   47 |
| chfjpy1D.csv |   47 |
| eurchf1D.csv |   45 |
| audjpy1D.csv |   46 |
| audnzd1D.csv |   49 |
| audusd1D.csv |   47 |
| cadjpy1D.csv |   47 |
| chfjpy1D.csv |   47 |
| eurchf1D.csv |   45 |
| eurgbp1D.csv |   47 |
| eurjpy1D.csv |   47 |
| eurusd1D.csv |   46 |
| gbpjpy1D.csv |   49 |
| gbpusd1D.csv |   48 |
| nzdusd1D.csv |   48 |
| usdcad1D.csv |   48 |
| usdchf1D.csv |   47 |
| usdjpy1D.csv |   46 |
| mean         | 47.1 |

| audjpy4H.csv |   47 |
| audnzd4H.csv |   46 |
| audusd4H.csv |   46 |
| cadjpy4H.csv |   46 |
| chfjpy4H.csv |   46 |
| eurchf4H.csv |   41 |
| eurgbp4H.csv |   44 |
| eurjpy4H.csv |   47 |
| eurusd4H.csv |   46 |
| gbpjpy4H.csv |   47 |
| gbpusd4H.csv |   46 |
| nzdusd4H.csv |   46 |
| usdcad4H.csv |   46 |
| usdchf4H.csv |   45 |
| usdjpy4H.csv |   45 |
| mean         | 45.6 |

| audjpy1H.csv |   44 |
| audnzd1H.csv |   42 |
| audusd1H.csv |   43 |
| cadjpy1H.csv |   43 |
| chfjpy1H.csv |   43 |
| eurchf1H.csv |   36 |
| eurgbp1H.csv |   39 |
| eurjpy1H.csv |   43 |
| eurusd1H.csv |   42 |
| gbpjpy1H.csv |   44 |
| gbpusd1H.csv |   43 |
| nzdusd1H.csv |   43 |
| usdcad1H.csv |   43 |
| usdchf1H.csv |   41 |
| usdjpy1H.csv |   42 |
| mean         | 42.1 |





**** uu ud dd du
        if uu:
            Auu += 1
        if ud:
            Aud += 1
        if dd:
            Add += 1
        if du:
            Adu += 1
./tfx/AUDJPY/audjpy1D.csv
577/582=0.99 473/583=0.81
./tfx/AUDNZD/audnzd1D.csv
535/537=1.00 592/538=1.10
./tfx/AUDUSD/audusd1D.csv
568/567=1.00 500/568=0.88
./tfx/CADJPY/cadjpy1D.csv
547/575=0.95 531/575=0.92
./tfx/CHFJPY/chfjpy1D.csv
549/579=0.95 503/580=0.87
./tfx/EURCHF/eurchf1D.csv
507/548=0.93 568/550=1.03
./tfx/EURGBP/eurgbp1D.csv
553/557=0.99 532/554=0.96
./tfx/EURJPY/eurjpy1D.csv
569/573=0.99 502/573=0.88
./tfx/EURUSD/eurusd1D.csv
538/572=0.94 514/571=0.90
./tfx/GBPJPY/gbpjpy1D.csv
571/555=1.03 533/556=0.96
./tfx/GBPUSD/gbpusd1D.csv
556/556=1.00 537/556=0.97
./tfx/NZDUSD/nzdusd1D.csv
549/553=0.99 539/557=0.97
./tfx/USDCAD/usdcad1D.csv
588/543=1.08 519/543=0.96
./tfx/USDCHF/usdchf1D.csv
563/568=0.99 498/570=0.87
./tfx/USDJPY/usdjpy1D.csv
545/589=0.93 491/588=0.84
**** uu+hh ud-hh dd+ll du-ll
        # hilo behaviors
        hh = df['high'].iloc[i-2] < df['high'].iloc[i-1]
        ll = df['low'].iloc[i-2] > df['low'].iloc[i-1]

        if uu and hh:
            Auu += 1
        if ud and not hh:
            Aud += 1
        if dd and ll:
            Add += 1
        if du and not ll:
            Adu += 1

./tfx/AUDJPY/audjpy1D.csv
386/207=1.86 313/197=1.59
./tfx/AUDNZD/audnzd1D.csv
352/176=2.00 396/159=2.49
./tfx/AUDUSD/audusd1D.csv
355/187=1.90 348/179=1.94
./tfx/CADJPY/cadjpy1D.csv
384/202=1.90 369/197=1.87
./tfx/CHFJPY/chfjpy1D.csv
384/210=1.83 359/213=1.69
./tfx/EURCHF/eurchf1D.csv
322/196=1.64 362/181=2.00
./tfx/EURGBP/eurgbp1D.csv
370/167=2.22 359/163=2.20
./tfx/EURJPY/eurjpy1D.csv
380/203=1.87 349/194=1.80
./tfx/EURUSD/eurusd1D.csv
358/193=1.85 336/174=1.93
./tfx/GBPJPY/gbpjpy1D.csv
406/186=2.18 374/182=2.05
./tfx/GBPUSD/gbpusd1D.csv
362/183=1.98 371/171=2.17
./tfx/NZDUSD/nzdusd1D.csv
367/183=2.01 377/173=2.18
./tfx/USDCAD/usdcad1D.csv
376/177=2.12 348/206=1.69
./tfx/USDCHF/usdchf1D.csv
379/184=2.06 341/199=1.71
./tfx/USDJPY/usdjpy1D.csv
357/189=1.89 310/193=1.61

**** uu+hh ud+hh dd+ll du+ll
        # hilo behaviors
        hh = df['high'].iloc[i-2] < df['high'].iloc[i-1]
        ll = df['low'].iloc[i-2] > df['low'].iloc[i-1]

        if uu and hh:
            Auu += 1
        if ud and hh:
            Aud += 1
        if dd and ll:
            Add += 1
        if du and ll:
            Adu += 1

./tfx/AUDJPY/audjpy1D.csv
386/375=1.03 313/386=0.81
./tfx/AUDNZD/audnzd1D.csv
352/361=0.98 396/379=1.04
./tfx/AUDUSD/audusd1D.csv
355/380=0.93 348/389=0.89
./tfx/CADJPY/cadjpy1D.csv
384/373=1.03 369/378=0.98
./tfx/CHFJPY/chfjpy1D.csv
384/369=1.04 359/367=0.98
./tfx/EURCHF/eurchf1D.csv
322/352=0.91 362/369=0.98
./tfx/EURGBP/eurgbp1D.csv
370/390=0.95 359/391=0.92
./tfx/EURJPY/eurjpy1D.csv
380/370=1.03 349/379=0.92
./tfx/EURUSD/eurusd1D.csv
358/379=0.94 336/397=0.85
./tfx/GBPJPY/gbpjpy1D.csv
406/369=1.10 374/374=1.00
./tfx/GBPUSD/gbpusd1D.csv
362/373=0.97 371/385=0.96
./tfx/NZDUSD/nzdusd1D.csv
367/370=0.99 377/384=0.98
./tfx/USDCAD/usdcad1D.csv
376/366=1.03 348/337=1.03
./tfx/USDCHF/usdchf1D.csv
379/384=0.99 341/371=0.92
./tfx/USDJPY/usdjpy1D.csv
357/400=0.89 310/395=0.78
**** uu+ll ud+ll dd+hh du+hh
* api
** .v20.conf file
hostname: api-fxpractice.oanda.com
streaming_hostname: stream-fxpractice.oanda.com
port: 443
ssl: true
token: 8682793479e663dfa1520ad753566ca7-7212ebf93fb7ecba4941835537a0f6f7
username: theprader
datetime_format: RFC3339
accounts:
- 101-002-9789110-001
- 101-002-9789110-002
- 101-002-9789110-003
- 101-002-9789110-004
active_account: 101-002-9789110-003

* notes
<2019-12-06 Fri>
5:30am nfp p:156, f:190, a:266
caused large gain in usd that lasted to 7am
8-12 minor retracements on various majors and yen pairs for some reason
so effect seems to last 2hrs
* zzold
** work through quantnews
 [[https://www.quantnews.com/algo-trading-with-rest-api-and-python-part-3/][Algo Trading with REST API and Python | Part 3: Using the fxcmpy Python wrapper to connect to FXCM’s REST API]]
 - create function to place entry and market trades with stops and limits
 [[https://www.quantnews.com/algo-trading-with-rest-api-and-python-part-4/][Algo Trading with REST API and Python | Part 4: Building and Backtesting an EMA Crossover Strategy]]
 [[https://www.quantnews.com/bollinger-bands-backtest-using-python-rest-api-part-1/][Bollinger Bands Backtest using Python and REST API | Part 1]]


*** understanding the various python strategies that are available
 [[https://www.quantnews.com/algo-trading-with-rest-api-and-python-part-4/][Algo Trading with REST API and Python | Part 4: Building and Backtesting an EMA Crossover Strategy]]
*** knowledge of backtesting

** test strategies
 - with backtesting on truefx data
** data sources with pandas-datareader
 https://pandas-datareader.readthedocs.io/en/latest/remote_data.html
 import pandas_datareader.data as web

 aapl = web.DataReader('AAPL.US', 'quandl', '2015-01-01', '2015-01-05')
 gdp = web.DataReader('GDP', 'fred', '2010-1-1', '2013-1-17')

 worldbank works
** mq4 systems
 171008
 these were attempts btn 1503 to 1709. we moved from fxcm in 1702 to questrade. the latter decided to eliminate mt4 which opened the way for python datasci efforts. many of the concepts below may be worth examining in the future. our efforts will now be to use questradefxglobal through the web for longterm trades as we develop analyses using python and various datasci techniques.

*** prader document (171008)
 this is the doc we have been developing and working on so far. things will take a different course from now, but many of the ideas will still be useable.

**** Intro
 AA.mql will be the program that we keep creating and enhancing. The title of this program  will indicate its intention. After the program is complete, it will be saved under its titles name.

 A goal will be to develop better programming skills with mql done as much as possible in a functional Style https://book.mql4.com/ resources. Additionally we will work through the various articles which show how to program at that higher level. We should minimize use of global variables so that each function is self-contained via parameters. A particular advantage of this method is that there is no conflict in naming when there are no Global variables. That way a particular variable can have a consistent meaning and we don't need to twist the name so that it doesn't have the same one as a global.

 Perhaps our efforts should be geared more towards identifying successful patterns rather than imagining what is supposed to be successful. We seem to be coming up with very innovative ideas every single time however when we test these they seem to not always work terribly well. On the other hand if we create our system as a ground for discovering patterns then we can use the analysis itself to find things rather than attempt to create them ourselves from our imagination. This effort will lead us into machine learning.


**** AA notes
***** NUance
 Find ways of identifying nu and predicting its appearance. Combinations of other indicators as well as our own may provide the solution. We examine the statistical occurrence of these and utilise them for ntrxit.

 So, we are not really being Guided by the indicators as in the past. What we are doing is seeing if the indicator situation corresponds to some maneuver of nu formation. It may be best to do this within a certain time frame or possibly using tick data itself.

 We should be able to acquire probabilities of different combinations of indicators and their values before the nu occurrence. This concept is similar to the nunu idea which produced a very decisive probability of repetition.

 We can actually start this right away even before getting further on in data science. However, it is probably a good idea to see how some of the machine learning algorithms have already been set up for Forex.

***** Frequencer
 Check nu frequencies in different time frames. There will likely be some sort of relation as to how many occurrences there are of these in the smaller versus in the larger.

***** Terrainer
 Use highs and lows over certain number of bars to determine SR levels. These can then be used to provide levels for the squeezer to operate with.

 Search for high and low values over specific number of bars corresponding possibly to certain time frames. If these values encounter other high and low values Within a certain tolerance level then they should be given a certain strength. The strengths may be used to determine how seriously we take the sr level. If the strength is high then the chance for a bounce is greater. Recall that that bounce may not appear at the actual level but somewhat Beyond it.

***** Squeezer
 A trailing stop loss and seeking take profit squeeze in on the price movement. Both the stop loss and the take profit  can find  standing locations based on the terrain. The idea motivating these constructs is to limit unprofitable price moves as well as provide the means to catch sudden spikes before they return to normal values.

 This setup are also important because the chances of a long and continuous movement in One Direction is really very unlikely.

***** Exit concept
 This seems to be one of the most important aspects of trading. It is not too hard to establish criteria for entry, but what seems to be of considerable difficulty is to plan a sensible exit system. The latter cannot be a mirror image of the former in order to be effective. In other words, it should not use the same criteria albeit with the different intent since the symmetry tends to detract from the principle itself that a buy should not be countered by a sell, but something else.

 Prices tend to do one of three things. They go up they go down or they go sideways. The sideways movements tend to proceed the other two. Therefore, it seems sensible to utilize the sideways movements to get out of existing trade by moving stop losses or take profits to their outskirts.

 Therefore what we require is a way to detect when prices are actually moving sideways and by how much so the stop loss and take profit can be placed appropriately.

***** Pattern density
 Take a look at pattern densities for slopes over the entire s line Spectrum. When the density is high it may be a good time to enter.

***** The standard structure
 This will be the template we follow for all programs. A standard template will save time in creation of different strategies and ensure consistency.

 Programs will be written and tested under the name AA.mq4 after which they will be given a specific name does clearing the template. This file will include display, utility, special files that contain often used subroutines. All strategy and indicator info will be established in this file.
  In the utility file, there will be the ntr and xit routines which will call various strategies from the main file to determine their action. These strategies will be contained in the routines ntr_strategy and xit_strategy of the main file. The latter should be mainly a trailing stop, while the former will be determined by the indicators.

**** Flops
***** Grid program
 The idea behind this program is 2 impose a rigid structure on what is a chaotic activity.

 At hline run through all cases to see if certain conditions are met. Note how the idea here is quite different from the way slides worked in that we are not trying to find a particular case as before, but rather a combo the may give insights into the present market conditions.

 Here are the specifics:
 Price must be in zone of gridline for the latter to become active.
 Once the line is active we look for indications of the various Trends using S line slopes. There is probably no need to go through the entire 83 possibilities in order to get the trends we actually want.
 Depending on the strength of the trend which are determined by the slope values, we will determine the stop-loss and take profit.

 Grid works at least as well as fibonacci (which is so dependent on personal choice), but sometimes the turn around is past the expected. Doing a stats on how well it works may be a good approach.

***** Well behaved bars
 The concept behind this program and approach is that we require some sort of stability in price movement patterns. In other words if prices are fluctuating excessively, it is difficult to ascertain whether we are in the position to place a trade. Bars show consistency as far as the high, the low, as well as the slopes of those two values indicate that prices are following a pattern that will likely hold for a while. On the other hand, when prices are going all over the place, then it is understandable that we do not have any form of intelligence that underlines the trading.

 We want to place our trades when things have a consistent pattern. Therefore, we look for well behaved bars (wbb). The criteria for these are as follows:

 Minimum of three bars need to be examined for high and low values. We compute the best fit straight line through these points and examine the slope as well as the goodness of fit. When we have a good fit, we assume that the pattern will continue into the next bar.
 Both hilo slopes less than threshold
 Bar size average must be greater than 60 points
 Points must be within Y% of the average of the bar size
 Both hilo slopes greater than threshold
 Slopes are in the same direction and relatively close to each other 
 Best fit line through points has small deviation

 These conditions make it viable to predict where the next low and high will be. Without this situation, we would be just guessing at the next bar being formed.

 The principle approach will be BODSOR accompanied by a trailing stop as well as a distant take profit in case the fluctuations suddenly can make use of it.

 Unfortunately, we don't think this idea will actually work because there seem to be very rare situations for good behavior.

**** Strategies
 A collection of potential ideas on how to strategize for Forex and other items.

***** Manual Trading
 Work and test manual Trading using the questrade platform on Android. Determine a plan for it and start in August 2017.

 Determine volatile parts of the year.

***** Losing to winning
 The losing strategy is very simple. Go in whenever you feel like then come out as soon as there's a small profit but stay in if you keep losing money. This approach pretty well guarantees that you will lose even if you guess the right directional trend. The reason is that your risk reward ratio in the long run is stacked against you. Specifically, you are determined to lose much more than you are to win.

 To turn this around the first thing to do is to flip the risk-reward ratio. We need to be willing to stay in a trade longer when we are winning and exit it faster when we are losing. The idea is a simple one based on staying against the trend as little as possible and with the trend as long as possible. Though it is true that if you set an infinitely large stop loss you will always win this idea for practical purposes will probably deplete ones account.

 The other concept to keep in mind is that we should make better judgement calls as far as entries. The exits are taken care of via the above paragraph. The entries should be based on determining not only the trend but the Rhythm or phase of the market. Doing this will tend to ensure that one ends up in profit sooner. One will also likely stay in profit for longer because we are in Phase with the dominating trend that is immediately present.

 We can test this on the one minute chart to see if the noise level can be non detrimental to the larger picture.

 These ideas may actually be useful when we come to doing the noise program.

**** Zmisc
 Readings
 Some articles or books that may be worth looking into in more detail.


 mql4 manual. Read this first and quickly to know what is available for the language.DONE
 mql4 coderguru. This will introduce various Concepts quickly for the language and programming matters.DONE
 mql4 book. This item will cover all Advanced programming Concepts that are useful to learn. Since this is largely a programming book and not just for this particular language it will be especially useful in a broader sense. DONE
 Articles. We should make an attempt to study articles on the topic on a regular basis since that will enhance our own programming capabilities as well as give insights into how to create more effective expert advisors.
 Bernstein complete day trader
 The book on mql4 Trading And programming.


 Ideas
 These are a collection of ideas that may be followed up in the future.


 Use the history function to determine how well the trades have been going and whether the parameters should or should not be reset.
 Static variables keep their values between function calls so we have no need to use a global.
 mt4 opportunities:​
 EAs which already exist for study or implementation try in tester
 social trading possibilities on some pairs
 other mt dealers?
 mt forums
 Use time to determine whether we have a new bar rather than the counting of all bars. DONE
 Investigate ordercloseby in more detail as a means of saving spreads. DONE possibly not offered by fxcm. Should check to see if Quest Trader has them.
 Make use of timeseries arrays. DONE not all that useful for the way that we are actually programming.
 un should not repeatedly enter a trade unless it is set up in such a way buy zones. In other words depending upon the pattern we have identified for entry that particular pattern should be divided into appropriate zones where entries are permissible. These zones may become smaller or larger depending upon some other criteria such as the moving average slope perhaps. DONE fractal xoner sort of takes all of this into account.
 Running script which figures out the volume at different hours of the day. This information could be useful for determining when trading times are going to be volatile and there may be a pattern that becomes very evident as to when to actually Place trades. This can be used in conjunction with ATR as well.
 Use SSI ideas from https://www.dailyfx.com/sentiment to do manual trading based on personal evaluation of 4hr chart. Develop a specific strategy for doing so as to ntrxit.
 Synthetic SSI computations may prove to be interesting to look at at some point. The article covering this area is https://www.dailyfx.com/forex/education/trading_tips/post_of_the_day/2014/05/31/Creating-Synthetic-SSI-for-Cross-Currencies.html?CMP=SFS-70160000000Nc3gAAC
 Work out Boutros scalping ideas. These can be found through analyst picks or perhaps there is a subscription that can be acquired.
 Contemplate a different definition of fractals based on average of prior 2 candles to determine a level at which the fractal actually takes place without waiting for the last two candles to form. After all the candles are Just an Illusion anyway. What's important is that there has been a change in Direction.
 This article is a good one to study later in order to develop a better understanding of how to use mt4. It covers various things including debugging.https://www.mql5.com/en/articles/2661
 Examine volatile pairs to see if we can develop a different type of trading strategy 4 automation. For instance, ppa may work very well in a volatile environment even if it is not trending.
 Utilize past ideas that we have had and try programming parts of them into automation. Example would be the work done on has fine or even Japanese candlesticks.
 Track movement levels at various times during the day and design EA to take advantage of such patterns.
 S line patterns should be quite decisive in many situations. For instance in an uptrend you would expect the shorter lines to have steeper slope than the longer lines. These patterns can be worked out in considerable detail.
 Create EA for candlesticks.
 Create multi pair analysis tool which examines the prices 4 different pairs to determine conditions. eg eurusd, usdjpy, eurjpy.
 Use open and close X on bars to determine what sort of momentum is there. The idea may work out for larger time frames.
 Try utilizing full symmetry on stop loss and take profit. For instance if you have a trailing stop then also have asymmetrical trailing profit when losses appear.
 Examine and how often a particular entry results in a sufficient gain so that we do not get a loss vs how often the entry immediately goes into irrecoverable loss. This may be a way to determine good entries.
 Alligator and fractals each  (may be available) http://www.investopedia.com/articles/trading/06/fractals.asp?utm_source=personalized&utm_campaign=www.investopedia.com&utm_term=9240280&utm_medium=email
 Investigating incorporation of Martingale strategies.
 There are only four triggers that are of any importance. These are buy enter, sell enter, buy exit and sell exit. All indicator combinations should be geared towards flagging one of these.
 Weekly News can be useful to indicate potential volatility or moves for the upcoming week. While it is unclear how much of the news is valid at least you can get an idea of what might happen during the week from the scheduled events. This information can then be used possibly to choose parameters for the week.

*** 2do from past
 - create mechanism which uses price movement rather than just incline.
 - create mechanism which uses incline relationships of different lookbacks
 - implement and test a divergence model preferably with macd.
 - examine ntrxit in light of heisenberg principle [[file:tradingtexts/technique/Encyclopedia%20Of%20Trading%20Strategies.pdf][katz151]].
 - try implementing katz ga as an exercise.
 - java ga looks educational for ga understanding [[file:tradingtexts/technique/Encyclopedia%20Of%20Trading%20Strategies.pdf][katz272]].
 - identify mc as +- of different degrees depending on incline and use to determine ntrxit rationale. * plan

**** axiom
 there exists good philosophy for trading from which provides justification of any technique. components include ideas such as:
 - use global, but act local
 - only local impetus exists and global ones appear as combos of local
 - hitting large sltp is result of random coincidence not prior impetus
 - correct ntrxit due to pre-trade analysis forming intelligent sltp
 - proper post-trade behavior seeking next trade
**** basic program structure
 void OnTick()
   int aords=0,pords=0,ords=ordersforsymbol(aords,pords);

   if(ords<1)
     opn(tkt);
   else
     alt(tkt);

 void opn(int &tk)
   opnfn(bs,lt,op,sl,tp)
   tk=OrderSend(Symbol(),bs,lt,op,lev=0,sl,tp)

 void opnfn(int &bs,double &lt,double &op,double &sl,double &tp)
   lt= <whatever>
   bs,sl,tp = <set through whatever mechanisms>

   bs=0
     op=Ask
     sl=op-sl
     tp=op+tp
   bs=1
     op=Bid
     sl=op+sl
     tp=op-tp
 ====

 this system allows components of ordersend to be set through multiple and even complex criteria buy creating a specific function for the situation that opn() calls. similar approach to using alt().

**** specifics
***** entry
 make trade only when there exists condition combinations for local impetus
   - sr: giving bounsr,penesr or brkout
   - miimai: minor trend returning to major 
   - momtum: increase due to momentum indicator, steep ma, strong pt move
***** exit
 if impetus is invalidated through initial sl, look to reposition
 otherwise secure at noloss and trail

**** code creation process:
 1. work in aa.mq4, but with //title// at top
 2. when leaving file, save under title name

 opt table:
 | profit | trades | profit factor | expected payoff | drawdown $ | drawdown % | parameters |

 *ntr*
 a strategy may produce poor results over long period, but may be superb in specific situations
 therefore find where it works and keep it in store for use
 repeated switching of strats may be key

 *xit*
 incorporation of trail seems to be important - using something like atr.
 in any case, trail should be used in every situation and is independent of strategy
 should have continuation ideas in it

 follow or stepper that is based on a percentage of dpt has issues:
 - doesn't give as true an indication of what is happening except over very large movements
 - as dpt gets larger so does the trailer which is counterproductive to its intent

 so we need a trailer which allows big moves, but also cuts off reversals quickly!! hmmm.
 these need not be mutually exclusive intentions.

 *mis*
 can we use fractals to establish rhythm?
 matching fractals in different tfs
 identify times when trading volatile
 use 1200  sltp and go inout of trades by setting boundaries
 atr6 regularly seems to peak at 18:00gmt or 10pst quite often with subsequent movement for many pairs

 *issues*
 milines array out of range on High[],Low[] when starting on mon 170213 after 2^7 which is really weird because it should go back into sun to pull out the required prices
 having default: break; on case statements seem to actually change optimizations?!

*** pragrammer notes
 one of the primary functions should be to determine good entries.

 we should develop several criteria so the market can be approached in many situations. additionally, the criteria can back each other up in certain situations as confirmation and even help set policy on where to set sltp (for instance, if confirmation is very strong then one can expect a larger tp and a smaller sl).

 setting too large sltp makes them meaningless. sltp should be done based on what is actually happening in the market. this might mean variable sltp or ones which are set based on volatility of market or may be atr or whatever?

 additionally, it may be just as meaningless to test the program over large periods of time, unless the program is adaptive in nature. for instance, using rsiac 150101-150630 gave the following: eurusd 1500, usdcad 695, eurgbp 700, usdjpy -800. so what is the point of all this testing over 6mo?

**** writing to file
 int fh=FileOpen("ttt.txt",FILE_READ | FILE_WRITE | FILE_TXT); top level
 FileClose(fh); OnDeinit
 FileSeek(fh,0,SEEK_END);FileWrite(fh,...); anywhere
 ttt.txt shows up ~/dmt4/tester/files
**** interestings
***** sensr3v2
 for some reason, the incomplete trailing stop, produced gains btw 150406-150410 for eurusd,gbpusd,eurjpy, but smaller losses for usdjpy,audjpy.
 /*
 SENSR3
 incorporate trailing stop
 then tickbouncer concept
 */


 extern double  lots=1.0;
 extern double  limit=50.0;
 extern double  maxloss=50.0;

 extern int     buse=0;                        //0 buy, 1 sell
 extern int     trailstop=5;
 extern int     trailstep=0;
 extern int     maxorders=1;
 extern int     lev=3;
 extern int     MagicNumber=250346;

 extern bool    UseAlerts=true;

 double         MaximumLossinMoney=1000,
                rr=0.9;                          //risk2reward
 int            tkt=0;


 int Oninit()
 {
    return(INIT_SUCCEEDED);
 }


 void OnDeinit(const int reason)
 {

 }


 void OnTick()
 {
    if(OrdersforSymbol()==0)
       entertrade(tkt, buse);

    managetrade(tkt);
 }


 void managetrade(int tk)
 {
    bool r=OrderSelect(tk, SELECT_BY_TICKET);
    double tstop;
    int ot=OrderType();
    switch(ot)
    {
       case 0: //buy
          tstop = Bid - Point*trailstop;
          if(OrderStopLoss()<tstop)
             r = OrderModify(tk,OrderOpenPrice(),tstop,OrderTakeProfit(),0,Blue);
       break;
       case 1: //sell
          tstop = Point*trailstop - Ask;
          if(OrderStopLoss()>tstop)
             r = OrderModify(tk,OrderOpenPrice(),tstop,OrderTakeProfit(),0,Red);
       break;
    } 
 }
   

 void entertrade(int& tk, int& bs)
 {
    switch(bs)
    {
       case 0: //se
          tk = OrderSend(Symbol(),OP_SELL,lots,Bid,lev,Bid+rr*limit*Point,Bid-limit*Point,"MLT",MagicNumber,0,Red);
          bs=1;
       break;
       case 1: //bu
          tk = OrderSend(Symbol(),OP_BUY,lots,Ask,lev,Ask-rr*limit*Point,Ask+limit*Point,"MLT",MagicNumber,0,Blue);
          bs=0;
       break;
    }   
 }


 void tradeexit(int tk, string& bs)
 //exit the trade
    {
       double ba;
       color co;
       bool z;
       if(bs=="s")
          {
             ba=Ask; co=Blue; bs="b";
          }
          else
             {
                ba=Bid; co=Red; bs="s";
             }
       z=OrderClose(tk,lots,ba,3,co);
    }


 bool exitcondmet(string bs, double& xprice, double cprice)
    {
       double pricediff;
      
       if (bs=="s")
          pricediff = cprice - xprice;
          else
             pricediff = xprice - cprice;
            
       if (pricediff > maxloss)
          return true;

       if (bs=="s" && cprice<xprice)
          {
             xprice = cprice;
             return false;
          }

       if (bs=="b" && cprice>xprice)
          {
             xprice = cprice;
             return false;
          }
    }
   

 int OrdersforSymbol()
 //calculates number of orders that have been placed for a particular symbol
 //TD: incorporate magic number when we understand it
 {
    int count=0,pos;
    for(pos = OrdersTotal()-1; pos >= 0 ; pos--) 
       if (OrderSelect(pos, SELECT_BY_POS) && OrderSymbol()==Symbol())
          count++;
    return(count);
 }

***** sensr3v3
 this has produces btw 500-900% on 6/6 pairs btn 150406-150410
 /*
 SENSR3
 incorporate trailing stop
 then tickbouncer concept
 */


 extern double  lots=1.0;
 extern double  limit=50.0;
 extern double  maxloss=50.0;

 extern int     buse=0;                        //0 buy, 1 sell
 extern int     trailstop=5;
 extern int     trailstep=0;
 extern int     maxorders=1;
 extern int     lev=3;
 extern int     MagicNumber=250346;

 extern bool    UseAlerts=true;

 double         MaximumLossinMoney=1000,
                rr=0.9;                          //risk2reward
 int            tkt=0;


 int Oninit()
 {
    return(INIT_SUCCEEDED);
 }


 void OnDeinit(const int reason)
 {

 }


 void OnTick()
 {
    if(OrdersforSymbol()==0)
       entertrade(tkt, buse);

    managetrade(tkt);
 }


 void managetrade(int tk)
 {
    bool r=OrderSelect(tk, SELECT_BY_TICKET);
    double tstop;
    int ot=OrderType();
    switch(ot)
    {
       case 0: //buy
          tstop = Bid - Point*trailstop;
          if(OrderStopLoss()<tstop)
             r = OrderModify(tk,OrderOpenPrice(),tstop,OrderTakeProfit(),0,Blue);
       break;
       case 1: //sell
          tstop = Ask + Point*trailstop; 
          if(OrderStopLoss()>tstop)
             r = OrderModify(tk,OrderOpenPrice(),tstop,OrderTakeProfit(),0,Red);
       break;
    } 
 }
   

 void entertrade(int& tk, int& bs)
 {
    switch(bs)
    {
       case 0: //se
          tk = OrderSend(Symbol(),OP_SELL,lots,Bid,lev,Bid+rr*limit*Point,Bid-limit*Point,"MLT",MagicNumber,0,Red);
          bs=1;
       break;
       case 1: //bu
          tk = OrderSend(Symbol(),OP_BUY,lots,Ask,lev,Ask-rr*limit*Point,Ask+limit*Point,"MLT",MagicNumber,0,Blue);
          bs=0;
       break;
    }   
 }



 int OrdersforSymbol()
 //calculates number of orders that have been placed for a particular symbol
 //TD: incorporate magic number when we understand it
 {
    int count=0,pos;
    for(pos = OrdersTotal()-1; pos >= 0 ; pos--) 
       if (OrderSelect(pos, SELECT_BY_POS) && OrderSymbol()==Symbol())
          count++;
    return(count);
 }

***** sensr4
 works on 3ma and actually showed profit even on spread 20.

 /*
 SENSR4
 added trailing stop
 add ma to determine trend
 */


 extern double  lots=1.0;
 extern double  limit=360.0;                  //points
 extern double  maxloss=50.0;

 extern int     buse;                       //0 buy, 1 sell
 extern int     trailstop=240;                //points
 extern int     trailstep=0;
 extern int     maxorders=1;
 extern int     lev=3;
 extern int     MagicNumber=250346;

 extern bool    UseAlerts=true;

 double         mah,mam,mal,pr,
                MaximumLossinMoney=1000,
                rr=.8;                      //risk2reward
 int            tkt=0;


 int Oninit()
 {
    srand(GetTickCount());
    return(INIT_SUCCEEDED);
 }


 void OnDeinit(const int reason)
 {

 }


 void OnTick()
 {
    mah = iMA(NULL,1,6,0,MODE_LWMA,PRICE_HIGH,6);
    mam = iMA(NULL,1,6,0,MODE_LWMA,PRICE_MEDIAN,6);
    mal = iMA(NULL,1,6,0,MODE_LWMA,PRICE_LOW,6);
    pr = (Bid+Ask)/2;
   
    if (pr>mah) buse=0;
    if (pr<mal) buse=1;
    //if (pr<mah && pr>mam) buse=1;
    //if (pr>mah && pr<mam) buse=0;
   
    if(OrdersforSymbol()==0)      
       entertrade(tkt, buse);

    managetrade(tkt);
 }


 void managetrade(int tk)
 {
    bool r=OrderSelect(tk, SELECT_BY_TICKET);
    double tstop;
    int ot=OrderType();
    switch(ot)
    {
       case 0: //buy
          tstop = Bid - trailstop*Point;
          if(OrderStopLoss()<tstop)
             r = OrderModify(tk,OrderOpenPrice(),tstop,OrderTakeProfit(),0,Blue);
       break;
       case 1: //sell
          tstop = Ask + trailstop*Point; 
          if(OrderStopLoss()>tstop)
             r = OrderModify(tk,OrderOpenPrice(),tstop,OrderTakeProfit(),0,Red);
       break;
    } 
 }
   

 void entertrade(int& tk, int& bs)
 {
    switch(bs)
    {
       case 0: //bu
          tk = OrderSend(Symbol(),OP_BUY,lots,Ask,lev,Ask-rr*limit*Point,Ask+limit*Point,"MLT",MagicNumber,0,Blue);
          bs=1;
       break;
       case 1: //se
          tk = OrderSend(Symbol(),OP_SELL,lots,Bid,lev,Bid+rr*limit*Point,Bid-limit*Point,"MLT",MagicNumber,0,Red);
          bs=0;
       break;
    }   
 }



 int OrdersforSymbol()
 //calculates number of orders that have been placed for a particular symbol
 //TD: incorporate magic number when we understand it
 {
    int count=0,pos;
    for(pos = OrdersTotal()-1; pos >= 0 ; pos--) 
       if (OrderSelect(pos, SELECT_BY_POS) && OrderSymbol()==Symbol())
          count++;

 }
   
***** hg1
 testing the ma approach and contains initial efforts
 //+------------------------------------------------------------------+
 //|                                                  hg1.mq4 |
 //|                                           Copyright 2015, prader |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+
 #property copyright "Copyright 2015, prader"
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict

 /*
 hg1
 use slope calculations within 6 candles to determine entry and exit
 */


 extern double  lots=1.0;                    //
 extern double  limit=60.0;
 extern double  maxloss=50.0;

 extern int     buse=0;                        //0 buy, 1 sell
 extern int     bars=6;                        //number of bars examined
 extern int     trailstop=5;
 extern int     trailstep=0;
 extern int     maxorders=1;
 extern int     lev=3;
 extern int     MagicNumber=250346;

 extern bool    UseAlerts=true;

 double         rr=0.9;                        //risk2reward
 int            fh,tkt=0;


 int Oninit()
 {

 
    return(INIT_SUCCEEDED);
 }


 void OnDeinit(const int reason)
 {

 }


 void OnTick()
 {
    fh=FileOpen("ttt.txt",FILE_READ | FILE_WRITE | FILE_TXT);
  
    if(OrdersforSymbol()==0 && slope0k(buse))
       entertrade(tkt, buse);

  FileClose(fh);
 /*   
    if(OrdersforSymbol()==1 && slope0(buse))
       exittrade(tkt);      
 */

 }


 bool slope0k(int& bs) //uses regression line from iMA6 points
 {
    int x=4; //bar on which to do calculations
    double imas[7]; ArrayInitialize(imas,0);
    double a[4][4]; ArrayInitialize(a,0);
    double b[4]; ArrayInitialize(b,0);
    double coeff[4]; ArrayInitialize(coeff,0);
    double y=0, y1=0, y11=0;
    double zeroslope=0.00001;
       
   
    for(int i=1;i<bars+1;i++)
      {
       imas[i] = NormalizeDouble(iMA(NULL,PERIOD_M1,6,0,MODE_SMA,PRICE_TYPICAL,bars+1-i),Digits);
      }

    fillab(a,b,imas);
    getcoeff(a,b,coeff);

    y = NormalizeDouble(coeff[1] + coeff[2]*x + coeff[3]*pow(x,2),Digits);
    y1 = NormalizeDouble(coeff[2] + coeff[3]*x,Digits);
    y11 = NormalizeDouble(coeff[3],Digits);
   
 FileSeek(fh,0,SEEK_END);FileWrite(fh,"bs=",bs," x=",x," y=",y," y1=",y1*10000," y11=",y11*10000);
    if(fabs(y1)<zeroslope && y11>0)
      {
       bs=0;FileWrite(fh,"BUY");
       return true;
      }
    if(fabs(y1)<zeroslope && y11<0)
      {
       bs=1;FileWrite(fh,"SELL");
       return true;
      }
   
    return false;


 /*
    if(fabs(y1)<zeroslope)
       {
          if (y11>0) bs=0; else bs=1;Comment(bs, " ", x, " ", "y=",y, " y1=",y1," y11=",y11);
          return true;
       }
       else
          return false;
 */
         

 }

 void getcoeff(double & a[][], double & b[], double& x[])
 {
  double u[4][4]; ArrayInitialize(u,EMPTY_VALUE);
  double c[4]; ArrayInitialize(c,EMPTY_VALUE);
 
  u[1,1] = sqrt(a[1,1]);
  u[1,2] = a[1,2]/u[1,1];
  u[1,3] = a[1,3]/u[1,1];
  u[2,2] = sqrt(a[2,2] - pow(u[1,2],2));
  u[2,3] = (a[2,3] - u[1,2]*u[1,3])/u[2,2];
  u[3,3] = sqrt(a[3,3] - pow(u[1,3],2) - pow(u[2,3],2));
  c[1] = b[1]/u[1,1];
  c[2] = (b[2] - c[1]*u[1,2])/u[2,2];
  c[3] = (b[3] - c[1]*u[1,3] - c[2]*u[2,3])/u[3,3];
 
 
  x[3] = c[3]/u[3,3];
  x[2] = (c[2] - u[2,3]*x[3])/u[2,2];
  x[1] = (c[1] - (u[1,2]*x[2]+u[1,3]*x[3]))/u[1,1];

 }

 void fillab(double& a[][], double& b[], double & mas[])
 {
  int tot=bars;

  a[1,1] = tot;
  for(int i=1;i<tot+1;i++)
    {
     a[1,2] += i;
     a[2,2] += pow(i,2);
     a[2,3] += pow(i,3);
     a[3,3] += pow(i,4);
     b[1] += mas[i];
     b[2] += i*mas[i];
     b[3] += pow(i,2)*mas[i];
    }
  //some of these are unnecessary, but put them in for now anyway
  a[2,1] = a[1,2];  
  a[1,3] = a[2,2];
  a[3,1] = a[2,2];
  a[3,2] = a[2,3];
 
  //Comment(a[2,2]);

 }



 bool slope0kavg(int& bs) //uses avgs of slopes from bar0 to others
 {
    double priarr[6]; ArrayInitialize(priarr,EMPTY_VALUE);
    double velarr[5]; ArrayInitialize(velarr,EMPTY_VALUE);
    double accarr[4]; ArrayInitialize(accarr,EMPTY_VALUE);
    double avgvel, avgacc, zerovel=0.000006;

    for(int i=0;i<bars;i++)          //fill array with prices
       priarr[i] = NormalizeDouble((Open[i] + High[i] + Low[i] + 3*Close[i])/6,Digits);
    for(int i=0;i<bars-1;i++)        //fill array with velocities
       velarr[i] = NormalizeDouble(priarr[0] - priarr[i+1],Digits);
    for(int i=0;i<bars-2;i++)        //fill array with accelerations
       accarr[i] = NormalizeDouble(velarr[0] - velarr[i],Digits); 
     
    avgvel = fabs(avgofarr(velarr));
    avgacc = avgofarr(accarr);
    Comment("");
    Comment(avgvel," ",avgacc);
   
    if(avgvel<zerovel)
      {
       if (avgacc<0)
          bs=0;
       if (avgacc>0)
          bs=1;
       return true;
      }
      else
       return false;
 }


 void managetrade(int tk)
 {
    bool r=OrderSelect(tk, SELECT_BY_TICKET);
    double tstop;
    int ot=OrderType();
    switch(ot)
    {
       case 0: //buy
          tstop = Bid - Point*trailstop;
          if(OrderStopLoss()<tstop)
             r = OrderModify(tk,OrderOpenPrice(),tstop,OrderTakeProfit(),0,Blue);
       break;
       case 1: //sell
          tstop = Ask + Point*trailstop; 
          if(OrderStopLoss()>tstop)
             r = OrderModify(tk,OrderOpenPrice(),tstop,OrderTakeProfit(),0,Red);
       break;
    } 
 }
   

 void entertrade(int& tk, int& bs)
 {
    switch(bs)
    {
       case 0: //bu
          tk = OrderSend(Symbol(),OP_BUY,lots,Ask,lev,Ask-rr*limit*Point,Ask+limit*Point,"MLT",MagicNumber,0,Blue);
       break;
       case 1: //se
          tk = OrderSend(Symbol(),OP_SELL,lots,Bid,lev,Bid+rr*limit*Point,Bid-limit*Point,"MLT",MagicNumber,0,Red);
       break;
    }   
 }



 int OrdersforSymbol()
 //calculates number of orders that have been placed for a particular symbol
 //TD: incorporate magic number when we understand it
 {
    int count=0,pos;
    for(pos = OrdersTotal()-1; pos >= 0 ; pos--) 
       if (OrderSelect(pos, SELECT_BY_POS) && OrderSymbol()==Symbol())
          count++;
    return(count);
 }

 double avgofarr(double & arr[])
 {
    double acc=0;
    int total=ArraySize(arr);
   
    for(int i=0;i<total;i++)
    {
       acc += arr[i];
    }

    return acc/total;
 }


 double cp()
 //current price as average of bid and ask
 {
    return (Bid+Ask)/2;
 }
***** hg2
 big losses when limit is <600, but significant profits when >600. we need to test in a variety of areas, but it seems that few trades going for larger wins is profitable.
***** hml6v1
 trying to enter with slope and exit with a flip if things go wrong way. produced $4500 with M1, but we don't really know what is happening. loses $2000 on M15,M30. loses $3000 on M5.

 //+------------------------------------------------------------------+
 //|                                                       hml6.mq4 |
 //|                                           Copyright 2015, prader |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+
 #property copyright "Copyright 2015, prader"
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict


 /*
 hml6 uses 3ma and we have to think out the rest
 */

 #define sp " "

 extern double  lots=1.0;
 extern double  limit=600.0;

 int      bs=-1, trailstop;                      
 int      bars=6, maxorders=1, lev=3, magnum=0;
 int      fh,tkt=0;
 int      period=PERIOD_M1, mode=MODE_LWMA;
 double   rr=0.6, sd1=3*Point;


 int Oninit()
 {return(INIT_SUCCEEDED);}


 void OnDeinit(const int reason)
 {}


 void OnTick()
 {
    double coH[4],coM[4],coL[4];
    double baP[4]; ArrayInitialize(baP,0);
    double valH=0,sloH=0,accH=0,valM=0,sloM=0,accM=0,valL=0,sloL=0,accL=0;
    double oc,op,sl,tp,pr;
    bool os;

    fillall(coH, coM, coL, baP);                 // get data into arrays

    int bn=6;    //set v,s,a for most recent bar
    valH = NormalizeDouble(coH[1]+coH[2]*bn+coH[3]*pow(bn,2),Digits);
    sloH = NormalizeDouble(coH[2]+coH[3]*bn,Digits);
    accH = NormalizeDouble(coH[3],Digits);
    valM = NormalizeDouble(coM[1]+coM[2]*bn+coM[3]*pow(bn,2),Digits);
    sloM = NormalizeDouble(coM[2]+coM[3]*bn,Digits);
    accM = NormalizeDouble(coM[3],Digits);
    valL = NormalizeDouble(coL[1]+coL[2]*bn+coM[3]*pow(bn,2),Digits);
    sloL = NormalizeDouble(coL[2]+coL[3]*bn,Digits);
    accL = NormalizeDouble(coL[3],Digits);

    double slo = (sloH+sloM+sloL)/3, acc = (accH+accM+accL)/3;

    if(OrdersforSymbol()<1)      //opening criteria
      {
       if(slo>0 && acc>=0)
          if(Bid<valL)
             {bs=0;entertrade(tkt,bs);} 
       if(slo<0 && acc<=0)
          if(Ask>valH)
             {bs=1;entertrade(tkt,bs);}
      }
      else      //closing criteria
        {
         os=OrderSelect(tkt,SELECT_BY_TICKET);
         op=OrderOpenPrice(); sl=10*Point; tp=60*Point; pr=(Bid+Ask)/2;Comment(tkt);
        
         if(bs==0)
           if(pr<op-sl)
             {
              oc=OrderClose(tkt,lots,Bid,0,Blue);
              if (OrdersforSymbol()<1) {entertrade(tkt,1);Comment("flip buy ",tkt);}
             }
         if(bs==1)
           if(pr>op+sl)
             {
              oc=OrderClose(tkt,lots,Ask,0,Red);
              if (OrdersforSymbol()<1) {entertrade(tkt,0);Comment("flip sell ",tkt);}
             }    
       }
 }

 void fillall(double& coH[], double& coM[], double& coL[], double& baP[])
 //fills arrays with appropriate data
 //bn barnum is set up so that 6 is most recent and 1 is furthest in past
 {
    double imaH[7],imaM[7],imaL[7];
    double bardata[7]; ArrayInitialize(bardata,0);

    for(int bn=1;bn<bars+1;bn++)
    {
       imaH[bn] = NormalizeDouble(iMA(NULL,period,bars,0,mode,PRICE_HIGH,bars+1-bn),Digits);
       imaM[bn] = NormalizeDouble(iMA(NULL,period,bars,0,mode,PRICE_TYPICAL,bars+1-bn),Digits);
       imaL[bn] = NormalizeDouble(iMA(NULL,period,bars,0,mode,PRICE_LOW,bars+1-bn),Digits);
    }
   
    getcoef(imaH,coH); getcoef(imaM,coM); getcoef(imaL,coL);
              
    for(int bn=0;bn<bars+1;bn++)
      {
       bardata[bn] = iLow(NULL,PERIOD_M1,bars+1-bn);      //low
       bardata[bn] = iOpen(NULL,PERIOD_M1,bars+1-bn);     //open
       bardata[bn] = iClose(NULL,PERIOD_M1,bars+1-bn);    //close
       bardata[bn] = iHigh(NULL,PERIOD_M1,bars+1-bn);     //high
      }
 }


 void getcoef(double & mas[], double& x[])
 //compute coefficients from moving averages using crout square root method and put into x[]
 {
    double a[4][4]; ArrayInitialize(a,0);
    double b[4]; ArrayInitialize(b,0);
    double u[4][4]; ArrayInitialize(u,0);
    double c[4]; ArrayInitialize(c,0);

  a[1,1] = bars;
  for(int i=1;i<bars+1;i++)
    {
     a[1,2] += i;
     a[2,2] += pow(i,2);
     a[2,3] += pow(i,3);
     a[3,3] += pow(i,4);
     b[1] += mas[i];
     b[2] += i*mas[i];
     b[3] += pow(i,2)*mas[i];
    }
  a[1,3] = a[2,2];

  u[1,1] = sqrt(a[1,1]);
  u[1,2] = a[1,2]/u[1,1];
  u[1,3] = a[1,3]/u[1,1];
  u[2,2] = sqrt(a[2,2] - pow(u[1,2],2));
  u[2,3] = (a[2,3] - u[1,2]*u[1,3])/u[2,2];
  u[3,3] = sqrt(a[3,3] - pow(u[1,3],2) - pow(u[2,3],2));
  c[1] = b[1]/u[1,1];
  c[2] = (b[2] - c[1]*u[1,2])/u[2,2];
  c[3] = (b[3] - c[1]*u[1,3] - c[2]*u[2,3])/u[3,3];
 
  x[3] = c[3]/u[3,3];                                  
  x[2] = (c[2] - u[2,3]*x[3])/u[2,2];                  
  x[1] = (c[1] - (u[1,2]*x[2]+u[1,3]*x[3]))/u[1,1];
 }


 void entertrade(int& tk,int buyorsell)
 //determines whether to buy or sell
 {
    switch(buyorsell)
    {
       case 0: //bu
          tk = OrderSend(Symbol(),OP_BUY,lots,Ask,lev,Ask-rr*limit*Point,Ask+limit*Point,"",magnum,0,Blue);
       break;
       case 1: //se
          tk = OrderSend(Symbol(),OP_SELL,lots,Bid,lev,Bid+rr*limit*Point,Bid-limit*Point,"",magnum,0,Red);
       break;
    }   
 }



 int OrdersforSymbol()
 //calculates number of orders that have been placed for a particular symbol
 //TD: incorporate magic number when we understand it
 {
    int count=0,pos;
    for(pos = OrdersTotal()-1; pos >= 0 ; pos--) 
       if (OrderSelect(pos, SELECT_BY_POS) && OrderSymbol()==Symbol())
          count++;
    return(count);
 }
***** thule using rvi
 increasing slope requirement to 18 made enormous difference apr1-24

 | slope |  min |   max |   fin |
 |    15 | 9761 | 14139 | 13119 |
 |    16 | 9761 | 14491 | 13471 |
 |    17 | 9761 | 14491 | 13471 |
 |    18 | 9761 | 14548 | 13178 |
 |    19 | 9761 | 14539 | 13304 |
 |    20 | 9761 | 14496 | 12049 |

 lowering profloss to 120 is not bad, but at 60 there are too many losses. above were done at 600, 360 being mostly good too. all done so far on M30.

 +$2000 profits shown from mar23-apr30 with profloss of 360 which gets exceeded only on weekends. on the other hand we are getting mar1-19805, feb1-20858, jan1-18104  with new data just downloaded.

 best result so far 150101-150430 on M30 and 360: 8879-15245-15012

 Bars in test	39180
 Ticks modelled	5818724
 Modelling quality	24.94%
 Mismatched charts errors	0
 Initial deposit	10000.00
 Spread	18
 Total net profit	5012.00
 Gross profit	17927.00
 Gross loss	-12915.00
 Profit factor	1.39
 Expected payoff	41.08
 Absolute drawdown	1268.00
 Maximal drawdown	3316.00 (21.89%)
 Relative drawdown	21.89% (3316.00)
 Total trades	122
 Short positions (won %)	63 (46.03%)
 Long positions (won %)	59 (44.07%)
 Profit trades (% of total)	55 (45.08%)
 Loss trades (% of total)	67 (54.92%)
	 Largest
 profit trade	1202.00
 loss trade	-361.00
	 Average
 profit trade	325.95
 loss trade	-192.76
	 Maximum
 consecutive wins (profit in money)	5 (1556.00)
 consecutive losses (loss in money)	7 (-1253.00)
	 Maximal
 consecutive profit (count of wins)	1556.00 (5)
 consecutive loss (count of losses)	-1440.00 (5)
	 Average
 consecutive wins	2
 consecutive losses	2

 improvement ideas:
 - don't run on weekends
 - play with profloss
 - play on other timeframes: not good on longer and require larger profloss while M15 is a total disaster losing nearly $7000 while M5 wipes out the account suggesting there are definite optimizations possible with period and rvibars that likely work better in specific timeframes


 //+------------------------------------------------------------------+
 //|                                                       hml6.mq4 |
 //|                                           Copyright 2015, prader |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+
 #property copyright "Copyright 2015, prader"
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict


 /*
 hml6 uses 3ma
 change the computations to discrete since possibly the regression line
 need multiangled approach to trades 

 domer180-240/prolos $879 
 */


 double   lots=1.0, takpro=6000, rr=0.9, stolos=rr*takpro, ps=18*Point, ns=-ps;   
 int      period=PERIOD_M30, mode=MODE_LWMA;
 int      rvibars=12;
 int      bs=-1, bars=6, maxorders=1, maxbars=0, lev=0, tkt=0, magnum=0;
 bool     pgnotdone;
 double   enp=0;
 
 double   valH[7],sloH[7],accH[7],valM[7],sloM[7],accM[7],valL[7],sloL[7],accL[7],
          barL[7],barO[7],barC[7],barH[7];


 int fh=FileOpen("ttt.txt",FILE_READ | FILE_WRITE | FILE_TXT);
 //FileSeek(fh,0,SEEK_END);FileWrite(fh,slo/Point);
 //FileClose(fh);

 int Oninit() {return(INIT_SUCCEEDED);}
 void OnDeinit(const int reason) {FileClose(fh);}


 void OnTick()
 {
    double sn=1*Point, masl=sn, misl=-sn;        //slope min and max requirements
    double op;
    bool os;
    bool atmaxorders = OrdersforSymbol()==maxorders; 

    fillall();
   
    if (maxbars!=Bars)                              //prevent more than one trade per bar
     {
       maxbars=Bars;
       if(!atmaxorders)              //ntr 
        {
          entertrade(tkt,ntr(),stolos,takpro);
        }
     }
    if (atmaxorders)                                    //xit
        {
          os=OrderSelect(tkt,SELECT_BY_TICKET);
          op = OrderOpenPrice();
          bs = OrderType();
          exittrade(tkt,xit());
        }
    
 }


 /////////////////////////////////////////////////////////////
 int ntr()
 //establish various enter conditions for buy or sell
 {
    return rvintr();
 }

 int xit()
 //establish conditions on which to exit
 {
    return rvixit();
 }
 /////////////////////////////////////////////////////////////


 //NTRs

 int rvintr()
 //ntr using rvi
 {
    bool  mls = iRVI(NULL,period,rvibars,MODE_MAIN,0)<iRVI(NULL,period,12,MODE_SIGNAL,0),
          mgs = iRVI(NULL,period,rvibars,MODE_MAIN,0)>iRVI(NULL,period,12,MODE_SIGNAL,0);
    if (sloM[1]>ps && mgs) return 0;
    if (sloM[1]<ps && mls) return 1;
    return -1;
 }

 int rvixit()
 //xit using rvi
 {
    bool  mls = iRVI(NULL,period,rvibars,MODE_MAIN,0)<iRVI(NULL,period,rvibars,MODE_SIGNAL,0),
          mgs = iRVI(NULL,period,rvibars,MODE_MAIN,0)>iRVI(NULL,period,rvibars,MODE_SIGNAL,0);
    if (bs==0 && ((sloM[1]<ns && mls) || OrderProfit()<-600)) return 0;
    if (bs==1 && ((sloM[1]>ps && mgs) || OrderProfit()<-600)) return 1;
    return -1;
 }

 int domers()
 //ntrxit on dome formation
 {
    if (sloM[5]<ns && sloM[4]<ns && sloM[3]<ns && sloM[2]<ns && sloM[1]>ps) return 0;
    if (sloM[5]>ps && sloM[4]>ps && sloM[3]>ps && sloM[2]>ps && sloM[1]<ns) return 1;
    return -1;
 }

 int slopeyntr()
 //ntrxit on slope inclination
 {
    if (sloM[1]>ps) return 0;
    if (sloM[1]<ns) return 1;
    return -1;
 }

 int slope0xit()
 //ntr on zero slope
 {
    if (bs==0 && ((sloM[2]>ps && sloM[1]<ns) || OrderProfit()<-120)) return 0;
    if (bs==1 && ((sloM[2]<ns && sloM[1]>ps) || OrderProfit()<-120)) return 1;
    return -1;
 }

 int mapupu()
 //ntrxit on pullbacks and pushthrus of ma
 {
    if (sloM[1]>ps && ((Bid<valL[1]) || (Bid>valH[1]))) return 0;
    if (sloM[1]<ns && ((Ask>valH[1]) || (Ask<valL[1]))) return 1;
    return -1;
 }

 int prolos()
 //xit on amount
 {
    if (bs==0 && (OrderProfit()>120 || OrderProfit()<-240)) return 0;
    if (bs==1 && (OrderProfit()>120 || OrderProfit()<-240)) return 1;
    return -1;
 }

 int crossr()
 //ntr price goes past maH or maL GETS CAUGHT IN EFFECTIVELY INFINITE LOOP - needs rewriting
 {
    if ((Ask<valL[1]-takpro*Point) || (Bid>valH[1]+takpro*Point)) return 1;
    return -1;
 }

 int snuggl()
 //ntrxit maM moves closer to maL/maH depending upon slope
 {
    if (sloM[1]>0 && (valH[1]-valM[1] < valM[1]-valL[1])) return 0;
    if (sloM[1]<0 && (valH[1]-valM[1] > valM[1]-valL[1])) return 1;
    return -1;
 }


 //XITs

 int cloord()
 //closes extraneous order
 {  
    bool od;
    if ((Ask<enp-stolos*Point) || (Ask>enp+takpro*Point)) {enp=0;od=OrderDelete(tkt);}
    if ((Bid>enp+stolos*Point) || (Bid<enp-takpro*Point)) {enp=0;od=OrderDelete(tkt);}
    return -1;
 }


 //ZZmisc

 int dither()
 //ntr on either side of current price - doesn't seem to work too well in general
 {
    double pcp = 11, sl = 161, tp = 61;
    if (enp==0) enp=(Bid+Ask)/2;
    stolos=sl; takpro=tp;
    if (Bid>enp+pcp*Point) return 0;
    if (Ask<enp-pcp*Point) return 1;
    return -1;
 }


 bool zeroU()
 //finds zero slope up
 {
    if (sloM[1]<ns && sloM[0]>ps) return true;
    else return false;
 }

 bool zeroD()
 //finds zero slope down
 {
    if (sloM[1]>ps && sloM[0]<ns) return true;
    else return false;
 }




 void managetrade(int& buse, double op, double pr)
 {
  double pgdiff=60, pgstls=20, stopout=90;

  switch(buse)
    {
     case  0:
       if((pr>op+pgdiff*Point) && pgnotdone)
        {
          modifytrade(tkt,op,pgstls,0);
          pgnotdone=false;        
        }
  /*     if(stopout<(op-pr)/Point)
        { 
          exittrade(tkt,buse);
          buse=1;
          entertrade(tkt,buse,rr*tapr,tapr);
        }*/
       break;
     case  1:
       if((pr<op-pgdiff*Point) && pgnotdone)
        {
          modifytrade(tkt,op,pgstls,1);
          pgnotdone=false;
        }
  /*     if(stopout<(pr-op)/Point)
        { 
          exittrade(tkt,buse);
          buse=0;
          entertrade(tkt,buse,rr*tapr,tapr);
        } */     
       break;
    }
 }


 void entertrade(int& tk,int buyorsell,double sl,double tp)
 //determines whether to buy or sell
 {
    switch(buyorsell)
    {
       case 0: tk = OrderSend(Symbol(),OP_BUY,lots,Ask,lev,Ask-sl*Point,Ask+tp*Point,"",magnum,0,Blue); break;
       case 1: tk = OrderSend(Symbol(),OP_SELL,lots,Bid,lev,Bid+sl*Point,Bid-tp*Point,"",magnum,0,Red); break;
       default: break;
    }   
 }


 void modifytrade(int tk, double op, double st, int buyorsell)
 //adjusts sl and tp
 {
    bool om;
    switch(buyorsell)
    {
       case 0: om = OrderModify(tk,op,op+st*Point,Ask+takpro*Point,0,Blue); break;
       case 1: om = OrderModify(tk,op,op-st*Point,Bid-takpro*Point,0,Red); break;
    }  
 }


 void exittrade(int tk,int buyorsell)
 //closes specific trade
 {
    bool oc;
    switch(buyorsell)
    {
       case 0: oc = OrderClose(tk,lots,Bid,0,Blue); break;
       case 1: oc = OrderClose(tk,lots,Ask,0,Red); break;
       default: break;
    }
 }


 void fillall()
 //fills arrays with appropriate data
 {
    double imaH[7],imaM[7],imaL[7];
    double bardata[7]; ArrayInitialize(bardata,0);
    int st=0;

    for(int i=st;i<=bars;i++)
      {
       valH[i] = NormalizeDouble(iMA(NULL,period,bars,0,mode,PRICE_HIGH,i),Digits);
       valM[i] = NormalizeDouble(iMA(NULL,period,bars,0,mode,PRICE_MEDIAN,i),Digits);
       valL[i] = NormalizeDouble(iMA(NULL,period,bars,0,mode,PRICE_LOW,i),Digits);
      }
    for(int i=st;i<=bars-1;i++)
      {
       sloH[i] = valH[i] - valH[i+1];
       sloM[i] = valM[i] - valM[i+1];
       sloL[i] = valL[i] - valL[i+1];
      }
    for(int i=st;i<=bars-2;i++)
      {
       accH[i] = sloH[i] - sloH[i+1];
       accM[i] = valM[i] - valM[i+1];
       accL[i] = valL[i] - valL[i+1];      
      }
    for(int i=st;i<=bars;i++)
      {
       barL[i] = iLow(NULL,period,i);
       barO[i] = iOpen(NULL,period,i);
       barC[i] = iClose(NULL,period,i);
       barH[i] = iHigh(NULL,period,i);
      }
 }


 int OrdersforSymbol()
 //calculates number of orders that have been placed for a particular symbol
 {
    int count=0,pos;
    for(pos = OrdersTotal()-1; pos >= 0 ; pos--) 
       if (OrderSelect(pos, SELECT_BY_POS) && OrderSymbol()==Symbol())
          count++;
    return(count);
 }

 Bars in test	25329
 Ticks modelled	3434102
 Modelling quality	25.00%
 Mismatched charts errors	0
 Initial deposit	10000.00
 Spread	18
 Total net profit	3178.00
 Gross profit	10554.00
 Gross loss	-7376.00
 Profit factor	1.43
 Expected payoff	45.40
 Absolute drawdown	409.00
 Maximal drawdown	2974.00 (19.95%)
 Relative drawdown	19.95% (2974.00)
 Total trades	70
 Short positions (won %)	35 (57.14%)
 Long positions (won %)	35 (51.43%)
 Profit trades (% of total)	38 (54.29%)
 Loss trades (% of total)	32 (45.71%)
	 Largest
 profit trade	1106.00
 loss trade	-601.00
	 Average
 profit trade	277.74
 loss trade	-230.50
	 Maximum
 consecutive wins (profit in money)	5 (1556.00)
 consecutive losses (loss in money)	7 (-1253.00)
	 Maximal
 consecutive profit (count of wins)	1556.00 (5)
 consecutive loss (count of losses)	-1291.00 (3)
	 Average
 consecutive wins	2
 consecutive losses	2
**** investigations
 can intensity of bouncing from sr determine trend? may be because sharks use the idea of bringing prices to certain levels
***** ideas to code
 sr identification
 channel
 wickening
 mima
 bosr
 pesr
 shapes - wedge, pennant, flag
 sr and aso combo
 doubles and tweezers - multiple tries create sr
 hai4
 phasing
 defining market condition types
 dither
 martingale
 hapist - lots of good ideas there even with elementary stats
***** eas to possibly examine
****** [[https://www.mql5.com/en/code/8462?utm_campaign%3DMetaTrader%2B4%2BTerminal&utm_medium%3Dspecial&utm_source%3Dmt4terminal%2Bcodebase][SimpleTrade]]
 put in orders continuously
****** [[https://www.mql5.com/en/code/8213?utm_campaign%3DMetaTrader%2B4%2BTerminal&utm_medium%3Dspecial&utm_source%3Dmt4terminal%2Bcodebase%00][SHE_Kanskigor]] 
 commented for edu purposes
 nat
****** [[https://www.mql5.com/en/code/10503?utm_campaign%3DMetaTrader%2B4%2BTerminal&utm_medium%3Dspecial&utm_source%3Dmt4terminal%2Bcodebase][simple scalping ea]]
 seems to work, but you need big price movement since orders keep moving
****** [[https://www.mql5.com/en/code/10503?utm_campaign%3DMetaTrader%2B4%2BTerminal&utm_medium%3Dspecial&utm_source%3Dmt4terminal%2Bcodebase][price action ea]]
 along the lines of tickbouncer. it has potential, but doesn't always seem to work.
****** [[https://www.mql5.com/en/code/10895?utm_campaign%3DMetaTrader%2B4%2BTerminal&utm_medium%3Dspecial&utm_source%3Dmt4terminal%2Bcodebase][followyourheart]]
 works on price movements for n bars
****** [[https://www.mql5.com/en/code/10940?utm_campaign%3DMetaTrader%2B4%2BTerminal&utm_medium%3Dspecial&utm_source%3Dmt4terminal%2Bcodebase][antifragile ea]]
 an interesting idea from the concept of fragility



*** noise
 exploration of using stats efforts to benefit from noise
**** code v1 simple
 put together in a hurry to see if galliumos could put in trades since it wasn't for others. the reason was because of the spread being too low for questrade. after being adjusted trades were made appropriately. the initial version of the program was not optimized for anything and lost significantly, which suggests that it could be tweaked to win significantly as well. here are some optimized settings:

 | 139.60 | 41 | 1.62 | 3.40 |  80.00 | 0.78% | tpfactor=2   | slfactor=1   | sline_number=2 |
 | 139.35 | 37 | 1.60 | 3.77 |  63.90 | 0.63% | tpfactor=1.7 | slfactor=1.6 | sline_number=1 |
 | 139.05 | 48 | 1.62 | 2.90 |  71.80 | 0.71% | tpfactor=1   | slfactor=2   | sline_number=1 |
 | 133.10 | 48 | 1.52 | 2.77 |  73.00 | 0.72% | tpfactor=1.2 | slfactor=1.8 | sline_number=1 |
 | 127.30 | 33 | 1.60 | 3.86 |  88.65 | 0.87% | tpfactor=1.9 | slfactor=1.5 | sline_number=2 |
 | 110.30 | 51 | 1.42 | 2.16 |  69.00 | 0.68% | tpfactor=1   | slfactor=2   | sline_number=8 |
 | 106.25 | 39 | 1.41 | 2.72 |  58.40 | 0.58% | tpfactor=1.8 | slfactor=1.4 | sline_number=1 |
 | 105.90 | 32 | 1.51 | 3.31 |  79.80 | 0.79% | tpfactor=1.5 | slfactor=2   | sline_number=2 |
 |  88.50 | 54 | 1.26 | 1.64 |  98.70 | 0.97% | tpfactor=1.5 | slfactor=1.4 | sline_number=3 |
 |  85.40 | 61 | 1.24 | 1.40 | 141.05 | 1.38% | tpfactor=1.6 | slfactor=1.1 | sline_number=3 | 

 so decent results are possible.

 //noise.mq4//

 //
 //TODO
 //
 /*
 setup prog
 */


 //
 //DESCRIP
 //
 /*
 newbar trades on every new bar provided a trade is not already present
 the sline chosen determines buysel
 */


 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 //#include <stdlib.mqh>
 //#include <stderror.mqh>



 //
 //CONSTANTS
 //
 #define sp "  "
 #define spp "    "
 #define LOTSIZE 0.1                             /* lotsize */
 #define Z 0.5                                   /* effective zero slope */



 //
 //EXTERNS
 //
 extern double tpfactor;
 extern double slfactor;
 extern int sline_number;                             /* sline exponent choice */



 //
 //GLOBALS
 //
 int Gtf[6];                                     /* timeframe array */
 int tkt=-1;                                     /* ticket number */
 int grid_spacing=100;                           /* sets the grid spacing */
 double incl_value;




 //
 //STRATEGY FUNCTIONS
 //
 void OnTick()
 //main center
 {
   if(is_new_bar())                              /* get indicator info on every new bar */
     get_ii();
  
   if(can_do_trade())                            /* trade possible */
     if(no_trades_active())                        /* there are no trades */
       {
         ntr();
       }
     else                                          /* on active trade look for xit */
       xit();
 }


 void get_ii()
 //acquires all indicator info
 {
   int
     tf=Gtf[0];

   //hi,mi,lo slines for trend determination
   double
     hi[10],mi[10],lo[10];
   get_slines(hi,mi,lo);
   incl_value=get_incline(hi,mi,lo);

 }


 double get_incline(double &hi[],
                    double &mi[],
                    double &lo[])
 //determines incline from sline values
 {
   return mi[sline_number];
 }


 void get_slines(double &hi[],double &mi[],double &lo[])
 //computes the hml sline values
 {
   int bar,i;
   double
     hib,hi1,mib,mi1,lob,lo1;
   for(i=1;i<=9;i++)                              
     {
       bar=(int)pow(2,i);                        /* bar number calculation */
       hib=High[bar]; hi1=High[1];               /* hi values for bar and 1 */
       lob=Low[bar]; lo1=Low[1];                 /* lo values for bar and 1 */
       mib=(hib+lob)/2; mi1=(hi1+lo1)/2;         /* mi values for bar and 1 */
       hi[i]=incline_value(bar,hib,1,hi1);       /* hi inclines */
       mi[i]=incline_value(bar,mib,1,mi1);       /* mi inclines */
       lo[i]=incline_value(bar,lob,1,lo1);       /* lo inclines */
       //draw_sline(bar,hi[i],Time[bar],High[bar],Time[1],High[1]);
     }
   //printf("%.5f",hi_inc[1]);
 }


 bool xit_do()
 //xit patterns and conditions
 {
   int
     bs=OrderType();

   //xit pattern choices
   bool                                          /* only xit parameters required */
     B_xit=false,
     S_xit=false;

   if((bs==0 && B_xit) ||                        /* buy with B_xit */
      (bs==1 && S_xit))                          /* sel with S_xit */
     return true;
   return false;
 }


 int ntr_do(double iv)
 //ntrs patterns and conditions
 {
   bool                                          /* only ntr parameters required */
     B_ntr=(iv>0),
     S_ntr=(iv<0);
     /* B_ntr=((iv>+Z) || */
     /*        (btn(+Z,iv,0))), */
     /* S_ntr=((iv<-Z) || */
     /*        (btn(-Z,iv,0))); */

   if(B_ntr) return 0;
   if(S_ntr) return 1;
   return -1;
 }




 //
 // UTILITY FUNCTIONS
 //
 void xit()
 //trailing xit
 {
   if(OrderSelect(tkt,SELECT_BY_TICKET))
     {
       if(xit_do())
         if(!OrderClose(tkt,LOTSIZE,OrderClosePrice(),0))
           Comment("Error - order not closed");
     }
 }


 void ntr()
 //makes a trade
 {
   int
     bs=ntr_do(incl_value);
   double oo=0,sl=0,tp=0,
     sl_pts=slfactor*grid_spacing*Point,
     tp_pts=tpfactor*grid_spacing*Point;
  
   switch(bs)
     {
     case 0:
       oo=Ask;
       //osl=oo-INITIAL_SL*Point;
       sl=oo-sl_pts;
       tp=oo+tp_pts;
       break;
     case 1:
       oo=Bid;
       //osl=oo+INITIAL_SL;
       sl=oo+sl_pts;
       tp=oo-tp_pts;
       break;
     }
   tkt=OrderSend(Symbol(),bs,LOTSIZE,oo,0,sl,tp);
 }


 bool is_new_bar()
 //checks to see if we have a new bar
 {
   static datetime lastbartime;
   datetime
     curbartime=Time[0];
   if(lastbartime!=curbartime)
     {
       lastbartime=curbartime;
       return (true);
     }
   else
     return(false);
 }


 double maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);

   if(minbar>maxbar)
     return diff_pts(minval,maxval);
   else
     return diff_pts(maxval,minval);
 }


 double diff_pts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }


 double incline_value(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf giving points per bar
 {
   int
     Dbar=bI-bF;
   return diff_pts(vI,vF)/Dbar;
 }


 bool btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }


 bool true_turning_point(int b,string hilo)
 //hilo is true turning point
 {
   if(hilo=="hi")
     if(High[b]>=High[b-1] && High[b]>=High[b+1])
       return true;
   if(hilo=="lo")
     if(Low[b]<=Low[b-1] && Low[b]<=Low[b+1])
       return true;
   return false;
 }



 //
 // DISPLAY FUNCTIONS
 //
 void tline(string objlabel,datetime t1,double p1,datetime t2,double p2,color clr)
 //draws trend line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_TREND,0,t1,p1,t2,p2,clr);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
   ObjectSet(objlabel,OBJPROP_RAY_RIGHT,false);
 }


 void hline(string objlabel,double price,color clr)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
 }


 void vline(string objlabel,string timestr,color clr)
 //draws vertical line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_VLINE,0,StrToTime(timestr),0);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);  
 }


 void display_txt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 void draw_sline(int bar,double inc,datetime tI,double pI,datetime tF,double pF)
 //draws sline with color
 {
   color
     clr=incl_color(inc);
   tline("tline"+IntegerToString(bar),tI,pI,tF,pF,clr);
 }


 color incl_color(double inc)
 //determines color from incline value with .5 being the zeroincl threshold
 {
   double
     zeroincl=0.5;
   color
     clr=Green;
  
   if(btn(-zeroincl,inc,+zeroincl))
     clr=Green;
   else
     {
       if(inc>+zeroincl)
         clr=Blue;
       if(inc<-zeroincl)
         clr=Red;
     }
   return clr;
 }


 void hgrid(int size_in_points)
 //draws horizontal gridlines
 {
   int num_hlines,line_num;
   double line_price,
     hgridsize=size_in_points*Point,
     anchor=NormalizeDouble(Bid,2);
  
   switch(size_in_points)
     {
     case 500:
       num_hlines=20;
       break;
     case 1000:
       num_hlines=10;
       break;
     case 100:
       num_hlines=100;
       break;
     default:
       num_hlines=0;
       break;
     }

   line_num=0;
   line_price=anchor-(0.5*num_hlines*
                      size_in_points*
                      Point);
   if(num_hlines!=0)
     while(line_num<=num_hlines)
       {
         hline(IntegerToString(line_num),line_price,Green);
         line_price=line_price+size_in_points*Point;
         line_num++;
       }
 }


 //
 // SPECIAL FUNCTIONS
 //
 bool can_do_trade()
 //checks if trading is ok via total orders, spread
 {
   bool
     equityOK=(AccountEquity()>6000),
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<30);
   return (equityOK && spreadOK);
 }


 bool no_trades_active()
 //no trades are active
 {
   int aords,pords;
   bool
     ntradeOK=(orders_for_symbol(aords,pords)==0);
   return (ntradeOK);
 }

 int orders_for_symbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
 {
   aords=0;pords=0;
   for(int p=OrdersTotal()-1;p>=0;p--)
     if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
       {
         if(OrderType()>1 && OrderType()<6)
           pords++;
         if(OrderType()==OP_BUY || OrderType()==OP_SELL)
           aords++;
       }
   return aords+pords;
 }


 /* void show_last_error() */
 /* //prints last error message */
 /* { */
 /*   int */
 /*     errnum=GetLastError(); */
 /*   if(errnum!=ERR_NO_ERROR) */
 /*     Comment(errnum,sp,ErrorDescription(errnum)); */
 /*   else */
 /*     Comment(ERR_NO_ERROR); */
 /* } */


 int OnInit()
 {
   Gtf[0]=1;Gtf[1]=5;Gtf[2]=15;Gtf[3]=30;Gtf[4]=60;Gtf[5]=240;
   return(INIT_SUCCEEDED);
 }


 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

*** grid
 trades only at fixed grid lines eg 100, 500, 1000

**** code v1 no trades just analyses
 preliminary analyses 170101-0401 shows

 ticks =  1934183

 |  b/p |     ASR |     SAX |
 | 1.70 | 0.00010 | 0.00030 |
 | 1.63 | 0.00010 | 0.00040 |
 | 1.58 | 0.00010 | 0.00050 |
 | 1.54 | 0.00010 | 0.00060 |
 | 1.51 | 0.00010 | 0.00070 |
 | 1.47 | 0.00010 | 0.00080 |
 | 1.45 | 0.00010 | 0.00090 |
 | 1.31 | 0.00010 | 0.00100 |
 | 1.51 | 0.00015 | 0.00030 |
 | 1.56 | 0.00015 | 0.00040 |
 | 1.58 | 0.00015 | 0.00050 |
 | 1.59 | 0.00015 | 0.00060 |
 | 1.59 | 0.00015 | 0.00070 |
 | 1.58 | 0.00015 | 0.00080 |
 | 1.56 | 0.00015 | 0.00090 |
 | 1.48 | 0.00015 | 0.00100 |
 | 1.70 | 0.00020 | 0.00030 |
 | 1.77 | 0.00020 | 0.00040 |
 | 1.79 | 0.00020 | 0.00050 |
 | 1.80 | 0.00020 | 0.00060 |
 | 1.80 | 0.00020 | 0.00070 |
 | 1.79 | 0.00020 | 0.00080 |
 | 1.78 | 0.00020 | 0.00090 |
 | 1.72 | 0.00020 | 0.00100 |
 | 1.99 | 0.00025 | 0.00030 |
 | 2.07 | 0.00025 | 0.00040 |
 | 2.10 | 0.00025 | 0.00050 |
 | 2.10 | 0.00025 | 0.00060 |
 | 2.10 | 0.00025 | 0.00070 |
 | 2.09 | 0.00025 | 0.00080 |
 | 2.07 | 0.00025 | 0.00090 |
 | 2.02 | 0.00025 | 0.00100 |

 haven't tried 500 or 1000
 should see how trends influence trade

 //grid.mq4//

 //
 //TODO
 //
 /*
 line activation DONE
 determine what trend is through slines
 */


 //
 //DESCRIP
 //
 /*
 ntrxit trades through variable, but rigid grid
 the concept is to deal with chaotic ppa through a gridlike setup subject to
 - inclines
 - atr
 - sr
 tf is not important in this scenario
 */


 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>



 //
 //CONSTANTS
 //
 #define sp "  "
 #define spp "    "

 #define LOTSIZE 0.1                             /* lotsize */
 #define SLTP 12000                              /* fixed stoploss takeprof limits */
 #define Z 0.5                                   /* effective zero slope */



 //
 //EXTERNS
 //
 extern int grid_spacing=100;                    /* sets the grid spacing */


 //
 //GLOBALS
 //
 int Gtf[6];                                     /* timeframe array */
 int tkt=-1;                                     /* ticket number */
 double E=10*Point;                              /* epsilon for being in range of a gridline */
 int ticks;



 //
 //STRATEGY FUNCTIONS
 //
 void OnTick()
 //main center
 {
   if(is_new_bar())                              /* get indicator info on every new bar */
     get_ii();

   /* if(can_do_trade())                            /\* no active trade *\/ */
   /*   ntr(); */
   /* else                                          /\* on active trade look for xit *\/ */
   /*   xit(); */
 }


 void get_ii()
 //acquires all indicator info
 {
   int
     tf=Gtf[0];
  
   //bnds and zones
   double ubnd,lbnd;
   bnds(ubnd,lbnd,grid_spacing); 
  
   //line activation
   static double line_value;
   active_line(line_value,ubnd,lbnd);

   //hi,mi,lo slines for trend determination
   double
     hi[10],mi[10],lo[10];
   hml_slines(hi,mi,lo);
   Comment(hi[2]);
 }


 void active_line(double &line_value,
                  double ubnd,double lbnd)
 //determines is ubnd or lbnd line is active
 {
   bool
     ubnd_active=(btn(ubnd+E,Bid,ubnd-E)),       /* ubnd active */
     lbnd_active=(btn(lbnd+E,Bid,lbnd-E)),       /* lbnd active */
     beyond_bnds=(!ubnd_active && !lbnd_active);

   if(beyond_bnds)                               /* Bid deactivates bnds */
     line_value=0;
   if(ubnd_active)                               /* Bid activates ubnd */
     line_value=ubnd;
   if(lbnd_active)                               /* Bid activates lbnd */
     line_value=lbnd;
 }


 void bnds(double &ubnd, double &lbnd,
           int gridspacing)
 //computes the bnds from position of pr
 {
   int digits;
   if(gridspacing==100)
     digits=3;
   else
     digits=2;
  
   double
     pr=Bid,
     hgridsize=gridspacing*Point,               /* sets horizontal gridsize */
     bnd=NormalizeDouble(Bid,digits);            /* bound is set as the Bid to 2 decimals */

   if(bnd>=pr)                                    /* the bound is above the pr */
     {
       ubnd=bnd;                                 /* so upper bound is the bound */
       lbnd=bnd-hgridsize;                       /* and lower bound is gridsize less */
     }
   if(bnd<=pr)                                    /* the bound is below the pr */
     {
       ubnd=bnd+hgridsize;                       /* so upper bound is gridsize more */
       lbnd=bnd;                                 /* and lower bound is the bound */
     }
   //printf("%u %.4f %.5f %.4f",gridspacing,ubnd,pr,lbnd);
 }


 void hml_slines(double &hi[],double &mi[],double &lo[])
 //computes the hml sline values
 {
   int bar,i;
   double
     hib,hi1,mib,mi1,lob,lo1;
   for(i=1;i<=9;i++)                              
     {
       bar=(int)pow(2,i);                        /* bar number calculation */
       hib=High[bar]; hi1=High[1];               /* hi values for bar and 1 */
       lob=Low[bar]; lo1=Low[1];                 /* lo values for bar and 1 */
       mib=(hib+lob)/2; mi1=(hi1+lo1)/2;         /* mi values for bar and 1 */
       hi[i]=incline_value(bar,hib,1,hi1);       /* hi inclines */
       mi[i]=incline_value(bar,mib,1,mi1);       /* mi inclines */
       lo[i]=incline_value(bar,lob,1,lo1);       /* lo inclines */
       draw_sline(bar,hi[i],Time[bar],High[bar],Time[1],High[1]);
     }
   //printf("%.5f",hi_inc[1]);
 }


 bool xit_do()
 //xit patterns and conditions
 {
   int
     bs=OrderType();

   //xit pattern choices
   bool                                          /* only xit parameters required */
     B_xit=false,
     S_xit=false;

   if((bs==0 && B_xit) ||                        /* buy with B_xit */
      (bs==1 && S_xit))                          /* sel with S_xit */
     return true;
   return false;
 }


 int ntr_do()
 //ntrs patterns and conditions
 {
   bool                                          /* only ntr parameters required */
     B_ntr=false,
     S_ntr=false;

   if(B_ntr) return 0;
   if(S_ntr) return 1;
   return -1;
 }




 //
 // UTILITY FUNCTIONS
 //
 void xit()
 //trailing xit
 {
   if(OrderSelect(tkt,SELECT_BY_TICKET))
     {
       if(xit_do())
         if(OrderClose(tkt,LOTSIZE,OrderClosePrice(),0))
           reset();
         else
           show_last_error();
     }
 }


 void ntr()
 //makes a trade
 {
   double oo=0,sl=0,tp=0;
   int
     bs=ntr_do();
  
   switch(bs)
     {
     case 0:
       oo=Ask;
       //osl=oo-INITIAL_SL*Point;
       sl=oo-SLTP*Point;
       tp=oo+SLTP*Point;
       break;
     case 1:
       oo=Bid;
       //osl=oo+INITIAL_SL*Point;
       sl=oo+SLTP*Point;
       tp=oo-SLTP*Point;
       break;
     }
   tkt=OrderSend(Symbol(),bs,LOTSIZE,oo,0,sl,tp);
 }


 bool is_new_bar()
 //checks to see if we have a new bar
 {
   static datetime lastbartime;
   datetime
     curbartime=Time[0];
   if(lastbartime!=curbartime)
     {
       lastbartime=curbartime;
       return (true);
     }
   else
     return(false);
 }


 double maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);

   if(minbar>maxbar)
     return diff_pts(minval,maxval);
   else
     return diff_pts(maxval,minval);
 }


 double diff_pts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }


 double incline_value(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf giving points per bar
 {
   int
     Dbar=bI-bF;
   return diff_pts(vI,vF)/Dbar;
 }


 bool btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }


 bool true_turning_point(int b,string hilo)
 //hilo is true turning point
 {
   if(hilo=="hi")
     if(High[b]>=High[b-1] && High[b]>=High[b+1])
       return true;
   if(hilo=="lo")
     if(Low[b]<=Low[b-1] && Low[b]<=Low[b+1])
       return true;
   return false;
 }


 void reset()
 //sets various items to initial values
 {
   tkt=-1;
 }



 //
 // DISPLAY FUNCTIONS
 //
 void tline(string objlabel,datetime t1,double p1,datetime t2,double p2,color clr)
 //draws trend line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_TREND,0,t1,p1,t2,p2,clr);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
   ObjectSet(objlabel,OBJPROP_RAY_RIGHT,false);
 }


 void hline(string objlabel,double price,color clr)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
 }


 void vline(string objlabel,string timestr,color clr)
 //draws vertical line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_VLINE,0,StrToTime(timestr),0);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);  
 }


 void display_txt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 void draw_sline(int bar,double inc,datetime tI,double pI,datetime tF,double pF)
 //draws sline with color
 {
   color
     clr=Incl_color(inc);
   tline("tline"+IntegerToString(bar),tI,pI,tF,pF,clr);
 }


 color Incl_color(double inc)
 //determines color from incline value with .5 being the zeroincl threshold
 {
   double
     zeroincl=0.5;
   color
     clr=Green;
  
   if(btn(-zeroincl,inc,+zeroincl))
     clr=Green;
   else
     {
       if(inc>+zeroincl)
         clr=Blue;
       if(inc<-zeroincl)
         clr=Red;
     }
   return clr;
 }


 void hgrid(int size_in_points)
 //draws horizontal gridlines
 {
   int num_hlines,line_num;
   double line_price,
     hgridsize=size_in_points*Point,
     anchor=NormalizeDouble(Bid,2);
  
   switch(size_in_points)
     {
     case 500:
       num_hlines=20;
       break;
     case 1000:
       num_hlines=10;
       break;
     case 100:
       num_hlines=100;
       break;
     default:
       num_hlines=0;
       break;
     }

   line_num=0;
   line_price=anchor-(0.5*num_hlines*
                      size_in_points*
                      Point);
   if(num_hlines!=0)
     while(line_num<=num_hlines)
       {
         hline(IntegerToString(line_num),line_price,Green);
         line_price=line_price+size_in_points*Point;
         line_num++;
       }
 }


 //
 // SPECIAL FUNCTIONS
 //
 bool can_do_trade()
 //checks if trading is ok via total orders, spread
 {
   int aords,pords;
   bool
     ntradeOK=(orders_for_symbol(aords,pords)==0),
     equityOK=(AccountEquity()>6000),
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12);
   return (ntradeOK && equityOK && spreadOK);
 }


 int orders_for_symbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
 {
   aords=0;pords=0;
   for(int p=OrdersTotal()-1;p>=0;p--)
     if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
       {
         if(OrderType()>1 && OrderType()<6)
           pords++;
         if(OrderType()==OP_BUY || OrderType()==OP_SELL)
           aords++;
       }
   return aords+pords;
 }


 void show_last_error()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }


 int OnInit()
 {
   Gtf[0]=1;Gtf[1]=5;Gtf[2]=15;Gtf[3]=30;Gtf[4]=60;Gtf[5]=240;
   return(INIT_SUCCEEDED);
 }


 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

*** lincs
 - line inclinations continues the milines and slines effort in a more systematic fashion
 - earlier tests seem to strongly suggest that we optimize through a single week rather than 1 month or longer - results are considerably better!
 - a possible goal would be to setup certain parameter combos that work well by seeing which ones appear with some frequency and these can be randomly utilized possibly
 - even better would be some way to alter combos to adjust to market conditions, though how to do this is yet a mystery.
 - all spreads are 10 and the year is 2017
 - possibly a more middle result will be consistently better than the best weekly optimizations - look for density?

 TODO
 - python prog to analyze optimizations
 - create ntr and xit 4 line nu on slope
 - create ranging pattern recognition

 DONE
 - build protection for bar0 fluctuations

**** code v1 basic setup with 3ntr and 3xit
 this starting point produces good results and we can look at refinements

 eurusd 0311-0318
 | 87.21 | 14 | 3.10 |  6.23 | 37.19 | 0.37% | Elmsch=51 | Entrch=2 | Exitch=2 |
 | 80.71 | 14 | 2.60 |  5.77 | 50.19 | 0.50% | Elmsch=42 | Entrch=1 | Exitch=2 |
 | 79.32 |  6 | 3.20 | 13.22 | 84.80 | 0.84% | Elmsch=80 | Entrch=3 | Exitch=1 |
 | 79.32 |  6 | 3.20 | 13.22 | 84.80 | 0.84% | Elmsch=78 | Entrch=3 | Exitch=1 |
 | 78.41 | 10 | 3.06 |  7.84 | 39.79 | 0.40% | Elmsch=49 | Entrch=2 | Exitch=2 |
 | 78.12 |  6 | 3.16 | 13.02 | 87.50 | 0.86% | Elmsch=68 | Entrch=3 | Exitch=1 |
 | 76.62 |  6 | 3.13 | 12.77 | 87.50 | 0.86% | Elmsch=64 | Entrch=3 | Exitch=1 |
 | 71.32 |  6 | 2.84 | 11.89 | 87.50 | 0.86% | Elmsch=72 | Entrch=3 | Exitch=1 |
 | 58.91 | 12 | 2.20 |  4.91 | 58.39 | 0.58% | Elmsch=47 | Entrch=1 | Exitch=2 |
 | 55.51 | 13 | 1.98 |  4.27 | 51.99 | 0.52% | Elmsch=49 | Entrch=1 | Exitch=2 |
 | 54.51 | 13 | 1.95 |  4.19 | 52.99 | 0.53% | Elmsch=48 | Entrch=1 | Exitch=2 |

 eurusd 0304-0311
 | 68.35 | 4 |  4.47 | 17.09 | 75.79 | 0.76% | Elmsch=64 | Entrch=1 | Exitch=1 |
 | 68.31 | 5 |  7.16 | 13.66 | 58.39 | 0.58% | Elmsch=64 | Entrch=1 | Exitch=2 |
 | 66.81 | 5 |  7.25 | 13.36 | 58.39 | 0.58% | Elmsch=63 | Entrch=1 | Exitch=2 |
 | 65.20 | 4 |  3.85 | 16.30 | 51.50 | 0.51% | Elmsch=75 | Entrch=1 | Exitch=2 |
 | 65.15 | 4 |  4.03 | 16.29 | 72.19 | 0.72% | Elmsch=62 | Entrch=2 | Exitch=1 |
 | 64.80 | 5 |  8.12 | 12.96 | 52.00 | 0.52% | Elmsch=62 | Entrch=1 | Exitch=2 |
 | 63.00 | 4 |  3.75 | 15.75 | 53.70 | 0.54% | Elmsch=73 | Entrch=1 | Exitch=2 |
 | 62.70 | 5 | 13.80 | 12.54 | 48.90 | 0.49% | Elmsch=70 | Entrch=2 | Exitch=2 |
 | 62.25 | 4 |  3.66 | 15.56 | 73.79 | 0.74% | Elmsch=62 | Entrch=1 | Exitch=1 |
 | 62.15 | 4 |  3.64 | 15.54 | 73.79 | 0.74% | Elmsch=65 | Entrch=1 | Exitch=1 |

 eurusd 0225-0304
 | 90.67 | 10 | 4.50 |  9.07 | 63.59 | 0.63% | Elmsch=43 | Entrch=2 | Exitch=1 |
 | 90.44 | 30 | 1.65 |  3.01 | 66.40 | 0.66% | Elmsch=20 | Entrch=2 | Exitch=1 |
 | 89.16 | 11 | 2.49 |  8.11 | 86.26 | 0.85% | Elmsch=46 | Entrch=3 | Exitch=1 |
 | 87.70 |  3 | 7.69 | 29.23 | 50.10 | 0.50% | Elmsch=83 | Entrch=2 | Exitch=2 |
 | 87.60 |  4 | 7.64 | 21.90 | 43.70 | 0.43% | Elmsch=80 | Entrch=2 | Exitch=2 |
 | 87.60 |  4 | 7.64 | 21.90 | 43.70 | 0.43% | Elmsch=82 | Entrch=2 | Exitch=2 |
 | 86.80 |  4 | 6.83 | 21.70 | 58.20 | 0.58% | Elmsch=80 | Entrch=1 | Exitch=2 |
 | 85.96 | 11 | 2.44 |  7.81 | 86.26 | 0.85% | Elmsch=48 | Entrch=3 | Exitch=1 |
 | 78.77 | 11 | 2.76 |  7.16 | 64.06 | 0.63% | Elmsch=41 | Entrch=2 | Exitch=1 |
 | 76.77 | 12 | 2.07 |  6.40 | 83.26 | 0.82% | Elmsch=53 | Entrch=3 | Exitch=1 |
 | 75.46 | 10 | 2.60 |  7.55 | 68.26 | 0.67% | Elmsch=43 | Entrch=1 | Exitch=1 |


 //lincs.mq4//

 //
 //DESCRIP
 //
 /*
 use slines combos to determine market conditions for ntrxit
 */


 //
 //TODO
 //
 /*
 create ntr and xit for various sline combos including 4 line nu on slope
 build protection for 0 fluctuations

 ideas
 - parama (slopes for multiple lines are parallel)
 - nununu (consistency of nunu or unun can be utilized because h[] 2+,2- = n and l[] 2-,2+ = u!)
 - bodsor (short lines opposite to longer lines)
 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>



 //
 //CONSTANTS
 //
 #define sp "  "
 #define spp "    "

 #define LOTSIZE 0.1                             /* lotsize */
 #define SLTP 12000                              /* fixed stoploss takeprof limits */
 #define INITIAL_SL 600                          /* initial stoploss */
 #define TRAILING_SL 600                         /* trailing stoploss distance */
 #define TRAILING_ACTIVATION 300                 /* trailer activation */



 //
 //EXTERNS
 //
 extern int Elmsch;
 extern int Entrch;
 extern int Exitch;


 //
 //GLOBALS
 //
 int L,M,S;                                      /* long,mid,short indices for slines */
 int tkt=-1;                                     /* ticket number */
 double osl;                                     /* order stoploss */
 double sl0=0.5;                                 /* slope threshold */
 bool B_ntr,S_ntr,B_xit,S_xit;                   /* only 4 indicators required */



 //
 //STRATEGY FUNCTIONS
 //
 void OnTick()
 //main center
 {
   set_LMS(Elmsch);
  
   if(is_new_bar())                              /* get indicator info on every new bar */
     get_indicator_info();

   if(tkt==-1)                                   /* no active trade */
     {
       if(B_ntr)                                 /* buy */
         tkt=ntr(0);
       if(S_ntr)                                 /* sel */
         tkt=ntr(1);
     }
   else                                          /* on active trade look for xit */
     xit();

 }


 void get_indicator_info()
 //fills the slope values
 {
   //fill hilo slines for L(512,256,128)  I(64,32,16)  S(8,4,2)
   double hi_inc[10],lo_inc[10];ArrayInitialize(hi_inc,0);ArrayInitialize(lo_inc,0);
   int i,bar,
     tf=PERIOD_M1;
   for(i=1;i<=9;i++)                              
     {
       bar=(int)pow(2,i);
       hi_inc[i]=incline_value(bar,iHigh(NULL,tf,bar),1,iHigh(NULL,tf,1));
       lo_inc[i]=incline_value(bar,iLow(NULL,tf,bar),1,iLow(NULL,tf,1));
       //draw_sline(bar,hi_inc[i],Time[bar],High[bar],Time[1],High[1]);
     }
   //printf("%.5f",hi_inc[1]);
   //printf("%s",ColorToString(Incl_color(hi_inc [6]),true));

  
   //xits
   switch(Exitch)
     {
     case 1:                                     /* Lbrksl0: -L sl0 */
       B_xit=(hi_inc[L]<-sl0);
       S_xit=(lo_inc[L]>+sl0);
       break;
     case 2:                                     /* Lbrk0: -L 0 */
       B_xit=(hi_inc[L]<0);
       S_xit=(lo_inc[L]>0);
       break;
     case 3:                                     /* Mbrksl0: -M sl0 */
       B_xit=(hi_inc[M]<-sl0);
       S_xit=(lo_inc[M]>+sl0);      
       break;
     }

   //ntrs
   switch(Entrch)
     {
     case 1:                                     /* bodsorA: +LS,-M */
       B_ntr=(lo_inc[L]>+sl0 && lo_inc[M]<0 && lo_inc[S]>0);
       S_ntr=(hi_inc[L]<-sl0 && hi_inc[M]>0 && hi_inc[S]<0);
       break;
     case 2:                                     /* bodsorB: +L,-MS */
       B_ntr=(lo_inc[L]>+sl0 && lo_inc[M]<0 && lo_inc[S]<0);
       S_ntr=(hi_inc[L]<-sl0 && hi_inc[M]>0 && hi_inc[S]>0);
       break;
     case 3:                                     /* parama: all slopes agree */
       B_ntr=(lo_inc[L]>+sl0 && lo_inc[M]>0 && lo_inc[S]>0);
       S_ntr=(hi_inc[L]<-sl0 && hi_inc[M]<0 && hi_inc[S]<0);
     }
 }


 bool isu(double ss,double sm,double sl)
 //finds u
 {
   return (sl<0 && sm>sl && ss>sm && ss>0);
 }


 bool isn(double ss,double sm,double sl)
 //finds n
 {
   return(sl>0 && sm<sl && ss<sm && ss<0);
 }



 //
 // UTILITY FUNCTIONS
 //
 void xit()
 //trailing xit
 {
   if(OrderSelect(tkt,SELECT_BY_TICKET))
     {
       bool
         xit_trade=false;
       int
         bs=OrderType();
       double
         dpt=diff_pts(OrderOpenPrice(),Bid);      /* progress of price in points from oop */

       switch(bs)
         {
         case 0:
           if(B_xit)
             xit_trade=true;
           break;
         case 1:
           if(S_xit)
             xit_trade=true;
           break;
         }
       if(xit_trade)
         if(OrderClose(tkt,LOTSIZE,OrderClosePrice(),0))
           reset();
     }
 }


 int ntr(int bs)
 //makes a trade
 {
   double oo=0,sl=0,tp=0;
  
   switch(bs)
     {
     case 0:
       oo=Ask;
       osl=oo-INITIAL_SL*Point;
       sl=oo-SLTP*Point;
       tp=oo+SLTP*Point;
       break;
     case 1:
       oo=Bid;
       osl=oo+INITIAL_SL*Point;
       sl=oo+SLTP*Point;
       tp=oo-SLTP*Point;
       break;
     }
   return OrderSend(Symbol(),bs,LOTSIZE,oo,0,sl,tp);
 }


 bool is_new_bar()
 //checks to see if we have a new bar
 {
   static datetime lastbartime;
   datetime
     curbartime=Time[0];
   if(lastbartime!=curbartime)
     {
       lastbartime=curbartime;
       return (true);
     }
   else
     return(false);
 }


 double maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);

   if(minbar>maxbar)
     return diff_pts(minval,maxval);
   else
     return diff_pts(maxval,minval);
 }


 double diff_pts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }


 double incline_value(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf giving points per bar
 {
   int
     Dbar=bI-bF;
   return diff_pts(vI,vF)/Dbar;
 }


 bool is_btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }


 bool true_turning_point(int b,string hilo)
 //hilo is true turning point
 {
   if(hilo=="hi")
     if(High[b]>=High[b-1] && High[b]>=High[b+1])
       return true;
   if(hilo=="lo")
     if(Low[b]<=Low[b-1] && Low[b]<=Low[b+1])
       return true;
   return false;
 }


 void reset()
 //sets various items to initial values
 {
   tkt=-1;
 }



 //
 // DISPLAY FUNCTIONS
 //
 void tline(string objlabel,datetime t1,double p1,datetime t2,double p2,color clr)
 //draws trend line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_TREND,0,t1,p1,t2,p2,clr);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
   ObjectSet(objlabel,OBJPROP_RAY_RIGHT,false);
 }


 void hline(string objlabel,double price,color clr)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
 }


 void vline(string objlabel,string timestr,color clr)
 //draws vertical line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_VLINE,0,StrToTime(timestr),0);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);  
 }


 void display_txt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 void draw_sline(int bar,double inc,datetime tI,double pI,datetime tF,double pF)
 //draws sline with color
 {
   color
     clr=Incl_color(inc);
   tline("tline"+IntegerToString(bar),tI,pI,tF,pF,clr);
 }


 color Incl_color(double inc)
 //determines color from incline value
 {
   double
     zeroincl=0.6;
   color
     clr=Green;
  
   if(is_btn(-zeroincl,inc,+zeroincl))
     clr=Green;
   else
     {
       if(inc>+zeroincl)
         clr=Blue;
       if(inc<-zeroincl)
         clr=Red;
     }
   return clr;
 }



 //
 // SPECIAL FUNCTIONS
 //
 bool can_do_trade()
 //checks if trading is ok via total orders, spread
 {
   bool
     equityOK=(AccountEquity()>6000),
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12);
   return (equityOK && spreadOK);
 }


 int orders_for_symbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
 {
   aords=0;pords=0;
   for(int p=OrdersTotal()-1;p>=0;p--)
     if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
       {
         if(OrderType()>1 && OrderType()<6)
           pords++;
         if(OrderType()==OP_BUY || OrderType()==OP_SELL)
           aords++;
       }
   return aords+pords;
 }


 void show_last_error()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }



 int OnInit() {return(INIT_SUCCEEDED);}




 void set_LMS(int ch)
 //gets the LMS indices as defined by choice
 {
   switch(ch)
     {
     case 0:
       L=3;M=2;S=1;
       break;
     case 1:
       L=4;M=2;S=1;
       break;
     case 2:
       L=4;M=3;S=1;
       break;
     case 3:
       L=4;M=3;S=2;
       break;
     case 4:
       L=5;M=2;S=1;
       break;
     case 5:
       L=5;M=3;S=1;
       break;
     case 6:
       L=5;M=3;S=2;
       break;
     case 7:
       L=5;M=4;S=1;
       break;
     case 8:
       L=5;M=4;S=2;
       break;
     case 9:
       L=5;M=4;S=3;
       break;
     case 10:
       L=6;M=2;S=1;
       break;
     case 11:
       L=6;M=3;S=1;
       break;
     case 12:
       L=6;M=3;S=2;
       break;
     case 13:
       L=6;M=4;S=1;
       break;
     case 14:
       L=6;M=4;S=2;
       break;
     case 15:
       L=6;M=4;S=3;
       break;
     case 16:
       L=6;M=5;S=1;
       break;
     case 17:
       L=6;M=5;S=2;
       break;
     case 18:
       L=6;M=5;S=3;
       break;
     case 19:
       L=6;M=5;S=4;
       break;
     case 20:
       L=7;M=2;S=1;
       break;
     case 21:
       L=7;M=3;S=1;
       break;
     case 22:
       L=7;M=3;S=2;
       break;
     case 23:
       L=7;M=4;S=1;
       break;
     case 24:
       L=7;M=4;S=2;
       break;
     case 25:
       L=7;M=4;S=3;
       break;
     case 26:
       L=7;M=5;S=1;
       break;
     case 27:
       L=7;M=5;S=2;
       break;
     case 28:
       L=7;M=5;S=3;
       break;
     case 29:
       L=7;M=5;S=4;
       break;
     case 30:
       L=7;M=6;S=1;
       break;
     case 31:
       L=7;M=6;S=2;
       break;
     case 32:
       L=7;M=6;S=3;
       break;
     case 33:
       L=7;M=6;S=4;
       break;
     case 34:
       L=7;M=6;S=5;
       break;
     case 35:
       L=8;M=2;S=1;
       break;
     case 36:
       L=8;M=3;S=1;
       break;
     case 37:
       L=8;M=3;S=2;
       break;
     case 38:
       L=8;M=4;S=1;
       break;
     case 39:
       L=8;M=4;S=2;
       break;
     case 40:
       L=8;M=4;S=3;
       break;
     case 41:
       L=8;M=5;S=1;
       break;
     case 42:
       L=8;M=5;S=2;
       break;
     case 43:
       L=8;M=5;S=3;
       break;
     case 44:
       L=8;M=5;S=4;
       break;
     case 45:
       L=8;M=6;S=1;
       break;
     case 46:
       L=8;M=6;S=2;
       break;
     case 47:
       L=8;M=6;S=3;
       break;
     case 48:
       L=8;M=6;S=4;
       break;
     case 49:
       L=8;M=6;S=5;
       break;
     case 50:
       L=8;M=7;S=1;
       break;
     case 51:
       L=8;M=7;S=2;
       break;
     case 52:
       L=8;M=7;S=3;
       break;
     case 53:
       L=8;M=7;S=4;
       break;
     case 54:
       L=8;M=7;S=5;
       break;
     case 55:
       L=8;M=7;S=6;
       break;
     case 56:
       L=9;M=2;S=1;
       break;
     case 57:
       L=9;M=3;S=1;
       break;
     case 58:
       L=9;M=3;S=2;
       break;
     case 59:
       L=9;M=4;S=1;
       break;
     case 60:
       L=9;M=4;S=2;
       break;
     case 61:
       L=9;M=4;S=3;
       break;
     case 62:
       L=9;M=5;S=1;
       break;
     case 63:
       L=9;M=5;S=2;
       break;
     case 64:
       L=9;M=5;S=3;
       break;
     case 65:
       L=9;M=5;S=4;
       break;
     case 66:
       L=9;M=6;S=1;
       break;
     case 67:
       L=9;M=6;S=2;
       break;
     case 68:
       L=9;M=6;S=3;
       break;
     case 69:
       L=9;M=6;S=4;
       break;
     case 70:
       L=9;M=6;S=5;
       break;
     case 71:
       L=9;M=7;S=1;
       break;
     case 72:
       L=9;M=7;S=2;
       break;
     case 73:
       L=9;M=7;S=3;
       break;
     case 74:
       L=9;M=7;S=4;
       break;
     case 75:
       L=9;M=7;S=5;
       break;
     case 76:
       L=9;M=7;S=6;
       break;
     case 77:
       L=9;M=8;S=1;
       break;
     case 78:
       L=9;M=8;S=2;
       break;
     case 79:
       L=9;M=8;S=3;
       break;
     case 80:
       L=9;M=8;S=4;
       break;
     case 81:
       L=9;M=8;S=5;
       break;
     case 82:
       L=9;M=8;S=6;
       break;
     case 83:
       L=9;M=8;S=7;
       break;
     }
 }

 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

**** code v2 separate ntr and xit indicators and add safeties to the latter
 ntr and xit become functions that execute actions based on condition determinators ntr_do and xit_do
 safety useful since large movements in bar 0 will not register on incs
 seems as though large max_dds are not going to produce the best results so max_dd 600 seems to be a good setting for now


 eurusd 0311-0318
 | 106.21 | 16 | 3.18 | 6.64 | 46.99 | 0.47% | Elmsch=44 | Entrch=1 | Exitch=2 | Emax_dd=400  |
 | 104.31 | 15 | 3.07 | 6.95 | 50.19 | 0.50% | Elmsch=42 | Entrch=1 | Exitch=2 | Emax_dd=800  |
 |  95.91 | 14 | 2.97 | 6.85 | 46.99 | 0.47% | Elmsch=44 | Entrch=1 | Exitch=2 | Emax_dd=800  |
 |  94.31 | 15 | 2.87 | 6.29 | 50.19 | 0.50% | Elmsch=42 | Entrch=1 | Exitch=2 | Emax_dd=700  |
 |  94.01 | 13 | 3.50 | 7.23 | 37.99 | 0.38% | Elmsch=53 | Entrch=2 | Exitch=2 | Emax_dd=1600 |
 |  94.01 | 13 | 3.50 | 7.23 | 37.99 | 0.38% | Elmsch=53 | Entrch=2 | Exitch=2 | Emax_dd=2100 |
 |  94.01 | 13 | 3.50 | 7.23 | 37.99 | 0.38% | Elmsch=53 | Entrch=2 | Exitch=2 | Emax_dd=1500 |
 |  92.31 | 17 | 2.31 | 5.43 | 58.70 | 0.58% | Elmsch=39 | Entrch=1 | Exitch=2 | Emax_dd=400  |
 |  91.81 | 16 | 2.30 | 5.74 | 64.20 | 0.63% | Elmsch=38 | Entrch=1 | Exitch=2 | Emax_dd=800  |
 |  89.91 | 16 | 2.28 | 5.62 | 61.60 | 0.61% | Elmsch=39 | Entrch=1 | Exitch=2 | Emax_dd=800  |

 eurusd 0304-0311
 | 125.35 | 6 |  4.39 | 20.89 | 75.79 | 0.76% | Elmsch=64 | Entrch=1 | Exitch=1 | Emax_dd=500  |
 | 122.92 | 6 |  4.12 | 20.49 | 72.79 | 0.73% | Elmsch=63 | Entrch=1 | Exitch=1 | Emax_dd=500  |
 | 103.02 | 6 |  3.22 | 17.17 | 72.49 | 0.72% | Elmsch=68 | Entrch=1 | Exitch=1 | Emax_dd=500  |
 | 100.45 | 5 |  3.78 | 20.09 | 72.49 | 0.72% | Elmsch=68 | Entrch=1 | Exitch=1 | Emax_dd=600  |
 |  94.50 | 5 | 10.64 | 18.90 | 35.80 | 0.36% | Elmsch=73 | Entrch=2 | Exitch=2 | Emax_dd=500  |
 |  90.11 | 7 |  4.90 | 12.87 | 42.39 | 0.42% | Elmsch=63 | Entrch=1 | Exitch=2 | Emax_dd=500  |
 |  89.41 | 7 |  4.61 | 12.77 | 42.39 | 0.42% | Elmsch=64 | Entrch=1 | Exitch=2 | Emax_dd=500  |
 |  88.80 | 3 |  0.00 | 29.60 | 48.90 | 0.49% | Elmsch=73 | Entrch=2 | Exitch=2 | Emax_dd=1500 |
 |  88.80 | 3 |  0.00 | 29.60 | 48.90 | 0.49% | Elmsch=73 | Entrch=2 | Exitch=2 | Emax_dd=1300 |
 |  88.80 | 3 |  0.00 | 29.60 | 48.90 | 0.49% | Elmsch=73 | Entrch=2 | Exitch=2 | Emax_dd=2100 |

 eurusd 0225-0304
 | 109.07 | 23 | 1.72 | 4.74 | 52.30 | 0.52% | Elmsch=41 | Entrch=2 | Exitch=1 | Emax_dd=200  |
 | 107.27 | 17 | 2.22 | 6.31 | 55.10 | 0.54% | Elmsch=35 | Entrch=2 | Exitch=1 | Emax_dd=300  |
 | 107.17 | 11 | 2.81 | 9.74 | 55.96 | 0.55% | Elmsch=42 | Entrch=2 | Exitch=1 | Emax_dd=800  |
 | 105.77 | 13 | 2.31 | 8.14 | 61.96 | 0.61% | Elmsch=42 | Entrch=2 | Exitch=1 | Emax_dd=500  |
 | 104.07 | 12 | 2.70 | 8.67 | 56.00 | 0.55% | Elmsch=35 | Entrch=2 | Exitch=1 | Emax_dd=600  |
 | 102.97 | 12 | 2.42 | 8.58 | 56.00 | 0.55% | Elmsch=35 | Entrch=2 | Exitch=1 | Emax_dd=700  |
 | 102.17 | 16 | 2.04 | 6.39 | 63.59 | 0.63% | Elmsch=43 | Entrch=2 | Exitch=1 | Emax_dd=300  |
 | 102.17 | 14 | 1.99 | 7.30 | 56.00 | 0.55% | Elmsch=35 | Entrch=2 | Exitch=1 | Emax_dd=500  |
 | 101.57 | 15 | 1.85 | 6.77 | 55.96 | 0.55% | Elmsch=42 | Entrch=2 | Exitch=1 | Emax_dd=400  |
 | 101.07 | 11 | 3.22 | 9.19 | 56.00 | 0.55% | Elmsch=35 | Entrch=2 | Exitch=1 | Emax_dd=1300 |

 eurusd 0218-0225
 | 127.23 | 3 | 12.17 | 42.41 | 65.40 | 0.65% | Elmsch=73 | Entrch=1 | Exitch=1 | Emax_dd=700 |
 | 126.33 | 4 | 11.11 | 31.58 | 67.60 | 0.67% | Elmsch=71 | Entrch=1 | Exitch=1 | Emax_dd=700 |
 | 126.23 | 3 | 11.11 | 42.08 | 66.80 | 0.66% | Elmsch=75 | Entrch=1 | Exitch=1 | Emax_dd=700 |
 | 121.43 | 9 |  2.98 | 13.49 | 54.20 | 0.54% | Elmsch=63 | Entrch=1 | Exitch=1 | Emax_dd=300 |
 | 120.33 | 9 |  2.97 | 13.37 | 56.40 | 0.56% | Elmsch=63 | Entrch=2 | Exitch=1 | Emax_dd=300 |
 | 119.03 | 5 |  4.12 | 23.81 | 71.50 | 0.71% | Elmsch=78 | Entrch=1 | Exitch=1 | Emax_dd=400 |
 | 119.03 | 5 |  4.08 | 23.81 | 65.40 | 0.65% | Elmsch=73 | Entrch=1 | Exitch=1 | Emax_dd=400 |
 | 118.13 | 5 |  4.04 | 23.63 | 71.50 | 0.71% | Elmsch=80 | Entrch=1 | Exitch=1 | Emax_dd=400 |
 | 116.83 | 6 |  3.85 | 19.47 | 65.90 | 0.65% | Elmsch=71 | Entrch=1 | Exitch=1 | Emax_dd=400 |
 | 116.73 | 5 |  3.85 | 23.35 | 61.30 | 0.61% | Elmsch=75 | Entrch=1 | Exitch=1 | Emax_dd=400 |

  


 //lincs.mq4//

 //
 //DESCRIP
 //
 /*
 use slines combos to determine market conditions for ntrxit
 */


 //
 //TODO
 //
 /*
 build protection for bar0 fluctuations DONE

 create ntr and xit for various sline combos including 4 line nu on slope
 incorporate nu
 create ranging pattern recognition

 ideas
 - parama (slopes for multiple lines are parallel)
 - nununu (consistency of nunu or unun can be utilized because h[] 2+,2- = n and l[] 2-,2+ = u!)
 - bodsor (short lines opposite to longer lines)
 */


 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>



 //
 //CONSTANTS
 //
 #define sp "  "
 #define spp "    "

 #define LOTSIZE 0.1                             /* lotsize */
 #define SLTP 12000                              /* fixed stoploss takeprof limits */
 #define Z 0.5                                   /* effective zero slope */



 //
 //EXTERNS
 //
 extern int Elmsch;
 extern int Entrch;
 extern int Exitch;
 extern int Emax_dd;



 //
 //GLOBALS
 //
 int tkt=-1;                                     /* ticket number */
 int L,M,S;                                      /* long,mid,short indices for slines */
 double incs[2,10];                              /* incline values array */
 double osl;                                     /* order stoploss */




 //
 //STRATEGY FUNCTIONS
 //
 void get_lincs()
 //fill hilo slines for L(512,256,128)  I(64,32,16)  S(8,4,2)
 {
   int i,bar,
     tf=PERIOD_M1;
   for(i=1;i<=9;i++)                              
     {
       bar=(int)pow(2,i);
       incs[0,i]=incline_value(bar,iHigh(NULL,tf,bar),1,iHigh(NULL,tf,1));
       incs[1,i]=incline_value(bar,iLow(NULL,tf,bar),1,iLow(NULL,tf,1));
     }
 }


 bool xit_do()
 //xit patterns and conditions
 {
   int
     bs=OrderType();

   //safety xit for bar0
   double
     max_dd=Emax_dd,                             /* maximum allowable drawdown */
     dpt=diff_pts(OrderOpenPrice(),Bid);         /* +ve for buy, -ve for sel */
   if((bs==0 && dpt<-max_dd) ||                  /* buy loss dpt<0 */
      (bs==1 && dpt>+max_dd) ||                  /* sel loss dpt>0 */
      (bs==0 && dpt>+max_dd) ||                  /* buy loss dpt<0 */
      (bs==1 && dpt<-max_dd))                    /* sel loss dpt>0 */
     return true;

   //xit pattern choices
   bool                                          /* only xit parameters required */
     B_xit=false,
     S_xit=false;
   switch(Exitch)
     {
     case 1:                                     /* LbrkZ */
       B_xit=(incs[0,L]<-Z);
       S_xit=(incs[1,L]>+Z);
       break;
     case 2:                                     /* Lbrk0 */
       B_xit=(incs[0,L]<0);
       S_xit=(incs[1,L]>0);
       break;
     }


   if((bs==0 && B_xit) ||                        /* buy with B_xit */
      (bs==1 && S_xit))                          /* sel with S_xit */
     return true;
   return false;
 }


 int ntr_do()
 //ntrs patterns and conditions
 {
   bool                                          /* only ntr parameters required */
     B_ntr=false,
     S_ntr=false;
  
   switch(Entrch)
     {
     case 1:                                     /* bodsorA: \L /M \S */
       B_ntr=(incs[1,L]>+Z && incs[1,M]<0 && incs[1,S]>0);
       S_ntr=(incs[0,L]<-Z && incs[0,M]>0 && incs[0,S]<0);
       break;
     case 2:                                     /* bodsorB: \L /M /S */
       B_ntr=(incs[1,L]>+Z && incs[1,M]<0 && incs[1,S]<0);
       S_ntr=(incs[0,L]<-Z && incs[0,M]>0 && incs[0,S]>0);
       break;
     case 3:                                     /* parama: \L \M \S */
       B_ntr=(incs[1,L]>+Z && incs[1,M]>0 && incs[1,S]>0);
       S_ntr=(incs[0,L]<-Z && incs[0,M]<0 && incs[0,S]<0);
     case 4:                                     /* straight nu */
       B_ntr=(isu(incs[1,L],incs[1,M],incs[1,S]));
       S_ntr=(isn(incs[0,L],incs[0,M],incs[0,S]));
     case 5:                                     /* incline aware nu */
       B_ntr=(isu(incs[1,L],incs[1,M],incs[1,S]) && incs[1,L+1]>0);
       S_ntr=(isn(incs[0,L],incs[0,M],incs[0,S]) && incs[0,L+1]<0);      
     }

   if(B_ntr) return 0;
   if(S_ntr) return 1;
   return -1;
 }


 bool isu(double sl,double sm,double ss)
 //finds u
 {
   return (sl<0 && sm>sl && ss>sm && ss>0);
 }


 bool isn(double sl,double sm,double ss)
 //finds n
 {
   return(sl>0 && sm<sl && ss<sm && ss<0);
 }



 //
 // UTILITY FUNCTIONS
 //
 void xit()
 //trailing xit
 {
   if(OrderSelect(tkt,SELECT_BY_TICKET))
     {
       if(xit_do())
         if(OrderClose(tkt,LOTSIZE,OrderClosePrice(),0))
           reset();
         else
           show_last_error();
     }
 }


 void ntr()
 //makes a trade
 {
   double oo=0,sl=0,tp=0;
   int
     bs=ntr_do();
  
   switch(bs)
     {
     case 0:
       oo=Ask;
       //osl=oo-INITIAL_SL*Point;
       sl=oo-SLTP*Point;
       tp=oo+SLTP*Point;
       break;
     case 1:
       oo=Bid;
       //osl=oo+INITIAL_SL*Point;
       sl=oo+SLTP*Point;
       tp=oo-SLTP*Point;
       break;
     }
   tkt=OrderSend(Symbol(),bs,LOTSIZE,oo,0,sl,tp);
 }


 bool is_new_bar()
 //checks to see if we have a new bar
 {
   static datetime lastbartime;
   datetime
     curbartime=Time[0];
   if(lastbartime!=curbartime)
     {
       lastbartime=curbartime;
       return (true);
     }
   else
     return(false);
 }


 double maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);

   if(minbar>maxbar)
     return diff_pts(minval,maxval);
   else
     return diff_pts(maxval,minval);
 }


 double diff_pts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }


 double incline_value(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf giving points per bar
 {
   int
     Dbar=bI-bF;
   return diff_pts(vI,vF)/Dbar;
 }


 bool is_btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }


 bool true_turning_point(int b,string hilo)
 //hilo is true turning point
 {
   if(hilo=="hi")
     if(High[b]>=High[b-1] && High[b]>=High[b+1])
       return true;
   if(hilo=="lo")
     if(Low[b]<=Low[b-1] && Low[b]<=Low[b+1])
       return true;
   return false;
 }


 void reset()
 //sets various items to initial values
 {
   tkt=-1;
 }



 //
 // DISPLAY FUNCTIONS
 //
 void tline(string objlabel,datetime t1,double p1,datetime t2,double p2,color clr)
 //draws trend line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_TREND,0,t1,p1,t2,p2,clr);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
   ObjectSet(objlabel,OBJPROP_RAY_RIGHT,false);
 }


 void hline(string objlabel,double price,color clr)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
 }


 void vline(string objlabel,string timestr,color clr)
 //draws vertical line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_VLINE,0,StrToTime(timestr),0);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);  
 }


 void display_txt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 void draw_sline(int bar,double inc,datetime tI,double pI,datetime tF,double pF)
 //draws sline with color
 {
   color
     clr=Incl_color(inc);
   tline("tline"+IntegerToString(bar),tI,pI,tF,pF,clr);
 }


 color Incl_color(double inc)
 //determines color from incline value
 {
   double
     zeroincl=0.6;
   color
     clr=Green;
  
   if(is_btn(-zeroincl,inc,+zeroincl))
     clr=Green;
   else
     {
       if(inc>+zeroincl)
         clr=Blue;
       if(inc<-zeroincl)
         clr=Red;
     }
   return clr;
 }



 //
 // SPECIAL FUNCTIONS
 //
 bool can_do_trade()
 //checks if trading is ok via total orders, spread
 {
   int aords,pords;
   bool
     ntradeOK=(orders_for_symbol(aords,pords)==0),
     equityOK=(AccountEquity()>6000),
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12);
   return (ntradeOK && equityOK && spreadOK);
 }


 int orders_for_symbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
 {
   aords=0;pords=0;
   for(int p=OrdersTotal()-1;p>=0;p--)
     if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
       {
         if(OrderType()>1 && OrderType()<6)
           pords++;
         if(OrderType()==OP_BUY || OrderType()==OP_SELL)
           aords++;
       }
   return aords+pords;
 }


 void show_last_error()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }



 int OnInit() {return(INIT_SUCCEEDED);}

 void OnTick()
 //main center
 {
   set_LMS(Elmsch);

   if(is_new_bar())                              /* get indicator info on every new bar */
     get_lincs();

   if(can_do_trade())                            /* no active trade */
     ntr();
   else                                          /* on active trade look for xit */
     xit();
 }



 void set_LMS(int ch)
 //gets the LMS indices as defined by choice
 {
   switch(ch)
     {
     case 0:
       L=3;M=2;S=1;
       break;
     case 1:
       L=4;M=2;S=1;
       break;
     case 2:
       L=4;M=3;S=1;
       break;
     case 3:
       L=4;M=3;S=2;
       break;
     case 4:
       L=5;M=2;S=1;
       break;
     case 5:
       L=5;M=3;S=1;
       break;
     case 6:
       L=5;M=3;S=2;
       break;
     case 7:
       L=5;M=4;S=1;
       break;
     case 8:
       L=5;M=4;S=2;
       break;
     case 9:
       L=5;M=4;S=3;
       break;
     case 10:
       L=6;M=2;S=1;
       break;
     case 11:
       L=6;M=3;S=1;
       break;
     case 12:
       L=6;M=3;S=2;
       break;
     case 13:
       L=6;M=4;S=1;
       break;
     case 14:
       L=6;M=4;S=2;
       break;
     case 15:
       L=6;M=4;S=3;
       break;
     case 16:
       L=6;M=5;S=1;
       break;
     case 17:
       L=6;M=5;S=2;
       break;
     case 18:
       L=6;M=5;S=3;
       break;
     case 19:
       L=6;M=5;S=4;
       break;
     case 20:
       L=7;M=2;S=1;
       break;
     case 21:
       L=7;M=3;S=1;
       break;
     case 22:
       L=7;M=3;S=2;
       break;
     case 23:
       L=7;M=4;S=1;
       break;
     case 24:
       L=7;M=4;S=2;
       break;
     case 25:
       L=7;M=4;S=3;
       break;
     case 26:
       L=7;M=5;S=1;
       break;
     case 27:
       L=7;M=5;S=2;
       break;
     case 28:
       L=7;M=5;S=3;
       break;
     case 29:
       L=7;M=5;S=4;
       break;
     case 30:
       L=7;M=6;S=1;
       break;
     case 31:
       L=7;M=6;S=2;
       break;
     case 32:
       L=7;M=6;S=3;
       break;
     case 33:
       L=7;M=6;S=4;
       break;
     case 34:
       L=7;M=6;S=5;
       break;
     case 35:
       L=8;M=2;S=1;
       break;
     case 36:
       L=8;M=3;S=1;
       break;
     case 37:
       L=8;M=3;S=2;
       break;
     case 38:
       L=8;M=4;S=1;
       break;
     case 39:
       L=8;M=4;S=2;
       break;
     case 40:
       L=8;M=4;S=3;
       break;
     case 41:
       L=8;M=5;S=1;
       break;
     case 42:
       L=8;M=5;S=2;
       break;
     case 43:
       L=8;M=5;S=3;
       break;
     case 44:
       L=8;M=5;S=4;
       break;
     case 45:
       L=8;M=6;S=1;
       break;
     case 46:
       L=8;M=6;S=2;
       break;
     case 47:
       L=8;M=6;S=3;
       break;
     case 48:
       L=8;M=6;S=4;
       break;
     case 49:
       L=8;M=6;S=5;
       break;
     case 50:
       L=8;M=7;S=1;
       break;
     case 51:
       L=8;M=7;S=2;
       break;
     case 52:
       L=8;M=7;S=3;
       break;
     case 53:
       L=8;M=7;S=4;
       break;
     case 54:
       L=8;M=7;S=5;
       break;
     case 55:
       L=8;M=7;S=6;
       break;
     case 56:
       L=9;M=2;S=1;
       break;
     case 57:
       L=9;M=3;S=1;
       break;
     case 58:
       L=9;M=3;S=2;
       break;
     case 59:
       L=9;M=4;S=1;
       break;
     case 60:
       L=9;M=4;S=2;
       break;
     case 61:
       L=9;M=4;S=3;
       break;
     case 62:
       L=9;M=5;S=1;
       break;
     case 63:
       L=9;M=5;S=2;
       break;
     case 64:
       L=9;M=5;S=3;
       break;
     case 65:
       L=9;M=5;S=4;
       break;
     case 66:
       L=9;M=6;S=1;
       break;
     case 67:
       L=9;M=6;S=2;
       break;
     case 68:
       L=9;M=6;S=3;
       break;
     case 69:
       L=9;M=6;S=4;
       break;
     case 70:
       L=9;M=6;S=5;
       break;
     case 71:
       L=9;M=7;S=1;
       break;
     case 72:
       L=9;M=7;S=2;
       break;
     case 73:
       L=9;M=7;S=3;
       break;
     case 74:
       L=9;M=7;S=4;
       break;
     case 75:
       L=9;M=7;S=5;
       break;
     case 76:
       L=9;M=7;S=6;
       break;
     case 77:
       L=9;M=8;S=1;
       break;
     case 78:
       L=9;M=8;S=2;
       break;
     case 79:
       L=9;M=8;S=3;
       break;
     case 80:
       L=9;M=8;S=4;
       break;
     case 81:
       L=9;M=8;S=5;
       break;
     case 82:
       L=9;M=8;S=6;
       break;
     case 83:
       L=9;M=8;S=7;
       break;
     }
 }

 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

**** code v3 add in nus which didn't work too well so we discard for now
 this was a bit of a surprise as neither nu ntr even showed up or produced peculiar results:
     case 4:                                     /* straight nu */
       B_ntr=(isu(incs[1,L],incs[1,M],incs[1,S]));
       S_ntr=(isn(incs[0,L],incs[0,M],incs[0,S]));
     case 5:                                     /* incline aware nu */
       if(LL<=9)
         {
           B_ntr=(isu(incs[1,L],incs[1,M],incs[1,S]) && incs[1,L+1]>0);
           S_ntr=(isn(incs[0,L],incs[0,M],incs[0,S]) && incs[0,L+1]<0);
         }

 eurusd 0211-0218
 | 81.90 | 48 | 2.06 | 1.71 | 63.95 | 0.64% | Elmsch=55 | Entrch=4 | Exitch=1 | Emax_dd=500  |
 | 81.90 | 48 | 2.06 | 1.71 | 63.95 | 0.64% | Elmsch=55 | Entrch=5 | Exitch=1 | Emax_dd=500  |
 | 59.50 | 50 | 1.69 | 1.19 | 63.95 | 0.64% | Elmsch=55 | Entrch=5 | Exitch=1 | Emax_dd=300  |
 | 59.50 | 50 | 1.69 | 1.19 | 63.95 | 0.64% | Elmsch=55 | Entrch=4 | Exitch=1 | Emax_dd=300  |
 | 45.10 | 50 | 1.40 | 0.90 | 63.95 | 0.64% | Elmsch=55 | Entrch=4 | Exitch=1 | Emax_dd=400  |
 | 45.10 | 50 | 1.40 | 0.90 | 63.95 | 0.64% | Elmsch=55 | Entrch=5 | Exitch=1 | Emax_dd=400  |
 | 41.30 | 47 | 1.61 | 0.88 | 63.95 | 0.64% | Elmsch=55 | Entrch=5 | Exitch=1 | Emax_dd=2100 |
 | 41.30 | 47 | 1.61 | 0.88 | 63.95 | 0.64% | Elmsch=55 | Entrch=5 | Exitch=1 | Emax_dd=1000 |
 | 41.30 | 47 | 1.61 | 0.88 | 63.95 | 0.64% | Elmsch=55 | Entrch=5 | Exitch=1 | Emax_dd=2400 |
 | 41.30 | 47 | 1.61 | 0.88 | 63.95 | 0.64% | Elmsch=55 | Entrch=5 | Exitch=1 | Emax_dd=600  |
 higher values did the last minute jumps


 //lincs.mq4//

 //
 //DESCRIP
 //
 /*
 use slines combos to determine market conditions for ntrxit
 */


 //
 //TODO
 //
 /*
 create ntr and xit for various sline combos including 4 line nu on slope
 build protection for bar0 fluctuations
 incorporate nu
 create ranging pattern recognition

 ideas
 - parama (slopes for multiple lines are parallel)
 - nununu (consistency of nunu or unun can be utilized because h[] 2+,2- = n and l[] 2-,2+ = u!)
 - bodsor (short lines opposite to longer lines)
 */


 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>



 //
 //CONSTANTS
 //
 #define sp "  "
 #define spp "    "

 #define LOTSIZE 0.1                             /* lotsize */
 #define SLTP 12000                              /* fixed stoploss takeprof limits */
 #define Z 0.5                                   /* effective zero slope */



 //
 //EXTERNS
 //
 extern int Elmsch;
 extern int Entrch;
 extern int Exitch;
 extern int Emax_dd;



 //
 //GLOBALS
 //
 int tkt=-1;                                     /* ticket number */
 int L,M,S;                                      /* long,mid,short indices for slines */
 double incs[2,10];                              /* incline values array */
 double osl;                                     /* order stoploss */




 //
 //STRATEGY FUNCTIONS
 //
 void get_lincs()
 //fill hilo slines for L(512,256,128)  I(64,32,16)  S(8,4,2)
 {
   int i,bar,
     tf=PERIOD_M1;
   for(i=1;i<=9;i++)                              
     {
       bar=(int)pow(2,i);
       incs[0,i]=incline_value(bar,iHigh(NULL,tf,bar),1,iHigh(NULL,tf,1));
       incs[1,i]=incline_value(bar,iLow(NULL,tf,bar),1,iLow(NULL,tf,1));
     }
 }


 bool xit_do()
 //xit patterns and conditions
 {
   int
     bs=OrderType();

   //safety xit for bar0
   double
     max_dd=Emax_dd,                             /* maximum allowable drawdown */
     dpt=diff_pts(OrderOpenPrice(),Bid);         /* +ve for buy, -ve for sel */
   if((bs==0 && dpt<-max_dd) ||                  /* buy loss dpt<0 */
      (bs==1 && dpt>+max_dd) ||                  /* sel loss dpt>0 */
      (bs==0 && dpt>+max_dd) ||                  /* buy loss dpt<0 */
      (bs==1 && dpt<-max_dd))                    /* sel loss dpt>0 */
     return true;

   //xit pattern choices
   bool                                          /* only xit parameters required */
     B_xit=false,
     S_xit=false;
   switch(Exitch)
     {
     case 1:                                     /* LbrkZ */
       B_xit=(incs[0,L]<-Z);
       S_xit=(incs[1,L]>+Z);
       break;
     case 2:                                     /* Lbrk0 */
       B_xit=(incs[0,L]<0);
       S_xit=(incs[1,L]>0);
       break;
     }


   if((bs==0 && B_xit) ||                        /* buy with B_xit */
      (bs==1 && S_xit))                          /* sel with S_xit */
     return true;
   return false;
 }


 int ntr_do()
 //ntrs patterns and conditions
 {
   bool                                          /* only ntr parameters required */
     B_ntr=false,
     S_ntr=false;
   int
     LL=L+1;
  
   switch(Entrch)
     {
     case 1:                                     /* bodsorA: \L /M \S */
       B_ntr=(incs[1,L]>+Z && incs[1,M]<0 && incs[1,S]>0);
       S_ntr=(incs[0,L]<-Z && incs[0,M]>0 && incs[0,S]<0);
       break;
     case 2:                                     /* bodsorB: \L /M /S */
       B_ntr=(incs[1,L]>+Z && incs[1,M]<0 && incs[1,S]<0);
       S_ntr=(incs[0,L]<-Z && incs[0,M]>0 && incs[0,S]>0);
       break;
     case 3:                                     /* parama: \L \M \S */
       B_ntr=(incs[1,L]>+Z && incs[1,M]>0 && incs[1,S]>0);
       S_ntr=(incs[0,L]<-Z && incs[0,M]<0 && incs[0,S]<0);
     case 4:                                     /* straight nu */
       B_ntr=(isu(incs[1,L],incs[1,M],incs[1,S]));
       S_ntr=(isn(incs[0,L],incs[0,M],incs[0,S]));
     case 5:                                     /* incline aware nu */
       if(LL<=9)
         {
           B_ntr=(isu(incs[1,L],incs[1,M],incs[1,S]) && incs[1,L+1]>0);
           S_ntr=(isn(incs[0,L],incs[0,M],incs[0,S]) && incs[0,L+1]<0);
         }
     }

   if(B_ntr) return 0;
   if(S_ntr) return 1;
   return -1;
 }


 bool isu(double l,double m,double s)
 //finds u
 {
   bool
     l_neg=(l<0),
     m_is_btn_ls=(is_btn(l,m,s)),
     s_pos=(s>0);
   return (l_neg && m_is_btn_ls && s_pos);
 }


 bool isn(double l,double m,double s)
 //finds n
 {
   bool
     l_pos=(l>0),
     m_is_btn_ls=(is_btn(l,m,s)),
     s_neg=(s<0);
   return (l_pos && m_is_btn_ls && s_neg);
 }



 //
 // UTILITY FUNCTIONS
 //
 void xit()
 //trailing xit
 {
   if(OrderSelect(tkt,SELECT_BY_TICKET))
     {
       if(xit_do())
         if(OrderClose(tkt,LOTSIZE,OrderClosePrice(),0))
           reset();
         else
           show_last_error();
     }
 }


 void ntr()
 //makes a trade
 {
   double oo=0,sl=0,tp=0;
   int
     bs=ntr_do();
  
   switch(bs)
     {
     case 0:
       oo=Ask;
       //osl=oo-INITIAL_SL*Point;
       sl=oo-SLTP*Point;
       tp=oo+SLTP*Point;
       break;
     case 1:
       oo=Bid;
       //osl=oo+INITIAL_SL*Point;
       sl=oo+SLTP*Point;
       tp=oo-SLTP*Point;
       break;
     }
   tkt=OrderSend(Symbol(),bs,LOTSIZE,oo,0,sl,tp);
 }


 bool is_new_bar()
 //checks to see if we have a new bar
 {
   static datetime lastbartime;
   datetime
     curbartime=Time[0];
   if(lastbartime!=curbartime)
     {
       lastbartime=curbartime;
       return (true);
     }
   else
     return(false);
 }


 double maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);

   if(minbar>maxbar)
     return diff_pts(minval,maxval);
   else
     return diff_pts(maxval,minval);
 }


 double diff_pts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }


 double incline_value(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf giving points per bar
 {
   int
     Dbar=bI-bF;
   return diff_pts(vI,vF)/Dbar;
 }


 bool is_btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }


 bool true_turning_point(int b,string hilo)
 //hilo is true turning point
 {
   if(hilo=="hi")
     if(High[b]>=High[b-1] && High[b]>=High[b+1])
       return true;
   if(hilo=="lo")
     if(Low[b]<=Low[b-1] && Low[b]<=Low[b+1])
       return true;
   return false;
 }


 void reset()
 //sets various items to initial values
 {
   tkt=-1;
 }



 //
 // DISPLAY FUNCTIONS
 //
 void tline(string objlabel,datetime t1,double p1,datetime t2,double p2,color clr)
 //draws trend line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_TREND,0,t1,p1,t2,p2,clr);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
   ObjectSet(objlabel,OBJPROP_RAY_RIGHT,false);
 }


 void hline(string objlabel,double price,color clr)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
 }


 void vline(string objlabel,string timestr,color clr)
 //draws vertical line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_VLINE,0,StrToTime(timestr),0);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);  
 }


 void display_txt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 void draw_sline(int bar,double inc,datetime tI,double pI,datetime tF,double pF)
 //draws sline with color
 {
   color
     clr=Incl_color(inc);
   tline("tline"+IntegerToString(bar),tI,pI,tF,pF,clr);
 }


 color Incl_color(double inc)
 //determines color from incline value
 {
   double
     zeroincl=0.6;
   color
     clr=Green;
  
   if(is_btn(-zeroincl,inc,+zeroincl))
     clr=Green;
   else
     {
       if(inc>+zeroincl)
         clr=Blue;
       if(inc<-zeroincl)
         clr=Red;
     }
   return clr;
 }



 //
 // SPECIAL FUNCTIONS
 //
 bool can_do_trade()
 //checks if trading is ok via total orders, spread
 {
   int aords,pords;
   bool
     ntradeOK=(orders_for_symbol(aords,pords)==0),
     equityOK=(AccountEquity()>6000),
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12);
   return (ntradeOK && equityOK && spreadOK);
 }


 int orders_for_symbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
 {
   aords=0;pords=0;
   for(int p=OrdersTotal()-1;p>=0;p--)
     if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
       {
         if(OrderType()>1 && OrderType()<6)
           pords++;
         if(OrderType()==OP_BUY || OrderType()==OP_SELL)
           aords++;
       }
   return aords+pords;
 }


 void show_last_error()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }



 int OnInit() {return(INIT_SUCCEEDED);}

 void OnTick()
 //main center
 {
   set_LMS(Elmsch);

   if(is_new_bar())                              /* get indicator info on every new bar */
     get_lincs();

   if(can_do_trade())                            /* no active trade */
     ntr();
   else                                          /* on active trade look for xit */
     xit();
 }



 void set_LMS(int ch)
 //gets the LMS indices as defined by choice
 {
   switch(ch)
     {
     case 0:
       L=3;M=2;S=1;
       break;
     case 1:
       L=4;M=2;S=1;
       break;
     case 2:
       L=4;M=3;S=1;
       break;
     case 3:
       L=4;M=3;S=2;
       break;
     case 4:
       L=5;M=2;S=1;
       break;
     case 5:
       L=5;M=3;S=1;
       break;
     case 6:
       L=5;M=3;S=2;
       break;
     case 7:
       L=5;M=4;S=1;
       break;
     case 8:
       L=5;M=4;S=2;
       break;
     case 9:
       L=5;M=4;S=3;
       break;
     case 10:
       L=6;M=2;S=1;
       break;
     case 11:
       L=6;M=3;S=1;
       break;
     case 12:
       L=6;M=3;S=2;
       break;
     case 13:
       L=6;M=4;S=1;
       break;
     case 14:
       L=6;M=4;S=2;
       break;
     case 15:
       L=6;M=4;S=3;
       break;
     case 16:
       L=6;M=5;S=1;
       break;
     case 17:
       L=6;M=5;S=2;
       break;
     case 18:
       L=6;M=5;S=3;
       break;
     case 19:
       L=6;M=5;S=4;
       break;
     case 20:
       L=7;M=2;S=1;
       break;
     case 21:
       L=7;M=3;S=1;
       break;
     case 22:
       L=7;M=3;S=2;
       break;
     case 23:
       L=7;M=4;S=1;
       break;
     case 24:
       L=7;M=4;S=2;
       break;
     case 25:
       L=7;M=4;S=3;
       break;
     case 26:
       L=7;M=5;S=1;
       break;
     case 27:
       L=7;M=5;S=2;
       break;
     case 28:
       L=7;M=5;S=3;
       break;
     case 29:
       L=7;M=5;S=4;
       break;
     case 30:
       L=7;M=6;S=1;
       break;
     case 31:
       L=7;M=6;S=2;
       break;
     case 32:
       L=7;M=6;S=3;
       break;
     case 33:
       L=7;M=6;S=4;
       break;
     case 34:
       L=7;M=6;S=5;
       break;
     case 35:
       L=8;M=2;S=1;
       break;
     case 36:
       L=8;M=3;S=1;
       break;
     case 37:
       L=8;M=3;S=2;
       break;
     case 38:
       L=8;M=4;S=1;
       break;
     case 39:
       L=8;M=4;S=2;
       break;
     case 40:
       L=8;M=4;S=3;
       break;
     case 41:
       L=8;M=5;S=1;
       break;
     case 42:
       L=8;M=5;S=2;
       break;
     case 43:
       L=8;M=5;S=3;
       break;
     case 44:
       L=8;M=5;S=4;
       break;
     case 45:
       L=8;M=6;S=1;
       break;
     case 46:
       L=8;M=6;S=2;
       break;
     case 47:
       L=8;M=6;S=3;
       break;
     case 48:
       L=8;M=6;S=4;
       break;
     case 49:
       L=8;M=6;S=5;
       break;
     case 50:
       L=8;M=7;S=1;
       break;
     case 51:
       L=8;M=7;S=2;
       break;
     case 52:
       L=8;M=7;S=3;
       break;
     case 53:
       L=8;M=7;S=4;
       break;
     case 54:
       L=8;M=7;S=5;
       break;
     case 55:
       L=8;M=7;S=6;
       break;
     case 56:
       L=9;M=2;S=1;
       break;
     case 57:
       L=9;M=3;S=1;
       break;
     case 58:
       L=9;M=3;S=2;
       break;
     case 59:
       L=9;M=4;S=1;
       break;
     case 60:
       L=9;M=4;S=2;
       break;
     case 61:
       L=9;M=4;S=3;
       break;
     case 62:
       L=9;M=5;S=1;
       break;
     case 63:
       L=9;M=5;S=2;
       break;
     case 64:
       L=9;M=5;S=3;
       break;
     case 65:
       L=9;M=5;S=4;
       break;
     case 66:
       L=9;M=6;S=1;
       break;
     case 67:
       L=9;M=6;S=2;
       break;
     case 68:
       L=9;M=6;S=3;
       break;
     case 69:
       L=9;M=6;S=4;
       break;
     case 70:
       L=9;M=6;S=5;
       break;
     case 71:
       L=9;M=7;S=1;
       break;
     case 72:
       L=9;M=7;S=2;
       break;
     case 73:
       L=9;M=7;S=3;
       break;
     case 74:
       L=9;M=7;S=4;
       break;
     case 75:
       L=9;M=7;S=5;
       break;
     case 76:
       L=9;M=7;S=6;
       break;
     case 77:
       L=9;M=8;S=1;
       break;
     case 78:
       L=9;M=8;S=2;
       break;
     case 79:
       L=9;M=8;S=3;
       break;
     case 80:
       L=9;M=8;S=4;
       break;
     case 81:
       L=9;M=8;S=5;
       break;
     case 82:
       L=9;M=8;S=6;
       break;
     case 83:
       L=9;M=8;S=7;
       break;
     }
 }

 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

**** code v4 uses only the best parts of prior versions and tries 3 digit cases
 however, the results tend to be inconsistent wrt older efforts (because i was using eurusdpro!)
 the peculiar results from removing code that isn't used is presently inexplicable though.
 we set max_dd=600 since that seems to be a good average.
 consider possibility that in a flat market xits are triggered very easily - require ranger component

 also, going with these xits doesn't quite match the 1 & 2:

     case 3:
       B_xit=(incs[0,L]<-Z &&
              incs[0,M]<-Z);
       S_xit=(incs[1,L]>+Z &&
              incs[1,M]>+Z);
       break;
     case 4:
       B_xit=(incs[0,L]<-Z &&
              incs[0,M]<incs[0,L]);
       S_xit=(incs[1,L]>+Z &&
              incs[1,M]>+incs[1,L]);
       break;

 on the other hand, look at 0225-0304
 | 122.56 |  9 | 3.87 | 13.62 | 92.26 | 0.91% | Elmsch=49 | Entrch=3 | Exitch=3 |
 | 122.36 |  9 | 3.85 | 13.60 | 92.46 | 0.92% | Elmsch=49 | Entrch=3 | Exitch=4 |
 | 121.26 |  9 | 3.75 | 13.47 | 92.26 | 0.91% | Elmsch=45 | Entrch=3 | Exitch=3 |
 | 121.06 |  9 | 3.74 | 13.45 | 92.46 | 0.92% | Elmsch=45 | Entrch=3 | Exitch=4 |
 | 119.36 |  9 | 3.79 | 13.26 | 92.26 | 0.91% | Elmsch=48 | Entrch=3 | Exitch=3 |
 | 119.16 |  9 | 3.77 | 13.24 | 92.46 | 0.92% | Elmsch=48 | Entrch=3 | Exitch=4 |
 | 119.05 | 28 | 1.86 |  4.25 | 71.00 | 0.70% | Elmsch=28 | Entrch=3 | Exitch=3 |
 |  90.70 |  4 | 6.60 | 22.68 | 52.40 | 0.52% | Elmsch=78 | Entrch=1 | Exitch=2 |
 |  90.67 | 10 | 4.50 |  9.07 | 63.59 | 0.63% | Elmsch=43 | Entrch=2 | Exitch=1 |
 |  90.44 | 30 | 1.65 |  3.01 | 66.40 | 0.66% | Elmsch=20 | Entrch=2 | Exitch=1 |
 where it blows away 1,2 though note the drawdown isn't as good

 most of the time though 3,4 barely appear
 | 152.92 | 21 | 2.50 | 7.28 |  70.40 | 0.70% | Elmsch=77 | Entrch=1 | Exitch=2 |
 | 128.32 | 18 | 2.51 | 7.13 |  68.80 | 0.68% | Elmsch=83 | Entrch=2 | Exitch=2 |
 | 110.34 | 31 | 1.50 | 3.56 | 141.49 | 1.41% | Elmsch=62 | Entrch=1 | Exitch=2 |
 | 103.37 | 20 | 1.46 | 5.17 | 141.07 | 1.39% | Elmsch=76 | Entrch=3 | Exitch=4 |
 |  98.42 | 19 | 2.00 | 5.18 |  66.00 | 0.66% | Elmsch=82 | Entrch=1 | Exitch=2 |
 |  94.14 | 27 | 1.52 | 3.49 |  88.48 | 0.87% | Elmsch=73 | Entrch=1 | Exitch=2 |
 |  89.60 | 22 | 1.34 | 4.07 | 213.37 | 2.11% | Elmsch=62 | Entrch=3 | Exitch=1 |
 |  86.61 | 14 | 1.93 | 6.19 | 120.27 | 1.18% | Elmsch=83 | Entrch=2 | Exitch=1 |
 |  84.90 | 22 | 1.32 | 3.86 | 214.47 | 2.12% | Elmsch=59 | Entrch=3 | Exitch=1 |
 |  82.80 | 22 | 1.30 | 3.76 | 222.27 | 2.20% | Elmsch=82 | Entrch=3 | Exitch=1 |

 | 193.34 | 21 | 2.93 | 9.21 |  69.90 | 0.69% | Elmsch=80 | Entrch=1 | Exitch=2 |
 | 112.93 | 16 | 1.74 | 7.06 | 118.19 | 1.16% | Elmsch=80 | Entrch=1 | Exitch=1 |
 | 109.46 | 34 | 1.39 | 3.22 | 147.89 | 1.47% | Elmsch=60 | Entrch=1 | Exitch=2 |
 | 106.14 | 19 | 2.11 | 5.59 |  68.80 | 0.68% | Elmsch=83 | Entrch=2 | Exitch=2 |
 | 104.93 | 16 | 1.68 | 6.56 | 118.19 | 1.16% | Elmsch=80 | Entrch=1 | Exitch=3 |
 | 103.63 | 16 | 1.66 | 6.48 | 118.19 | 1.16% | Elmsch=80 | Entrch=1 | Exitch=4 |
 | 101.39 | 18 | 1.44 | 5.63 | 221.58 | 2.18% | Elmsch=73 | Entrch=2 | Exitch=1 |
 |  95.16 | 23 | 1.33 | 4.14 | 149.18 | 1.49% | Elmsch=71 | Entrch=3 | Exitch=4 |
 |  91.29 | 18 | 1.40 | 5.07 | 221.58 | 2.18% | Elmsch=73 | Entrch=2 | Exitch=3 |
 |  91.29 | 18 | 1.40 | 5.07 | 221.58 | 2.18% | Elmsch=73 | Entrch=2 | Exitch=4 |

 so we should investigate how 0225-0304 is different from the others


 try to correlate results below with weekly market conditions and derive combos for various situations.
 use M-x count-matches to determine frequency of significant items.

 switching to 3 figure lms seems to produce lower results in every case except eurusd 0225-0304
 there is often an excess of L=9 as well
 we don't get identical results even though the situation is identical.


 eurusd 0318-0325
 | 52.80 | 2 |  0.00 | 26.40 | 25.70 | 0.26% | Elmsch=981 | Entrch=1 | Exitch=2 |
 | 51.00 | 2 |  0.00 | 25.50 | 25.70 | 0.26% | Elmsch=985 | Entrch=1 | Exitch=2 |
 | 50.80 | 2 |  0.00 | 25.40 | 25.70 | 0.26% | Elmsch=983 | Entrch=1 | Exitch=2 |
 | 50.80 | 2 |  0.00 | 25.40 | 25.70 | 0.26% | Elmsch=982 | Entrch=1 | Exitch=2 |
 | 49.40 | 2 |  0.00 | 24.70 | 25.70 | 0.26% | Elmsch=981 | Entrch=2 | Exitch=2 |
 | 49.40 | 2 |  0.00 | 24.70 | 25.70 | 0.26% | Elmsch=984 | Entrch=2 | Exitch=2 |
 | 46.70 | 2 | 78.83 | 23.35 | 25.70 | 0.26% | Elmsch=987 | Entrch=1 | Exitch=2 |
 | 46.70 | 2 | 78.83 | 23.35 | 25.70 | 0.26% | Elmsch=986 | Entrch=1 | Exitch=2 |
 | 46.03 | 3 | 34.60 | 15.34 | 25.70 | 0.26% | Elmsch=963 | Entrch=1 | Exitch=2 |
 | 46.03 | 3 | 34.60 | 15.34 | 25.70 | 0.26% | Elmsch=965 | Entrch=1 | Exitch=2 |

 | 82.42 |  6 | 3.59 | 13.74 | 87.50 | 0.86% | Elmsch=964 | Entrch=3 | Exitch=1 |
 | 80.71 | 14 | 2.60 |  5.77 | 50.19 | 0.50% | Elmsch=42 | Entrch=1 | Exitch=2 |
 | 80.12 |  6 | 3.15 | 13.35 | 87.50 | 0.86% | Elmsch=58 | Entrch=2 | Exitch=4 |
 | 79.32 |  6 | 3.20 | 13.22 | 84.80 | 0.84% | Elmsch=80 | Entrch=3 | Exitch=1 |
 | 79.12 |  6 | 3.19 | 13.19 | 84.80 | 0.84% | Elmsch=60 | Entrch=3 | Exitch=3 |
 | 79.12 |  6 | 3.19 | 13.19 | 84.80 | 0.84% | Elmsch=58 | Entrch=3 | Exitch=4 |
 | 79.12 |  6 | 3.19 | 13.19 | 84.80 | 0.84% | Elmsch=58 | Entrch=3 | Exitch=1 |
 | 79.12 |  6 | 3.19 | 13.19 | 84.80 | 0.84% | Elmsch=60 | Entrch=3 | Exitch=4 |
 | 79.12 |  6 | 3.19 | 13.19 | 84.80 | 0.84% | Elmsch=60 | Entrch=3 | Exitch=1 |
 | 79.12 |  6 | 3.19 | 13.19 | 84.80 | 0.84% | Elmsch=58 | Entrch=3 | Exitch=3 |


 eurusd 0311-0318
 | 79.32 |  6 | 3.20 | 13.22 | 84.80 | 0.84% | Elmsch=982 | Entrch=3 | Exitch=1 |
 | 79.32 |  6 | 3.20 | 13.22 | 84.80 | 0.84% | Elmsch=983 | Entrch=3 | Exitch=1 |
 | 79.32 |  6 | 3.20 | 13.22 | 84.80 | 0.84% | Elmsch=984 | Entrch=3 | Exitch=1 |
 | 78.92 |  6 | 3.24 | 13.15 | 87.50 | 0.86% | Elmsch=986 | Entrch=3 | Exitch=1 |
 | 78.32 |  6 | 3.22 | 13.05 | 87.50 | 0.86% | Elmsch=961 | Entrch=3 | Exitch=1 |
 | 77.21 | 12 | 2.85 |  6.43 | 37.99 | 0.38% | Elmsch=875 | Entrch=2 | Exitch=2 |
 | 76.62 |  6 | 3.13 | 12.77 | 87.50 | 0.86% | Elmsch=981 | Entrch=3 | Exitch=1 |
 | 76.62 |  6 | 3.13 | 12.77 | 87.50 | 0.86% | Elmsch=951 | Entrch=3 | Exitch=1 |
 | 76.62 |  6 | 3.13 | 12.77 | 87.50 | 0.86% | Elmsch=985 | Entrch=3 | Exitch=1 |
 | 71.32 |  6 | 2.84 | 11.89 | 87.50 | 0.86% | Elmsch=987 | Entrch=3 | Exitch=1 |

 | 88.80 | 3 | 0.00 | 29.60 | 48.90 | 0.49% | Elmsch=73 | Entrch=2 | Exitch=2 |
 | 68.35 | 4 | 4.47 | 17.09 | 75.79 | 0.76% | Elmsch=953 | Entrch=1 | Exitch=1 |
 | 68.31 | 5 | 7.16 | 13.66 | 58.39 | 0.58% | Elmsch=953 | Entrch=1 | Exitch=2 |
 | 67.45 | 4 | 4.42 | 16.86 | 75.79 | 0.76% | Elmsch=953 | Entrch=1 | Exitch=4 |
 | 67.45 | 4 | 4.42 | 16.86 | 75.79 | 0.76% | Elmsch=953 | Entrch=1 | Exitch=3 |
 | 64.40 | 3 | 4.44 | 21.47 | 75.20 | 0.75% | Elmsch=73 | Entrch=2 | Exitch=4 |
 | 64.40 | 3 | 4.44 | 21.47 | 75.20 | 0.75% | Elmsch=73 | Entrch=2 | Exitch=3 |
 | 64.40 | 3 | 4.44 | 21.47 | 75.20 | 0.75% | Elmsch=73 | Entrch=2 | Exitch=1 |
 | 58.41 | 6 | 5.06 |  9.73 | 61.19 | 0.61% | Elmsch=59 | Entrch=2 | Exitch=2 |
 | 58.15 | 4 | 3.13 | 14.54 | 76.59 | 0.76% | Elmsch=59 | Entrch=1 | Exitch=3 |


 eurusd 0304-0311
 | 43.56 | 5 | 1.95 | 8.71 | 80.60 | 0.80% | Elmsch=932 | Entrch=3 | Exitch=1 |
 | 43.56 | 5 | 1.95 | 8.71 | 80.60 | 0.80% | Elmsch=932 | Entrch=3 | Exitch=4 |
 | 43.56 | 5 | 1.95 | 8.71 | 80.60 | 0.80% | Elmsch=932 | Entrch=3 | Exitch=3 |
 | 42.86 | 5 | 1.86 | 8.57 | 85.10 | 0.85% | Elmsch=932 | Entrch=1 | Exitch=1 |
 | 42.86 | 5 | 1.86 | 8.57 | 85.10 | 0.85% | Elmsch=932 | Entrch=1 | Exitch=3 |
 | 42.66 | 5 | 1.91 | 8.53 | 80.60 | 0.80% | Elmsch=985 | Entrch=3 | Exitch=1 |
 | 41.66 | 5 | 1.84 | 8.33 | 84.49 | 0.84% | Elmsch=961 | Entrch=1 | Exitch=1 |
 | 41.16 | 5 | 1.83 | 8.23 | 85.10 | 0.85% | Elmsch=931 | Entrch=1 | Exitch=4 |
 | 41.16 | 5 | 1.83 | 8.23 | 85.10 | 0.85% | Elmsch=931 | Entrch=1 | Exitch=1 |
 | 40.76 | 5 | 1.83 | 8.15 | 80.60 | 0.80% | Elmsch=931 | Entrch=3 | Exitch=3 |


 | 68.35 | 4 | 4.47 | 17.09 | 75.79 | 0.76% | Elmsch=953 | Entrch=1 | Exitch=1 |
 | 68.31 | 5 | 7.16 | 13.66 | 58.39 | 0.58% | Elmsch=953 | Entrch=1 | Exitch=2 |
 | 67.95 | 4 | 4.45 | 16.99 | 72.49 | 0.72% | Elmsch=68 | Entrch=1 | Exitch=1 |
 | 66.85 | 4 | 3.86 | 16.71 | 72.79 | 0.73% | Elmsch=63 | Entrch=1 | Exitch=1 |
 | 66.81 | 5 | 7.25 | 13.36 | 58.39 | 0.58% | Elmsch=63 | Entrch=1 | Exitch=2 |
 | 65.20 | 4 | 3.85 | 16.30 | 51.50 | 0.51% | Elmsch=75 | Entrch=1 | Exitch=2 |
 | 64.05 | 4 | 4.25 | 16.01 | 74.39 | 0.74% | Elmsch=61 | Entrch=1 | Exitch=1 |
 | 63.50 | 4 | 3.58 | 15.88 | 51.50 | 0.51% | Elmsch=72 | Entrch=1 | Exitch=2 |
 | 63.00 | 4 | 3.75 | 15.75 | 53.70 | 0.54% | Elmsch=73 | Entrch=1 | Exitch=2 |
 | 59.34 | 4 | 3.12 | 14.84 | 72.50 | 0.72% | Elmsch=75 | Entrch=1 | Exitch=1 |


 eurusd 0225-0304
 | 123.26 |  9 | 3.88 | 13.70 | 92.26 | 0.91% | Elmsch=863 | Entrch=3 | Exitch=3 |
 | 123.06 |  9 | 3.87 | 13.67 | 92.46 | 0.92% | Elmsch=863 | Entrch=3 | Exitch=4 |
 | 122.56 |  9 | 3.87 | 13.62 | 92.26 | 0.91% | Elmsch=862 | Entrch=3 | Exitch=3 |
 | 122.36 |  9 | 3.85 | 13.60 | 92.46 | 0.92% | Elmsch=862 | Entrch=3 | Exitch=4 |
 | 121.26 |  9 | 3.75 | 13.47 | 92.26 | 0.91% | Elmsch=861 | Entrch=3 | Exitch=3 |
 | 121.06 |  9 | 3.74 | 13.45 | 92.46 | 0.92% | Elmsch=861 | Entrch=3 | Exitch=4 |
 | 117.25 | 28 | 1.84 |  4.19 | 69.50 | 0.69% | Elmsch=751 | Entrch=3 | Exitch=3 |
 |  89.86 | 11 | 2.51 |  8.17 | 86.26 | 0.85% | Elmsch=863 | Entrch=3 | Exitch=1 |
 |  89.47 | 10 | 3.78 |  8.95 | 66.09 | 0.66% | Elmsch=841 | Entrch=1 | Exitch=1 |
 |  89.16 | 11 | 2.49 |  8.11 | 86.26 | 0.85% | Elmsch=862 | Entrch=3 | Exitch=1 |

 | 118.96 |  9 | 3.78 | 13.22 | 92.26 | 0.91% | Elmsch=47 | Entrch=3 | Exitch=3 |
 | 118.76 |  9 | 3.77 | 13.20 | 92.46 | 0.92% | Elmsch=47 | Entrch=3 | Exitch=4 |
 | 118.26 |  9 | 3.77 | 13.14 | 92.26 | 0.91% | Elmsch=46 | Entrch=3 | Exitch=3 |
 | 118.06 |  9 | 3.75 | 13.12 | 92.46 | 0.92% | Elmsch=46 | Entrch=3 | Exitch=4 |
 | 116.96 |  9 | 3.66 | 13.00 | 92.26 | 0.91% | Elmsch=45 | Entrch=3 | Exitch=3 |
 | 115.06 |  9 | 3.69 | 12.78 | 92.26 | 0.91% | Elmsch=48 | Entrch=3 | Exitch=3 |
 | 114.86 |  9 | 3.67 | 12.76 | 92.46 | 0.92% | Elmsch=48 | Entrch=3 | Exitch=4 |
 |  90.05 | 24 | 2.06 |  3.75 | 46.30 | 0.46% | Elmsch=28 | Entrch=1 | Exitch=3 |
 |  86.85 | 23 | 2.01 |  3.78 | 46.00 | 0.46% | Elmsch=28 | Entrch=1 | Exitch=4 |
 |  86.14 | 30 | 1.62 |  2.87 | 66.40 | 0.66% | Elmsch=20 | Entrch=2 | Exitch=1 |


 eurusd 0218-0225
 | 87.13 | 3 | 0.00 | 29.04 | 71.00 | 0.70% | Elmsch=963 | Entrch=1 | Exitch=1 |
 | 83.83 | 3 | 0.00 | 27.94 | 73.40 | 0.73% | Elmsch=961 | Entrch=1 | Exitch=4 |
 | 83.83 | 3 | 0.00 | 27.94 | 73.40 | 0.73% | Elmsch=961 | Entrch=1 | Exitch=1 |
 | 81.63 | 3 | 0.00 | 27.21 | 67.60 | 0.67% | Elmsch=971 | Entrch=1 | Exitch=4 |
 | 81.63 | 3 | 0.00 | 27.21 | 67.60 | 0.67% | Elmsch=971 | Entrch=1 | Exitch=3 |
 | 81.63 | 3 | 0.00 | 27.21 | 67.60 | 0.67% | Elmsch=971 | Entrch=1 | Exitch=1 |
 | 80.93 | 2 | 0.00 | 40.47 | 74.00 | 0.73% | Elmsch=984 | Entrch=1 | Exitch=1 |
 | 80.72 | 2 | 0.00 | 40.36 | 72.90 | 0.72% | Elmsch=985 | Entrch=1 | Exitch=1 |
 | 78.63 | 3 | 0.00 | 26.21 | 75.40 | 0.75% | Elmsch=985 | Entrch=3 | Exitch=1 |
 | 78.53 | 3 | 0.00 | 26.18 | 75.40 | 0.75% | Elmsch=961 | Entrch=3 | Exitch=3 |

 | 106.33 | 3 | 0.00 | 35.44 | 65.40 | 0.65% | Elmsch=964 | Entrch=1 | Exitch=1 |
 | 106.33 | 3 | 0.00 | 35.44 | 65.40 | 0.65% | Elmsch=964 | Entrch=1 | Exitch=4 |
 | 106.33 | 3 | 0.00 | 35.44 | 65.40 | 0.65% | Elmsch=964 | Entrch=1 | Exitch=3 |
 | 105.23 | 3 | 0.00 | 35.08 | 65.90 | 0.65% | Elmsch=65 | Entrch=1 | Exitch=3 |
 | 105.23 | 3 | 0.00 | 35.08 | 65.90 | 0.65% | Elmsch=65 | Entrch=1 | Exitch=1 |
 | 105.23 | 3 | 0.00 | 35.08 | 65.90 | 0.65% | Elmsch=65 | Entrch=1 | Exitch=4 |
 | 103.23 | 3 | 0.00 | 34.41 | 64.70 | 0.64% | Elmsch=63 | Entrch=1 | Exitch=3 |
 | 103.23 | 3 | 0.00 | 34.41 | 64.70 | 0.64% | Elmsch=63 | Entrch=1 | Exitch=4 |
 | 103.23 | 3 | 0.00 | 34.41 | 64.70 | 0.64% | Elmsch=63 | Entrch=1 | Exitch=1 |
 | 102.83 | 3 | 0.00 | 34.28 | 64.90 | 0.64% | Elmsch=65 | Entrch=2 | Exitch=1 |


 eurusd 0211-0218
 opened offline
 | 87.40 |  5 | 5.34 | 17.48 | 59.60 | 0.59% | Elmsch=973 | Entrch=2 | Exitch=2 |
 | 78.80 |  6 | 3.65 | 13.13 | 59.00 | 0.59% | Elmsch=974 | Entrch=2 | Exitch=2 |
 | 71.30 |  6 | 2.96 | 11.88 | 59.60 | 0.59% | Elmsch=975 | Entrch=2 | Exitch=2 |
 | 63.70 |  7 | 2.49 |  9.10 | 59.60 | 0.60% | Elmsch=976 | Entrch=2 | Exitch=2 |
 | 63.60 |  7 | 2.48 |  9.09 | 59.60 | 0.60% | Elmsch=972 | Entrch=2 | Exitch=2 |
 | 63.00 |  6 | 3.11 | 10.50 | 64.30 | 0.64% | Elmsch=985 | Entrch=1 | Exitch=2 |
 | 62.40 |  7 | 2.55 |  8.91 | 60.90 | 0.61% | Elmsch=976 | Entrch=1 | Exitch=2 |
 | 62.10 |  7 | 2.44 |  8.87 | 59.20 | 0.59% | Elmsch=973 | Entrch=1 | Exitch=2 |
 | 60.15 | 24 | 1.56 |  2.51 | 52.50 | 0.52% | Elmsch=851 | Entrch=3 | Exitch=2 |
 | 57.20 |  7 | 2.26 |  8.17 | 59.60 | 0.60% | Elmsch=974 | Entrch=1 | Exitch=2 |

 | 95.25 | 17 | 2.69 | 5.60 | 50.70 | 0.50% | Elmsch=843 | Entrch=2 | Exitch=2 |
 | 79.25 | 17 | 2.38 | 4.66 | 58.10 | 0.58% | Elmsch=841 | Entrch=2 | Exitch=2 |
 | 79.25 | 11 | 2.16 | 7.20 | 53.80 | 0.53% | Elmsch=876 | Entrch=3 | Exitch=4 |
 | 77.20 | 13 | 1.98 | 5.94 | 53.80 | 0.53% | Elmsch=876 | Entrch=3 | Exitch=3 |
 | 73.70 | 11 | 3.53 | 6.70 | 28.60 | 0.28% | Elmsch=876 | Entrch=1 | Exitch=2 |
 | 66.35 | 23 | 1.65 | 2.88 | 51.70 | 0.51% | Elmsch=852 | Entrch=3 | Exitch=2 |
 | 63.35 | 17 | 1.95 | 3.73 | 55.20 | 0.55% | Elmsch=841 | Entrch=1 | Exitch=2 |
 | 62.65 |  8 | 2.82 | 7.83 | 33.50 | 0.33% | Elmsch=876 | Entrch=1 | Exitch=1 |
 | 62.45 |  8 | 2.80 | 7.81 | 33.50 | 0.33% | Elmsch=876 | Entrch=1 | Exitch=3 |
 | 61.15 | 24 | 1.57 | 2.55 | 52.50 | 0.52% | Elmsch=843 | Entrch=3 | Exitch=2 |

 | 74.40 | 62 | 1.34 |  1.20 | 70.60 | 0.70% | Elmsch=632 | Entrch=1 | Exitch=1 |
 | 74.30 |  6 | 3.27 | 12.38 | 59.00 | 0.59% | Elmsch=971 | Entrch=2 | Exitch=2 |
 | 66.35 | 23 | 1.65 |  2.88 | 51.70 | 0.51% | Elmsch=852 | Entrch=3 | Exitch=2 |
 | 63.00 |  6 | 3.11 | 10.50 | 64.30 | 0.64% | Elmsch=985 | Entrch=1 | Exitch=2 |
 | 60.15 | 24 | 1.56 |  2.51 | 52.50 | 0.52% | Elmsch=851 | Entrch=3 | Exitch=2 |
 | 59.75 | 23 | 1.58 |  2.60 | 51.70 | 0.51% | Elmsch=862 | Entrch=3 | Exitch=2 |
 | 56.20 | 83 | 1.24 |  0.68 | 82.90 | 0.82% | Elmsch=631 | Entrch=1 | Exitch=1 |
 | 53.40 | 15 | 1.50 |  3.56 | 70.20 | 0.70% | Elmsch=843 | Entrch=3 | Exitch=1 |
 | 53.40 | 15 | 1.50 |  3.56 | 70.20 | 0.70% | Elmsch=851 | Entrch=3 | Exitch=3 |
 | 53.40 | 15 | 1.50 |  3.56 | 70.20 | 0.70% | Elmsch=851 | Entrch=3 | Exitch=4 |

 | 124.45 | 16 | 3.28 | 7.78 | 45.20 | 0.45% | Elmsch=36 | Entrch=1 | Exitch=2 |
 | 108.35 | 18 | 2.74 | 6.02 | 44.70 | 0.44% | Elmsch=35 | Entrch=1 | Exitch=2 |
 | 101.25 | 19 | 2.51 | 5.33 | 44.60 | 0.44% | Elmsch=36 | Entrch=2 | Exitch=2 |
 |  95.25 | 17 | 2.69 | 5.60 | 50.70 | 0.50% | Elmsch=40 | Entrch=2 | Exitch=2 |
 |  83.85 | 11 | 2.32 | 7.62 | 53.80 | 0.53% | Elmsch=53 | Entrch=3 | Exitch=4 |
 |  83.25 | 11 | 2.32 | 7.57 | 53.80 | 0.53% | Elmsch=50 | Entrch=3 | Exitch=4 |
 |  82.30 | 12 | 2.31 | 6.86 | 52.40 | 0.52% | Elmsch=36 | Entrch=1 | Exitch=1 |
 |  81.80 | 13 | 2.10 | 6.29 | 53.80 | 0.53% | Elmsch=53 | Entrch=3 | Exitch=3 |
 |  81.40 | 12 | 2.29 | 6.78 | 53.50 | 0.53% | Elmsch=36 | Entrch=1 | Exitch=3 |
 |  81.40 | 12 | 2.29 | 6.78 | 53.50 | 0.53% | Elmsch=36 | Entrch=1 | Exitch=4 |

 | 108.35 | 18 |  2.74 |  6.02 | 44.70 | 0.44% | Elmsch=35 | Entrch=1 | Exitch=2 |
 |  91.40 |  4 | 64.03 | 22.85 | 36.00 | 0.36% | Elmsch=78 | Entrch=2 | Exitch=2 |
 |  88.20 | 12 |  2.64 |  7.35 | 60.20 | 0.60% | Elmsch=35 | Entrch=1 | Exitch=1 |
 |  87.40 |  5 |  5.34 | 17.48 | 59.60 | 0.59% | Elmsch=73 | Entrch=2 | Exitch=2 |
 |  84.15 | 11 |  2.33 |  7.65 | 53.80 | 0.53% | Elmsch=54 | Entrch=3 | Exitch=4 |
 |  83.85 | 11 |  2.32 |  7.62 | 53.80 | 0.53% | Elmsch=53 | Entrch=3 | Exitch=4 |
 |  82.10 | 13 |  2.11 |  6.32 | 53.80 | 0.53% | Elmsch=54 | Entrch=3 | Exitch=3 |
 |  81.80 | 13 |  2.10 |  6.29 | 53.80 | 0.53% | Elmsch=53 | Entrch=3 | Exitch=3 |
 |  78.80 |  6 |  3.65 | 13.13 | 59.00 | 0.59% | Elmsch=74 | Entrch=2 | Exitch=2 |
 |  75.40 | 13 |  3.99 |  5.80 | 31.50 | 0.31% | Elmsch=51 | Entrch=2 | Exitch=2 |

 | 101.25 | 19 |  2.51 |  5.33 | 44.60 | 0.44% | Elmsch=36 | Entrch=2 | Exitch=2 |
 |  91.40 |  4 | 64.03 | 22.85 | 36.00 | 0.36% | Elmsch=78 | Entrch=2 | Exitch=2 |
 |  84.15 | 11 |  2.33 |  7.65 | 53.80 | 0.53% | Elmsch=52 | Entrch=3 | Exitch=4 |
 |  83.85 | 11 |  2.32 |  7.62 | 53.80 | 0.53% | Elmsch=53 | Entrch=3 | Exitch=4 |
 |  82.30 | 12 |  2.31 |  6.86 | 52.40 | 0.52% | Elmsch=36 | Entrch=1 | Exitch=1 |
 |  82.10 | 13 |  2.11 |  6.32 | 53.80 | 0.53% | Elmsch=52 | Entrch=3 | Exitch=3 |
 |  81.80 | 13 |  2.10 |  6.29 | 53.80 | 0.53% | Elmsch=53 | Entrch=3 | Exitch=3 |
 |  81.40 | 12 |  2.29 |  6.78 | 53.50 | 0.53% | Elmsch=36 | Entrch=1 | Exitch=4 |
 |  79.75 | 17 |  2.39 |  4.69 | 58.10 | 0.58% | Elmsch=39 | Entrch=2 | Exitch=2 |
 |  76.40 | 13 |  4.03 |  5.88 | 31.50 | 0.31% | Elmsch=50 | Entrch=2 | Exitch=2 |

 back to orig 0329 afternoon
 | 118.25 | 15 | 3.31 |  7.88 | 43.10 | 0.43% | Elmsch=37 | Entrch=1 | Exitch=2 |
 | 115.95 | 19 | 2.91 |  6.10 | 44.70 | 0.44% | Elmsch=35 | Entrch=2 | Exitch=2 |
 | 113.25 | 19 | 2.64 |  5.96 | 42.40 | 0.42% | Elmsch=37 | Entrch=2 | Exitch=2 |
 | 108.35 | 18 | 2.74 |  6.02 | 44.70 | 0.44% | Elmsch=35 | Entrch=1 | Exitch=2 |
 |  89.30 | 11 | 2.98 |  8.12 | 54.10 | 0.54% | Elmsch=37 | Entrch=1 | Exitch=1 |
 |  88.20 | 12 | 2.64 |  7.35 | 60.20 | 0.60% | Elmsch=35 | Entrch=1 | Exitch=1 |
 |  84.70 | 13 | 2.32 |  6.52 | 50.40 | 0.50% | Elmsch=35 | Entrch=2 | Exitch=1 |
 |  79.25 | 11 | 2.16 |  7.20 | 53.80 | 0.53% | Elmsch=55 | Entrch=3 | Exitch=4 |
 |  78.80 |  6 | 3.65 | 13.13 | 59.00 | 0.59% | Elmsch=74 | Entrch=2 | Exitch=2 |
 |  77.20 | 13 | 1.98 |  5.94 | 53.80 | 0.53% | Elmsch=55 | Entrch=3 | Exitch=3 |

 | 115.95 | 19 |  2.91 |  6.10 | 44.70 | 0.44% | Elmsch=35 | Entrch=2 | Exitch=2 |
 | 108.35 | 18 |  2.74 |  6.02 | 44.70 | 0.44% | Elmsch=35 | Entrch=1 | Exitch=2 |
 | 101.25 | 19 |  2.51 |  5.33 | 44.60 | 0.44% | Elmsch=36 | Entrch=2 | Exitch=2 |
 |  91.40 |  4 | 64.03 | 22.85 | 36.00 | 0.36% | Elmsch=78 | Entrch=2 | Exitch=2 |
 |  88.20 | 12 |  2.64 |  7.35 | 60.20 | 0.60% | Elmsch=35 | Entrch=1 | Exitch=1 |
 |  84.15 | 11 |  2.33 |  7.65 | 53.80 | 0.53% | Elmsch=52 | Entrch=3 | Exitch=4 |
 |  82.10 | 13 |  2.11 |  6.32 | 53.80 | 0.53% | Elmsch=52 | Entrch=3 | Exitch=3 |
 |  79.25 | 11 |  2.16 |  7.20 | 53.80 | 0.53% | Elmsch=55 | Entrch=3 | Exitch=4 |
 |  77.20 | 13 |  1.98 |  5.94 | 53.80 | 0.53% | Elmsch=55 | Entrch=3 | Exitch=3 |
 |  76.20 | 13 |  1.97 |  5.86 | 53.80 | 0.53% | Elmsch=51 | Entrch=3 | Exitch=3 |

 | 108.35 | 18 |  2.74 |  6.02 | 44.70 | 0.44% | Elmsch=35 | Entrch=1 | Exitch=2 |
 |  91.40 |  4 | 64.03 | 22.85 | 36.00 | 0.36% | Elmsch=78 | Entrch=2 | Exitch=2 |
 |  87.40 |  5 |  5.34 | 17.48 | 59.60 | 0.59% | Elmsch=73 | Entrch=2 | Exitch=2 |
 |  83.25 | 11 |  2.32 |  7.57 | 53.80 | 0.53% | Elmsch=50 | Entrch=3 | Exitch=4 |
 |  79.75 | 17 |  2.39 |  4.69 | 58.10 | 0.58% | Elmsch=39 | Entrch=2 | Exitch=2 |
 |  76.90 | 13 |  2.05 |  5.92 | 53.80 | 0.53% | Elmsch=50 | Entrch=3 | Exitch=3 |
 |  74.40 | 62 |  1.34 |  1.20 | 70.60 | 0.70% | Elmsch=12 | Entrch=1 | Exitch=1 |
 |  73.70 | 11 |  3.53 |  6.70 | 28.60 | 0.28% | Elmsch=55 | Entrch=1 | Exitch=2 |
 |  73.00 | 12 |  2.15 |  6.08 | 61.30 | 0.61% | Elmsch=35 | Entrch=1 | Exitch=3 |
 |  69.50 |  5 |  4.27 | 13.90 | 66.40 | 0.66% | Elmsch=80 | Entrch=1 | Exitch=2 |


 done 0329 in close temporal proximity
 | 95.25 | 17 | 2.69 |  5.60 | 50.70 | 0.50% | Elmsch=843 | Entrch=2 | Exitch=2 |
 | 79.25 | 17 | 2.38 |  4.66 | 58.10 | 0.58% | Elmsch=841 | Entrch=2 | Exitch=2 |
 | 74.30 |  6 | 3.27 | 12.38 | 59.00 | 0.59% | Elmsch=971 | Entrch=2 | Exitch=2 |
 | 71.30 |  6 | 2.96 | 11.88 | 59.60 | 0.59% | Elmsch=975 | Entrch=2 | Exitch=2 |
 | 64.80 |  7 | 2.49 |  9.26 | 59.60 | 0.60% | Elmsch=971 | Entrch=1 | Exitch=2 |
 | 63.35 | 17 | 1.95 |  3.73 | 55.20 | 0.55% | Elmsch=841 | Entrch=1 | Exitch=2 |
 | 63.00 |  6 | 3.11 | 10.50 | 64.30 | 0.64% | Elmsch=985 | Entrch=1 | Exitch=2 |
 | 62.40 |  7 | 2.55 |  8.91 | 60.90 | 0.61% | Elmsch=976 | Entrch=1 | Exitch=2 |
 | 62.10 |  7 | 2.44 |  8.87 | 59.20 | 0.59% | Elmsch=973 | Entrch=1 | Exitch=2 |
 | 61.15 | 24 | 1.57 |  2.55 | 52.50 | 0.52% | Elmsch=843 | Entrch=3 | Exitch=2 |

 | 115.95 | 19 | 2.91 |  6.10 | 44.70 | 0.44% | Elmsch=821 | Entrch=2 | Exitch=2 |
 | 108.35 | 18 | 2.74 |  6.02 | 44.70 | 0.44% | Elmsch=821 | Entrch=1 | Exitch=2 |
 |  95.25 | 17 | 2.69 |  5.60 | 50.70 | 0.50% | Elmsch=843 | Entrch=2 | Exitch=2 |
 |  88.20 | 12 | 2.64 |  7.35 | 60.20 | 0.60% | Elmsch=821 | Entrch=1 | Exitch=1 |
 |  87.40 |  5 | 5.34 | 17.48 | 59.60 | 0.59% | Elmsch=973 | Entrch=2 | Exitch=2 |
 |  84.70 | 13 | 2.32 |  6.52 | 50.40 | 0.50% | Elmsch=821 | Entrch=2 | Exitch=1 |
 |  79.75 | 17 | 2.39 |  4.69 | 58.10 | 0.58% | Elmsch=842 | Entrch=2 | Exitch=2 |
 |  79.25 | 17 | 2.38 |  4.66 | 58.10 | 0.58% | Elmsch=841 | Entrch=2 | Exitch=2 |
 |  74.90 | 13 | 2.10 |  5.76 | 51.50 | 0.51% | Elmsch=821 | Entrch=2 | Exitch=3 |
 |  74.90 | 13 | 2.10 |  5.76 | 51.50 | 0.51% | Elmsch=821 | Entrch=2 | Exitch=4 |

 | 95.25 | 17 | 2.69 |  5.60 | 50.70 | 0.50% | Elmsch=843 | Entrch=2 | Exitch=2 |
 | 79.25 | 17 | 2.38 |  4.66 | 58.10 | 0.58% | Elmsch=841 | Entrch=2 | Exitch=2 |
 | 74.40 | 62 | 1.34 |  1.20 | 70.60 | 0.70% | Elmsch=632 | Entrch=1 | Exitch=1 |
 | 74.30 |  6 | 3.27 | 12.38 | 59.00 | 0.59% | Elmsch=971 | Entrch=2 | Exitch=2 |
 | 71.30 |  6 | 2.96 | 11.88 | 59.60 | 0.59% | Elmsch=975 | Entrch=2 | Exitch=2 |
 | 68.10 |  7 | 2.65 |  9.73 | 59.60 | 0.59% | Elmsch=963 | Entrch=1 | Exitch=2 |
 | 66.65 | 23 | 1.65 |  2.90 | 51.70 | 0.51% | Elmsch=842 | Entrch=3 | Exitch=2 |
 | 66.35 | 23 | 1.65 |  2.88 | 51.70 | 0.51% | Elmsch=852 | Entrch=3 | Exitch=2 |
 | 64.80 |  7 | 2.49 |  9.26 | 59.60 | 0.60% | Elmsch=971 | Entrch=1 | Exitch=2 |
 | 63.60 |  7 | 2.48 |  9.09 | 59.60 | 0.60% | Elmsch=972 | Entrch=2 | Exitch=2 |

 done 0328
 | 104.81 | 20 | 2.61 | 5.24 | 45.80 | 0.45% | Elmsch=851 | Entrch=3 | Exitch=2 |
 | 104.61 | 20 | 2.60 | 5.23 | 45.80 | 0.45% | Elmsch=841 | Entrch=3 | Exitch=2 |
 | 101.01 | 21 | 2.48 | 4.81 | 45.80 | 0.45% | Elmsch=843 | Entrch=3 | Exitch=2 |
 | 100.91 | 21 | 2.48 | 4.81 | 45.80 | 0.45% | Elmsch=842 | Entrch=3 | Exitch=2 |
 |  98.91 | 17 | 2.97 | 5.82 | 49.00 | 0.49% | Elmsch=843 | Entrch=2 | Exitch=2 |
 |  97.51 | 16 | 3.14 | 6.09 | 52.00 | 0.52% | Elmsch=841 | Entrch=1 | Exitch=2 |
 |  97.51 | 21 | 2.43 | 4.64 | 45.80 | 0.45% | Elmsch=864 | Entrch=3 | Exitch=2 |
 |  86.71 | 17 | 2.63 | 5.10 | 50.00 | 0.50% | Elmsch=841 | Entrch=2 | Exitch=2 |
 |  78.42 | 13 | 1.82 | 6.03 | 82.60 | 0.82% | Elmsch=864 | Entrch=3 | Exitch=1 |
 |  77.02 | 13 | 1.80 | 5.92 | 82.60 | 0.82% | Elmsch=843 | Entrch=3 | Exitch=3 |

 | 129.63 |  9 |  3.44 | 14.40 | 48.50 | 0.48% | Elmsch=52 | Entrch=3 | Exitch=4 |
 | 104.61 | 20 |  2.60 |  5.23 | 45.80 | 0.45% | Elmsch=38 | Entrch=3 | Exitch=2 |
 | 102.72 | 11 |  2.51 |  9.34 | 55.70 | 0.55% | Elmsch=52 | Entrch=3 | Exitch=3 |
 | 101.01 | 21 |  2.48 |  4.81 | 45.80 | 0.45% | Elmsch=42 | Entrch=3 | Exitch=2 |
 | 101.01 | 21 |  2.48 |  4.81 | 45.80 | 0.45% | Elmsch=52 | Entrch=3 | Exitch=2 |
 | 100.91 | 21 |  2.48 |  4.81 | 45.80 | 0.45% | Elmsch=39 | Entrch=3 | Exitch=2 |
 |  99.92 |  4 | 35.57 | 24.98 | 35.90 | 0.36% | Elmsch=80 | Entrch=1 | Exitch=2 |
 |  97.81 | 21 |  2.44 |  4.66 | 45.80 | 0.45% | Elmsch=49 | Entrch=3 | Exitch=2 |
 |  97.51 | 16 |  3.14 |  6.09 | 52.00 | 0.52% | Elmsch=38 | Entrch=1 | Exitch=2 |
 |  97.51 | 21 |  2.43 |  4.64 | 45.80 | 0.45% | Elmsch=48 | Entrch=3 | Exitch=2 |


 eurusd 0204-0211
 | 153.01 | 40 | 2.84 | 3.83 |  49.60 | 0.49% | Elmsch=26 | Entrch=2 | Exitch=2 |
 | 129.71 | 30 | 2.81 | 4.32 |  79.10 | 0.78% | Elmsch=26 | Entrch=2 | Exitch=1 |
 | 109.32 | 29 | 1.99 | 3.77 |  97.49 | 0.96% | Elmsch=25 | Entrch=2 | Exitch=4 |
 | 107.52 | 29 | 1.97 | 3.71 |  97.49 | 0.96% | Elmsch=25 | Entrch=2 | Exitch=3 |
 | 105.23 | 42 | 1.89 | 2.51 |  72.09 | 0.71% | Elmsch=25 | Entrch=1 | Exitch=2 |
 | 102.93 | 33 | 1.73 | 3.12 | 104.79 | 1.03% | Elmsch=20 | Entrch=1 | Exitch=4 |
 | 102.93 | 33 | 1.73 | 3.12 | 104.79 | 1.03% | Elmsch=20 | Entrch=1 | Exitch=3 |
 |  99.43 | 46 | 1.66 | 2.16 |  73.09 | 0.72% | Elmsch=20 | Entrch=1 | Exitch=2 |
 |  96.72 | 30 | 1.85 | 3.22 |  92.49 | 0.91% | Elmsch=25 | Entrch=2 | Exitch=1 |
 |  96.21 | 29 | 2.14 | 3.32 |  76.30 | 0.75% | Elmsch=26 | Entrch=2 | Exitch=4 |



 //lincs.mq4//

 //
 //DESCRIP
 //
 /*
 use slines combos to determine market conditions for ntrxit
 */


 //
 //TODO
 //
 /*
 build protection for bar0 fluctuations DONE

 create ntr and xit for various sline combos including 4 line nu on slope
 incorporate nu
 create ranging pattern recognition

 ideas
 - parama (slopes for multiple lines are parallel)
 - nununu (consistency of nunu or unun can be utilized because h[] 2+,2- = n and l[] 2-,2+ = u!)
 - bodsor (short lines opposite to longer lines)
 */


 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>



 //
 //CONSTANTS
 //
 #define sp "  "
 #define spp "    "

 #define LOTSIZE 0.1                             /* lotsize */
 #define SLTP 12000                              /* fixed stoploss takeprof limits */
 #define Z 0.5                                   /* effective zero slope */



 //
 //EXTERNS
 //
 extern int Elmsch;
 extern int Entrch;
 extern int Exitch;



 //
 //GLOBALS
 //
 int Gtf[6];                                      /* timeframe array */
 int tkt=-1;                                     /* ticket number */
 int L,M,S;                                      /* long,mid,short indices for slines */
 double incs[2,10];                              /* incline values array */
 double osl;                                     /* order stoploss */




 //
 //STRATEGY FUNCTIONS
 //
 void get_lincs()
 //fill hilo slines for L(512,256,128)  I(64,32,16)  S(8,4,2)
 {
   int i,bar,
     tf=PERIOD_M1;
   for(i=1;i<=9;i++)                              
     {
       bar=(int)pow(2,i);
       incs[0,i]=incline_value(bar,iHigh(NULL,tf,bar),1,iHigh(NULL,tf,1));
       incs[1,i]=incline_value(bar,iLow(NULL,tf,bar),1,iLow(NULL,tf,1));
     }
 }


 bool xit_do()
 //xit patterns and conditions
 {
   int
     bs=OrderType();

   //safety xit for bar0
   double
     max_dd=600,                                 /* maximum allowable drawdown */
     dpt=diff_pts(OrderOpenPrice(),Bid);         /* +ve for buy, -ve for sel */
   if((bs==0 && dpt<-max_dd) ||                  /* buy loss dpt<0 */
      (bs==1 && dpt>+max_dd))                    /* sel loss dpt>0 */
     return true;

   //xit pattern choices
   bool                                          /* only xit parameters required */
     B_xit=false,
     S_xit=false;
   switch(Exitch)
     {
     case 1:                                     /* LbrkZ */
       B_xit=(incs[0,L]<-Z);
       S_xit=(incs[1,L]>+Z);
       break;
     case 2:                                     /* Lbrk0 */
       B_xit=(incs[0,L]<0);
       S_xit=(incs[1,L]>0);
       break;
     case 3:
       B_xit=(incs[0,L]<-Z &&
              incs[0,M]<-Z);
       S_xit=(incs[1,L]>+Z &&
              incs[1,M]>+Z);
       break;
     case 4:
       B_xit=(incs[0,L]<-Z &&
              incs[0,M]<incs[0,L]);
       S_xit=(incs[1,L]>+Z &&
              incs[1,M]>+incs[1,L]);
       break;
     default:
       break;
     }
   if((bs==0 && B_xit) ||                        /* buy with B_xit */
      (bs==1 && S_xit))                          /* sel with S_xit */
     return true;
   return false;
 }


 int ntr_do()
 //ntrs patterns and conditions
 {
   bool                                          /* only ntr parameters required */
     B_ntr=false,
     S_ntr=false;
   switch(Entrch)
     {
     case 1:                                     /* bodsorA: \L /M \S */
       B_ntr=(incs[1,L]>+Z && incs[1,M]<0 && incs[1,S]>0);
       S_ntr=(incs[0,L]<-Z && incs[0,M]>0 && incs[0,S]<0);
       break;
     case 2:                                     /* bodsorB: \L /M /S */
       B_ntr=(incs[1,L]>+Z && incs[1,M]<0 && incs[1,S]<0);
       S_ntr=(incs[0,L]<-Z && incs[0,M]>0 && incs[0,S]>0);
       break;
     case 3:                                     /* parama: \L \M \S */
       B_ntr=(incs[1,L]>+Z && incs[1,M]>0 && incs[1,S]>0);
       S_ntr=(incs[0,L]<-Z && incs[0,M]<0 && incs[0,S]<0);
     default:
       break;
     }
   if(B_ntr) return 0;
   if(S_ntr) return 1;
   return -1;
 }




 //
 // UTILITY FUNCTIONS
 //
 void xit()
 //trailing xit
 {
   if(OrderSelect(tkt,SELECT_BY_TICKET))
     {
       if(xit_do())
         if(OrderClose(tkt,LOTSIZE,OrderClosePrice(),0))
           reset();
         else
           show_last_error();
     }
 }


 void ntr()
 //makes a trade
 {
   double oo=0,sl=0,tp=0;
   int
     bs=ntr_do();
  
   switch(bs)
     {
     case 0:
       oo=Ask;
       //osl=oo-INITIAL_SL*Point;
       sl=oo-SLTP*Point;
       tp=oo+SLTP*Point;
       break;
     case 1:
       oo=Bid;
       //osl=oo+INITIAL_SL*Point;
       sl=oo+SLTP*Point;
       tp=oo-SLTP*Point;
       break;
     }
   tkt=OrderSend(Symbol(),bs,LOTSIZE,oo,0,sl,tp);
 }


 bool is_new_bar()
 //checks to see if we have a new bar
 {
   static datetime lastbartime;
   datetime
     curbartime=Time[0];
   if(lastbartime!=curbartime)
     {
       lastbartime=curbartime;
       return (true);
     }
   else
     return(false);
 }


 double maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);

   if(minbar>maxbar)
     return diff_pts(minval,maxval);
   else
     return diff_pts(maxval,minval);
 }


 double diff_pts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }


 double incline_value(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf giving points per bar
 {
   int
     Dbar=bI-bF;
   return diff_pts(vI,vF)/Dbar;
 }


 bool is_btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }


 bool true_turning_point(int b,string hilo)
 //hilo is true turning point
 {
   if(hilo=="hi")
     if(High[b]>=High[b-1] && High[b]>=High[b+1])
       return true;
   if(hilo=="lo")
     if(Low[b]<=Low[b-1] && Low[b]<=Low[b+1])
       return true;
   return false;
 }


 void reset()
 //sets various items to initial values
 {
   tkt=-1;
 }



 //
 // DISPLAY FUNCTIONS
 //
 void tline(string objlabel,datetime t1,double p1,datetime t2,double p2,color clr)
 //draws trend line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_TREND,0,t1,p1,t2,p2,clr);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
   ObjectSet(objlabel,OBJPROP_RAY_RIGHT,false);
 }


 void hline(string objlabel,double price,color clr)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
 }


 void vline(string objlabel,string timestr,color clr)
 //draws vertical line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_VLINE,0,StrToTime(timestr),0);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);  
 }


 void display_txt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 void draw_sline(int bar,double inc,datetime tI,double pI,datetime tF,double pF)
 //draws sline with color
 {
   color
     clr=Incl_color(inc);
   tline("tline"+IntegerToString(bar),tI,pI,tF,pF,clr);
 }


 color Incl_color(double inc)
 //determines color from incline value
 {
   double
     zeroincl=0.6;
   color
     clr=Green;
  
   if(is_btn(-zeroincl,inc,+zeroincl))
     clr=Green;
   else
     {
       if(inc>+zeroincl)
         clr=Blue;
       if(inc<-zeroincl)
         clr=Red;
     }
   return clr;
 }



 //
 // SPECIAL FUNCTIONS
 //
 bool can_do_trade()
 //checks if trading is ok via total orders, spread
 {
   int aords,pords;
   bool
     ntradeOK=(orders_for_symbol(aords,pords)==0),
     equityOK=(AccountEquity()>6000),
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12);
   return (ntradeOK && equityOK && spreadOK);
 }


 int orders_for_symbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
 {
   aords=0;pords=0;
   for(int p=OrdersTotal()-1;p>=0;p--)
     if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
       {
         if(OrderType()>1 && OrderType()<6)
           pords++;
         if(OrderType()==OP_BUY || OrderType()==OP_SELL)
           aords++;
       }
   return aords+pords;
 }


 void show_last_error()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }


 int OnInit()
 {
   Gtf[0]=1;Gtf[1]=5;Gtf[2]=15;Gtf[3]=30;Gtf[4]=60;Gtf[5]=240;
   return(INIT_SUCCEEDED);
 }


 void OnTick()
 //main center
 {
   set_LMS(Elmsch);

   if(is_new_bar())                              /* get indicator info on every new bar */
     get_lincs();

   if(can_do_trade())                            /* no active trade */
     ntr();
   else                                          /* on active trade look for xit */
     xit();
 }



 void set_LMS(int ch)
 //gets the LMS indices as defined by choice
 {
   /*
   switch(ch)
     {
     case 0: L=3;M=2;S=1; break;
     case 1: L=4;M=2;S=1; break;
     case 2: L=4;M=3;S=1; break;
     case 3: L=4;M=3;S=2; break;
     case 4: L=5;M=2;S=1; break;
     case 5: L=5;M=3;S=1; break;
     case 6: L=5;M=3;S=2; break;
     case 7: L=5;M=4;S=1; break;
     case 8: L=5;M=4;S=2; break;
     case 9: L=5;M=4;S=3; break;
     case 10: L=6;M=2;S=1; break;
     case 11: L=6;M=3;S=1; break;
     case 12: L=6;M=3;S=2; break;
     case 13: L=6;M=4;S=1; break;
     case 14: L=6;M=4;S=2; break;
     case 15: L=6;M=4;S=3; break;
     case 16: L=6;M=5;S=1; break;
     case 17: L=6;M=5;S=2; break;
     case 18: L=6;M=5;S=3; break;
     case 19: L=6;M=5;S=4; break;
     case 20: L=7;M=2;S=1; break;
     case 21: L=7;M=3;S=1; break;
     case 22: L=7;M=3;S=2; break;
     case 23: L=7;M=4;S=1; break;
     case 24: L=7;M=4;S=2; break;
     case 25: L=7;M=4;S=3; break;
     case 26: L=7;M=5;S=1; break;
     case 27: L=7;M=5;S=2; break;
     case 28: L=7;M=5;S=3; break;
     case 29: L=7;M=5;S=4; break;
     case 30: L=7;M=6;S=1; break;
     case 31: L=7;M=6;S=2; break;
     case 32: L=7;M=6;S=3; break;
     case 33: L=7;M=6;S=4; break;
     case 34: L=7;M=6;S=5; break;
     case 35: L=8;M=2;S=1; break;
     case 36: L=8;M=3;S=1; break;
     case 37: L=8;M=3;S=2; break;
     case 38: L=8;M=4;S=1; break;
     case 39: L=8;M=4;S=2; break;
     case 40: L=8;M=4;S=3; break;
     case 41: L=8;M=5;S=1; break;
     case 42: L=8;M=5;S=2; break;
     case 43: L=8;M=5;S=3; break;
     case 44: L=8;M=5;S=4; break;
     case 45: L=8;M=6;S=1; break;
     case 46: L=8;M=6;S=2; break;
     case 47: L=8;M=6;S=3; break;
     case 48: L=8;M=6;S=4; break;
     case 49: L=8;M=6;S=5; break;
     case 50: L=8;M=7;S=1; break;
     case 51: L=8;M=7;S=2; break;
     case 52: L=8;M=7;S=3; break;
     case 53: L=8;M=7;S=4; break;
     case 54: L=8;M=7;S=5; break;
     case 55: L=8;M=7;S=6; break;
     case 56: L=9;M=2;S=1; break;
     case 57: L=9;M=3;S=1; break;
     case 58: L=9;M=3;S=2; break;
     case 59: L=9;M=4;S=1; break;
     case 60: L=9;M=4;S=2; break;
     case 61: L=9;M=4;S=3; break;
     case 62: L=9;M=5;S=1; break;
     case 63: L=9;M=5;S=2; break;
     case 64: L=9;M=5;S=3; break;
     case 65: L=9;M=5;S=4; break;
     case 66: L=9;M=6;S=1; break;
     case 67: L=9;M=6;S=2; break;
     case 68: L=9;M=6;S=3; break;
     case 69: L=9;M=6;S=4; break;
     case 70: L=9;M=6;S=5; break;
     case 71: L=9;M=7;S=1; break;
     case 72: L=9;M=7;S=2; break;
     case 73: L=9;M=7;S=3; break;
     case 74: L=9;M=7;S=4; break;
     case 75: L=9;M=7;S=5; break;
     case 76: L=9;M=7;S=6; break;
     case 77: L=9;M=8;S=1; break;
     case 78: L=9;M=8;S=2; break;
     case 79: L=9;M=8;S=3; break;
     case 80: L=9;M=8;S=4; break;
     case 81: L=9;M=8;S=5; break;
     case 82: L=9;M=8;S=6; break;
     case 83: L=9;M=8;S=7; break;
     default:break;
     }
   */

   /*
   switch(ch)
     {
     case 321: L=3;M=2;S=1; break;
     case 421: L=4;M=2;S=1; break;
     case 431: L=4;M=3;S=1; break;
     case 432: L=4;M=3;S=2; break;
     case 521: L=5;M=2;S=1; break;
     case 531: L=5;M=3;S=1; break;
     case 532: L=5;M=3;S=2; break;
     case 541: L=5;M=4;S=1; break;
     case 542: L=5;M=4;S=2; break;
     case 543: L=5;M=4;S=3; break;
     case 621: L=6;M=2;S=1; break;
     case 631: L=6;M=3;S=1; break;
     case 632: L=6;M=3;S=2; break;
     case 641: L=6;M=4;S=1; break;
     case 642: L=6;M=4;S=2; break;
     case 643: L=6;M=4;S=3; break;
     case 651: L=6;M=5;S=1; break;
     case 652: L=6;M=5;S=2; break;
     case 653: L=6;M=5;S=3; break;
     case 654: L=6;M=5;S=4; break;
     case 721: L=7;M=2;S=1; break;
     case 731: L=7;M=3;S=1; break;
     case 732: L=7;M=3;S=2; break;
     case 741: L=7;M=4;S=1; break;
     case 742: L=7;M=4;S=2; break;
     case 743: L=7;M=4;S=3; break;
     case 751: L=7;M=5;S=1; break;
     case 752: L=7;M=5;S=2; break;
     case 753: L=7;M=5;S=3; break;
     case 754: L=7;M=5;S=4; break;
     case 761: L=7;M=6;S=1; break;
     case 762: L=7;M=6;S=2; break;
     case 763: L=7;M=6;S=3; break;
     case 764: L=7;M=6;S=4; break;
     case 765: L=7;M=6;S=5; break;
     case 821: L=8;M=2;S=1; break;
     case 831: L=8;M=3;S=1; break;
     case 832: L=8;M=3;S=2; break;
     case 841: L=8;M=4;S=1; break;
     case 842: L=8;M=4;S=2; break;
     case 843: L=8;M=4;S=3; break;
     case 851: L=8;M=5;S=1; break;
     case 852: L=8;M=5;S=2; break;
     case 853: L=8;M=5;S=3; break;
     case 854: L=8;M=5;S=4; break;
     case 861: L=8;M=6;S=1; break;
     case 862: L=8;M=6;S=2; break;
     case 863: L=8;M=6;S=3; break;
     case 864: L=8;M=6;S=4; break;
     case 865: L=8;M=6;S=5; break;
     case 871: L=8;M=7;S=1; break;
     case 872: L=8;M=7;S=2; break;
     case 873: L=8;M=7;S=3; break;
     case 874: L=8;M=7;S=4; break;
     case 875: L=8;M=7;S=5; break;
     case 876: L=8;M=7;S=6; break;
     case 921: L=9;M=2;S=1; break;
     case 931: L=9;M=3;S=1; break;
     case 932: L=9;M=3;S=2; break;
     case 941: L=9;M=4;S=1; break;
     case 942: L=9;M=4;S=2; break;
     case 943: L=9;M=4;S=3; break;
     case 951: L=9;M=5;S=1; break;
     case 952: L=9;M=5;S=2; break;
     case 953: L=9;M=5;S=3; break;
     case 954: L=9;M=5;S=4; break;
     case 961: L=9;M=6;S=1; break;
     case 962: L=9;M=6;S=2; break;
     case 963: L=9;M=6;S=3; break;
     case 964: L=9;M=6;S=4; break;
     case 965: L=9;M=6;S=5; break;
     case 971: L=9;M=7;S=1; break;
     case 972: L=9;M=7;S=2; break;
     case 973: L=9;M=7;S=3; break;
     case 974: L=9;M=7;S=4; break;
     case 975: L=9;M=7;S=5; break;
     case 976: L=9;M=7;S=6; break;
     case 981: L=9;M=8;S=1; break;
     case 982: L=9;M=8;S=2; break;
     case 983: L=9;M=8;S=3; break;
     case 984: L=9;M=8;S=4; break;
     case 985: L=9;M=8;S=5; break;
     case 986: L=9;M=8;S=6; break;
     case 987: L=9;M=8;S=7; break;
     }
   */
 }

 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

**** code v5 tries to identify specific combos

 eurusd 0325-0328
 | 59.90 | 2 | 0.00 | 29.95 | 35.30 | 0.35% | Elmsch=43 | Entrch=2 | Exitch=1 |
 | 59.90 | 2 | 0.00 | 29.95 | 35.30 | 0.35% | Elmsch=43 | Entrch=2 | Exitch=3 |
 | 59.90 | 2 | 0.00 | 29.95 | 35.30 | 0.35% | Elmsch=44 | Entrch=2 | Exitch=3 |
 | 59.90 | 2 | 0.00 | 29.95 | 35.30 | 0.35% | Elmsch=43 | Entrch=2 | Exitch=4 |
 | 59.90 | 2 | 0.00 | 29.95 | 35.30 | 0.35% | Elmsch=44 | Entrch=2 | Exitch=4 |
 | 59.90 | 2 | 0.00 | 29.95 | 35.30 | 0.35% | Elmsch=44 | Entrch=2 | Exitch=1 |
 | 56.60 | 2 | 0.00 | 28.30 | 35.40 | 0.35% | Elmsch=35 | Entrch=2 | Exitch=4 |
 | 56.60 | 2 | 0.00 | 28.30 | 35.40 | 0.35% | Elmsch=35 | Entrch=2 | Exitch=1 |
 | 56.60 | 2 | 0.00 | 28.30 | 35.40 | 0.35% | Elmsch=35 | Entrch=2 | Exitch=3 |
 | 56.50 | 2 | 0.00 | 28.25 | 35.30 | 0.35% | Elmsch=43 | Entrch=1 | Exitch=3 |


 eurusd 0318-0325 maxmin=1085 lv
 | 49.40 | 2 |  0.00 | 24.70 | 25.70 | 0.26% | Elmsch=80 | Entrch=2 | Exitch=2 |
 | 46.70 | 2 | 78.83 | 23.35 | 25.70 | 0.26% | Elmsch=82 | Entrch=1 | Exitch=2 |
 | 46.70 | 2 | 78.83 | 23.35 | 25.70 | 0.26% | Elmsch=83 | Entrch=1 | Exitch=2 |
 | 31.63 | 4 |  2.48 |  7.91 | 35.27 | 0.35% | Elmsch=60 | Entrch=1 | Exitch=2 |
 | 31.53 | 4 |  2.47 |  7.88 | 35.37 | 0.35% | Elmsch=59 | Entrch=1 | Exitch=2 |
 | 30.43 | 4 |  2.67 |  7.61 | 35.37 | 0.35% | Elmsch=67 | Entrch=1 | Exitch=2 |
 | 29.73 | 4 |  2.70 |  7.43 | 34.77 | 0.35% | Elmsch=67 | Entrch=2 | Exitch=2 |
 | 28.83 | 4 |  2.57 |  7.21 | 35.67 | 0.35% | Elmsch=66 | Entrch=1 | Exitch=2 |
 | 28.03 | 4 |  2.42 |  7.01 | 36.47 | 0.36% | Elmsch=60 | Entrch=2 | Exitch=2 |
 | 25.70 | 2 |  7.95 | 12.85 | 43.40 | 0.43% | Elmsch=80 | Entrch=2 | Exitch=1 |


 eurusd 0311-0318 maxmin=1844 dnup
 | 84.31 | 12 | 3.25 |  7.03 | 36.89 | 0.37% | Elmsch=55 | Entrch=2 | Exitch=2 |
 | 80.71 | 14 | 2.60 |  5.77 | 50.19 | 0.50% | Elmsch=42 | Entrch=1 | Exitch=2 |
 | 79.32 |  6 | 3.20 | 13.22 | 84.80 | 0.84% | Elmsch=80 | Entrch=3 | Exitch=1 |
 | 79.12 |  6 | 3.19 | 13.19 | 84.80 | 0.84% | Elmsch=61 | Entrch=3 | Exitch=3 |
 | 79.12 |  6 | 3.19 | 13.19 | 84.80 | 0.84% | Elmsch=61 | Entrch=3 | Exitch=1 |
 | 79.12 |  6 | 3.19 | 13.19 | 84.80 | 0.84% | Elmsch=61 | Entrch=3 | Exitch=4 |
 | 76.62 |  6 | 3.13 | 12.77 | 87.50 | 0.86% | Elmsch=63 | Entrch=3 | Exitch=1 |
 | 76.62 |  6 | 3.13 | 12.77 | 87.50 | 0.86% | Elmsch=64 | Entrch=3 | Exitch=1 |
 | 74.51 | 15 | 2.06 |  4.97 | 61.60 | 0.61% | Elmsch=39 | Entrch=1 | Exitch=2 |
 | 71.51 | 11 | 2.70 |  6.50 | 42.09 | 0.42% | Elmsch=48 | Entrch=2 | Exitch=2 |


 eurusd 0304-0311 maxmin=1774 dnup
 | 74.00 | 4 |  5.71 | 18.50 | 51.10 | 0.51% | Elmsch=71 | Entrch=1 | Exitch=2 |
 | 70.30 | 5 | 10.25 | 14.06 | 53.20 | 0.53% | Elmsch=65 | Entrch=2 | Exitch=2 |
 | 69.75 | 4 |  4.24 | 17.44 | 72.19 | 0.72% | Elmsch=65 | Entrch=2 | Exitch=1 |
 | 68.85 | 4 |  4.20 | 17.21 | 72.19 | 0.72% | Elmsch=65 | Entrch=2 | Exitch=4 |
 | 68.35 | 4 |  4.47 | 17.09 | 75.79 | 0.76% | Elmsch=64 | Entrch=1 | Exitch=1 |
 | 68.31 | 5 |  7.16 | 13.66 | 58.39 | 0.58% | Elmsch=64 | Entrch=1 | Exitch=2 |
 | 68.14 | 4 |  4.48 | 17.04 | 72.50 | 0.72% | Elmsch=71 | Entrch=1 | Exitch=4 |
 | 67.45 | 4 |  4.42 | 16.86 | 75.79 | 0.76% | Elmsch=64 | Entrch=1 | Exitch=3 |
 | 67.45 | 4 |  4.42 | 16.86 | 75.79 | 0.76% | Elmsch=64 | Entrch=1 | Exitch=4 |
 | 66.85 | 4 |  3.86 | 16.71 | 72.79 | 0.73% | Elmsch=63 | Entrch=1 | Exitch=1 |


 eurusd 0225-0304 maxmin=1403 dnup
 | 121.26 |  9 | 3.75 | 13.47 | 92.26 | 0.91% | Elmsch=45 | Entrch=3 | Exitch=3 |
 | 121.06 |  9 | 3.74 | 13.45 | 92.46 | 0.92% | Elmsch=45 | Entrch=3 | Exitch=4 |
 | 119.36 |  9 | 3.79 | 13.26 | 92.26 | 0.91% | Elmsch=48 | Entrch=3 | Exitch=3 |
 | 119.16 |  9 | 3.77 | 13.24 | 92.46 | 0.92% | Elmsch=48 | Entrch=3 | Exitch=4 |
 |  90.70 |  4 | 6.60 | 22.68 | 52.40 | 0.52% | Elmsch=78 | Entrch=1 | Exitch=2 |
 |  89.16 | 11 | 2.49 |  8.11 | 86.26 | 0.85% | Elmsch=55 | Entrch=3 | Exitch=1 |
 |  87.60 |  4 | 7.64 | 21.90 | 43.70 | 0.43% | Elmsch=82 | Entrch=2 | Exitch=2 |
 |  86.80 |  4 | 6.83 | 21.70 | 58.20 | 0.58% | Elmsch=80 | Entrch=1 | Exitch=2 |
 |  85.96 | 11 | 2.44 |  7.81 | 86.26 | 0.85% | Elmsch=48 | Entrch=3 | Exitch=1 |
 |  85.15 | 24 | 1.87 |  3.55 | 48.60 | 0.48% | Elmsch=27 | Entrch=1 | Exitch=3 |


 eurusd 0218-0225 maxmin=1403 dnup
 | 98.03 | 3 | 0.00 | 32.68 | 65.90 | 0.65% | Elmsch=65 | Entrch=1 | Exitch=4 |
 | 96.03 | 3 | 0.00 | 32.01 | 64.70 | 0.64% | Elmsch=63 | Entrch=1 | Exitch=4 |
 | 96.03 | 3 | 0.00 | 32.01 | 64.70 | 0.64% | Elmsch=63 | Entrch=1 | Exitch=3 |
 | 92.53 | 3 | 0.00 | 30.84 | 66.50 | 0.66% | Elmsch=60 | Entrch=1 | Exitch=1 |
 | 92.53 | 3 | 0.00 | 30.84 | 66.50 | 0.66% | Elmsch=60 | Entrch=1 | Exitch=3 |
 | 92.53 | 3 | 0.00 | 30.84 | 66.50 | 0.66% | Elmsch=60 | Entrch=1 | Exitch=4 |
 | 91.33 | 3 | 0.00 | 30.44 | 65.90 | 0.65% | Elmsch=61 | Entrch=1 | Exitch=4 |
 | 91.33 | 3 | 0.00 | 30.44 | 65.90 | 0.65% | Elmsch=61 | Entrch=1 | Exitch=1 |
 | 91.33 | 3 | 0.00 | 30.44 | 65.90 | 0.65% | Elmsch=61 | Entrch=1 | Exitch=3 |
 | 89.23 | 3 | 0.00 | 29.74 | 68.80 | 0.68% | Elmsch=64 | Entrch=1 | Exitch=3 |


 eurusd 0211-0218 maxmin=1614 dnup
 | 118.41 | 15 | 4.14 |  7.89 | 51.40 | 0.51% | Elmsch=37 | Entrch=1 | Exitch=2 |
 | 111.13 |  9 | 2.94 | 12.35 | 48.50 | 0.48% | Elmsch=50 | Entrch=3 | Exitch=4 |
 | 104.81 | 20 | 2.61 |  5.24 | 45.80 | 0.45% | Elmsch=50 | Entrch=3 | Exitch=2 |
 | 104.72 | 10 | 3.18 | 10.47 | 70.70 | 0.70% | Elmsch=37 | Entrch=1 | Exitch=1 |
 | 103.22 | 10 | 3.15 | 10.32 | 72.00 | 0.72% | Elmsch=37 | Entrch=1 | Exitch=3 |
 | 102.31 | 21 | 2.49 |  4.87 | 45.80 | 0.45% | Elmsch=44 | Entrch=3 | Exitch=2 |
 | 101.01 | 21 | 2.48 |  4.81 | 45.80 | 0.45% | Elmsch=37 | Entrch=3 | Exitch=2 |
 | 101.01 | 21 | 2.48 |  4.81 | 45.80 | 0.45% | Elmsch=40 | Entrch=3 | Exitch=2 |
 | 100.91 | 21 | 2.48 |  4.81 | 45.80 | 0.45% | Elmsch=39 | Entrch=3 | Exitch=2 |
 |  98.91 | 17 | 2.97 |  5.82 | 49.00 | 0.49% | Elmsch=40 | Entrch=2 | Exitch=2 |


 eurusd 0204-0211 maxmin=1844 dn
 | 163.02 | 38 | 2.92 | 4.29 | 53.79 | 0.53% | Elmsch=23 | Entrch=2 | Exitch=2 |
 | 155.01 | 40 | 2.87 | 3.88 | 49.60 | 0.49% | Elmsch=26 | Entrch=2 | Exitch=2 |
 | 151.52 | 28 | 2.93 | 5.41 | 72.00 | 0.71% | Elmsch=23 | Entrch=2 | Exitch=1 |
 | 142.32 | 27 | 2.76 | 5.27 | 76.60 | 0.75% | Elmsch=23 | Entrch=2 | Exitch=3 |
 | 141.42 | 27 | 2.75 | 5.24 | 76.60 | 0.75% | Elmsch=23 | Entrch=2 | Exitch=4 |
 | 131.71 | 30 | 2.85 | 4.39 | 79.10 | 0.78% | Elmsch=26 | Entrch=2 | Exitch=1 |
 | 121.51 | 20 | 2.79 | 6.08 | 70.70 | 0.69% | Elmsch=32 | Entrch=1 | Exitch=3 |
 | 121.11 | 20 | 2.77 | 6.06 | 70.60 | 0.69% | Elmsch=32 | Entrch=1 | Exitch=4 |
 | 115.31 | 38 | 2.25 | 3.03 | 69.00 | 0.68% | Elmsch=27 | Entrch=2 | Exitch=2 |
 | 112.61 | 41 | 2.09 | 2.75 | 68.40 | 0.67% | Elmsch=29 | Entrch=2 | Exitch=2 |



 //lincs.mq4//

 //
 //DESCRIP
 //
 /*
 use slines combos to determine market conditions for ntrxit
 */


 //
 //TODO
 //
 /*
 build protection for bar0 fluctuations DONE

 create ntr and xit for various sline combos including 4 line nu on slope
 incorporate nu
 create ranging pattern recognition

 ideas
 - parama (slopes for multiple lines are parallel)
 - nununu (consistency of nunu or unun can be utilized because h[] 2+,2- = n and l[] 2-,2+ = u!)
 - bodsor (short lines opposite to longer lines)
 */


 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>



 //
 //CONSTANTS
 //
 #define sp "  "
 #define spp "    "

 #define LOTSIZE 0.1                             /* lotsize */
 #define SLTP 12000                              /* fixed stoploss takeprof limits */
 #define Z 0.5                                   /* effective zero slope */



 //
 //EXTERNS
 //
 extern int Elmsch;
 extern int Entrch;
 extern int Exitch;



 //
 //GLOBALS
 //
 int Gtf[6];                                      /* timeframe array */
 int tkt=-1;                                     /* ticket number */
 int L,M,S;                                      /* long,mid,short indices for slines */
 double incs[2,10];                              /* incline values array */
 double osl;                                     /* order stoploss */




 //
 //STRATEGY FUNCTIONS
 //
 void OnTick()
 //main center
 {
   set_LMS(Elmsch);

   if(is_new_bar())                              /* get indicator info on every new bar */
     get_lincs();

   if(can_do_trade())                            /* no active trade */
     ntr();
   else                                          /* on active trade look for xit */
     xit();
 }


 void get_lincs()
 //fill hilo slines for L(512,256,128)  I(64,32,16)  S(8,4,2)
 {
   int i,bar,
     tf=PERIOD_M1;
   for(i=1;i<=9;i++)                              
     {
       bar=(int)pow(2,i);
       incs[0,i]=incline_value(bar,iHigh(NULL,tf,bar),1,iHigh(NULL,tf,1));
       incs[1,i]=incline_value(bar,iLow(NULL,tf,bar),1,iLow(NULL,tf,1));
     }
 }


 bool xit_do()
 //xit patterns and conditions
 {
   int
     bs=OrderType();

   //safety xit for bar0
   double
     max_dd=600,                                 /* maximum allowable drawdown */
     dpt=diff_pts(OrderOpenPrice(),Bid);         /* +ve for buy, -ve for sel */
   if((bs==0 && dpt<-max_dd) ||                  /* buy loss dpt<0 */
      (bs==1 && dpt>+max_dd))                    /* sel loss dpt>0 */
     return true;

   //xit pattern choices
   bool                                          /* only xit parameters required */
     B_xit=false,
     S_xit=false;
   switch(Exitch)
     {
     case 1:                                     /* LbrkZ */
       B_xit=(incs[0,L]<-Z);
       S_xit=(incs[1,L]>+Z);
       break;
     case 2:                                     /* Lbrk0 */
       B_xit=(incs[0,L]<0);
       S_xit=(incs[1,L]>0);
       break;
     case 3:
       B_xit=(incs[0,L]<-Z &&
              incs[0,M]<-Z);
       S_xit=(incs[1,L]>+Z &&
              incs[1,M]>+Z);
       break;
     case 4:
       B_xit=(incs[0,L]<-Z &&
              incs[0,M]<incs[0,L]);
       S_xit=(incs[1,L]>+Z &&
              incs[1,M]>+incs[1,L]);
       break;
     default:
       break;
     }
   if((bs==0 && B_xit) ||                        /* buy with B_xit */
      (bs==1 && S_xit))                          /* sel with S_xit */
     return true;
   return false;
 }


 int ntr_do()
 //ntrs patterns and conditions
 {
   bool                                          /* only ntr parameters required */
     B_ntr=false,
     S_ntr=false;
   switch(Entrch)
     {
     case 1:                                     /* bodsorA: \L /M \S */
       B_ntr=(incs[1,L]>+Z && incs[1,M]<0 && incs[1,S]>0);
       S_ntr=(incs[0,L]<-Z && incs[0,M]>0 && incs[0,S]<0);
       break;
     case 2:                                     /* bodsorB: \L /M /S */
       B_ntr=(incs[1,L]>+Z && incs[1,M]<0 && incs[1,S]<0);
       S_ntr=(incs[0,L]<-Z && incs[0,M]>0 && incs[0,S]>0);
       break;
     case 3:                                     /* parama: \L \M \S */
       B_ntr=(incs[1,L]>+Z && incs[1,M]>0 && incs[1,S]>0);
       S_ntr=(incs[0,L]<-Z && incs[0,M]<0 && incs[0,S]<0);
     default:
       break;
     }
   if(B_ntr) return 0;
   if(S_ntr) return 1;
   return -1;
 }




 //
 // UTILITY FUNCTIONS
 //
 void xit()
 //trailing xit
 {
   if(OrderSelect(tkt,SELECT_BY_TICKET))
     {
       if(xit_do())
         if(OrderClose(tkt,LOTSIZE,OrderClosePrice(),0))
           reset();
         else
           show_last_error();
     }
 }


 void ntr()
 //makes a trade
 {
   double oo=0,sl=0,tp=0;
   int
     bs=ntr_do();
  
   switch(bs)
     {
     case 0:
       oo=Ask;
       //osl=oo-INITIAL_SL*Point;
       sl=oo-SLTP*Point;
       tp=oo+SLTP*Point;
       break;
     case 1:
       oo=Bid;
       //osl=oo+INITIAL_SL*Point;
       sl=oo+SLTP*Point;
       tp=oo-SLTP*Point;
       break;
     }
   tkt=OrderSend(Symbol(),bs,LOTSIZE,oo,0,sl,tp);
 }


 bool is_new_bar()
 //checks to see if we have a new bar
 {
   static datetime lastbartime;
   datetime
     curbartime=Time[0];
   if(lastbartime!=curbartime)
     {
       lastbartime=curbartime;
       return (true);
     }
   else
     return(false);
 }


 double maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);

   if(minbar>maxbar)
     return diff_pts(minval,maxval);
   else
     return diff_pts(maxval,minval);
 }


 double diff_pts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }


 double incline_value(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf giving points per bar
 {
   int
     Dbar=bI-bF;
   return diff_pts(vI,vF)/Dbar;
 }


 bool is_btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }


 bool true_turning_point(int b,string hilo)
 //hilo is true turning point
 {
   if(hilo=="hi")
     if(High[b]>=High[b-1] && High[b]>=High[b+1])
       return true;
   if(hilo=="lo")
     if(Low[b]<=Low[b-1] && Low[b]<=Low[b+1])
       return true;
   return false;
 }


 void reset()
 //sets various items to initial values
 {
   tkt=-1;
 }



 //
 // DISPLAY FUNCTIONS
 //
 void tline(string objlabel,datetime t1,double p1,datetime t2,double p2,color clr)
 //draws trend line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_TREND,0,t1,p1,t2,p2,clr);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
   ObjectSet(objlabel,OBJPROP_RAY_RIGHT,false);
 }


 void hline(string objlabel,double price,color clr)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
 }


 void vline(string objlabel,string timestr,color clr)
 //draws vertical line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_VLINE,0,StrToTime(timestr),0);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);  
 }


 void display_txt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 void draw_sline(int bar,double inc,datetime tI,double pI,datetime tF,double pF)
 //draws sline with color
 {
   color
     clr=Incl_color(inc);
   tline("tline"+IntegerToString(bar),tI,pI,tF,pF,clr);
 }


 color Incl_color(double inc)
 //determines color from incline value
 {
   double
     zeroincl=0.6;
   color
     clr=Green;
  
   if(is_btn(-zeroincl,inc,+zeroincl))
     clr=Green;
   else
     {
       if(inc>+zeroincl)
         clr=Blue;
       if(inc<-zeroincl)
         clr=Red;
     }
   return clr;
 }



 //
 // SPECIAL FUNCTIONS
 //
 bool can_do_trade()
 //checks if trading is ok via total orders, spread
 {
   int aords,pords;
   bool
     ntradeOK=(orders_for_symbol(aords,pords)==0),
     equityOK=(AccountEquity()>6000),
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12);
   return (ntradeOK && equityOK && spreadOK);
 }


 int orders_for_symbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
 {
   aords=0;pords=0;
   for(int p=OrdersTotal()-1;p>=0;p--)
     if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
       {
         if(OrderType()>1 && OrderType()<6)
           pords++;
         if(OrderType()==OP_BUY || OrderType()==OP_SELL)
           aords++;
       }
   return aords+pords;
 }


 void show_last_error()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }




 //
 // INITIALIZATIONS
 //
 void set_LMS(int ch)
 //gets the LMS indices as defined by choice
 {
   switch(ch)
     {case 0: L=3;M=2;S=1; break; case 1: L=4;M=2;S=1; break; case 2: L=4;M=3;S=1; break; case 3: L=4;M=3;S=2; break; case 4: L=5;M=2;S=1; break; case 5: L=5;M=3;S=1; break; case 6: L=5;M=3;S=2; break; case 7: L=5;M=4;S=1; break; case 8: L=5;M=4;S=2; break; case 9: L=5;M=4;S=3; break; case 10: L=6;M=2;S=1; break; case 11: L=6;M=3;S=1; break; case 12: L=6;M=3;S=2; break; case 13: L=6;M=4;S=1; break; case 14: L=6;M=4;S=2; break; case 15: L=6;M=4;S=3; break; case 16: L=6;M=5;S=1; break; case 17: L=6;M=5;S=2; break; case 18: L=6;M=5;S=3; break; case 19: L=6;M=5;S=4; break; case 20: L=7;M=2;S=1; break; case 21: L=7;M=3;S=1; break; case 22: L=7;M=3;S=2; break; case 23: L=7;M=4;S=1; break; case 24: L=7;M=4;S=2; break; case 25: L=7;M=4;S=3; break; case 26: L=7;M=5;S=1; break; case 27: L=7;M=5;S=2; break; case 28: L=7;M=5;S=3; break; case 29: L=7;M=5;S=4; break; case 30: L=7;M=6;S=1; break; case 31: L=7;M=6;S=2; break; case 32: L=7;M=6;S=3; break; case 33: L=7;M=6;S=4; break; case 34: L=7;M=6;S=5; break; case 35: L=8;M=2;S=1; break; case 36: L=8;M=3;S=1; break; case 37: L=8;M=3;S=2; break; case 38: L=8;M=4;S=1; break; case 39: L=8;M=4;S=2; break; case 40: L=8;M=4;S=3; break; case 41: L=8;M=5;S=1; break; case 42: L=8;M=5;S=2; break; case 43: L=8;M=5;S=3; break; case 44: L=8;M=5;S=4; break; case 45: L=8;M=6;S=1; break; case 46: L=8;M=6;S=2; break; case 47: L=8;M=6;S=3; break; case 48: L=8;M=6;S=4; break; case 49: L=8;M=6;S=5; break; case 50: L=8;M=7;S=1; break; case 51: L=8;M=7;S=2; break; case 52: L=8;M=7;S=3; break; case 53: L=8;M=7;S=4; break; case 54: L=8;M=7;S=5; break; case 55: L=8;M=7;S=6; break; case 56: L=9;M=2;S=1; break; case 57: L=9;M=3;S=1; break; case 58: L=9;M=3;S=2; break; case 59: L=9;M=4;S=1; break; case 60: L=9;M=4;S=2; break; case 61: L=9;M=4;S=3; break; case 62: L=9;M=5;S=1; break; case 63: L=9;M=5;S=2; break; case 64: L=9;M=5;S=3; break; case 65: L=9;M=5;S=4; break; case 66: L=9;M=6;S=1; break; case 67: L=9;M=6;S=2; break; case 68: L=9;M=6;S=3; break; case 69: L=9;M=6;S=4; break; case 70: L=9;M=6;S=5; break; case 71: L=9;M=7;S=1; break; case 72: L=9;M=7;S=2; break; case 73: L=9;M=7;S=3; break; case 74: L=9;M=7;S=4; break; case 75: L=9;M=7;S=5; break; case 76: L=9;M=7;S=6; break; case 77: L=9;M=8;S=1; break; case 78: L=9;M=8;S=2; break; case 79: L=9;M=8;S=3; break; case 80: L=9;M=8;S=4; break; case 81: L=9;M=8;S=5; break; case 82: L=9;M=8;S=6; break; case 83: L=9;M=8;S=7; break; default:break;
     }
 }


 int OnInit()
 {
   Gtf[0]=1;Gtf[1]=5;Gtf[2]=15;Gtf[3]=30;Gtf[4]=60;Gtf[5]=240;
   return(INIT_SUCCEEDED);
 }


 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

**** code v6 introduces midline and tries in various tfs

 higher tfs sometimes certainly look as though they do better quite often

 eurusd 0325-0401
 | 236.80 | 2 | 0.00 | 118.40 | 51.65 | 0.51% | Elmsch=83 | Entrch=3 | Exitch=1 | Etfx=0 |
 | 236.80 | 2 | 0.00 | 118.40 | 51.65 | 0.51% | Elmsch=80 | Entrch=3 | Exitch=1 | Etfx=0 |
 | 236.20 | 2 | 0.00 | 118.10 | 52.25 | 0.52% | Elmsch=81 | Entrch=3 | Exitch=1 | Etfx=0 |
 | 236.20 | 2 | 0.00 | 118.10 | 52.25 | 0.52% | Elmsch=82 | Entrch=3 | Exitch=1 | Etfx=0 |
 | 236.20 | 2 | 0.00 | 118.10 | 52.25 | 0.52% | Elmsch=65 | Entrch=3 | Exitch=1 | Etfx=0 |
 | 235.60 | 2 | 0.00 | 117.80 | 52.25 | 0.52% | Elmsch=64 | Entrch=3 | Exitch=1 | Etfx=0 |
 | 232.40 | 2 | 0.00 | 116.20 | 51.15 | 0.51% | Elmsch=66 | Entrch=1 | Exitch=1 | Etfx=0 |
 | 231.45 | 2 | 0.00 | 115.72 | 61.60 | 0.61% | Elmsch=10 | Entrch=3 | Exitch=4 | Etfx=3 |
 | 230.80 | 2 | 0.00 | 115.40 | 54.55 | 0.54% | Elmsch=66 | Entrch=3 | Exitch=1 | Etfx=0 |
 | 230.20 | 2 | 0.00 | 115.10 | 51.65 | 0.51% | Elmsch=69 | Entrch=1 | Exitch=1 | Etfx=0 |

 eurusd 0318-0325
 | 61.70 | 1 | 0.00 | 61.70 | 65.00 | 0.64% | Elmsch=48 | Entrch=2 | Exitch=3 | Etfx=3 |
 | 61.70 | 1 | 0.00 | 61.70 | 65.00 | 0.64% | Elmsch=47 | Entrch=2 | Exitch=1 | Etfx=3 |
 | 61.70 | 1 | 0.00 | 61.70 | 65.00 | 0.64% | Elmsch=49 | Entrch=2 | Exitch=1 | Etfx=3 |
 | 61.70 | 1 | 0.00 | 61.70 | 65.00 | 0.64% | Elmsch=58 | Entrch=2 | Exitch=4 | Etfx=4 |
 | 61.70 | 1 | 0.00 | 61.70 | 65.00 | 0.64% | Elmsch=48 | Entrch=2 | Exitch=4 | Etfx=3 |
 | 61.70 | 1 | 0.00 | 61.70 | 65.00 | 0.64% | Elmsch=47 | Entrch=2 | Exitch=4 | Etfx=3 |
 | 61.70 | 1 | 0.00 | 61.70 | 65.00 | 0.64% | Elmsch=48 | Entrch=2 | Exitch=2 | Etfx=3 |
 | 61.70 | 1 | 0.00 | 61.70 | 65.00 | 0.64% | Elmsch=58 | Entrch=2 | Exitch=2 | Etfx=4 |
 | 61.70 | 1 | 0.00 | 61.70 | 65.00 | 0.64% | Elmsch=58 | Entrch=2 | Exitch=3 | Etfx=4 |
 | 61.70 | 1 | 0.00 | 61.70 | 65.00 | 0.64% | Elmsch=58 | Entrch=2 | Exitch=1 | Etfx=4 |

 eurusd 0311-0318
 | 167.82 | 6 | 9.74 |  27.97 | 46.10 | 0.46% | Elmsch=28 | Entrch=1 | Exitch=3 | Etfx=1 |
 | 162.72 | 2 | 0.00 |  81.36 | 54.90 | 0.54% | Elmsch=57 | Entrch=1 | Exitch=1 | Etfx=5 |
 | 151.52 | 6 | 8.46 |  25.25 | 46.10 | 0.46% | Elmsch=29 | Entrch=1 | Exitch=3 | Etfx=1 |
 | 137.62 | 9 | 4.57 |  15.29 | 48.30 | 0.48% | Elmsch=28 | Entrch=1 | Exitch=2 | Etfx=1 |
 | 125.72 | 7 | 3.83 |  17.96 | 70.20 | 0.69% | Elmsch=24 | Entrch=1 | Exitch=1 | Etfx=1 |
 | 118.50 | 1 | 0.00 | 118.50 | 54.90 | 0.54% | Elmsch=74 | Entrch=2 | Exitch=4 | Etfx=3 |
 | 117.70 | 1 | 0.00 | 117.70 | 54.90 | 0.54% | Elmsch=47 | Entrch=2 | Exitch=1 | Etfx=4 |
 | 117.12 | 9 | 3.93 |  13.01 | 48.30 | 0.48% | Elmsch=29 | Entrch=1 | Exitch=2 | Etfx=1 |
 | 116.80 | 1 | 0.00 | 116.80 | 54.90 | 0.54% | Elmsch=5  | Entrch=1 | Exitch=4 | Etfx=5 |
 | 116.80 | 1 | 0.00 | 116.80 | 54.90 | 0.54% | Elmsch=10 | Entrch=1 | Exitch=4 | Etfx=5 |

 eurusd 0304-0311
 | 183.52 | 2 | 0.00 | 91.76 | 48.90 | 0.48% | Elmsch=52 | Entrch=1 | Exitch=4 | Etfx=4 |
 | 174.83 | 2 | 0.00 | 87.41 | 48.90 | 0.48% | Elmsch=55 | Entrch=2 | Exitch=4 | Etfx=4 |
 | 174.83 | 2 | 0.00 | 87.41 | 48.90 | 0.48% | Elmsch=51 | Entrch=2 | Exitch=4 | Etfx=4 |
 | 174.83 | 2 | 0.00 | 87.41 | 48.90 | 0.48% | Elmsch=52 | Entrch=2 | Exitch=4 | Etfx=4 |
 | 174.75 | 2 | 0.00 | 87.38 | 48.90 | 0.48% | Elmsch=61 | Entrch=3 | Exitch=3 | Etfx=3 |
 | 174.75 | 2 | 0.00 | 87.38 | 48.90 | 0.48% | Elmsch=60 | Entrch=3 | Exitch=3 | Etfx=3 |
 | 174.75 | 2 | 0.00 | 87.38 | 48.90 | 0.48% | Elmsch=60 | Entrch=3 | Exitch=4 | Etfx=3 |
 | 164.33 | 2 | 0.00 | 82.17 | 48.90 | 0.48% | Elmsch=71 | Entrch=2 | Exitch=1 | Etfx=3 |
 | 147.45 | 2 | 0.00 | 73.72 | 47.90 | 0.48% | Elmsch=36 | Entrch=1 | Exitch=4 | Etfx=4 |
 | 144.02 | 2 | 0.00 | 72.01 | 48.90 | 0.48% | Elmsch=61 | Entrch=3 | Exitch=1 | Etfx=3 |

 | 195.36 | 2 |  0.00 | 97.68 | 48.90 | 0.48% | Elmsch=60 | Entrch=2 | Exitch=4 | Etfx=3 |
 | 191.06 | 2 |  0.00 | 95.53 | 48.90 | 0.48% | Elmsch=61 | Entrch=2 | Exitch=3 | Etfx=3 |
 | 191.06 | 2 |  0.00 | 95.53 | 48.90 | 0.48% | Elmsch=61 | Entrch=2 | Exitch=4 | Etfx=3 |
 | 174.83 | 2 |  0.00 | 87.41 | 48.90 | 0.48% | Elmsch=54 | Entrch=2 | Exitch=3 | Etfx=4 |
 | 174.75 | 2 |  0.00 | 87.38 | 48.90 | 0.48% | Elmsch=61 | Entrch=3 | Exitch=3 | Etfx=3 |
 | 164.33 | 2 |  0.00 | 82.17 | 48.90 | 0.48% | Elmsch=71 | Entrch=2 | Exitch=3 | Etfx=3 |
 | 164.33 | 2 |  0.00 | 82.17 | 48.90 | 0.48% | Elmsch=72 | Entrch=2 | Exitch=1 | Etfx=3 |
 | 164.33 | 2 |  0.00 | 82.17 | 48.90 | 0.48% | Elmsch=72 | Entrch=2 | Exitch=3 | Etfx=3 |
 | 164.33 | 2 |  0.00 | 82.17 | 48.90 | 0.48% | Elmsch=71 | Entrch=2 | Exitch=1 | Etfx=3 |
 | 164.25 | 3 | 41.06 | 54.75 | 47.90 | 0.48% | Elmsch=36 | Entrch=1 | Exitch=3 | Etfx=4 |



 //lincs.mq4//

 //
 //DESCRIP
 //
 /*
 use slines combos to determine market conditions for ntrxit
 */


 //
 //TODO
 //
 /*
 build protection for bar0 fluctuations DONE

 create ntr and xit for various sline combos including 4 line nu on slope
 incorporate nu
 create ranging pattern recognition

 ideas
 - parama (slopes for multiple lines are parallel)
 - nununu (consistency of nunu or unun can be utilized because h[] 2+,2- = n and l[] 2-,2+ = u!)
 - bodsor (short lines opposite to longer lines)
 */


 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>



 //
 //CONSTANTS
 //
 #define sp "  "
 #define spp "    "

 #define LOTSIZE 0.1                             /* lotsize */
 #define SLTP 12000                              /* fixed stoploss takeprof limits */
 #define Z 0.5                                   /* effective zero slope */



 //
 //EXTERNS
 //
 extern int Elmsch;
 extern int Entrch;
 extern int Exitch;
 extern int Etfx;



 //
 //GLOBALS
 //
 int Gtf[6];                                      /* timeframe array */
 int tkt=-1;                                     /* ticket number */
 int L,M,S;                                      /* long,mid,short indices for slines */
 double incs[3,10];                              /* incline values array */
 double osl;                                     /* order stoploss */




 //
 //STRATEGY FUNCTIONS
 //
 void OnTick()
 //main center
 {
   set_LMS(Elmsch);

   if(is_new_bar())                              /* get indicator info on every new bar */
     get_lincs();

   if(can_do_trade())                            /* no active trade */
     ntr();
   else                                          /* on active trade look for xit */
     xit();
 }


 void get_lincs()
 //fill hilo slines for L(512,256,128)  I(64,32,16)  S(8,4,2)
 {
   int i,bar,
     tf=Gtf[Etfx];
   double hib,hi1,lob,lo1,mib,mi1;
   for(i=1;i<=9;i++)                              
     {
       bar=(int)pow(2,i);
       hib=iHigh(NULL,tf,bar); hi1=iHigh(NULL,tf,1);
       lob=iLow(NULL,tf,bar); lo1=iLow(NULL,tf,1);
       mib=(hib+lob)/2; mi1=(hi1+lo1)/2;
       incs[0,i]=incline_value(bar,hib,1,hi1);
       incs[1,i]=incline_value(bar,lob,1,lo1);
       incs[2,i]=incline_value(bar,mib,1,mi1);
     }
   //printf("%.5f",hi_inc[1]);
 }


 bool xit_do()
 //xit patterns and conditions
 {
   int
     bs=OrderType();

   //safety xit for bar0
   double
     max_dd=600,                                 /* maximum allowable drawdown */
     dpt=diff_pts(OrderOpenPrice(),Bid);         /* +ve for buy, -ve for sel */
   if((bs==0 && dpt<-max_dd) ||                  /* buy loss dpt<0 */
      (bs==1 && dpt>+max_dd))                    /* sel loss dpt>0 */
     return true;

   //xit pattern choices
   bool                                          /* only xit parameters required */
     B_xit=false,
     S_xit=false;
   switch(Exitch)
     {
     case 1:                                     /* LbrkZ */
       B_xit=(incs[0,L]<-Z);
       S_xit=(incs[1,L]>+Z);
       break;
     case 2:                                     /* Lbrk0 */
       B_xit=(incs[0,L]<0);
       S_xit=(incs[1,L]>0);
       break;
     case 3:
       B_xit=(incs[0,L]<-Z &&
              incs[0,M]<-Z);
       S_xit=(incs[1,L]>+Z &&
              incs[1,M]>+Z);
       break;
     case 4:
       B_xit=(incs[0,L]<-Z &&
              incs[0,M]<incs[0,L]);
       S_xit=(incs[1,L]>+Z &&
              incs[1,M]>+incs[1,L]);
       break;
     default:
       break;
     }
   if((bs==0 && B_xit) ||                        /* buy with B_xit */
      (bs==1 && S_xit))                          /* sel with S_xit */
     return true;
   return false;
 }


 int ntr_do()
 //ntrs patterns and conditions
 {
   bool                                          /* only ntr parameters required */
     B_ntr=false,
     S_ntr=false;
   switch(Entrch)
     {
     case 1:                                     /* bodsorA: \L /M \S */
       B_ntr=(incs[1,L]>+Z && incs[1,M]<0 && incs[1,S]>0);
       S_ntr=(incs[0,L]<-Z && incs[0,M]>0 && incs[0,S]<0);
       break;
     case 2:                                     /* bodsorB: \L /M /S */
       B_ntr=(incs[1,L]>+Z && incs[1,M]<0 && incs[1,S]<0);
       S_ntr=(incs[0,L]<-Z && incs[0,M]>0 && incs[0,S]>0);
       break;
     case 3:                                     /* parama: \L \M \S */
       B_ntr=(incs[1,L]>+Z && incs[1,M]>0 && incs[1,S]>0);
       S_ntr=(incs[0,L]<-Z && incs[0,M]<0 && incs[0,S]<0);
     default:
       break;
     }
   if(B_ntr) return 0;
   if(S_ntr) return 1;
   return -1;
 }




 //
 // UTILITY FUNCTIONS
 //
 void xit()
 //trailing xit
 {
   if(OrderSelect(tkt,SELECT_BY_TICKET))
     {
       if(xit_do())
         if(OrderClose(tkt,LOTSIZE,OrderClosePrice(),0))
           reset();
         else
           show_last_error();
     }
 }


 void ntr()
 //makes a trade
 {
   double oo=0,sl=0,tp=0;
   int
     bs=ntr_do();
  
   switch(bs)
     {
     case 0:
       oo=Ask;
       //osl=oo-INITIAL_SL*Point;
       sl=oo-SLTP*Point;
       tp=oo+SLTP*Point;
       break;
     case 1:
       oo=Bid;
       //osl=oo+INITIAL_SL*Point;
       sl=oo+SLTP*Point;
       tp=oo-SLTP*Point;
       break;
     }
   tkt=OrderSend(Symbol(),bs,LOTSIZE,oo,0,sl,tp);
 }


 bool is_new_bar()
 //checks to see if we have a new bar
 {
   static datetime lastbartime;
   datetime
     curbartime=Time[0];
   if(lastbartime!=curbartime)
     {
       lastbartime=curbartime;
       return (true);
     }
   else
     return(false);
 }


 double maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);

   if(minbar>maxbar)
     return diff_pts(minval,maxval);
   else
     return diff_pts(maxval,minval);
 }


 double diff_pts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }


 double incline_value(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf giving points per bar
 {
   int
     Dbar=bI-bF;
   return diff_pts(vI,vF)/Dbar;
 }


 bool is_btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }


 bool true_turning_point(int b,string hilo)
 //hilo is true turning point
 {
   if(hilo=="hi")
     if(High[b]>=High[b-1] && High[b]>=High[b+1])
       return true;
   if(hilo=="lo")
     if(Low[b]<=Low[b-1] && Low[b]<=Low[b+1])
       return true;
   return false;
 }


 void reset()
 //sets various items to initial values
 {
   tkt=-1;
 }



 //
 // DISPLAY FUNCTIONS
 //
 void tline(string objlabel,datetime t1,double p1,datetime t2,double p2,color clr)
 //draws trend line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_TREND,0,t1,p1,t2,p2,clr);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
   ObjectSet(objlabel,OBJPROP_RAY_RIGHT,false);
 }


 void hline(string objlabel,double price,color clr)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
 }


 void vline(string objlabel,string timestr,color clr)
 //draws vertical line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_VLINE,0,StrToTime(timestr),0);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);  
 }


 void display_txt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 void draw_sline(int bar,double inc,datetime tI,double pI,datetime tF,double pF)
 //draws sline with color
 {
   color
     clr=Incl_color(inc);
   tline("tline"+IntegerToString(bar),tI,pI,tF,pF,clr);
 }


 color Incl_color(double inc)
 //determines color from incline value
 {
   double
     zeroincl=0.6;
   color
     clr=Green;
  
   if(is_btn(-zeroincl,inc,+zeroincl))
     clr=Green;
   else
     {
       if(inc>+zeroincl)
         clr=Blue;
       if(inc<-zeroincl)
         clr=Red;
     }
   return clr;
 }



 //
 // SPECIAL FUNCTIONS
 //
 bool can_do_trade()
 //checks if trading is ok via total orders, spread
 {
   int aords,pords;
   bool
     ntradeOK=(orders_for_symbol(aords,pords)==0),
     equityOK=(AccountEquity()>6000),
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12);
   return (ntradeOK && equityOK && spreadOK);
 }


 int orders_for_symbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
 {
   aords=0;pords=0;
   for(int p=OrdersTotal()-1;p>=0;p--)
     if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
       {
         if(OrderType()>1 && OrderType()<6)
           pords++;
         if(OrderType()==OP_BUY || OrderType()==OP_SELL)
           aords++;
       }
   return aords+pords;
 }


 void show_last_error()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }




 //
 // INITIALIZATIONS
 //
 void set_LMS(int ch)
 //gets the LMS indices as defined by choice
 {
   switch(ch)
     {case 0: L=3;M=2;S=1; break; case 1: L=4;M=2;S=1; break; case 2: L=4;M=3;S=1; break; case 3: L=4;M=3;S=2; break; case 4: L=5;M=2;S=1; break; case 5: L=5;M=3;S=1; break; case 6: L=5;M=3;S=2; break; case 7: L=5;M=4;S=1; break; case 8: L=5;M=4;S=2; break; case 9: L=5;M=4;S=3; break; case 10: L=6;M=2;S=1; break; case 11: L=6;M=3;S=1; break; case 12: L=6;M=3;S=2; break; case 13: L=6;M=4;S=1; break; case 14: L=6;M=4;S=2; break; case 15: L=6;M=4;S=3; break; case 16: L=6;M=5;S=1; break; case 17: L=6;M=5;S=2; break; case 18: L=6;M=5;S=3; break; case 19: L=6;M=5;S=4; break; case 20: L=7;M=2;S=1; break; case 21: L=7;M=3;S=1; break; case 22: L=7;M=3;S=2; break; case 23: L=7;M=4;S=1; break; case 24: L=7;M=4;S=2; break; case 25: L=7;M=4;S=3; break; case 26: L=7;M=5;S=1; break; case 27: L=7;M=5;S=2; break; case 28: L=7;M=5;S=3; break; case 29: L=7;M=5;S=4; break; case 30: L=7;M=6;S=1; break; case 31: L=7;M=6;S=2; break; case 32: L=7;M=6;S=3; break; case 33: L=7;M=6;S=4; break; case 34: L=7;M=6;S=5; break; case 35: L=8;M=2;S=1; break; case 36: L=8;M=3;S=1; break; case 37: L=8;M=3;S=2; break; case 38: L=8;M=4;S=1; break; case 39: L=8;M=4;S=2; break; case 40: L=8;M=4;S=3; break; case 41: L=8;M=5;S=1; break; case 42: L=8;M=5;S=2; break; case 43: L=8;M=5;S=3; break; case 44: L=8;M=5;S=4; break; case 45: L=8;M=6;S=1; break; case 46: L=8;M=6;S=2; break; case 47: L=8;M=6;S=3; break; case 48: L=8;M=6;S=4; break; case 49: L=8;M=6;S=5; break; case 50: L=8;M=7;S=1; break; case 51: L=8;M=7;S=2; break; case 52: L=8;M=7;S=3; break; case 53: L=8;M=7;S=4; break; case 54: L=8;M=7;S=5; break; case 55: L=8;M=7;S=6; break; case 56: L=9;M=2;S=1; break; case 57: L=9;M=3;S=1; break; case 58: L=9;M=3;S=2; break; case 59: L=9;M=4;S=1; break; case 60: L=9;M=4;S=2; break; case 61: L=9;M=4;S=3; break; case 62: L=9;M=5;S=1; break; case 63: L=9;M=5;S=2; break; case 64: L=9;M=5;S=3; break; case 65: L=9;M=5;S=4; break; case 66: L=9;M=6;S=1; break; case 67: L=9;M=6;S=2; break; case 68: L=9;M=6;S=3; break; case 69: L=9;M=6;S=4; break; case 70: L=9;M=6;S=5; break; case 71: L=9;M=7;S=1; break; case 72: L=9;M=7;S=2; break; case 73: L=9;M=7;S=3; break; case 74: L=9;M=7;S=4; break; case 75: L=9;M=7;S=5; break; case 76: L=9;M=7;S=6; break; case 77: L=9;M=8;S=1; break; case 78: L=9;M=8;S=2; break; case 79: L=9;M=8;S=3; break; case 80: L=9;M=8;S=4; break; case 81: L=9;M=8;S=5; break; case 82: L=9;M=8;S=6; break; case 83: L=9;M=8;S=7; break; default:break;
     }
 }


 int OnInit()
 {
   Gtf[0]=1;Gtf[1]=5;Gtf[2]=15;Gtf[3]=30;Gtf[4]=60;Gtf[5]=240;
   return(INIT_SUCCEEDED);
 }


 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

**** code v7 look into incline phasing with python code

*** milines
 based on slines, market inclination lines uses various inclines to determine the conditions:
 buyntr
 selntr
 buyxit
 selxit
 no trade

 the focus is on using the conditions to determine ntrxit.
 trailing stop is used mainly for the purpose of catching spikes that milines cannot detect

 milines are in 3 groups Long,Inter,Short and each group has 3 members:
 Llis
 Ilis
 Slis

**** code v1 with original trade_ntrxit no real testing done here
 //MIlines.mq4

 //
 //DESCRIP
 //
 /*
 use slines combos to determine market conditions for ntrxit
 */


 //
 //TODO
 //
 /*
 setup bodsor
 create sline analysis function with 3 parameters to implement any test which uses any 3 slines
 determine and test various sline combos

 ideas
 - parama (slopes for multiple lines are parallel)
 - nununu (consistency of nunu or unun can be utilized because h[] 2+,2- = n and l[] 2-,2+ = u!)
 - bodsor (short lines opposite to longer lines)
 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>



 //
 //CONSTANTS
 //
 #define sp "  "
 #define spp "    "

 #define LOTSIZE 0.1                             /* lotsize */
 #define SLTP 12000                              /* fixed stoploss takeprof limits */
 #define INITIAL_SL 600                          /* initial stoploss */
 #define TRAILING_SL 600                         /* trailing stoploss distance */
 #define TRAILING_ACTIVATION 300                 /* trailer activation */



 //
 //EXTERNS
 //



 //
 //GLOBALS
 //
 int L,M,S;                                      /* long,mid,short indices for slines */
 int tkt=-1;                                     /* ticket number */
 double osl;                                     /* order stoploss */
 double sl0=0.5;                                 /* slope threshold */
 bool B_ntr,S_ntr,B_xit,S_xit;                   /* only 4 indicators required */

 //
 //STRATEGY FUNCTIONS
 //
 void OnTick()
 //main center
 {
   set_LMS(1);
  
   if(is_new_bar())                              /* get indicator info on every new bar */
     get_indicator_info();

   if(tkt==-1)                                   /* no active trade */
     {
       if(B_ntr)                                 /* buy */
         tkt=trade_ntr(0);
       if(S_ntr)                                 /* sel */
         tkt=trade_ntr(1);
     }
   else                                          /* on active trade look for xit */
     trade_xit();

 }


 void get_indicator_info()
 //fills the slope values
 {

   //fill hilo slines for L(512,256,128)  I(64,32,16)  S(8,4,2)
   double hi_inc[10],lo_inc[10];ArrayInitialize(hi_inc,0);ArrayInitialize(lo_inc,0);
   int i,bar;
   for(i=1;i<=9;i++)                              
     {
       bar=(int)pow(2,i);printf("%d",i);
       hi_inc[i]=incline_value(bar,High[bar],1,High[1]);
       lo_inc[i]=incline_value(bar,Low[bar],1,Low[1]);
       //draw_sline(bar,hi_inc[i],Time[bar],High[bar],Time[1],High[1]);
     }
   //printf("%.5f",hi_inc[1]);
   //printf("%s",ColorToString(Incl_color(hi_inc [6]),true));

  
   //xits
   B_xit=(hi_inc[L]<-sl0);                    /* pressures on hi to sel */
   S_xit=(lo_inc[L]>+sl0);                    /* pressures on lo to buy */

   //ntrs
   B_ntr=
     //bodsor
     (lo_inc[L]>+sl0 && lo_inc[M]<0 && lo_inc[S]>0);
   S_ntr=
     //bodsor
     (hi_inc[L]<-sl0 && hi_inc[M]>0 && hi_inc[S]<0);  


 }


 bool isu(double ss,double sm,double sl)
 //finds u
 {
   return (sl<0 && sm>sl && ss>sm && ss>0);
 }


 bool isn(double ss,double sm,double sl)
 //finds n
 {
   return(sl>0 && sm<sl && ss<sm && ss<0);
 }


 void set_LMS(int ch)
 //gets the LMS indices as defined by choice
 {
   switch(ch)
     {
     case 01:
       L=3;M=2;S=1;
       break;
     case 02:
       break;
     }
 }



 //
 // UTILITY FUNCTIONS
 //
 void trade_xit()
 //trailing xit
 {
   if(OrderSelect(tkt,SELECT_BY_TICKET))
     {
       int bssign=0,
         bs=OrderType();

       double newosl,
         pr=Bid,
         oop=OrderOpenPrice(),
         dpt=diff_pts(oop,pr);

       switch(bs)
         {
         case 0:
           if(dpt>+TRAILING_ACTIVATION)
             {
               newosl=pr-TRAILING_SL*Point;
               if(newosl>osl)
                 osl=newosl;
             }
           break;
         case 1:
           if(dpt<-TRAILING_ACTIVATION)
             {
               newosl=pr+TRAILING_SL*Point;
               if(newosl<osl)
                 osl=newosl;
             }
           break;
         }
 hline("osl",osl,Red);
       bool
         Buyxit=(bs==0 && pr<osl),
         Selxit=(bs==1 && pr>osl);

       if(Buyxit || Selxit)
         if(OrderClose(tkt,LOTSIZE,OrderClosePrice(),0))
           reset();
     }
 }


 int trade_ntr(int bs)
 //makes a trade
 {
   double oo=0,sl=0,tp=0;
  
   switch(bs)
     {
     case 0:
       oo=Ask;
       osl=oo-INITIAL_SL*Point;
       sl=oo-SLTP*Point;
       tp=oo+SLTP*Point;
       break;
     case 1:
       oo=Bid;
       osl=oo+INITIAL_SL*Point;
       sl=oo+SLTP*Point;
       tp=oo-SLTP*Point;
       break;
     }
   return OrderSend(Symbol(),bs,LOTSIZE,oo,0,sl,tp);
 }


 bool is_new_bar()
 //checks to see if we have a new bar
 {
   static datetime lastbartime;
   datetime
     curbartime=Time[0];
   if(lastbartime!=curbartime)
     {
       lastbartime=curbartime;
       return (true);
     }
   else
     return(false);
 }


 double maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);

   if(minbar>maxbar)
     return diff_pts(minval,maxval);
   else
     return diff_pts(maxval,minval);
 }


 double diff_pts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }


 double incline_value(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf giving points per bar
 {
   int
     Dbar=bI-bF;
   return diff_pts(vI,vF)/Dbar;
 }


 bool is_btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }


 bool true_turning_point(int b,string hilo)
 //hilo is true turning point
 {
   if(hilo=="hi")
     if(High[b]>=High[b-1] && High[b]>=High[b+1])
       return true;
   if(hilo=="lo")
     if(Low[b]<=Low[b-1] && Low[b]<=Low[b+1])
       return true;
   return false;
 }


 void reset()
 //sets various items to initial values
 {
   tkt=-1;
 }



 //
 // DISPLAY FUNCTIONS
 //
 void tline(string objlabel,datetime t1,double p1,datetime t2,double p2,color clr)
 //draws trend line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_TREND,0,t1,p1,t2,p2,clr);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
   ObjectSet(objlabel,OBJPROP_RAY_RIGHT,false);
 }


 void hline(string objlabel,double price,color clr)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
 }


 void vline(string objlabel,string timestr,color clr)
 //draws vertical line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_VLINE,0,StrToTime(timestr),0);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);  
 }


 void display_txt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 void draw_sline(int bar,double inc,datetime tI,double pI,datetime tF,double pF)
 //draws sline with color
 {
   color
     clr=Incl_color(inc);
   tline("tline"+IntegerToString(bar),tI,pI,tF,pF,clr);
 }


 color Incl_color(double inc)
 //determines color from incline value
 {
   double
     zeroincl=0.6;
   color
     clr=Green;
  
   if(is_btn(-zeroincl,inc,+zeroincl))
     clr=Green;
   else
     {
       if(inc>+zeroincl)
         clr=Blue;
       if(inc<-zeroincl)
         clr=Red;
     }
   return clr;
 }



 //
 // SPECIAL FUNCTIONS
 //
 bool can_do_trade()
 //checks if trading is ok via total orders, spread
 {
   bool
     equityOK=(AccountEquity()>6000),
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12);
   return (equityOK && spreadOK);
 }


 int orders_for_symbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
 {
   aords=0;pords=0;
   for(int p=OrdersTotal()-1;p>=0;p--)
     if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
       {
         if(OrderType()>1 && OrderType()<6)
           pords++;
         if(OrderType()==OP_BUY || OrderType()==OP_SELL)
           aords++;
       }
   return aords+pords;
 }


 void show_last_error()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }


 int OnInit() {return(INIT_SUCCEEDED);}


 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

**** code v2 trying to find profitable combo
 170215-170318

 spread 2
 | 163.65 | 17 | 1.82 |  9.63 | 179.20 | 1.76% | Ech=74 |
 | 153.45 | 13 | 2.47 | 11.80 | 101.35 | 1.00% | Ech=78 |
 | 153.05 | 13 | 2.46 | 11.77 | 100.35 | 0.99% | Ech=77 |
 | 150.75 | 17 | 1.71 |  8.87 | 192.60 | 1.89% | Ech=72 |
 | 150.15 | 13 | 2.36 | 11.55 | 101.35 | 1.00% | Ech=80 |
 | 148.65 | 19 | 1.62 |  7.82 | 228.65 | 2.25% | Ech=62 |
 | 148.15 | 13 | 2.37 | 11.40 | 101.35 | 1.00% | Ech=79 |
 | 144.65 | 18 | 1.66 |  8.04 | 224.75 | 2.21% | Ech=68 |
 | 140.20 | 20 | 1.52 |  7.01 | 218.55 | 2.15% | Ech=58 |
 | 132.85 | 19 | 1.52 |  6.99 | 240.65 | 2.37% | Ech=65 |
 | 131.75 | 19 | 1.52 |  6.93 | 239.35 | 2.35% | Ech=63 |
 | 130.55 | 19 | 1.53 |  6.87 | 235.15 | 2.31% | Ech=64 |
 | 118.05 | 18 | 1.53 |  6.56 | 230.55 | 2.27% | Ech=67 |
 | 113.10 | 20 | 1.38 |  5.66 | 232.25 | 2.28% | Ech=56 |
 | 105.05 | 19 | 1.41 |  5.53 | 235.05 | 2.31% | Ech=69 |
 | 103.90 | 20 | 1.39 |  5.20 | 213.25 | 2.10% | Ech=57 |
 | 102.55 | 13 | 1.75 |  7.89 | 100.35 | 0.99% | Ech=81 |
 | 102.15 | 15 | 1.51 |  6.81 | 188.70 | 1.86% | Ech=76 |
 |  99.50 | 20 | 1.35 |  4.98 | 236.25 | 2.32% | Ech=60 |
 |  96.05 | 53 | 1.26 |  1.81 | 164.90 | 1.63% | Ech=43 |
 |  95.30 | 19 | 1.37 |  5.02 | 239.85 | 2.36% | Ech=66 |
 |  95.15 | 54 | 1.26 |  1.76 | 116.40 | 1.15% | Ech=44 |
 |  94.50 | 20 | 1.33 |  4.72 | 231.55 | 2.28% | Ech=59 |
 |  91.45 | 16 | 1.38 |  5.72 | 218.10 | 2.14% | Ech=75 |
 |  89.20 | 20 | 1.32 |  4.46 | 230.45 | 2.27% | Ech=61 |
 |  82.10 | 19 | 1.32 |  4.32 | 229.85 | 2.26% | Ech=70 |
 |  67.20 | 54 | 1.17 |  1.24 | 164.60 | 1.62% | Ech=41 |
 |  55.35 | 12 | 1.42 |  4.61 | 107.05 | 1.06% | Ech=82 |
 |  53.30 | 55 | 1.14 |  0.97 | 177.40 | 1.75% | Ech=42 |
 |  39.05 | 17 | 1.15 |  2.30 | 232.50 | 2.28% | Ech=73 |
 |  30.35 | 16 | 1.13 |  1.90 | 205.90 | 2.02% | Ech=71 |
 |  27.35 | 12 | 1.15 |  2.28 | 154.55 | 1.53% | Ech=83 |



 //MIlines.mq4

 //
 //DESCRIP
 //
 /*
 use slines combos to determine market conditions for ntrxit
 */


 //
 //TODO
 //
 /*
 setup bodsor
 create sline analysis function with 3 parameters to implement any test which uses any 3 slines
 determine and test various sline combos

 ideas
 - parama (slopes for multiple lines are parallel)
 - nununu (consistency of nunu or unun can be utilized because h[] 2+,2- = n and l[] 2-,2+ = u!)
 - bodsor (short lines opposite to longer lines)
 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>



 //
 //CONSTANTS
 //
 #define sp "  "
 #define spp "    "

 #define LOTSIZE 0.1                             /* lotsize */
 #define SLTP 12000                              /* fixed stoploss takeprof limits */
 #define INITIAL_SL 600                          /* initial stoploss */
 #define TRAILING_SL 600                         /* trailing stoploss distance */
 #define TRAILING_ACTIVATION 300                 /* trailer activation */



 //
 //EXTERNS
 //
 extern int Ech;


 //
 //GLOBALS
 //
 int L,M,S;                                      /* long,mid,short indices for slines */
 int tkt=-1;                                     /* ticket number */
 double osl;                                     /* order stoploss */
 double sl0=0.5;                                 /* slope threshold */
 bool B_ntr,S_ntr,B_xit,S_xit;                   /* only 4 indicators required */

 //
 //STRATEGY FUNCTIONS
 //
 void OnTick()
 //main center
 {
   int
     ch=Ech;
   set_LMS(ch);
  
   if(is_new_bar())                              /* get indicator info on every new bar */
     get_indicator_info();

   if(tkt==-1)                                   /* no active trade */
     {
       if(B_ntr)                                 /* buy */
         tkt=trade_ntr(0);
       if(S_ntr)                                 /* sel */
         tkt=trade_ntr(1);
     }
   else                                          /* on active trade look for xit */
     trade_xit();

 }


 void get_indicator_info()
 //fills the slope values
 {

   //fill hilo slines for L(512,256,128)  I(64,32,16)  S(8,4,2)
   double hi_inc[10],lo_inc[10];ArrayInitialize(hi_inc,0);ArrayInitialize(lo_inc,0);
   int i,bar;
   for(i=1;i<=9;i++)                              
     {
       bar=(int)pow(2,i);printf("%d",i);
       hi_inc[i]=incline_value(bar,High[bar],1,High[1]);
       lo_inc[i]=incline_value(bar,Low[bar],1,Low[1]);
       //draw_sline(bar,hi_inc[i],Time[bar],High[bar],Time[1],High[1]);
     }
   //printf("%.5f",hi_inc[1]);
   //printf("%s",ColorToString(Incl_color(hi_inc [6]),true));

  
   //xits
   B_xit=(hi_inc[L]<-sl0);                    /* pressures on hi to sel */
   S_xit=(lo_inc[L]>+sl0);                    /* pressures on lo to buy */

   //ntrs
   B_ntr=
     //bodsor
     (lo_inc[L]>+sl0 && lo_inc[M]<0 && lo_inc[S]>0);
   S_ntr=
     //bodsor
     (hi_inc[L]<-sl0 && hi_inc[M]>0 && hi_inc[S]<0);  


 }


 bool isu(double ss,double sm,double sl)
 //finds u
 {
   return (sl<0 && sm>sl && ss>sm && ss>0);
 }


 bool isn(double ss,double sm,double sl)
 //finds n
 {
   return(sl>0 && sm<sl && ss<sm && ss<0);
 }



 //
 // UTILITY FUNCTIONS
 //
 void trade_xit()
 //trailing xit
 {
   if(OrderSelect(tkt,SELECT_BY_TICKET))
     {
       bool
         xit_trade=false;
       int
         bs=OrderType();
       double
         dpt=diff_pts(OrderOpenPrice(),Bid);      /* progress of price in points from oop */

       switch(bs)
         {
         case 0:
           if(B_xit)
             xit_trade=true;
           break;
         case 1:
           if(S_xit)
             xit_trade=true;
           break;
         }
       if(xit_trade)
         if(OrderClose(tkt,LOTSIZE,OrderClosePrice(),0))
           reset();
     }
 }


 int trade_ntr(int bs)
 //makes a trade
 {
   double oo=0,sl=0,tp=0;
  
   switch(bs)
     {
     case 0:
       oo=Ask;
       osl=oo-INITIAL_SL*Point;
       sl=oo-SLTP*Point;
       tp=oo+SLTP*Point;
       break;
     case 1:
       oo=Bid;
       osl=oo+INITIAL_SL*Point;
       sl=oo+SLTP*Point;
       tp=oo-SLTP*Point;
       break;
     }
   return OrderSend(Symbol(),bs,LOTSIZE,oo,0,sl,tp);
 }


 bool is_new_bar()
 //checks to see if we have a new bar
 {
   static datetime lastbartime;
   datetime
     curbartime=Time[0];
   if(lastbartime!=curbartime)
     {
       lastbartime=curbartime;
       return (true);
     }
   else
     return(false);
 }


 double maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);

   if(minbar>maxbar)
     return diff_pts(minval,maxval);
   else
     return diff_pts(maxval,minval);
 }


 double diff_pts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }


 double incline_value(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf giving points per bar
 {
   int
     Dbar=bI-bF;
   return diff_pts(vI,vF)/Dbar;
 }


 bool is_btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }


 bool true_turning_point(int b,string hilo)
 //hilo is true turning point
 {
   if(hilo=="hi")
     if(High[b]>=High[b-1] && High[b]>=High[b+1])
       return true;
   if(hilo=="lo")
     if(Low[b]<=Low[b-1] && Low[b]<=Low[b+1])
       return true;
   return false;
 }


 void reset()
 //sets various items to initial values
 {
   tkt=-1;
 }



 //
 // DISPLAY FUNCTIONS
 //
 void tline(string objlabel,datetime t1,double p1,datetime t2,double p2,color clr)
 //draws trend line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_TREND,0,t1,p1,t2,p2,clr);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
   ObjectSet(objlabel,OBJPROP_RAY_RIGHT,false);
 }


 void hline(string objlabel,double price,color clr)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
 }


 void vline(string objlabel,string timestr,color clr)
 //draws vertical line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_VLINE,0,StrToTime(timestr),0);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);  
 }


 void display_txt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 void draw_sline(int bar,double inc,datetime tI,double pI,datetime tF,double pF)
 //draws sline with color
 {
   color
     clr=Incl_color(inc);
   tline("tline"+IntegerToString(bar),tI,pI,tF,pF,clr);
 }


 color Incl_color(double inc)
 //determines color from incline value
 {
   double
     zeroincl=0.6;
   color
     clr=Green;
  
   if(is_btn(-zeroincl,inc,+zeroincl))
     clr=Green;
   else
     {
       if(inc>+zeroincl)
         clr=Blue;
       if(inc<-zeroincl)
         clr=Red;
     }
   return clr;
 }



 //
 // SPECIAL FUNCTIONS
 //
 bool can_do_trade()
 //checks if trading is ok via total orders, spread
 {
   bool
     equityOK=(AccountEquity()>6000),
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12);
   return (equityOK && spreadOK);
 }


 int orders_for_symbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
 {
   aords=0;pords=0;
   for(int p=OrdersTotal()-1;p>=0;p--)
     if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
       {
         if(OrderType()>1 && OrderType()<6)
           pords++;
         if(OrderType()==OP_BUY || OrderType()==OP_SELL)
           aords++;
       }
   return aords+pords;
 }


 void show_last_error()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }



 int OnInit() {return(INIT_SUCCEEDED);}




 void set_LMS(int ch)
 //gets the LMS indices as defined by choice
 {
   switch(ch)
     {
     case 0:
       L=3;M=2;S=1;
       break;
     case 1:
       L=4;M=2;S=1;
       break;
     case 2:
       L=4;M=3;S=1;
       break;
     case 3:
       L=4;M=3;S=2;
       break;
     case 4:
       L=5;M=2;S=1;
       break;
     case 5:
       L=5;M=3;S=1;
       break;
     case 6:
       L=5;M=3;S=2;
       break;
     case 7:
       L=5;M=4;S=1;
       break;
     case 8:
       L=5;M=4;S=2;
       break;
     case 9:
       L=5;M=4;S=3;
       break;
     case 10:
       L=6;M=2;S=1;
       break;
     case 11:
       L=6;M=3;S=1;
       break;
     case 12:
       L=6;M=3;S=2;
       break;
     case 13:
       L=6;M=4;S=1;
       break;
     case 14:
       L=6;M=4;S=2;
       break;
     case 15:
       L=6;M=4;S=3;
       break;
     case 16:
       L=6;M=5;S=1;
       break;
     case 17:
       L=6;M=5;S=2;
       break;
     case 18:
       L=6;M=5;S=3;
       break;
     case 19:
       L=6;M=5;S=4;
       break;
     case 20:
       L=7;M=2;S=1;
       break;
     case 21:
       L=7;M=3;S=1;
       break;
     case 22:
       L=7;M=3;S=2;
       break;
     case 23:
       L=7;M=4;S=1;
       break;
     case 24:
       L=7;M=4;S=2;
       break;
     case 25:
       L=7;M=4;S=3;
       break;
     case 26:
       L=7;M=5;S=1;
       break;
     case 27:
       L=7;M=5;S=2;
       break;
     case 28:
       L=7;M=5;S=3;
       break;
     case 29:
       L=7;M=5;S=4;
       break;
     case 30:
       L=7;M=6;S=1;
       break;
     case 31:
       L=7;M=6;S=2;
       break;
     case 32:
       L=7;M=6;S=3;
       break;
     case 33:
       L=7;M=6;S=4;
       break;
     case 34:
       L=7;M=6;S=5;
       break;
     case 35:
       L=8;M=2;S=1;
       break;
     case 36:
       L=8;M=3;S=1;
       break;
     case 37:
       L=8;M=3;S=2;
       break;
     case 38:
       L=8;M=4;S=1;
       break;
     case 39:
       L=8;M=4;S=2;
       break;
     case 40:
       L=8;M=4;S=3;
       break;
     case 41:
       L=8;M=5;S=1;
       break;
     case 42:
       L=8;M=5;S=2;
       break;
     case 43:
       L=8;M=5;S=3;
       break;
     case 44:
       L=8;M=5;S=4;
       break;
     case 45:
       L=8;M=6;S=1;
       break;
     case 46:
       L=8;M=6;S=2;
       break;
     case 47:
       L=8;M=6;S=3;
       break;
     case 48:
       L=8;M=6;S=4;
       break;
     case 49:
       L=8;M=6;S=5;
       break;
     case 50:
       L=8;M=7;S=1;
       break;
     case 51:
       L=8;M=7;S=2;
       break;
     case 52:
       L=8;M=7;S=3;
       break;
     case 53:
       L=8;M=7;S=4;
       break;
     case 54:
       L=8;M=7;S=5;
       break;
     case 55:
       L=8;M=7;S=6;
       break;
     case 56:
       L=9;M=2;S=1;
       break;
     case 57:
       L=9;M=3;S=1;
       break;
     case 58:
       L=9;M=3;S=2;
       break;
     case 59:
       L=9;M=4;S=1;
       break;
     case 60:
       L=9;M=4;S=2;
       break;
     case 61:
       L=9;M=4;S=3;
       break;
     case 62:
       L=9;M=5;S=1;
       break;
     case 63:
       L=9;M=5;S=2;
       break;
     case 64:
       L=9;M=5;S=3;
       break;
     case 65:
       L=9;M=5;S=4;
       break;
     case 66:
       L=9;M=6;S=1;
       break;
     case 67:
       L=9;M=6;S=2;
       break;
     case 68:
       L=9;M=6;S=3;
       break;
     case 69:
       L=9;M=6;S=4;
       break;
     case 70:
       L=9;M=6;S=5;
       break;
     case 71:
       L=9;M=7;S=1;
       break;
     case 72:
       L=9;M=7;S=2;
       break;
     case 73:
       L=9;M=7;S=3;
       break;
     case 74:
       L=9;M=7;S=4;
       break;
     case 75:
       L=9;M=7;S=5;
       break;
     case 76:
       L=9;M=7;S=6;
       break;
     case 77:
       L=9;M=8;S=1;
       break;
     case 78:
       L=9;M=8;S=2;
       break;
     case 79:
       L=9;M=8;S=3;
       break;
     case 80:
       L=9;M=8;S=4;
       break;
     case 81:
       L=9;M=8;S=5;
       break;
     case 82:
       L=9;M=8;S=6;
       break;
     case 83:
       L=9;M=8;S=7;
       break;
     }
 }

 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

**** code v3 lms,ntr,xit combos
 170215-170317 spread 10

 | 218.94 | 20 | 1.95 | 10.95 | 208.07 | 2.04% | Echlms=59 | Echntr=2 | Echxit=1 |
 | 213.24 | 20 | 1.91 | 10.66 | 213.17 | 2.09% | Echlms=57 | Echntr=2 | Echxit=1 |
 | 211.14 | 20 | 1.92 | 10.56 | 208.07 | 2.04% | Echlms=59 | Echntr=2 | Echxit=2 |
 | 210.94 | 20 | 1.88 | 10.55 | 216.27 | 2.12% | Echlms=70 | Echntr=2 | Echxit=1 |
 | 208.14 | 20 | 1.88 | 10.41 | 218.27 | 2.14% | Echlms=57 | Echntr=2 | Echxit=2 |
 | 208.14 | 20 | 1.85 | 10.41 | 220.97 | 2.17% | Echlms=58 | Echntr=2 | Echxit=1 |
 | 204.34 | 20 | 1.85 | 10.22 | 215.87 | 2.12% | Echlms=76 | Echntr=2 | Echxit=1 |
 | 204.24 | 20 | 1.83 | 10.21 | 221.37 | 2.17% | Echlms=64 | Echntr=2 | Echxit=1 |
 | 200.14 | 20 | 1.83 | 10.01 | 215.87 | 2.12% | Echlms=72 | Echntr=2 | Echxit=1 |
 | 199.91 | 17 | 2.19 | 11.76 | 181.18 | 1.77% | Echlms=73 | Echntr=1 | Echxit=2 |
 | 199.54 | 18 | 1.89 | 11.09 | 152.47 | 1.50% | Echlms=82 | Echntr=2 | Echxit=2 |
 | 197.94 | 18 | 1.88 | 11.00 | 152.47 | 1.50% | Echlms=80 | Echntr=2 | Echxit=2 |
 | 197.54 | 18 | 1.88 | 10.97 | 152.87 | 1.50% | Echlms=81 | Echntr=2 | Echxit=2 |
 | 195.04 | 20 | 1.80 |  9.75 | 220.97 | 2.17% | Echlms=73 | Echntr=2 | Echxit=1 |
 | 192.84 | 18 | 1.84 | 10.71 | 157.57 | 1.55% | Echlms=79 | Echntr=2 | Echxit=2 |
 | 185.24 | 20 | 1.69 |  9.26 | 215.87 | 2.12% | Echlms=80 | Echntr=2 | Echxit=1 |
 | 182.92 | 18 | 1.98 | 10.16 | 233.18 | 2.28% | Echlms=68 | Echntr=1 | Echxit=1 |
 | 182.14 | 20 | 1.68 |  9.11 | 216.27 | 2.13% | Echlms=81 | Echntr=2 | Echxit=1 |
 | 178.34 | 20 | 1.68 |  8.92 | 222.47 | 2.18% | Echlms=64 | Echntr=2 | Echxit=2 |
 | 178.01 | 13 | 2.90 | 13.69 | 109.49 | 1.07% | Echlms=79 | Echntr=1 | Echxit=1 |
 | 171.61 | 13 | 2.80 | 13.20 | 115.79 | 1.14% | Echlms=80 | Echntr=1 | Echxit=1 |
 | 166.52 | 18 | 1.86 |  9.25 | 240.18 | 2.35% | Echlms=68 | Echntr=1 | Echxit=2 |
 | 165.92 | 19 | 1.82 |  8.73 | 224.78 | 2.20% | Echlms=62 | Echntr=1 | Echxit=1 |
 | 163.61 | 13 | 2.66 | 12.59 | 115.79 | 1.14% | Echlms=80 | Echntr=1 | Echxit=2 |
 | 162.03 | 19 | 1.73 |  8.53 | 241.47 | 2.37% | Echlms=64 | Echntr=1 | Echxit=1 |

 what seems to be clear is:
 1. Echntr=2 produces better results, surprising since we thought bodsor would be more effective than 3gree
 2. Echxit=1 seems somewhat better, though either appears to be fine
 3. L needs to be 9 (or at least 8) for best results, though M,S can vary considerably
 4. 20 trades in 20 days suggests hanging in for the slow haul


 however, for usdjpy results were small profit and for gbpusd we had a loss using 59-2-1.

 optimization didn't produce particularly good results:

 | 156.64 | 25 | 1.36 | 6.27 | 249.32 | 2.48% | Echlms=80 | Echntr=2 | Echxit=2 |
 | 110.94 | 26 | 1.23 | 4.27 | 249.36 | 2.49% | Echlms=78 | Echntr=2 | Echxit=2 |
 |  69.85 | 18 | 1.27 | 3.88 | 251.68 | 2.50% | Echlms=82 | Echntr=1 | Echxit=2 |
 |  54.50 | 24 | 1.19 | 2.27 | 195.71 | 1.94% | Echlms=80 | Echntr=1 | Echxit=1 |
 |  46.00 | 31 | 1.09 | 1.48 | 239.55 | 2.38% | Echlms=70 | Echntr=2 | Echxit=2 |
 |  34.61 | 24 | 1.11 | 1.44 | 193.20 | 1.92% | Echlms=81 | Echntr=1 | Echxit=1 |


 what these results suggests is that a miline combo is inadequate to the market conditions in certain situations.

 possibly one advantage to xonesr is that we provide the landscape to some extent and if we go for small wins mostly, we may be able to circumvent the issue of having some combo that is universally effective.

 unfortunately, we didn't save the last effort, but it is close to the previous one.

**** code v4 lms,ntr,xit combos continuation examining weeks
 what is interesting is that there is more variety going by weeks than by months and considerably more profit
 also, bodsor does much better
 nor are we restricted to the largest indices 9,8
 on difficult weeks, we get larger indices and fewer trades
 we are also getting some blow-ups which are unexplained

 possibly we can determine market conditions from these to some extent and/or establish set and compatible combos.

 eurusd 170204-0211
 | 104.42 | 30 | 1.85 | 3.48 | 106.60 | 1.04% | Elmsch=24 | Entrch=1 |
 | 104.31 | 30 | 2.27 | 3.48 |  87.30 | 0.86% | Elmsch=27 | Entrch=1 |
 | 100.51 | 30 | 2.19 | 3.35 |  87.00 | 0.86% | Elmsch=26 | Entrch=1 |
 |  96.63 | 30 | 1.81 | 3.22 |  91.49 | 0.90% | Elmsch=25 | Entrch=1 |
 |  91.63 | 31 | 1.70 | 2.96 | 111.29 | 1.09% | Elmsch=23 | Entrch=1 |
 |  76.52 | 32 | 1.54 | 2.39 |  93.29 | 0.92% | Elmsch=22 | Entrch=1 |
 |  75.73 | 37 | 1.46 | 2.05 | 108.39 | 1.07% | Elmsch=31 | Entrch=2 |
 |  69.93 | 37 | 1.42 | 1.89 | 109.29 | 1.08% | Elmsch=30 | Entrch=2 |
 |  68.93 | 35 | 1.43 | 1.97 | 104.59 | 1.03% | Elmsch=20 | Entrch=1 |
 |  68.13 | 38 | 1.40 | 1.79 | 108.49 | 1.07% | Elmsch=32 | Entrch=2 |

 eurusd 170211-0218
 | 104.72 | 10 | 3.18 | 10.47 | 70.70 | 0.70% | Elmsch=37 | Entrch=1 |
 |  89.01 |  7 | 3.23 | 12.72 | 35.20 | 0.35% | Elmsch=55 | Entrch=1 |
 |  85.42 | 11 | 2.11 |  7.77 | 70.20 | 0.70% | Elmsch=36 | Entrch=1 |
 |  78.42 | 13 | 1.82 |  6.03 | 82.60 | 0.82% | Elmsch=55 | Entrch=2 |
 |  78.42 | 13 | 1.82 |  6.03 | 82.60 | 0.82% | Elmsch=54 | Entrch=2 |
 |  78.42 | 13 | 1.82 |  6.03 | 82.60 | 0.82% | Elmsch=53 | Entrch=2 |
 |  78.42 | 13 | 1.82 |  6.03 | 82.60 | 0.82% | Elmsch=49 | Entrch=2 |
 |  78.42 | 13 | 1.82 |  6.03 | 82.60 | 0.82% | Elmsch=48 | Entrch=2 |
 |  78.42 | 13 | 1.82 |  6.03 | 82.60 | 0.82% | Elmsch=44 | Entrch=2 |
 |  77.02 | 13 | 1.80 |  5.92 | 82.60 | 0.82% | Elmsch=52 | Entrch=2 |

 eurusd 170218-0225
 | 99.13 | 3 | 0.00 | 33.04 | 65.40 | 0.65% | Elmsch=69 | Entrch=1 |
 | 98.03 | 3 | 0.00 | 32.68 | 65.90 | 0.65% | Elmsch=65 | Entrch=1 |
 | 97.93 | 3 | 0.00 | 32.64 | 64.90 | 0.64% | Elmsch=62 | Entrch=1 |
 | 96.03 | 3 | 0.00 | 32.01 | 64.70 | 0.64% | Elmsch=63 | Entrch=1 |
 | 94.63 | 3 | 0.00 | 31.54 | 64.80 | 0.64% | Elmsch=59 | Entrch=1 |
 | 93.63 | 3 | 0.00 | 31.21 | 65.40 | 0.65% | Elmsch=58 | Entrch=1 |
 | 92.53 | 3 | 0.00 | 30.84 | 66.50 | 0.66% | Elmsch=60 | Entrch=1 |
 | 91.33 | 3 | 0.00 | 30.44 | 65.90 | 0.65% | Elmsch=61 | Entrch=1 |
 | 89.23 | 3 | 0.00 | 29.74 | 68.80 | 0.68% | Elmsch=64 | Entrch=1 |
 | 87.33 | 3 | 0.00 | 29.11 | 65.40 | 0.65% | Elmsch=57 | Entrch=1 |

 eurusd 170218-03
 | 89.86 | 11 | 2.51 | 8.17 | 86.26 | 0.85% | Elmsch=47 | Entrch=2 |
 | 89.47 | 10 | 3.78 | 8.95 | 66.09 | 0.66% | Elmsch=38 | Entrch=1 |
 | 89.16 | 11 | 2.49 | 8.11 | 86.26 | 0.85% | Elmsch=55 | Entrch=2 |
 | 89.16 | 11 | 2.49 | 8.11 | 86.26 | 0.85% | Elmsch=46 | Entrch=2 |
 | 88.36 | 10 | 3.26 | 8.84 | 69.16 | 0.68% | Elmsch=40 | Entrch=1 |
 | 86.74 | 28 | 1.83 | 3.10 | 54.30 | 0.54% | Elmsch=28 | Entrch=1 |
 | 85.96 | 11 | 2.44 | 7.81 | 86.26 | 0.85% | Elmsch=48 | Entrch=2 |
 | 81.24 | 28 | 1.68 | 2.90 | 56.47 | 0.56% | Elmsch=27 | Entrch=1 |
 | 81.06 | 11 | 2.36 | 7.37 | 86.26 | 0.85% | Elmsch=49 | Entrch=2 |
 | 79.97 | 12 | 2.11 | 6.66 | 83.26 | 0.82% | Elmsch=51 | Entrch=2 |

 eurusd 170304-0311
 | 68.35 | 4 | 4.47 | 17.09 | 75.79 | 0.76% | Elmsch=64 | Entrch=1 |
 | 68.14 | 4 | 4.48 | 17.04 | 72.50 | 0.72% | Elmsch=71 | Entrch=1 |
 | 67.95 | 4 | 4.45 | 16.99 | 72.49 | 0.72% | Elmsch=68 | Entrch=1 |
 | 66.85 | 4 | 3.86 | 16.71 | 72.79 | 0.73% | Elmsch=63 | Entrch=1 |
 | 64.05 | 4 | 4.25 | 16.01 | 74.39 | 0.74% | Elmsch=61 | Entrch=1 |
 | 62.25 | 4 | 3.66 | 15.56 | 73.79 | 0.74% | Elmsch=62 | Entrch=1 |
 | 62.15 | 4 | 3.64 | 15.54 | 73.79 | 0.74% | Elmsch=65 | Entrch=1 |
 | 62.05 | 4 | 3.65 | 15.51 | 72.69 | 0.72% | Elmsch=59 | Entrch=1 |
 | 61.95 | 4 | 3.65 | 15.49 | 72.79 | 0.73% | Elmsch=60 | Entrch=1 |
 | 59.34 | 4 | 3.12 | 14.84 | 72.50 | 0.72% | Elmsch=75 | Entrch=1 |
 | 57.74 | 4 | 2.95 | 14.44 | 72.50 | 0.72% | Elmsch=74 | Entrch=1 |
 | 57.64 | 4 | 2.94 | 14.41 | 72.50 | 0.72% | Elmsch=72 | Entrch=1 |

 eurusd 170311-0318
 | 82.42 | 6 | 3.59 | 13.74 | 87.50 | 0.86% | Elmsch=69 | Entrch=2 |
 | 79.32 | 6 | 3.20 | 13.22 | 84.80 | 0.84% | Elmsch=80 | Entrch=2 |
 | 79.32 | 6 | 3.20 | 13.22 | 84.80 | 0.84% | Elmsch=79 | Entrch=2 |
 | 79.32 | 6 | 3.20 | 13.22 | 84.80 | 0.84% | Elmsch=78 | Entrch=2 |
 | 79.12 | 6 | 3.19 | 13.19 | 84.80 | 0.84% | Elmsch=61 | Entrch=2 |
 | 79.12 | 6 | 3.19 | 13.19 | 84.80 | 0.84% | Elmsch=60 | Entrch=2 |
 | 79.12 | 6 | 3.19 | 13.19 | 84.80 | 0.84% | Elmsch=58 | Entrch=2 |
 | 78.92 | 6 | 3.24 | 13.15 | 87.50 | 0.86% | Elmsch=82 | Entrch=2 |
 | 78.92 | 6 | 3.24 | 13.15 | 87.50 | 0.86% | Elmsch=70 | Entrch=2 |
 | 78.32 | 6 | 3.22 | 13.05 | 87.50 | 0.86% | Elmsch=66 | Entrch=2 |
 | 78.12 | 6 | 3.16 | 13.02 | 87.50 | 0.86% | Elmsch=68 | Entrch=2 |
 | 76.62 | 6 | 3.13 | 12.77 | 87.50 | 0.86% | Elmsch=81 | Entrch=2 |


 //MIlines.mq4//

 //
 //DESCRIP
 //
 /*
 use slines combos to determine market conditions for ntrxit
 */


 //
 //TODO
 //
 /*
 create ntr and xit for various sline combos including 4 line nu on slope

 ideas
 - parama (slopes for multiple lines are parallel)
 - nununu (consistency of nunu or unun can be utilized because h[] 2+,2- = n and l[] 2-,2+ = u!)
 - bodsor (short lines opposite to longer lines)
 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>



 //
 //CONSTANTS
 //
 #define sp "  "
 #define spp "    "

 #define LOTSIZE 0.1                             /* lotsize */
 #define SLTP 12000                              /* fixed stoploss takeprof limits */
 #define INITIAL_SL 600                          /* initial stoploss */
 #define TRAILING_SL 600                         /* trailing stoploss distance */
 #define TRAILING_ACTIVATION 300                 /* trailer activation */



 //
 //EXTERNS
 //
 extern int Elmsch;
 extern int Entrch;


 //
 //GLOBALS
 //
 int L,M,S;                                      /* long,mid,short indices for slines */
 int tkt=-1;                                     /* ticket number */
 double osl;                                     /* order stoploss */
 double sl0=0.5;                                 /* slope threshold */
 bool B_ntr,S_ntr,B_xit,S_xit;                   /* only 4 indicators required */

 //
 //STRATEGY FUNCTIONS
 //
 void OnTick()
 //main center
 {
   set_LMS(Elmsch);
  
   if(is_new_bar())                              /* get indicator info on every new bar */
     get_indicator_info();

   if(tkt==-1)                                   /* no active trade */
     {
       if(B_ntr)                                 /* buy */
         tkt=trade_ntr(0);
       if(S_ntr)                                 /* sel */
         tkt=trade_ntr(1);
     }
   else                                          /* on active trade look for xit */
     trade_xit();

 }


 void get_indicator_info()
 //fills the slope values
 {
   //fill hilo slines for L(512,256,128)  I(64,32,16)  S(8,4,2)
   double hi_inc[10],lo_inc[10];ArrayInitialize(hi_inc,0);ArrayInitialize(lo_inc,0);
   int i,bar,
     tf=PERIOD_M1;
   for(i=1;i<=9;i++)                              
     {
       bar=(int)pow(2,i);
       hi_inc[i]=incline_value(bar,iHigh(NULL,tf,bar),1,iHigh(NULL,tf,1));
       lo_inc[i]=incline_value(bar,iLow(NULL,tf,bar),1,iLow(NULL,tf,1));
       //draw_sline(bar,hi_inc[i],Time[bar],High[bar],Time[1],High[1]);
     }
   //printf("%.5f",hi_inc[1]);
   //printf("%s",ColorToString(Incl_color(hi_inc [6]),true));

  
   //xits
   B_xit=(hi_inc[L]<-sl0);                    /* pressures on hi to sel */
   S_xit=(lo_inc[L]>+sl0);                    /* pressures on lo to buy */

   //ntrs
   switch(Entrch)
     {
     case 1:                                     /* bodsor */
       B_ntr=(lo_inc[L]>+sl0 && lo_inc[M]<0 && lo_inc[S]>0);
       S_ntr=(hi_inc[L]<-sl0 && hi_inc[M]>0 && hi_inc[S]<0);
       break;
     case 2:                                     /* 3gree */
       B_ntr=(lo_inc[L]>+sl0 && lo_inc[M]>0 && lo_inc[S]>0);
       S_ntr=(hi_inc[L]<-sl0 && hi_inc[M]<0 && hi_inc[S]<0);
     }
 }


 bool isu(double ss,double sm,double sl)
 //finds u
 {
   return (sl<0 && sm>sl && ss>sm && ss>0);
 }


 bool isn(double ss,double sm,double sl)
 //finds n
 {
   return(sl>0 && sm<sl && ss<sm && ss<0);
 }



 //
 // UTILITY FUNCTIONS
 //
 void trade_xit()
 //trailing xit
 {
   if(OrderSelect(tkt,SELECT_BY_TICKET))
     {
       bool
         xit_trade=false;
       int
         bs=OrderType();
       double
         dpt=diff_pts(OrderOpenPrice(),Bid);      /* progress of price in points from oop */

       switch(bs)
         {
         case 0:
           if(B_xit)
             xit_trade=true;
           break;
         case 1:
           if(S_xit)
             xit_trade=true;
           break;
         }
       if(xit_trade)
         if(OrderClose(tkt,LOTSIZE,OrderClosePrice(),0))
           reset();
     }
 }


 int trade_ntr(int bs)
 //makes a trade
 {
   double oo=0,sl=0,tp=0;
  
   switch(bs)
     {
     case 0:
       oo=Ask;
       osl=oo-INITIAL_SL*Point;
       sl=oo-SLTP*Point;
       tp=oo+SLTP*Point;
       break;
     case 1:
       oo=Bid;
       osl=oo+INITIAL_SL*Point;
       sl=oo+SLTP*Point;
       tp=oo-SLTP*Point;
       break;
     }
   return OrderSend(Symbol(),bs,LOTSIZE,oo,0,sl,tp);
 }


 bool is_new_bar()
 //checks to see if we have a new bar
 {
   static datetime lastbartime;
   datetime
     curbartime=Time[0];
   if(lastbartime!=curbartime)
     {
       lastbartime=curbartime;
       return (true);
     }
   else
     return(false);
 }


 double maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);

   if(minbar>maxbar)
     return diff_pts(minval,maxval);
   else
     return diff_pts(maxval,minval);
 }


 double diff_pts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }


 double incline_value(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf giving points per bar
 {
   int
     Dbar=bI-bF;
   return diff_pts(vI,vF)/Dbar;
 }


 bool is_btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }


 bool true_turning_point(int b,string hilo)
 //hilo is true turning point
 {
   if(hilo=="hi")
     if(High[b]>=High[b-1] && High[b]>=High[b+1])
       return true;
   if(hilo=="lo")
     if(Low[b]<=Low[b-1] && Low[b]<=Low[b+1])
       return true;
   return false;
 }


 void reset()
 //sets various items to initial values
 {
   tkt=-1;
 }



 //
 // DISPLAY FUNCTIONS
 //
 void tline(string objlabel,datetime t1,double p1,datetime t2,double p2,color clr)
 //draws trend line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_TREND,0,t1,p1,t2,p2,clr);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
   ObjectSet(objlabel,OBJPROP_RAY_RIGHT,false);
 }


 void hline(string objlabel,double price,color clr)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
 }


 void vline(string objlabel,string timestr,color clr)
 //draws vertical line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_VLINE,0,StrToTime(timestr),0);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);  
 }


 void display_txt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 void draw_sline(int bar,double inc,datetime tI,double pI,datetime tF,double pF)
 //draws sline with color
 {
   color
     clr=Incl_color(inc);
   tline("tline"+IntegerToString(bar),tI,pI,tF,pF,clr);
 }


 color Incl_color(double inc)
 //determines color from incline value
 {
   double
     zeroincl=0.6;
   color
     clr=Green;
  
   if(is_btn(-zeroincl,inc,+zeroincl))
     clr=Green;
   else
     {
       if(inc>+zeroincl)
         clr=Blue;
       if(inc<-zeroincl)
         clr=Red;
     }
   return clr;
 }



 //
 // SPECIAL FUNCTIONS
 //
 bool can_do_trade()
 //checks if trading is ok via total orders, spread
 {
   bool
     equityOK=(AccountEquity()>6000),
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12);
   return (equityOK && spreadOK);
 }


 int orders_for_symbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
 {
   aords=0;pords=0;
   for(int p=OrdersTotal()-1;p>=0;p--)
     if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
       {
         if(OrderType()>1 && OrderType()<6)
           pords++;
         if(OrderType()==OP_BUY || OrderType()==OP_SELL)
           aords++;
       }
   return aords+pords;
 }


 void show_last_error()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }



 int OnInit() {return(INIT_SUCCEEDED);}




 void set_LMS(int ch)
 //gets the LMS indices as defined by choice
 {
   switch(ch)
     {
     case 0:
       L=3;M=2;S=1;
       break;
     case 1:
       L=4;M=2;S=1;
       break;
     case 2:
       L=4;M=3;S=1;
       break;
     case 3:
       L=4;M=3;S=2;
       break;
     case 4:
       L=5;M=2;S=1;
       break;
     case 5:
       L=5;M=3;S=1;
       break;
     case 6:
       L=5;M=3;S=2;
       break;
     case 7:
       L=5;M=4;S=1;
       break;
     case 8:
       L=5;M=4;S=2;
       break;
     case 9:
       L=5;M=4;S=3;
       break;
     case 10:
       L=6;M=2;S=1;
       break;
     case 11:
       L=6;M=3;S=1;
       break;
     case 12:
       L=6;M=3;S=2;
       break;
     case 13:
       L=6;M=4;S=1;
       break;
     case 14:
       L=6;M=4;S=2;
       break;
     case 15:
       L=6;M=4;S=3;
       break;
     case 16:
       L=6;M=5;S=1;
       break;
     case 17:
       L=6;M=5;S=2;
       break;
     case 18:
       L=6;M=5;S=3;
       break;
     case 19:
       L=6;M=5;S=4;
       break;
     case 20:
       L=7;M=2;S=1;
       break;
     case 21:
       L=7;M=3;S=1;
       break;
     case 22:
       L=7;M=3;S=2;
       break;
     case 23:
       L=7;M=4;S=1;
       break;
     case 24:
       L=7;M=4;S=2;
       break;
     case 25:
       L=7;M=4;S=3;
       break;
     case 26:
       L=7;M=5;S=1;
       break;
     case 27:
       L=7;M=5;S=2;
       break;
     case 28:
       L=7;M=5;S=3;
       break;
     case 29:
       L=7;M=5;S=4;
       break;
     case 30:
       L=7;M=6;S=1;
       break;
     case 31:
       L=7;M=6;S=2;
       break;
     case 32:
       L=7;M=6;S=3;
       break;
     case 33:
       L=7;M=6;S=4;
       break;
     case 34:
       L=7;M=6;S=5;
       break;
     case 35:
       L=8;M=2;S=1;
       break;
     case 36:
       L=8;M=3;S=1;
       break;
     case 37:
       L=8;M=3;S=2;
       break;
     case 38:
       L=8;M=4;S=1;
       break;
     case 39:
       L=8;M=4;S=2;
       break;
     case 40:
       L=8;M=4;S=3;
       break;
     case 41:
       L=8;M=5;S=1;
       break;
     case 42:
       L=8;M=5;S=2;
       break;
     case 43:
       L=8;M=5;S=3;
       break;
     case 44:
       L=8;M=5;S=4;
       break;
     case 45:
       L=8;M=6;S=1;
       break;
     case 46:
       L=8;M=6;S=2;
       break;
     case 47:
       L=8;M=6;S=3;
       break;
     case 48:
       L=8;M=6;S=4;
       break;
     case 49:
       L=8;M=6;S=5;
       break;
     case 50:
       L=8;M=7;S=1;
       break;
     case 51:
       L=8;M=7;S=2;
       break;
     case 52:
       L=8;M=7;S=3;
       break;
     case 53:
       L=8;M=7;S=4;
       break;
     case 54:
       L=8;M=7;S=5;
       break;
     case 55:
       L=8;M=7;S=6;
       break;
     case 56:
       L=9;M=2;S=1;
       break;
     case 57:
       L=9;M=3;S=1;
       break;
     case 58:
       L=9;M=3;S=2;
       break;
     case 59:
       L=9;M=4;S=1;
       break;
     case 60:
       L=9;M=4;S=2;
       break;
     case 61:
       L=9;M=4;S=3;
       break;
     case 62:
       L=9;M=5;S=1;
       break;
     case 63:
       L=9;M=5;S=2;
       break;
     case 64:
       L=9;M=5;S=3;
       break;
     case 65:
       L=9;M=5;S=4;
       break;
     case 66:
       L=9;M=6;S=1;
       break;
     case 67:
       L=9;M=6;S=2;
       break;
     case 68:
       L=9;M=6;S=3;
       break;
     case 69:
       L=9;M=6;S=4;
       break;
     case 70:
       L=9;M=6;S=5;
       break;
     case 71:
       L=9;M=7;S=1;
       break;
     case 72:
       L=9;M=7;S=2;
       break;
     case 73:
       L=9;M=7;S=3;
       break;
     case 74:
       L=9;M=7;S=4;
       break;
     case 75:
       L=9;M=7;S=5;
       break;
     case 76:
       L=9;M=7;S=6;
       break;
     case 77:
       L=9;M=8;S=1;
       break;
     case 78:
       L=9;M=8;S=2;
       break;
     case 79:
       L=9;M=8;S=3;
       break;
     case 80:
       L=9;M=8;S=4;
       break;
     case 81:
       L=9;M=8;S=5;
       break;
     case 82:
       L=9;M=8;S=6;
       break;
     case 83:
       L=9;M=8;S=7;
       break;
     }
 }

 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */
*** slines
 use hilo differences 2,4,8,16,32,64,128,256,512 and their interplay to ntrxit

 all these myriad of patterns are fine and uninterpretable without thought
 therefore consider possibilities:
 - parama (slopes for multiple lines are parallel)
 - nununu (consistency of nunu or unun can be utilized because h[] 2+,2- = n and l[] 2-,2+ = u!)
 - bodsor (short lines opposite to longer lines)

**** code v0test efforts with various parameters fin,ntrs,mininc
 the problem with this seems to be it too is dependent on movement
 16nov5-12 produces nearly $400 

 | 379.90 |  73 | 2.42 | 5.20 | 107.00 | 1.04% | chfin=1 | chntrs=3 | minc=3 |
 | 378.50 |  56 | 2.95 | 6.76 |  58.10 | 0.57% | chfin=1 | chntrs=3 | minc=4 |
 | 375.90 |  92 | 2.03 | 4.09 | 113.10 | 1.10% | chfin=1 | chntrs=3 | minc=2 |
 | 333.20 | 161 | 1.49 | 2.07 |  95.20 | 0.92% | chfin=1 | chntrs=1 | minc=4 |
 | 306.60 | 171 | 1.41 | 1.79 |  80.60 | 0.78% | chfin=1 | chntrs=1 | minc=1 |
 | 305.40 | 106 | 1.64 | 2.88 | 113.10 | 1.10% | chfin=1 | chntrs=3 | minc=1 |
 | 280.80 |  39 | 2.94 | 7.20 |  52.20 | 0.51% | chfin=1 | chntrs=3 | minc=5 |
 | 266.00 | 170 | 1.35 | 1.56 |  81.80 | 0.82% | chfin=1 | chntrs=1 | minc=2 |
 | 252.90 | 169 | 1.33 | 1.50 |  92.00 | 0.89% | chfin=1 | chntrs=1 | minc=3 |
 | 241.20 |  35 | 2.81 | 6.89 |  51.80 | 0.51% | chfin=1 | chntrs=3 | minc=6 |
 | 232.60 | 161 | 1.31 | 1.44 | 125.60 | 1.22% | chfin=1 | chntrs=1 | minc=5 |
 | 218.30 |  27 | 3.08 | 8.09 |  56.50 | 0.56% | chfin=1 | chntrs=3 | minc=7 |

 however, the next two weeks were weak with only $50.

 //sline.mq4

 //DESCRIP
 /*

 */

 //TODO
 /*
 switch for Far Intermediate Recent combos
 switch for relations between FIR
 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>

 //////////////////////////////////////////////////////////////

 //
 //CONSTANTS
 //
 #define sp "  "
 #define spp "    "

 #define LT 0.1
 #define SLTP 1200.0*Point
 #define TS 120


 //
 //EXTERNS
 //
 extern int chfin;                               /* fin pattern choice */
 extern int chntrs;                              /* ntrs criteria choice */
 extern double minc;                             /* minimum incline */


 //
 //GLOBALS
 //
 int Gbar[8];
 int Gtf[6];
 int tfx=0;                                      /* timeframe index */
 int tkt=-1;                                     /* ticket number */
 double h[9],l[9];                               /* hilo incline arrays from 0-8 for 2^x bars */
 double osl;                                     /* order stoploss */


 //
 //FUNCTIONS
 //

 void OnTick()                                        
 {
   int f,i,n,bs;
  
   if(is_new_bar())                              /* get indicator info and trademerit only on every new bar */
     fill_hl();

   fins(chfin,f,i,n);
   bs=ntrs(chntrs,f,i,n);
  
   if(bs!=-1 && tkt==-1)                         /* no trade active */
     tkt=trantr(bs);                             /* try a strategy */
   else
     traxit();                                   /* use trailing exit since we have a trade */
 }


 void traxit()
 //trailing stoploss xit
 {
   if(OrderSelect(tkt,SELECT_BY_TICKET))
     {
       int
         bs=OrderType();
       double
         oop=OrderOpenPrice(),
         ocp=OrderClosePrice();

       switch(bs)
         {
         case 0:
           if(Dpts(osl,Bid)>TS) osl=Bid-TS*Point;
           if(Bid<osl)
             if(OrderClose(tkt,LT,ocp,0))
                tkt=-1;
           break;
         case 1:
           if(Dpts(Ask,osl)>TS) osl=Ask+TS*Point;
           if(Ask>osl)
             if(OrderClose(tkt,LT,ocp,0))
                tkt=-1;            
           break;
         }
       hline("osl",osl);
     }
 }


 void fins(int ch,int &f,int &i,int &n)
 //selection of far,intermediate,near indices
 {
   switch(ch)
     {
     case 01: f=2;i=1;n=0;break;
     case 02: f=5;i=4;n=3;break;
     case 03: f=8;i=7;n=6;break;      
     }
 }


 int ntrs(int ch,int f,int i,int n)
 //returns buy or sel
 {
   bool buy,sel;
  
   switch(ch)
     {
     case 01:                                    /* fin */
       buy=(+minc<l[f] && l[f]<l[i] && l[i]<l[n]) && (h[f]>0);
       sel=(-minc>h[f] && h[f]>h[i] && h[i]>h[n]) && (l[f]<0);
       break;
     case 02:                                    /* fi-n */
       buy=(+minc<l[f] && l[f]<l[i] && l[n]<-l[f]) && (h[f]>0);
       sel=(-minc>h[f] && h[f]>h[i] && h[n]>-h[f]) && (l[f]<0);      
       break;
     case 03:                                    /* f-i-n */
       buy=(+minc<l[f] && l[i]<-l[f] && l[n]<l[i]) && (h[f]>0);
       sel=(-minc>h[f] && h[i]>-h[f] && h[n]>h[i]) && (l[f]<0);      
       break;      
     }

   if(buy) return 0;
   if(sel) return 1;
   return -1;
 }


 int trantr(int bs)
 //makes a trade
 {
   switch(bs)
     {
     case 0:
       osl=Ask-TS;
       return OrderSend(Symbol(),0,LT,Ask,0,Ask-SLTP,Ask+SLTP);
       break;
     case 1:
       osl=Bid+TS;
       return OrderSend(Symbol(),1,LT,Bid,0,Bid+SLTP,Bid-SLTP);
       break;
     }
   return -1;
 }


 void fill_slines()
 //fills the slope values
 { int i,bar;
   for(i=0;i<9;i++)                              /* slines for S(2,4,8)  M(16,32,64)  L(128,256,512) */
     {
       bar=(int)pow(2,i+1);
       h[i]=incline(bar,High[bar],1,High[1]);
       l[i]=incline(bar,Low[bar],1,Low[1]);
     }
 }


 bool is_new_bar()
 //checks to see if we have a new bar
 {
   static datetime lastbartime;
   datetime
     curbartime=Time[0];
   if(lastbartime!=curbartime)
     {
       lastbartime=curbartime;
       return (true);
     }
   else
     return(false);
 }


 double maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);

   if(minbar>maxbar)
     return Dpts(minval,maxval);
   else
     return Dpts(maxval,minval);
 }


 double Dprs(double pI,double pF)
 //difference between two prices
 {
   return (pF-pI);
 }


 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }


 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf giving points per bar
 {
   int
     Dbar=bI-bF;
   return Dpts(vI,vF)/Dbar;
 }


 bool btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }



 //
 //SPECIAL FUNCTIONS
 //
 int OnInit()
 {
   Gtf[0]=1;Gtf[1]=5;Gtf[2]=15;Gtf[3]=30;Gtf[4]=60;Gtf[5]=240;
   return(INIT_SUCCEEDED);
 }


 bool CanDoTrade()
 //checks if trading is ok via total orders, spread
 {
   bool
     equityOK=(AccountEquity()>6000),
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12);
   return (equityOK && spreadOK);
 }


 void showlasterror()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }


 void hline(string objlabel,double price)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
 }


 void displaytxt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

**** code v1 optimization for sline incline><0 only
 161105-161231
 | 220.00 | 18 | 12.22 | 65.30 | 0.65% | Ei=5 |
 | 213.80 | 16 | 13.36 | 65.70 | 0.65% | Ei=6 |
 | 193.20 | 13 | 14.86 | 82.50 | 0.82% | Ei=3 |
 | 187.30 | 11 | 17.03 | 77.20 | 0.77% | Ei=8 |
 | 187.30 | 11 | 17.03 | 77.20 | 0.77% | Ei=7 |
 | 169.30 | 12 | 14.11 | 78.10 | 0.78% | Ei=2 |
 | 166.90 | 11 | 15.17 | 78.10 | 0.78% | Ei=4 |
 small gains mostly, no losses sometimes and some large gains too - last trade doesn't complete

 note there is nothing fancy here - we just go in direction of the sline.

 //nusline.mq4

 //DESCRIP
 /*

 */

 //TODO
 /*
 develop xit

 use slines to determine trend
 form nu based on distance from any extremity beyond atr

 since we don't really know how to use slines start doing things simply and develop understanding
 1. single sline results
 2. SML sline combos
 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>

 //////////////////////////////////////////////////////////////

 //
 //CONSTANTS
 //
 #define sp "  "
 #define spp "    "

 #define LT 0.1
 #define SLTP 1200.0*Point
 #define TS 120



 //
 //EXTERNS
 //
 /* extern int chfin;                               /\* fin pattern choice *\/ */
 /* extern int chntrs;                              /\* ntrs criteria choice *\/ */
 /* extern double minc;                             /\* minimum incline *\/ */
 extern int Ei;


 //
 //GLOBALS
 //
 int tfs[6];                                     /* timeframes */
 int tkt=-1;                                     /* ticket number */

 double h[10],l[10];                             /* hilo incline arrays from 1-9 for 2^x bars */
 double osl;                                     /* order stoploss */

 int Shs,Mhs,Lhs,Sls,Mls,Lls;                    /* SML inclines */
 bool Su,Sn,Mu,Mn,Lu,Ln;                         /* SML nu */
 double atr12;                                   /* range calculation for 12 bars */


 //
 //STRATEGY FUNCTIONS
 //

 void main()
 //control center
 {
   int
     bs=-1;
  
   if(IsNewBar())                              /* get indicator info on every new bar */
     IndiInfo();

   bs=SingleSline();
  
   if(bs!=-1 && tkt==-1)                         /* no trade active */
     tkt=trantr(bs);                             /* try a strategy */
   else
     traxit();                                   /* use trailing exit since we have a trade */
 }

 int SingleSline()
 //set bs based on single sline
 {
   int
     i=Ei;
   if(h[i]>0 && l[i]>0)
     return 0;
   if(h[i]<0 && l[i]<0)
     return 1;
   return -1;
 }

 void IndiInfo()
 //fills the slope values
 { int i,bar;

   for(i=1;i<=9;i++)                              /* slines for S(2,4,8)  M(16,32,64)  L(128,256,512) */
     {
       bar=(int)pow(2,i);
       h[i]=incl(bar,High[bar],1,High[1]);
       l[i]=incl(bar,Low[bar],1,Low[1]);
       //      if(l[i]>0) clr=Blue; else clr=Red;
       //Tline("tline"+IntegerToString(bar),Time[bar],Low[bar],Time[1],Low[1],clr);
     }

  
   Shs=(int)(round(h[1]+h[2]+h[3]));             /* SML inclines */
   Mhs=(int)(round(h[4]+h[5]+h[6]));
   Lhs=(int)(round(h[7]+h[8]+h[9]));
   Sls=(int)(round(l[1]+l[2]+l[3]));
   Mls=(int)(round(l[4]+l[5]+l[6]));
   Lls=(int)(round(l[7]+l[8]+l[9]));

   Sn=isn(h[1],h[2],h[3]);                       /* SML nus */
   Mn=isn(h[4],h[5],h[6]);
   Ln=isn(h[7],h[8],h[9]);
   Su=isu(l[1],l[2],l[3]);
   Mu=isu(l[4],l[5],l[6]);
   Lu=isu(l[7],l[8],l[9]);  
  
   atr12=iATR(NULL,1,12,1);

 }


 bool isu(double ss,double sm,double sl)
 //finds u
 {
   return (sl<0 && sm>sl && ss>sm && ss>0);
 }

 bool isn(double ss,double sm,double sl)
 //finds n
 {
   return(sl>0 && sm<sl && ss<sm && ss<0);
 }

 //
 // UTILITY FUNCTIONS
 //

 int trantr(int bs)
 //makes a trade
 {
   switch(bs)
     {
     case 0:
       osl=Ask-TS;
       return OrderSend(Symbol(),0,LT,Ask,0,Ask-SLTP,Ask+SLTP);
       break;
     case 1:
       osl=Bid+TS;
       return OrderSend(Symbol(),1,LT,Bid,0,Bid+SLTP,Bid-SLTP);
       break;
     }
   return -1;
 }


 void traxit()
 //trailing xit
 {

   if(OrderSelect(tkt,SELECT_BY_TICKET))
     {
       int
         bs=OrderType();

       if(OrderProfit()>0)
         {
           int
             trsl=0;
           double newosl,
             oop=OrderOpenPrice(),
             dpt=fabs(Dpts(oop,Bid));

           if(dpt>60) trsl=30;
           if(dpt>120) trsl=60;
           if(dpt>180) trsl=90;
           if(dpt>240) trsl=120;
           if(dpt>300) trsl=150;
          
           if(trsl>=30)
             switch(bs)
               {
               case 0:
                 newosl=oop+trsl*Point;
                 if(newosl>osl) osl=newosl;
                 break;
               case 1:
                 newosl=oop-trsl*Point;
                 if(newosl<osl) osl=newosl;
                 break;
               }
         }

       if(((bs==0 && Bid<osl) || (bs==1 && Bid>osl))
          && OrderClose(tkt,LT,OrderClosePrice(),0))
         Reset();
     }
 }


 bool IsNewBar()
 //checks to see if we have a new bar
 {
   static datetime lastbartime;
   datetime
     curbartime=Time[0];
   if(lastbartime!=curbartime)
     {
       lastbartime=curbartime;
       return (true);
     }
   else
     return(false);
 }


 double maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);

   if(minbar>maxbar)
     return Dpts(minval,maxval);
   else
     return Dpts(maxval,minval);
 }


 double Dprs(double pI,double pF)
 //difference between two prices
 {
   return (pF-pI);
 }


 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }


 double incl(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf giving points per bar
 {
   int
     Dbar=bI-bF;
   return Dpts(vI,vF)/Dbar;
 }


 bool btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }


 bool TrueTurningPoint(int b,string hilo)
 //hilo is true turning point
 {
   if(hilo=="hi")
     if(High[b]>=High[b-1] && High[b]>=High[b+1])
       return true;
   if(hilo=="lo")
     if(Low[b]<=Low[b-1] && Low[b]<=Low[b+1])
       return true;
   return false;
 }


 void Reset()
 //sets various items to initial values
 {
   tkt=-1;
 }



 //
 // DISPLAY FUNCTIONS
 //

 void Tline(string objlabel,datetime t1,double p1,datetime t2,double p2,color clr)
 //draws trend line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_TREND,0,t1,p1,t2,p2,clr);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
   ObjectSet(objlabel,OBJPROP_RAY_RIGHT,false);
 }

 void Hline(string objlabel,double price,color clr)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
 }


 void Vline(string objlabel,string timestr,color clr)
 //draws vertical line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_VLINE,0,StrToTime(timestr),0);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);  
 }

 void DisplayTxt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }



 //
 // SPECIAL FUNCTIONS
 //

 bool CanDoTrade()
 //checks if trading is ok via total orders, spread
 {
   bool
     equityOK=(AccountEquity()>6000),
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12);
   return (equityOK && spreadOK);
 }


 void ShowLastError()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }


 int OnInit()
 {
   tfs[0]=1;tfs[1]=5;tfs[2]=15;tfs[3]=30;tfs[4]=60;tfs[5]=240;
   return(INIT_SUCCEEDED);
 }


 void OnTick()                                        
 {
   main();
 }



 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

**** code v2 working on better traxit
 two versions 161105-1231
 | 141.50 | 20 | 2.65 |   7.07 | 79.50 | 0.78% | Einclitem=7 | Ech=1 |
 | 136.50 | 24 | 2.39 |   5.69 | 79.50 | 0.78% | Einclitem=4 | Ech=1 |
 | 122.90 |  2 | 0.00 |  61.45 | 60.90 | 0.60% | Einclitem=8 | Ech=2 |
 | 122.90 |  2 | 0.00 |  61.45 | 60.90 | 0.60% | Einclitem=7 | Ech=2 |
 | 122.90 |  2 | 0.00 |  61.45 | 60.90 | 0.60% | Einclitem=6 | Ech=2 |
 | 122.90 |  2 | 0.00 |  61.45 | 60.90 | 0.60% | Einclitem=5 | Ech=2 |
 | 122.90 |  2 | 0.00 |  61.45 | 60.90 | 0.60% | Einclitem=4 | Ech=2 |
 | 122.90 |  2 | 0.00 |  61.45 | 60.90 | 0.60% | Einclitem=2 | Ech=2 |
 | 120.00 |  1 | 0.00 | 120.00 | 60.90 | 0.60% | Einclitem=9 | Ech=2 |


 difficult to say which is better:
             case 1:             /* 50% following */
             case 2:             /* 50% stepper */

 the problem though is that 9,8 give the best results in this simplistic setup
 it is also a bit of a problem because as soon as xit, ntr in exactly the same direction

 also, don't understand why no more trades after tp is hit on nov9.
 answer: if xit through sltp, there is no reset.

 fixed somewhat by SLTP=12000 resulting in:
 | 380.70 | 35 | 2.93 |  10.88 | 301.10 | 2.86% | Einclitem=1 | Ech=1 |
 | 366.50 |  3 | 0.00 | 122.17 | 321.60 | 3.11% | Einclitem=7 | Ech=2 |
 | 366.50 |  3 | 0.00 | 122.17 | 321.60 | 3.11% | Einclitem=6 | Ech=2 |
 | 366.50 |  3 | 0.00 | 122.17 | 321.60 | 3.11% | Einclitem=4 | Ech=2 |
 | 366.50 |  3 | 0.00 | 122.17 | 321.60 | 3.11% | Einclitem=2 | Ech=2 |
 | 308.90 | 60 | 1.93 |   5.15 | 318.60 | 3.10% | Einclitem=2 | Ech=1 |
 | 285.70 | 57 | 1.83 |   5.01 | 301.10 | 2.89% | Einclitem=6 | Ech=1 |
 | 270.90 | 56 | 1.76 |   4.84 | 379.60 | 3.69% | Einclitem=4 | Ech=1 |
 | 260.20 | 64 | 1.68 |   4.07 | 367.30 | 3.58% | Einclitem=3 | Ech=1 |
 | 247.40 | 16 | 6.06 |  15.46 | 347.30 | 3.36% | Einclitem=8 | Ech=2 |
 | 247.10 | 15 | 6.04 |  16.47 | 359.60 | 3.48% | Einclitem=5 | Ech=2 |
 | 136.20 | 86 | 1.31 |   1.58 | 393.30 | 3.75% | Einclitem=7 | Ech=1 |

 however, that is a poor solution, so we find total orders for symbol being 0 to reset.
 //slines.mq4

 //DESCRIP
 /*
 use slines to determine ntrxit in 1m
 */

 //TODO
 /*
 all from 1m tf
 counting Bid and Ask for momentum direction
 figure out what happened with v3
 develop xit

 - parama (slopes for multiple lines are parallel)
 - nununu (consistency of nunu or unun can be utilized because h[] 2+,2- = n and l[] 2-,2+ = u!)
 - bodsor (short lines opposite to longer lines)

 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>



 //
 //CONSTANTS
 //
 #define sp "  "
 #define spp "    "

 #define LT 0.1
 #define SLTP 12000.0*Point
 #define TS 120



 //
 //EXTERNS
 //
 /* extern int chfin;                               /\* fin pattern choice *\/ */
 /* extern int chntrs;                              /\* ntrs criteria choice *\/ */
 /* extern double minc;                             /\* minimum incline *\/ */
 extern int Einclitem;
 extern int Ech;



 //
 //GLOBALS
 //
 int tkt=-1;                                     /* ticket number */

 double osl;                                     /* order stoploss */


 double atr12;                                   /* range calculation for 12 bars */



 //
 //STRUCTURES
 //
 struct IndicatorInfo
 //indicator block
 {
   //bodsor
   bool Lbuy,Lsel,Mbuy,Msel,Sbuy,Ssel;           /* LMS bodsor */
  
   //nununu
   bool Ln,Lu,Mn,Mu,Sm,Su;                       /* LMS nu */

   //parai
   bool lLM,mLM,sLM,lMS,mMS,sMS;                 /* llinclines */

   //inclines
   int Shs,Mhs,Lhs,Sls,Mls,Lls;                  /* LMS inclines */
  
 };

 IndicatorInfo ii;



 //
 //STRATEGY FUNCTIONS
 //

 void OnTick()
 //control center
 {
   int
     bs=-1;
  
   if(IsNewBar())                                /* get indicator info on every new bar */
     bs=IndiInfo();

   if(bs!=-1 && tkt==-1)                         /* no trade active */
     tkt=trantr(bs);                             /* try a strategy */
   else
     traxit();                                   /* use trailing exit since we have a trade */
 }


 int IndiInfo()
 //fills the slope values
 {

   /* int aords,pords;                              /\* resets if no orders *\/ */
   /* if(OrdersForSymbol(aords,pords)) */
   /*   Reset(); */

   //fill hilo slines for L(128,256,512)  M(16,32,64)  S(2,4,8)
   double hinc[10],linc[10];ArrayInitialize(hinc,0);ArrayInitialize(linc,0);
   int i,bar;
   for(i=1;i<=9;i++)                              
     {
       bar=(int)pow(2,i);
       hinc[i]=incl(bar,High[bar],1,High[1]);
       linc[i]=incl(bar,Low[bar],1,Low[1]);
       /* DrawSline(bar,l[i],Time[bar],Low[bar],Time[1],Low[1]); */
     }


   double buysel;
  
   //single sline
     int SingleSline_bs,
     inclitem=Einclitem;
   if(hinc[inclitem]>0 && linc[inclitem]>0)
     SingleSline_bs=1;
   if(hinc[inclitem]<0 && linc[inclitem]<0)
     SingleSline_bs=-1;
  
   /* Shs=(int)(round(hinc[1]+hinc[2]+hinc[3]));             /\* SML inclines *\/ */
   /* Mhs=(int)(round(hinc[4]+hinc[5]+hinc[6])); */
   /* Lhs=(int)(round(hinc[7]+hinc[8]+hinc[9])); */
   /* Sls=(int)(round(linc[1]+linc[2]+linc[3])); */
   /* Mls=(int)(round(linc[4]+linc[5]+linc[6])); */
   /* Lls=(int)(round(linc[7]+linc[8]+linc[9])); */

   /* Sn=isn(hinc[1],hinc[2],hinc[3]);                       /\* SML nus *\/ */
   /* Mn=isn(hinc[4],hinc[5],hinc[6]); */
   /* Ln=isn(hinc[7],hinc[8],hinc[9]); */
   /* Su=isu(linc[1],linc[2],linc[3]); */
   /* Mu=isu(linc[4],linc[5],linc[6]); */
   /* Lu=isu(linc[7],linc[8],linc[9]);   */
  
   /* atr12=iATR(NULL,1,12,1); */

   buysel=SingleSline_bs;

   if(buysel>0) return 0;
   if(buysel<1) return 1;
   return -1;

 }


 /* int SingleSline() */
 /* //set bs based on single sline */
 /* { */
 /*   int */
 /*     i=Ei; */
 /*   if(h[i]>0 && l[i]>0) */
 /*     return 0; */
 /*   if(h[i]<0 && l[i]<0) */
 /*     return 1; */
 /*   return -1; */
 /* } */


 void DrawSline(int bar,double inc,datetime tI,double pI,datetime tF,double pF)
 //draws sline with color
 {
   color clr;
  
   if(inc>0)
     clr=Blue;
   else
     clr=Red;

   Tline("tline"+IntegerToString(bar),tI,pI,tF,pF,clr);
 }


 bool isu(double ss,double sm,double sl)
 //finds u
 {
   return (sl<0 && sm>sl && ss>sm && ss>0);
 }


 bool isn(double ss,double sm,double sl)
 //finds n
 {
   return(sl>0 && sm<sl && ss<sm && ss<0);
 }



 //
 // UTILITY FUNCTIONS
 //

 int trantr(int bs)
 //makes a trade
 {
   switch(bs)
     {
     case 0:
       osl=Ask-TS*Point;
       return OrderSend(Symbol(),0,LT,Ask,0,Ask-SLTP,Ask+SLTP);
       break;
     case 1:
       osl=Bid+TS*Point;
       return OrderSend(Symbol(),1,LT,Bid,0,Bid+SLTP,Bid-SLTP);
       break;
     }
   return -1;
 }


 void traxit()
 //trailing xit
 {

   if(OrderSelect(tkt,SELECT_BY_TICKET))
     {
       int
         ch=Ech,
         bs=OrderType();

       if(OrderProfit()>0)
         {
           double newosl,
             trsl=0,
             oop=OrderOpenPrice(),
             dpt=fabs(Dpts(oop,Bid));

           switch(ch)
             {
             case 1:             /* 50% following */
               trsl=.3*dpt;
               break;
             case 2:             /* 50% stepper */
               if(dpt>60) trsl=30;
               if(dpt>120) trsl=60;
               if(dpt>180) trsl=90;
               if(dpt>240) trsl=120;
               if(dpt>300) trsl=150;
               if(dpt>360) trsl=180;
               break;
             default:
               break;
             }
                    
           if(trsl>=30)
             switch(bs)
               {
               case 0:
                 newosl=oop+trsl*Point;
                 if(newosl>osl) osl=newosl;
                 break;
               case 1:
                 newosl=oop-trsl*Point;
                 if(newosl<osl) osl=newosl;
                 break;
               }
         }

       if(((bs==0 && Bid<osl) || (bs==1 && Bid>osl))
          && OrderClose(tkt,LT,OrderClosePrice(),0))
         Reset();
     }
 }


 bool IsNewBar()
 //checks to see if we have a new bar
 {
   static datetime lastbartime;
   datetime
     curbartime=Time[0];
   if(lastbartime!=curbartime)
     {
       lastbartime=curbartime;
       return (true);
     }
   else
     return(false);
 }


 double maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);

   if(minbar>maxbar)
     return Dpts(minval,maxval);
   else
     return Dpts(maxval,minval);
 }


 double Dprs(double pI,double pF)
 //difference between two prices
 {
   return (pF-pI);
 }


 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }


 double incl(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf giving points per bar
 {
   int
     Dbar=bI-bF;
   return Dpts(vI,vF)/Dbar;
 }


 bool btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }


 bool TrueTurningPoint(int b,string hilo)
 //hilo is true turning point
 {
   if(hilo=="hi")
     if(High[b]>=High[b-1] && High[b]>=High[b+1])
       return true;
   if(hilo=="lo")
     if(Low[b]<=Low[b-1] && Low[b]<=Low[b+1])
       return true;
   return false;
 }


 void Reset()
 //sets various items to initial values
 {
   tkt=-1;
 }



 //
 // DISPLAY FUNCTIONS
 //

 void Tline(string objlabel,datetime t1,double p1,datetime t2,double p2,color clr)
 //draws trend line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_TREND,0,t1,p1,t2,p2,clr);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
   ObjectSet(objlabel,OBJPROP_RAY_RIGHT,false);
 }


 void Hline(string objlabel,double price,color clr)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
 }


 void Vline(string objlabel,string timestr,color clr)
 //draws vertical line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_VLINE,0,StrToTime(timestr),0);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);  
 }


 void DisplayTxt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }



 //
 // SPECIAL FUNCTIONS
 //

 bool CanDoTrade()
 //checks if trading is ok via total orders, spread
 {
   bool
     equityOK=(AccountEquity()>6000),
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12);
   return (equityOK && spreadOK);
 }


 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
 {
   aords=0;pords=0;
   for(int p=OrdersTotal()-1;p>=0;p--)
     if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
       {
         if(OrderType()>1 && OrderType()<6)
           pords++;
         if(OrderType()==OP_BUY || OrderType()==OP_SELL)
           aords++;
       }
   return aords+pords;
 }


 void ShowLastError()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }


 int OnInit() {return(INIT_SUCCEEDED);}


 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

 attempt at a symmetrical trailing stop which may or may not be a good idea:
 void traxit()
 //trailing xit
 {
   if(OrderSelect(tkt,SELECT_BY_TICKET))
     {
       int bssign=0,
         bs=OrderType();

       double newosl,
         pr=Bid,
         oop=OrderOpenPrice(),
         dpt=Dpts(oop,pr);


       switch(bs)
         {
         case 0:
           if(dpt>+TRACTIVATION)
             {
               newosl=pr-TRSL;
               if(newosl>osl)
                 osl=newosl;
             }
           else
             if(dpt<-TRACTIVATION)
               otp=pr-TRSL;
           break;
         case 1:
           if(dpt<-TRACTIVATION)
             {
               newosl=pr+TRSL;
               if(newosl<osl)
                 osl=newosl;
             }
           else
             if(dpt>+TRACTIVATION)
               otp=pr+TRSL;
           break;
         }

       bool
         Buyxit=(bs==0 && ((dpt>0 && pr<osl) || (dpt<0 && pr>otp))),
         Selxit=(bs==1 && ((dpt<0 && pr>osl) || (dpt>0 && pr<otp)));

       if(Buyxit || Selxit)
         if(OrderClose(tkt,LT,OrderClosePrice(),0))
           Reset();
     }

 }


**** code v3 trying better solution for the sltp situation resulting in fascinating occurence
 | 14345.50 | 808 | 1.42 | 17.75 | 13050.10 | 38.74% | Ei=6 | Ech=1 |
 | 14147.80 | 831 | 1.41 | 17.03 | 12773.40 | 38.73% | Ei=6 | Ech=2 |
 | 12695.20 | 826 | 1.33 | 15.37 | 13505.90 | 38.55% | Ei=7 | Ech=1 |
 | 11814.80 | 841 | 1.30 | 14.05 | 12991.40 | 38.84% | Ei=7 | Ech=2 |
 | 10013.30 | 656 | 1.35 | 15.26 | 14149.80 | 59.56% | Ei=9 | Ech=2 |
 |  6086.60 | 731 | 1.17 |  8.33 |  7953.50 | 36.82% | Ei=5 | Ech=1 |
 |  5668.90 | 637 | 1.18 |  8.90 | 13674.10 | 58.72% | Ei=8 | Ech=2 |
 |  5447.90 | 613 | 1.18 |  8.89 | 13680.80 | 58.75% | Ei=8 | Ech=1 |
 |  5289.50 | 606 | 1.17 |  8.73 | 14150.30 | 59.56% | Ei=9 | Ech=1 |
 |  4495.20 | 739 | 1.12 |  6.08 |  7646.90 | 38.83% | Ei=5 | Ech=2 |
 |  3070.90 | 639 | 1.09 |  4.81 |  2040.60 | 20.14% | Ei=4 | Ech=1 |

 probably worth investigating.

 //nusline.mq4

 //DESCRIP
 /*

 */

 //TODO
 /*
 develop xit

 use slines to determine trend
 form nu based on distance from any extremity beyond atr

 since we don't really know how to use slines start doing things simply and develop understanding
 1. single sline results
 2. SML sline combos
 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>

 //////////////////////////////////////////////////////////////

 //
 //CONSTANTS
 //
 #define sp "  "
 #define spp "    "

 #define LT 0.1
 #define SLTP 1200.0*Point
 #define TS 120



 //
 //EXTERNS
 //
 /* extern int chfin;                               /\* fin pattern choice *\/ */
 /* extern int chntrs;                              /\* ntrs criteria choice *\/ */
 /* extern double minc;                             /\* minimum incline *\/ */
 extern int Ei;
 extern int Ech;


 //
 //GLOBALS
 //
 int tfs[6];                                     /* timeframes */
 int tkt=-1;                                     /* ticket number */

 double h[10],l[10];                             /* hilo incline arrays from 1-9 for 2^x bars */
 double osl;                                     /* order stoploss */

 int Shs,Mhs,Lhs,Sls,Mls,Lls;                    /* SML inclines */
 bool Su,Sn,Mu,Mn,Lu,Ln;                         /* SML nu */
 double atr12;                                   /* range calculation for 12 bars */


 //
 //STRATEGY FUNCTIONS
 //

 void main()
 //control center
 {
   int
     bs=-1;
  
   if(IsNewBar())                                /* get indicator info on every new bar */
     IndiInfo();

   bs=SingleSline();
  
   if(bs!=-1 && tkt==-1)                         /* no trade active */
     tkt=trantr(bs);                             /* try a strategy */
   else
     traxit();                                   /* use trailing exit since we have a trade */
 }

 int SingleSline()
 //set bs based on single sline
 {
   int
     i=Ei;
   if(h[i]>0 && l[i]>0)
     return 0;
   if(h[i]<0 && l[i]<0)
     return 1;
   return -1;
 }

 void IndiInfo()
 //fills the slope values
 {
   int aords,pords;                              /* resets if no orders */
   if(OrdersForSymbol(aords,pords))
     Reset();

   int i,bar;

   for(i=1;i<=9;i++)                              /* slines for S(2,4,8)  M(16,32,64)  L(128,256,512) */
     {
       bar=(int)pow(2,i);
       h[i]=incl(bar,High[bar],1,High[1]);
       l[i]=incl(bar,Low[bar],1,Low[1]);
       //      if(l[i]>0) clr=Blue; else clr=Red;
       //Tline("tline"+IntegerToString(bar),Time[bar],Low[bar],Time[1],Low[1],clr);
     }

  
   Shs=(int)(round(h[1]+h[2]+h[3]));             /* SML inclines */
   Mhs=(int)(round(h[4]+h[5]+h[6]));
   Lhs=(int)(round(h[7]+h[8]+h[9]));
   Sls=(int)(round(l[1]+l[2]+l[3]));
   Mls=(int)(round(l[4]+l[5]+l[6]));
   Lls=(int)(round(l[7]+l[8]+l[9]));

   Sn=isn(h[1],h[2],h[3]);                       /* SML nus */
   Mn=isn(h[4],h[5],h[6]);
   Ln=isn(h[7],h[8],h[9]);
   Su=isu(l[1],l[2],l[3]);
   Mu=isu(l[4],l[5],l[6]);
   Lu=isu(l[7],l[8],l[9]);  
  
   atr12=iATR(NULL,1,12,1);

 }


 bool isu(double ss,double sm,double sl)
 //finds u
 {
   return (sl<0 && sm>sl && ss>sm && ss>0);
 }

 bool isn(double ss,double sm,double sl)
 //finds n
 {
   return(sl>0 && sm<sl && ss<sm && ss<0);
 }

 //
 // UTILITY FUNCTIONS
 //

 int trantr(int bs)
 //makes a trade
 {
   switch(bs)
     {
     case 0:
       osl=Ask-TS*Point;
       return OrderSend(Symbol(),0,LT,Ask,0,Ask-SLTP,Ask+SLTP);
       break;
     case 1:
       osl=Bid+TS*Point;
       return OrderSend(Symbol(),1,LT,Bid,0,Bid+SLTP,Bid-SLTP);
       break;
     }
   return -1;
 }


 void traxit()
 //trailing xit
 {

   if(OrderSelect(tkt,SELECT_BY_TICKET))
     {
       int
         ch=Ech,
         bs=OrderType();

       if(OrderProfit()>0)
         {
           double newosl,
             trsl=0,
             oop=OrderOpenPrice(),
             dpt=fabs(Dpts(oop,Bid));

           switch(ch)
             {
             case 1:             /* 50% following */
               trsl=.3*dpt;
               break;
             case 2:             /* 50% stepper */
               if(dpt>60) trsl=30;
               if(dpt>120) trsl=60;
               if(dpt>180) trsl=90;
               if(dpt>240) trsl=120;
               if(dpt>300) trsl=150;
               if(dpt>360) trsl=180;
               break;
             default:
               break;
             }
                    
           if(trsl>=30)
             switch(bs)
               {
               case 0:
                 newosl=oop+trsl*Point;
                 if(newosl>osl) osl=newosl;
                 break;
               case 1:
                 newosl=oop-trsl*Point;
                 if(newosl<osl) osl=newosl;
                 break;
               }
         }

       if(((bs==0 && Bid<osl) || (bs==1 && Bid>osl))
          && OrderClose(tkt,LT,OrderClosePrice(),0))
         Reset();
     }
 }


 bool IsNewBar()
 //checks to see if we have a new bar
 {
   static datetime lastbartime;
   datetime
     curbartime=Time[0];
   if(lastbartime!=curbartime)
     {
       lastbartime=curbartime;
       return (true);
     }
   else
     return(false);
 }


 double maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);

   if(minbar>maxbar)
     return Dpts(minval,maxval);
   else
     return Dpts(maxval,minval);
 }


 double Dprs(double pI,double pF)
 //difference between two prices
 {
   return (pF-pI);
 }


 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }


 double incl(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf giving points per bar
 {
   int
     Dbar=bI-bF;
   return Dpts(vI,vF)/Dbar;
 }


 bool btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }


 bool TrueTurningPoint(int b,string hilo)
 //hilo is true turning point
 {
   if(hilo=="hi")
     if(High[b]>=High[b-1] && High[b]>=High[b+1])
       return true;
   if(hilo=="lo")
     if(Low[b]<=Low[b-1] && Low[b]<=Low[b+1])
       return true;
   return false;
 }


 void Reset()
 //sets various items to initial values
 {
   tkt=-1;
 }



 //
 // DISPLAY FUNCTIONS
 //

 void Tline(string objlabel,datetime t1,double p1,datetime t2,double p2,color clr)
 //draws trend line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_TREND,0,t1,p1,t2,p2,clr);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
   ObjectSet(objlabel,OBJPROP_RAY_RIGHT,false);
 }

 void Hline(string objlabel,double price,color clr)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
 }


 void Vline(string objlabel,string timestr,color clr)
 //draws vertical line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_VLINE,0,StrToTime(timestr),0);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);  
 }

 void DisplayTxt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }



 //
 // SPECIAL FUNCTIONS
 //

 bool CanDoTrade()
 //checks if trading is ok via total orders, spread
 {
   bool
     equityOK=(AccountEquity()>6000),
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12);
   return (equityOK && spreadOK);
 }


 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
 {
   aords=0;pords=0;
   for(int p=OrdersTotal()-1;p>=0;p--)
     if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
       {
         if(OrderType()>1 && OrderType()<6)
           pords++;
         if(OrderType()==OP_BUY || OrderType()==OP_SELL)
           aords++;
       }
   return aords+pords;
 }


 void ShowLastError()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }


 int OnInit()
 {
   tfs[0]=1;tfs[1]=5;tfs[2]=15;tfs[3]=30;tfs[4]=60;tfs[5]=240;
   return(INIT_SUCCEEDED);
 }


 void OnTick()                                        
 {
   main();
 }



 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

**** code v4 another interesting accident where we never get a losing trade
 the problem is that it never hits sl when losing - hits only when winning
 still it seems remarkable that we have such high profits min $100.
 additionally, there were no losses except on the final trade which never completed
 | 301.90 | 108 | 5.52 |   2.80 | 104.80 | 1.01% | Einclitem=1 | Edptmult=1   | Ech=0 |
 | 251.80 |  60 | 4.77 |   4.20 | 107.90 | 1.06% | Einclitem=7 | Edptmult=0.6 | Ech=0 |
 | 248.10 |  90 | 4.71 |   2.76 | 107.70 | 1.06% | Einclitem=8 | Edptmult=0.9 | Ech=0 |
 | 248.10 |  90 | 4.71 |   2.76 | 107.70 | 1.06% | Einclitem=7 | Edptmult=0.9 | Ech=0 |
 | 248.10 |  90 | 4.71 |   2.76 | 107.70 | 1.06% | Einclitem=6 | Edptmult=0.9 | Ech=0 |
 | 248.10 |  90 | 4.71 |   2.76 | 107.70 | 1.06% | Einclitem=5 | Edptmult=0.9 | Ech=0 |
 | 248.10 |  90 | 4.71 |   2.76 | 107.70 | 1.06% | Einclitem=4 | Edptmult=0.9 | Ech=0 |
 | 248.10 |  90 | 4.71 |   2.76 | 107.70 | 1.06% | Einclitem=3 | Edptmult=0.9 | Ech=0 |
 | 247.70 |  91 | 4.71 |   2.72 | 107.40 | 1.06% | Einclitem=8 | Edptmult=1   | Ech=0 |
 | 247.70 |  91 | 4.71 |   2.72 | 107.40 | 1.06% | Einclitem=7 | Edptmult=1   | Ech=0 |
 | 247.70 |  91 | 4.71 |   2.72 | 107.40 | 1.06% | Einclitem=6 | Edptmult=1   | Ech=0 |
 | 247.70 |  91 | 4.71 |   2.72 | 107.40 | 1.06% | Einclitem=5 | Edptmult=1   | Ech=0 |
 | 247.70 |  91 | 4.71 |   2.72 | 107.40 | 1.06% | Einclitem=4 | Edptmult=1   | Ech=0 |
 | 247.70 |  91 | 4.71 |   2.72 | 107.40 | 1.06% | Einclitem=3 | Edptmult=1   | Ech=0 |
 | 244.80 |  58 | 4.66 |   4.22 | 107.90 | 1.06% | Einclitem=8 | Edptmult=0.6 | Ech=0 |
 | 244.80 |  58 | 4.66 |   4.22 | 107.90 | 1.06% | Einclitem=6 | Edptmult=0.6 | Ech=0 |
 | 244.80 |  58 | 4.66 |   4.22 | 107.90 | 1.06% | Einclitem=5 | Edptmult=0.6 | Ech=0 |
 | 243.60 |  89 | 4.65 |   2.74 | 104.80 | 1.02% | Einclitem=1 | Edptmult=0.9 | Ech=0 |
 | 241.40 |   1 | 0.00 | 241.40 | 109.30 | 1.06% | Einclitem=9 | Edptmult=0.1 | Ech=0 |
 | 241.40 |   1 | 0.00 | 241.40 | 109.30 | 1.06% | Einclitem=1 | Edptmult=0.1 | Ech=0 |
 | 241.10 |  77 | 4.61 |   3.13 | 107.40 | 1.06% | Einclitem=8 | Edptmult=0.8 | Ech=0 |
 | 241.10 |  77 | 4.61 |   3.13 | 107.40 | 1.06% | Einclitem=7 | Edptmult=0.8 | Ech=0 |
 | 241.10 |  77 | 4.61 |   3.13 | 107.40 | 1.06% | Einclitem=6 | Edptmult=0.8 | Ech=0 |
 | 241.10 |  77 | 4.61 |   3.13 | 107.40 | 1.06% | Einclitem=5 | Edptmult=0.8 | Ech=0 |
 | 241.10 |  77 | 4.61 |   3.13 | 107.40 | 1.06% | Einclitem=4 | Edptmult=0.8 | Ech=0 |
 | 241.10 |  77 | 4.61 |   3.13 | 107.40 | 1.06% | Einclitem=3 | Edptmult=0.8 | Ech=0 |
 | 241.00 |  87 | 4.61 |   2.77 | 107.70 | 1.06% | Einclitem=9 | Edptmult=0.9 | Ech=0 |
 | 237.40 |  58 | 4.55 |   4.09 | 107.90 | 1.06% | Einclitem=9 | Edptmult=0.6 | Ech=0 |
 | 237.30 |  88 | 4.55 |   2.70 | 107.40 | 1.06% | Einclitem=9 | Edptmult=1   | Ech=0 |
 | 234.50 |  75 | 4.51 |   3.13 | 107.40 | 1.06% | Einclitem=9 | Edptmult=0.8 | Ech=0 |
 | 234.40 |  69 | 4.51 |   3.40 | 107.30 | 1.06% | Einclitem=8 | Edptmult=0.7 | Ech=0 |
 | 234.40 |  69 | 4.51 |   3.40 | 107.30 | 1.06% | Einclitem=7 | Edptmult=0.7 | Ech=0 |
 | 234.40 |  69 | 4.51 |   3.40 | 107.30 | 1.06% | Einclitem=6 | Edptmult=0.7 | Ech=0 |
 | 234.40 |  69 | 4.51 |   3.40 | 107.30 | 1.06% | Einclitem=5 | Edptmult=0.7 | Ech=0 |
 | 229.90 |  53 | 4.41 |   4.34 | 109.90 | 1.09% | Einclitem=8 | Edptmult=0.5 | Ech=0 |
 | 229.20 |  69 | 4.43 |   3.32 | 107.30 | 1.06% | Einclitem=9 | Edptmult=0.7 | Ech=0 |
 | 218.50 |  51 | 4.24 |   4.28 | 109.90 | 1.09% | Einclitem=9 | Edptmult=0.5 | Ech=0 |
 | 190.20 |  60 | 4.00 |   3.17 | 139.80 | 1.36% | Einclitem=4 | Edptmult=0.7 | Ech=0 |
 | 171.10 |  34 | 3.73 |   5.03 | 167.00 | 1.63% | Einclitem=9 | Edptmult=0.4 | Ech=0 |
 | 113.90 |  46 | 2.76 |   2.48 | 139.80 | 1.37% | Einclitem=1 | Edptmult=0.8 | Ech=0 |
 | 100.90 |  41 | 2.43 |   2.46 | 144.60 | 1.42% | Einclitem=3 | Edptmult=0.7 | Ech=0 |


 //slines.mq4

 //DESCRIP
 /*
 use slines to determine ntrxit in 1m
 */

 //TODO
 /*
 symmetrical xit
 all from 1m tf
 counting Bid and Ask for momentum direction
 figure out what happened with v3
 develop xit

 - parama (slopes for multiple lines are parallel)
 - nununu (consistency of nunu or unun can be utilized because h[] 2+,2- = n and l[] 2-,2+ = u!)
 - bodsor (short lines opposite to longer lines)

 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>



 //
 //CONSTANTS
 //
 #define sp "  "
 #define spp "    "

 #define LT 0.1
 #define SLTP 12000.0*Point
 #define TS 60



 //
 //EXTERNS
 //
 /* extern int chfin;                               /\* fin pattern choice *\/ */
 /* extern int chntrs;                              /\* ntrs criteria choice *\/ */
 /* extern double minc;                             /\* minimum incline *\/ */
 extern int Einclitem;
 extern int Ech;
 extern double Edptmult;



 //
 //GLOBALS
 //
 int tkt=-1;                                     /* ticket number */
 double osl;                                     /* order stoploss */

 double atr12;                                   /* range calculation for 12 bars */



 //
 //STRUCTURES
 //
 struct IndicatorInfo
 //indicator block
 {
   //bodsor
   bool Lbuy,Lsel,Mbuy,Msel,Sbuy,Ssel;           /* LMS bodsor */
  
   //nununu
   bool Ln,Lu,Mn,Mu,Sm,Su;                       /* LMS nu */

   //parai
   bool lLM,mLM,sLM,lMS,mMS,sMS;                 /* llinclines */

   //inclines
   int Shs,Mhs,Lhs,Sls,Mls,Lls;                  /* LMS inclines */
  
 };

 IndicatorInfo ii;



 //
 //STRATEGY FUNCTIONS
 //

 void OnTick()
 //main center
 {
   int
     bs=-1;
  
   if(IsNewBar())                                /* get indicator info on every new bar */
     bs=IndiInfo();

   if(bs!=-1 && tkt==-1)                         /* no trade active */
     tkt=trantr(bs);                             /* try a strategy */
   else
     traxit();                                   /* use trailing exit since we have a trade */
 }


 int IndiInfo()
 //fills the slope values
 {

   /* int aords,pords;                              /\* resets if no orders *\/ */
   /* if(OrdersForSymbol(aords,pords)) */
   /*   Reset(); */

   //fill hilo slines for L(128,256,512)  M(16,32,64)  S(2,4,8)
   double hinc[10],linc[10];ArrayInitialize(hinc,0);ArrayInitialize(linc,0);
   int i,bar;
   for(i=1;i<=9;i++)                              
     {
       bar=(int)pow(2,i);
       hinc[i]=incl(bar,High[bar],1,High[1]);
       linc[i]=incl(bar,Low[bar],1,Low[1]);
       /* DrawSline(bar,l[i],Time[bar],Low[bar],Time[1],Low[1]); */
     }


  
   //single sline
     int
       SingleSline_bs=0,
       inclitem=Einclitem;
   if(hinc[inclitem]>0 && linc[inclitem]>0)
     SingleSline_bs=1;
   if(hinc[inclitem]<0 && linc[inclitem]<0)
     SingleSline_bs=-1;
  
   /* Shs=(int)(round(hinc[1]+hinc[2]+hinc[3]));             /\* SML inclines *\/ */
   /* Mhs=(int)(round(hinc[4]+hinc[5]+hinc[6])); */
   /* Lhs=(int)(round(hinc[7]+hinc[8]+hinc[9])); */
   /* Sls=(int)(round(linc[1]+linc[2]+linc[3])); */
   /* Mls=(int)(round(linc[4]+linc[5]+linc[6])); */
   /* Lls=(int)(round(linc[7]+linc[8]+linc[9])); */

   /* Sn=isn(hinc[1],hinc[2],hinc[3]);                       /\* SML nus *\/ */
   /* Mn=isn(hinc[4],hinc[5],hinc[6]); */
   /* Ln=isn(hinc[7],hinc[8],hinc[9]); */
   /* Su=isu(linc[1],linc[2],linc[3]); */
   /* Mu=isu(linc[4],linc[5],linc[6]); */
   /* Lu=isu(linc[7],linc[8],linc[9]);   */
  
   /* atr12=iATR(NULL,1,12,1); */

   double
     buysel=SingleSline_bs;

   if(buysel>0) return 0;
   if(buysel<1) return 1;
   return -1;

 }


 void DrawSline(int bar,double inc,datetime tI,double pI,datetime tF,double pF)
 //draws sline with color
 {
   color clr;
  
   if(inc>0)
     clr=Blue;
   else
     clr=Red;

   Tline("tline"+IntegerToString(bar),tI,pI,tF,pF,clr);
 }


 bool isu(double ss,double sm,double sl)
 //finds u
 {
   return (sl<0 && sm>sl && ss>sm && ss>0);
 }


 bool isn(double ss,double sm,double sl)
 //finds n
 {
   return(sl>0 && sm<sl && ss<sm && ss<0);
 }



 //
 // UTILITY FUNCTIONS
 //

 int trantr(int bs)
 //makes a trade
 {
   switch(bs)
     {
     case 0:
       osl=Ask-TS*Point;
       return OrderSend(Symbol(),0,LT,Ask,0,Ask-SLTP,Ask+SLTP);
       break;
     case 1:
       osl=Bid+TS*Point;
       return OrderSend(Symbol(),1,LT,Bid,0,Bid+SLTP,Bid-SLTP);
       break;
     }
   return -1;
 }


 void traxit()
 //trailing xit
 {

   if(OrderSelect(tkt,SELECT_BY_TICKET))
     {
       bool
         InProfit=(OrderProfit()>0);
       int
         stepfactor=0,
         ch=1,
         bs=OrderType();
       double newosl,
         tratp=0,
         trasl=0,
         oop=OrderOpenPrice(),
         dpt=fabs(Dpts(oop,Bid));

       if(InProfit)                       /* profit is +ve */
         {
           switch(ch)
             {
             case 1:             /* 50% following */
               trasl=Edptmult*dpt;
               break;
             case 2:             /* 50% stepper */
               stepfactor=0;
               while(dpt<stepfactor*60)
                 stepfactor++;
               trasl=dpt/2;
              
              
               /* if(dpt>60) trasl=30; */
               /* if(dpt>120) trasl=60; */
               /* if(dpt>180) trasl=90; */
               /* if(dpt>240) trasl=120; */
               /* if(dpt>300) trasl=150; */
               /* if(dpt>360) trasl=dpt/2; */
               break;
             }
                    
           if(trasl>=30)
             switch(bs)
               {
               case 0:
                 newosl=oop+trasl*Point;
                 if(newosl>osl) osl=newosl;
                 break;
               case 1:
                 newosl=oop-trasl*Point;
                 if(newosl<osl) osl=newosl;
                 break;
               }
         }
       else                                      /* profit is -ve */
           if(dpt>60) tratp=30;
       Hline("osl",osl,Red);
       bool
         Buytrasl=(InProfit && bs==0 && Bid<osl),
         Seltrasl=(InProfit && bs==1 && Bid>osl),
         Buytratp=(!InProfit && bs==0 && btn(oop,Bid,oop-tratp*Point)),
         Seltratp=(!InProfit && bs==1 && btn(oop,Bid,oop+tratp*Point));


       if((Buytrasl || Seltrasl) // || Buytratp || Seltratp)
          && OrderClose(tkt,LT,OrderClosePrice(),0))
         Reset();
     }
 }


 bool IsNewBar()
 //checks to see if we have a new bar
 {
   static datetime lastbartime;
   datetime
     curbartime=Time[0];
   if(lastbartime!=curbartime)
     {
       lastbartime=curbartime;
       return (true);
     }
   else
     return(false);
 }


 double maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);

   if(minbar>maxbar)
     return Dpts(minval,maxval);
   else
     return Dpts(maxval,minval);
 }


 double Dprs(double pI,double pF)
 //difference between two prices
 {
   return (pF-pI);
 }


 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }


 double incl(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf giving points per bar
 {
   int
     Dbar=bI-bF;
   return Dpts(vI,vF)/Dbar;
 }


 bool btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }


 bool TrueTurningPoint(int b,string hilo)
 //hilo is true turning point
 {
   if(hilo=="hi")
     if(High[b]>=High[b-1] && High[b]>=High[b+1])
       return true;
   if(hilo=="lo")
     if(Low[b]<=Low[b-1] && Low[b]<=Low[b+1])
       return true;
   return false;
 }


 void Reset()
 //sets various items to initial values
 {
   tkt=-1;
 }



 //
 // DISPLAY FUNCTIONS
 //

 void Tline(string objlabel,datetime t1,double p1,datetime t2,double p2,color clr)
 //draws trend line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_TREND,0,t1,p1,t2,p2,clr);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
   ObjectSet(objlabel,OBJPROP_RAY_RIGHT,false);
 }


 void Hline(string objlabel,double price,color clr)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
 }


 void Vline(string objlabel,string timestr,color clr)
 //draws vertical line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_VLINE,0,StrToTime(timestr),0);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);  
 }


 void DisplayTxt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }



 //
 // SPECIAL FUNCTIONS
 //

 bool CanDoTrade()
 //checks if trading is ok via total orders, spread
 {
   bool
     equityOK=(AccountEquity()>6000),
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12);
   return (equityOK && spreadOK);
 }


 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
 {
   aords=0;pords=0;
   for(int p=OrdersTotal()-1;p>=0;p--)
     if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
       {
         if(OrderType()>1 && OrderType()<6)
           pords++;
         if(OrderType()==OP_BUY || OrderType()==OP_SELL)
           aords++;
       }
   return aords+pords;
 }


 void ShowLastError()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }


 int OnInit() {return(INIT_SUCCEEDED);}


 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

**** code v5 clean program with only incl as indicator w
 so far we have parama, nununu, bodsor. there are likely some others.


 if we have large sl and trsl we get decent results over 2mo

 SLTP 12000
 INITSL 600
 TRSL 600
 TRACT 300

 | 620.90 | 31 | 2.28 | 20.03 | 312.70 | 3.09% | Einclitem=1 |
 | 500.80 | 31 | 1.99 | 16.15 | 294.50 | 2.91% | Einclitem=9 |
 | 185.90 | 35 | 1.24 |  5.31 | 455.60 | 4.55% | Einclitem=3 |
 | 183.90 | 35 | 1.23 |  5.25 | 457.60 | 4.57% | Einclitem=4 |
 | 183.40 | 35 | 1.23 |  5.24 | 457.60 | 4.57% | Einclitem=2 |
 |  83.80 | 36 | 1.10 |  2.33 | 312.70 | 3.12% | Einclitem=8 |
 |  56.60 | 36 | 1.06 |  1.57 | 457.60 | 4.57% | Einclitem=5 |

 this may be a good starting point.
 interesting that 1 and 9 produced the best results!

 varying the sl parameters produces reasonable results:

 | 573.00 |  31 | 1.95 | 18.48 | 231.20 | 2.16% | Einclitem=3 | INITSL=300  | TRSL=200 | TRACT=1200 |
 | 554.50 |  22 | 2.02 | 25.20 | 272.10 | 2.53% | Einclitem=5 | INITSL=600  | TRSL=400 | TRACT=1000 |
 | 524.80 |  41 | 1.52 | 12.80 | 293.80 | 2.73% | Einclitem=2 | INITSL=500  | TRSL=200 | TRACT=800  |
 | 523.40 | 115 | 1.36 |  4.55 | 235.70 | 2.33% | Einclitem=3 | INITSL=200  | TRSL=300 | TRACT=500  |
 | 494.40 |  67 | 1.50 |  7.38 | 296.10 | 2.80% | Einclitem=8 | INITSL=300  | TRSL=400 | TRACT=400  |
 | 373.90 |  24 | 1.55 | 15.58 | 232.90 | 2.33% | Einclitem=5 | INITSL=1200 | TRSL=300 | TRACT=600  |
 | 370.80 |  86 | 1.25 |  4.31 | 221.80 | 2.14% | Einclitem=3 | INITSL=300  | TRSL=200 | TRACT=500  |
 | 362.50 |  23 | 1.79 | 15.76 | 284.20 | 2.68% | Einclitem=1 | INITSL=600  | TRSL=700 | TRACT=600  |
 | 341.20 |  59 | 1.30 |  5.78 | 247.70 | 2.35% | Einclitem=7 | INITSL=500  | TRSL=300 | TRACT=400  |
 | 339.20 |  15 | 1.59 | 22.61 | 332.70 | 3.29% | Einclitem=5 | INITSL=1000 | TRSL=300 | TRACT=900  |


 //slines.mq4

 //DESCRIP
 /*
 use slines to determine ntrxit in 1m
 */

 //TODO
 /*
 redo traxit with symmetrical xit and bs differences
 all from 1m tf
 counting Bid and Ask for momentum direction
 figure out what happened with v3
 develop xit

 - parama (slopes for multiple lines are parallel)
 - nununu (consistency of nunu or unun can be utilized because h[] 2+,2- = n and l[] 2-,2+ = u!)
 - bodsor (short lines opposite to longer lines)

 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>



 //
 //CONSTANTS
 //
 #define sp "  "
 #define spp "    "

 #define LT 0.1                                  /* lotsize */
 #define SLTP 12000                              /* fixed stoploss takeprof limits */
 #define INITSL 600                              /* initial stoploss */
 #define TRSL 600                                /* trailing stoploss distance */
 #define TRACT 300                               /* trailer activation */



 //
 //EXTERNS
 //
 extern int Einclitem;



 //
 //GLOBALS
 //
 int tkt=-1;                                     /* ticket number */
 double osl;                                     /* order stoploss */



 //
 //STRUCTURES
 //
 struct IndicatorInfo
 //indicator block
 {
   //bodsor
   bool Lbuy,Lsel,Mbuy,Msel,Sbuy,Ssel;           /* LMS bodsor */
  
   //nununu
   bool Ln,Lu,Mn,Mu,Sm,Su;                       /* LMS nu */

   //parai
   bool lLM,mLM,sLM,lMS,mMS,sMS;                 /* llinclines */

   //inclines
   int Shs,Mhs,Lhs,Sls,Mls,Lls;                  /* LMS inclines */
  
 };

 IndicatorInfo ii;



 //
 //STRATEGY FUNCTIONS
 //

 void OnTick()
 //main center
 {
   int
     bs=-1;
  
   if(IsNewBar())                                /* get indicator info on every new bar */
     bs=IndiInfo();

   if(bs!=-1 && tkt==-1)                         /* trade recommended and no trade already active */
     tkt=trantr(bs);                             /* try a strategy */
   else
     traxit();                                   /* use trailing exit since we have a trade */
 }


 int IndiInfo()
 //fills the slope values
 {

   /* int aords,pords;                              /\* resets if no orders *\/ */
   /* if(OrdersForSymbol(aords,pords)) */
   /*   Reset(); */

   //fill hilo slines for L(128,256,512)  M(16,32,64)  S(2,4,8)
   double hinc[10],linc[10];ArrayInitialize(hinc,0);ArrayInitialize(linc,0);
   int i,bar;
   for(i=1;i<=9;i++)                              
     {
       bar=(int)pow(2,i);
       hinc[i]=incl(bar,High[bar],1,High[1]);
       linc[i]=incl(bar,Low[bar],1,Low[1]);
       /* DrawSline(bar,l[i],Time[bar],Low[bar],Time[1],Low[1]); */
     }


  
   //single sline
     int
       SingleSline_bs=0,
       inclitem=Einclitem;
   if(hinc[inclitem]>0 && linc[inclitem]>0)
     SingleSline_bs=1;
   if(hinc[inclitem]<0 && linc[inclitem]<0)
     SingleSline_bs=-1;
  
   /* Shs=(int)(round(hinc[1]+hinc[2]+hinc[3]));             /\* SML inclines *\/ */
   /* Mhs=(int)(round(hinc[4]+hinc[5]+hinc[6])); */
   /* Lhs=(int)(round(hinc[7]+hinc[8]+hinc[9])); */
   /* Sls=(int)(round(linc[1]+linc[2]+linc[3])); */
   /* Mls=(int)(round(linc[4]+linc[5]+linc[6])); */
   /* Lls=(int)(round(linc[7]+linc[8]+linc[9])); */

   /* Sn=isn(hinc[1],hinc[2],hinc[3]);                       /\* SML nus *\/ */
   /* Mn=isn(hinc[4],hinc[5],hinc[6]); */
   /* Ln=isn(hinc[7],hinc[8],hinc[9]); */
   /* Su=isu(linc[1],linc[2],linc[3]); */
   /* Mu=isu(linc[4],linc[5],linc[6]); */
   /* Lu=isu(linc[7],linc[8],linc[9]);   */
  
   /* atr12=iATR(NULL,1,12,1); */

   double
     buysel=SingleSline_bs;
  
   if(buysel>0) return 0;
   if(buysel<0) return 1;
   return -1;

 }


 void DrawSline(int bar,double inc,datetime tI,double pI,datetime tF,double pF)
 //draws sline with color
 {
   color clr;
  
   if(inc>0)
     clr=Blue;
   else
     clr=Red;

   Tline("tline"+IntegerToString(bar),tI,pI,tF,pF,clr);
 }


 bool isu(double ss,double sm,double sl)
 //finds u
 {
   return (sl<0 && sm>sl && ss>sm && ss>0);
 }


 bool isn(double ss,double sm,double sl)
 //finds n
 {
   return(sl>0 && sm<sl && ss<sm && ss<0);
 }



 //
 // UTILITY FUNCTIONS
 //

 void traxit()
 //trailing xit
 {
   if(OrderSelect(tkt,SELECT_BY_TICKET))
     {
       int bssign=0,
         bs=OrderType();

       double newosl,
         pr=Bid,
         oop=OrderOpenPrice(),
         dpt=Dpts(oop,pr);

       Comment(TRACT,sp,dpt);
       switch(bs)
         {
         case 0:
           if(dpt>+TRACT)
             {
               newosl=pr-TRSL*Point;
               if(newosl>osl)
                 osl=newosl;
             }
           break;
         case 1:
           if(dpt<-TRACT)
             {
               newosl=pr+TRSL*Point;
               if(newosl<osl)
                 osl=newosl;
             }
           break;
         }
 Hline("osl",osl,Red);
       bool
         Buyxit=(bs==0 && pr<osl),
         Selxit=(bs==1 && pr>osl);

       if(Buyxit || Selxit)
         if(OrderClose(tkt,LT,OrderClosePrice(),0))
           Reset();
     }
 }


 int trantr(int bs)
 //makes a trade
 {
   double oo=0,sl=0,tp=0;
  
   switch(bs)
     {
     case 0:
       osl=Ask-INITSL*Point;
       oo=Ask;
       sl=oo-SLTP*Point;
       tp=oo+SLTP*Point;
       break;
     case 1:
       osl=Bid+INITSL*Point;
       oo=Bid;
       sl=oo+SLTP*Point;
       tp=oo-SLTP*Point;
       break;
     }
   return OrderSend(Symbol(),bs,LT,oo,0,sl,tp);
 }


 bool IsNewBar()
 //checks to see if we have a new bar
 {
   static datetime lastbartime;
   datetime
     curbartime=Time[0];
   if(lastbartime!=curbartime)
     {
       lastbartime=curbartime;
       return (true);
     }
   else
     return(false);
 }


 double maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);

   if(minbar>maxbar)
     return Dpts(minval,maxval);
   else
     return Dpts(maxval,minval);
 }


 double Dprs(double pI,double pF)
 //difference between two prices
 {
   return (pF-pI);
 }


 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }


 double incl(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf giving points per bar
 {
   int
     Dbar=bI-bF;
   return Dpts(vI,vF)/Dbar;
 }


 bool btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }


 bool TrueTurningPoint(int b,string hilo)
 //hilo is true turning point
 {
   if(hilo=="hi")
     if(High[b]>=High[b-1] && High[b]>=High[b+1])
       return true;
   if(hilo=="lo")
     if(Low[b]<=Low[b-1] && Low[b]<=Low[b+1])
       return true;
   return false;
 }


 void Reset()
 //sets various items to initial values
 {
   tkt=-1;
 }



 //
 // DISPLAY FUNCTIONS
 //

 void Tline(string objlabel,datetime t1,double p1,datetime t2,double p2,color clr)
 //draws trend line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_TREND,0,t1,p1,t2,p2,clr);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
   ObjectSet(objlabel,OBJPROP_RAY_RIGHT,false);
 }


 void Hline(string objlabel,double price,color clr)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
 }


 void Vline(string objlabel,string timestr,color clr)
 //draws vertical line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_VLINE,0,StrToTime(timestr),0);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);  
 }


 void DisplayTxt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }



 //
 // SPECIAL FUNCTIONS
 //

 bool CanDoTrade()
 //checks if trading is ok via total orders, spread
 {
   bool
     equityOK=(AccountEquity()>6000),
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12);
   return (equityOK && spreadOK);
 }


 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
 {
   aords=0;pords=0;
   for(int p=OrdersTotal()-1;p>=0;p--)
     if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
       {
         if(OrderType()>1 && OrderType()<6)
           pords++;
         if(OrderType()==OP_BUY || OrderType()==OP_SELL)
           aords++;
       }
   return aords+pords;
 }


 void ShowLastError()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }


 int OnInit() {return(INIT_SUCCEEDED);}


 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */
*** sr_scape
**** code v1 new attempt at reworking xonesr
 not quite working properly due to confusion regarding active xone and bslines

 //sr_scape.mq4

 //
 //DESCRIP
 //
 /*
 develops price action landscape using manually placed sr lines
 trading takes place at these levels
 */


 //
 //TODO
 //
 /*
 decision making at sr (based on what??)
 do this with pending orders so computer has less work to do?
 traxit
 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>



 //
 //CONSTANTS
 //
 #define sp "  "
 #define spp "    "

 #define LOTSIZE 0.1                             /* lotsize */
 #define SLTP 120                                /* fixed stoploss takeprof limits */
 #define XONEPAD 10*Point                        /* size of xone on each side of srline */
 #define NTR_DIST 60*Point                       /* distance in point from srline for ntr */
 #define COL 1500                                /* column from which to display text */

 //
 //EXTERNS
 //



 //
 //GLOBALS
 //
 int tkt=-1;                                     /* ticket number */
 double osl;                                     /* order stoploss */
 double sr_values[25];                           /* sr values from chart */
 int total_srlines;                              /* determines total number of hlines */



 //
 //STRATEGY FUNCTIONS
 //
 void OnTick()
 //main center
 {
   if(is_new_bar(PERIOD_M1))                     /* on each new bar for given tf check for srlines */
     get_indicator_info();

   ntrxit();
 }

 void ntrxit()
 //manages trade
 {
   double act_line,buy_line,sel_line;
   bool bs_set;

   activate_xone(
                 total_srlines,                  /* determine if in xone */
                 sr_values,                      /* using total srlines and sr array */
                 act_line,                       /* set active srline */
                 buy_line,                       /* set buy line */
                 sel_line,                       /* set sel line */
                 bs_set);                        /* bs_set to true if xone activated */

   if(can_do_trade() && bs_set)
     tkt=ntr(buy_line,sel_line,bs_set);
   else
     xit();

  
   /* 
 in active zone
   set bs_lines

 no trade exists
   can do trade
     ntr

 there is trade
   look for xit
     trailing stop
     opposite bs crossing
  */
 }
                                                            
 void get_indicator_info()
 //get all indicator information
 {
   /* //get the sline values */
   /* double hi_inc[10],lo_inc[10];ArrayInitialize(hi_inc,0);ArrayInitialize(lo_inc,0); */
   /* get_slines(PERIOD_M1,hi_inc,lo_inc); */

   //get sr values
   total_srlines=get_sr(sr_values);
   display_txt("total_srlines","SRlines="+IntegerToString(total_srlines)+"/24",0,COL,1,Blue);

 }


 void activate_xone(int srlines,double &sr[],double &aline, double &bline, double &sline,bool &bs_set)
 //determines if price is in sr zone
 {
   double pad=XONEPAD;

   for(int i=0;i<=srlines;i++)
     if(is_btn(sr[i]-pad,Bid,sr[i]+pad))
       {
         double
           ntr_dist=NTR_DIST,
           bs_fract_1=.5,
           bs_fract_2=1-bs_fract_1;
         aline=sr[i];
         bline=aline+bs_fract_1*ntr_dist;
         sline=aline-bs_fract_2*ntr_dist;
         bs_set=true;
         display_line_values(aline,bline,sline);
       }
 }


 void get_slines(int tf,double &hi_inc[],double &lo_inc[])
 //computes slines
 {
   //fill hilo slines for L(512,256,128)  I(64,32,16)  S(8,4,2)
   int i,bar;
   for(i=1;i<=9;i++)                              
     {
       bar=(int)pow(2,i);
       hi_inc[i]=incline_value(bar,iHigh(NULL,tf,bar),1,iHigh(NULL,tf,1));
       lo_inc[i]=incline_value(bar,iLow(NULL,tf,bar),1,iLow(NULL,tf,1));
     }
 }


 int get_sr(double &sr[])
 //puts hline values into sr array starting at index 1 and returns number of hlines
 {
   int i,
     hline_count=0,
     num_of_objects=ObjectsTotal();
   string object_name;

   ArrayInitialize(sr,0);                        /* set all values to 0 and rebuild array */
   for(i=0;i<num_of_objects;i++)
     {
       object_name=ObjectName(i);
       if(ObjectType(object_name)==OBJ_HLINE)
         {
           hline_count++;
           sr[hline_count]=NormalizeDouble(ObjectGet(object_name,OBJPROP_PRICE1),Digits);
         }
     }
   return hline_count;
 }



 //
 // UTILITY FUNCTIONS
 //
 void xit()
 //trailing xit
 {
   if(OrderSelect(tkt,SELECT_BY_TICKET))
     {
       int aords,pords,
         tords=orders_for_symbol(aords,pords),
         bs=OrderType();
       bool
         sltp_xit=(tords==0),
         xit_trade=false;
       double
         dpt=diff_pts(OrderOpenPrice(),Bid);  /* progress of price in points from oop */

        
        
       /* if(xit_trade) */
       /*   if(!OrderClose(tkt,LOTSIZE,OrderClosePrice(),0)) */
       /*     reset(); */
     }
 }


 int ntr(double bline,double sline,bool &bs_set)
 //makes a trade
 {
   int bs=-1;
   double oo=0,sl=0,tp=0;

   if(Bid>bline)
     {
       bs=OP_BUY;
       oo=Ask;
       //osl=oo-INITIAL_SL*Point;
       sl=oo-.5*SLTP*Point;
       tp=oo+SLTP*Point;
       bs_set=false;
     }
   if(Bid<sline)
     { 
       bs=OP_SELL;
       oo=Bid;
       //osl=oo+INITIAL_SL*Point;
       sl=oo+.5*SLTP*Point;
       tp=oo-SLTP*Point;
       bs_set=false;
     }
   return OrderSend(Symbol(),bs,LOTSIZE,oo,0,sl,tp);
 }


 bool is_new_bar(int tf)
 //checks to see if we have a new bar
 {
   static datetime lastbartime;
   datetime
     curbartime=iTime(NULL,tf,0);//Comment(curbartime,sp,lastbartime);
   if(lastbartime!=curbartime)
     {
       lastbartime=curbartime;
       return (true);
     }
   else
     return(false);
 }


 double maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);

   if(minbar>maxbar)
     return diff_pts(minval,maxval);
   else
     return diff_pts(maxval,minval);
 }


 double diff_pts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }


 double incline_value(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf giving points per bar
 {
   int
     Dbar=bI-bF;
   return diff_pts(vI,vF)/Dbar;
 }


 bool is_btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }


 bool true_turning_point(int b,string hilo)
 //hilo is true turning point
 {
   if(hilo=="hi")
     if(High[b]>=High[b-1] && High[b]>=High[b+1])
       return true;
   if(hilo=="lo")
     if(Low[b]<=Low[b-1] && Low[b]<=Low[b+1])
       return true;
   return false;
 }




 //
 // DISPLAY FUNCTIONS
 //
 void tline(string objlabel,datetime t1,double p1,datetime t2,double p2,color clr)
 //draws trend line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_TREND,0,t1,p1,t2,p2,clr);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
   ObjectSet(objlabel,OBJPROP_RAY_RIGHT,false);
 }


 void hline(string objlabel,double price,color clr)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
 }


 void vline(string objlabel,string timestr,color clr)
 //draws vertical line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_VLINE,0,StrToTime(timestr),0);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);  
 }


 void display_txt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 void display_line_values(double aline,double bline,double sline)
 //displays values for aline,bline,sline
 {
   display_txt("buy_line","buy_line="+DoubleToStr(bline,5),0,COL,23,Blue);
   display_txt("a_srline","act_line="+DoubleToStr(aline,5),0,COL,33,Purple);
   display_txt("sel_line","sel_line="+DoubleToStr(sline,5),0,COL,43,Red);
 }


 void draw_sline(int bar,double inc,datetime tI,double pI,datetime tF,double pF)
 //draws sline with color
 {
   color
     clr=Incl_color(inc);
   tline("tline"+IntegerToString(bar),tI,pI,tF,pF,clr);
 }


 color Incl_color(double inc)
 //determines color from incline value
 {
   double
     zeroincl=0.6;
   color
     clr=Green;
  
   if(is_btn(-zeroincl,inc,+zeroincl))
     clr=Green;
   else
     {
       if(inc>+zeroincl)
         clr=Blue;
       if(inc<-zeroincl)
         clr=Red;
     }
   return clr;
 }



 //
 // SPECIAL FUNCTIONS
 //
 bool can_do_trade()
 //checks if trading is ok via total orders, spread
 {
   int aords,pords;
   bool
     notradOK=(orders_for_symbol(aords,pords)==0),
     equityOK=(AccountEquity()>6000),
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<40);
   return (notradOK && equityOK && spreadOK);
 }


 int orders_for_symbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
 {
   aords=0;pords=0;
   for(int p=OrdersTotal()-1;p>=0;p--)
     if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
       {
         if(OrderType()>1 && OrderType()<6)
           pords++;
         if(OrderType()==OP_BUY || OrderType()==OP_SELL)
           aords++;
       }
   return aords+pords;
 }


 void show_last_error()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }



 int OnInit() {return(INIT_SUCCEEDED);}



 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

**** code v2 use pending orders instead of manual
 we think this might cause less work for galios

**** code v3 figuring out an intelligent oco
 results aren't too good because of randomness at sr lines
 we may be able to improve the situation through other parameters
 work on the oco further then remplace below

 //sr_scape.mq4

 //
 //DESCRIP
 //
 /*
 develops price action landscape using manually placed sr lines
 trading takes place at these levels
 */


 //
 //TODO
 //
 /*
 decision making at sr (based on what??)
 do this with pending orders so computer has less work to do? DONE
 work on oco so it doesn't get called every tick
 traxit
 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>



 //
 //CONSTANTS
 //
 #define sp "  "
 #define spp "    "

 #define LOTSIZE 0.1                             /* lotsize */
 #define SLTP 120                                /* fixed stoploss takeprof limits */
 #define NTR_DIST 60*Point                       /* distance in point from srline for ntr */
 #define COL 1500                                /* column from which to display text */

 //
 //EXTERNS
 //



 //
 //GLOBALS
 //
 int tkt[2];                                     /* ticket number array 0 buy, 1 sel*/
 double osl;                                     /* order stoploss */
 double sr_values[25];                           /* sr values from chart */
 int total_srlines;                              /* determines total number of hlines */



 //
 //STRATEGY FUNCTIONS
 //
 void OnTick()
 //main center
 {
   if(is_new_bar(PERIOD_M1))                     /* on each new bar for given tf check for srlines */
     get_indicator_info();

   ntrxit();
 }

 void ntrxit()
 //manages trade
 {
   double act_line,buy_line,sel_line;
  
   in_xone(
           total_srlines,                        /* determine if in xone */
           sr_values,                            /* bs_set to true if xone activated */
           act_line,                             /* set active srline */
           buy_line,                             /* set buy line */
           sel_line);                            /* set sel line */

   if(can_do_trade())
     ntr(act_line,buy_line,sel_line);
   else
     xit(oco(tkt));

 }
                                                            
 void get_indicator_info()
 //get all indicator information
 {
   /* //get the sline values */
   /* double hi_inc[10],lo_inc[10];ArrayInitialize(hi_inc,0);ArrayInitialize(lo_inc,0); */
   /* get_slines(PERIOD_M1,hi_inc,lo_inc); */

   //get sr values
   total_srlines=get_sr(sr_values);
   display_txt("total_srlines","SRlines="+IntegerToString(total_srlines)+"/24",0,COL,1,Blue);

 }


 void in_xone(int srlines,double &sr[],double &aline, double &bline, double &sline)
 //determines if price is in sr zone
 {
   double
     pad=10*Point;

   for(int i=0;i<=srlines;i++)
     if(is_btn(sr[i]-pad,Bid,sr[i]+pad))         /* Bid is in xone */
       {
         double
           ntr_dist=NTR_DIST,
           bs_fract_1=.5,
           bs_fract_2=1-bs_fract_1;
         aline=sr[i];
         bline=aline+bs_fract_1*ntr_dist;
         sline=aline-bs_fract_2*ntr_dist;
         display_line_values(aline,bline,sline);
       }
 }


 void get_slines(int tf,double &hi_inc[],double &lo_inc[])
 //computes slines
 {
   //fill hilo slines for L(512,256,128)  I(64,32,16)  S(8,4,2)
   int i,bar;
   for(i=1;i<=9;i++)                              
     {
       bar=(int)pow(2,i);
       hi_inc[i]=incline_value(bar,iHigh(NULL,tf,bar),1,iHigh(NULL,tf,1));
       lo_inc[i]=incline_value(bar,iLow(NULL,tf,bar),1,iLow(NULL,tf,1));
     }
 }


 int get_sr(double &sr[])
 //puts hline values into sr array starting at index 1 and returns number of hlines
 {
   int i,
     hline_count=0,
     num_of_objects=ObjectsTotal();
   string object_name;

   ArrayInitialize(sr,0);                        /* set all values to 0 and rebuild array */
   for(i=0;i<num_of_objects;i++)
     {
       object_name=ObjectName(i);
       if(ObjectType(object_name)==OBJ_HLINE)
         {
           hline_count++;
           sr[hline_count]=NormalizeDouble(ObjectGet(object_name,OBJPROP_PRICE1),Digits);
         }
     }
   return hline_count;
 }



 //
 // UTILITY FUNCTIONS
 //
 void xit(int tk)
 //trailing xit
 {
   if(tk!=-1)
     {

     }
 }


 int oco(int &tk[])
 //order cancels order
 {
   int bs;
   if(OrderSelect(tk[0],SELECT_BY_TICKET))
     {
       bs=OrderType();
       if(bs==OP_BUY || bs==OP_SELL)
         if(OrderDelete(tk[1]))
           return tk[0];
     }
   if(OrderSelect(tk[1],SELECT_BY_TICKET))
     {
       bs=OrderType();
       if(bs==OP_SELL || bs==OP_BUY)
         if(OrderDelete(tk[0]))
           return tk[1];
     }
   return -1;
 }

 void ntr(double aline,double bline,double sline)
 //makes a trade
 {
   double
     Boo=bline,
     Bsl=aline-SLTP*Point,
     Btp=aline+2*SLTP*Point,
     Soo=sline,
     Ssl=aline+SLTP*Point,
     Stp=aline-2*SLTP*Point;

   tkt[0]=OrderSend(Symbol(),OP_BUYSTOP,LOTSIZE,Boo,0,Bsl,Btp);
   tkt[1]=OrderSend(Symbol(),OP_SELLSTOP,LOTSIZE,Soo,0,Ssl,Stp);
 }


 bool is_new_bar(int tf)
 //checks to see if we have a new bar
 {
   static datetime lastbartime;
   datetime
     curbartime=iTime(NULL,tf,0);//Comment(curbartime,sp,lastbartime);
   if(lastbartime!=curbartime)
     {
       lastbartime=curbartime;
       return (true);
     }
   else
     return(false);
 }


 double maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);

   if(minbar>maxbar)
     return diff_pts(minval,maxval);
   else
     return diff_pts(maxval,minval);
 }


 double diff_pts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }


 double incline_value(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf giving points per bar
 {
   int
     Dbar=bI-bF;
   return diff_pts(vI,vF)/Dbar;
 }


 bool is_btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }


 bool true_turning_point(int b,string hilo)
 //hilo is true turning point
 {
   if(hilo=="hi")
     if(High[b]>=High[b-1] && High[b]>=High[b+1])
       return true;
   if(hilo=="lo")
     if(Low[b]<=Low[b-1] && Low[b]<=Low[b+1])
       return true;
   return false;
 }




 //
 // DISPLAY FUNCTIONS
 //
 void tline(string objlabel,datetime t1,double p1,datetime t2,double p2,color clr)
 //draws trend line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_TREND,0,t1,p1,t2,p2,clr);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
   ObjectSet(objlabel,OBJPROP_RAY_RIGHT,false);
 }


 void hline(string objlabel,double price,color clr)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
 }


 void vline(string objlabel,string timestr,color clr)
 //draws vertical line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_VLINE,0,StrToTime(timestr),0);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);  
 }


 void display_txt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 void display_line_values(double aline,double bline,double sline)
 //displays values for aline,bline,sline
 {
   display_txt("buy_line","buy_line="+DoubleToStr(bline,5),0,COL,23,Blue);
   display_txt("a_srline","act_line="+DoubleToStr(aline,5),0,COL,33,Purple);
   display_txt("sel_line","sel_line="+DoubleToStr(sline,5),0,COL,43,Red);
 }


 void draw_sline(int bar,double inc,datetime tI,double pI,datetime tF,double pF)
 //draws sline with color
 {
   color
     clr=Incl_color(inc);
   tline("tline"+IntegerToString(bar),tI,pI,tF,pF,clr);
 }


 color Incl_color(double inc)
 //determines color from incline value
 {
   double
     zeroincl=0.6;
   color
     clr=Green;
  
   if(is_btn(-zeroincl,inc,+zeroincl))
     clr=Green;
   else
     {
       if(inc>+zeroincl)
         clr=Blue;
       if(inc<-zeroincl)
         clr=Red;
     }
   return clr;
 }



 //
 // SPECIAL FUNCTIONS
 //
 bool can_do_trade()
 //checks if trading is ok via total orders, spread
 {
   int aords,pords;
   bool
     atradeOK=(orders_for_symbol(aords,pords)==0),
     equityOK=(AccountEquity()>6000),
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<40);
   return (atradeOK && equityOK && spreadOK);
 }


 int orders_for_symbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
 {
   aords=0;pords=0;
   for(int p=OrdersTotal()-1;p>=0;p--)
     if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
       {
         if(OrderType()>1 && OrderType()<6)
           pords++;
         if(OrderType()==OP_BUY || OrderType()==OP_SELL)
           aords++;
       }
   return aords+pords;
 }


 void show_last_error()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }



 int OnInit() {return(INIT_SUCCEEDED);}



 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */
*** xonesr
 uses xone and support resistance

 this is an elaboration of ppa with sr added and using xones. generally, ppa worked fairly well because of a 2:1 rr. however, it had to work double to get into a breakeven situation and never took into account the larger picture. this program attempts to do so by 
 - manually supplying sr accessible through a file that is updated each day
 - computing inclines possibly in multiple tfs
 - using zoner concept at sr with appropriately proportioned buysel ntr as well as xit distances from price

 form xones around sr of fixed size
 when pr enters a zone, set up buysel ntrs depending on situation
 if ntr then follow usual system for moving sl, but with attention to situation

**** code getting sr values through filereads and hlines
   //get sr values from file
   string s,srS[6];
   int fh=FileOpen(FNAME,FILE_CSV);
   if(fh!=INVALID_HANDLE)
     {
       s=FileReadString(fh);
       FileClose(fh);
       StringSplit(s,StringGetCharacter(",",0),srS);
       for(int i=0;i<6;i++)
         ii.sr[i]=StringToDouble(srS[i]);
     }
   else
     showlasterror();


 int fill_sr(double &sr[])
 //finds all hlines on chart and puts values into sr array
 {
   int i,
     hline_count=0,
     num_of_objects=ObjectsTotal();
   string object_name;

   ArrayInitialize(sr,0);
   for(i=0;i<num_of_objects;i++)
     {
       object_name=ObjectName(i);
       if(hline_count<12 && ObjectType(object_name)==OBJ_HLINE)
         {
           hline_count++;
           ArrayResize(sr,hline_count);
           sr[hline_count]=NormalizeDouble(ObjectGet(object_name,OBJPROP_PRICE1),Digits);
         }
       else
         Alert("Arraysize of 12 EXCEEDED!");
     }
   return hline_count;
 }

**** code v1 produced $300 with 130 trades using h4 over 2wks
 this is conceptually very strong:
 1. trades only at sr
 2. limits sl to 120
 3. trails by 120 so is capable of following trends

 we think it can be considerably improved:
 1. incorporate a more intelligent traxit which waits at established swing points it may do better
 2. take market conditions into account to provide intelligence to the ntrxit process
 3. find a way to handle rng situations

 //ppasr.mq4

 //DESCRIP
 /*
 ppasr uses pure price action for ntrxit incorporating sr
 */

 //TODO
 /*
 traxit to work using newly formed swing points
 */


 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>


 //
 //CONSTANTS
 //
 #define sp "  "
 #define spp "    "

 #define LT 0.1
 #define SLTP 1200.0*Point
 #define NTR_DIST 60*Point
 #define PAD 10*Point
 #define TS 120

 //
 //EXTERNS
 //
 extern int Estep;

 //
 //GLOBALS
 //
 int tfs[6];


 //
 //STRUCTURES
 //
 struct T_indiinfo
 //market condition status by indicator
 {
   //sr parameters
   double sr[12];                                /* sr values from chart */
   int total_hlines;                             /* determines total number of hlines */
   double buyline,selline;                       /* buy and sell lines to be crossed */

   //trade parameters
   bool spreadOK;                                /* spread should be < 12 */
   int tkt;                                      /* tkt number */
   double osl;                                   /* order stop limit */
  
 };

 T_indiinfo ii;                                  /* setup ii structure variable */
                                                
 //
 //FUNCTIONS
 //
 void OnTick()
 {
   if(is_new_bar())                              /* on each new bar get the ii */
     get_ii();

   int
     axn=price_xone(ii.total_hlines,ii.sr);      /* gets active xone number for price */

   if(axn!=-1)                                   /* if there is valid active xone number */
     set_buysel_lines(ii.sr[axn],ii.buyline,ii.selline);

   if(ii.tkt==-1)                              /* if no trades then consider ntr */
     trantr();
   else                                        /* otherwise plan xit */
     traxit();

 }


 void get_ii()
 //determines all relevant market conditions
 {
   //sr parameters filling
   ii.total_hlines=fill_sr(ii.sr);                  /* find sr and get hline_count */

   //other parameters
   ii.spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12);
  
 }


 void set_buysel_lines(double aline,double &bline,double &sline)
 //sets the buysel lines from active sr
 {
   double
     ntr_dist=NTR_DIST,
     bs_fract_1=.5,
     bs_fract_2=1-bs_fract_1;
   bline=aline+bs_fract_1*ntr_dist; //hline("bline",bline);
   sline=aline-bs_fract_2*ntr_dist; //hline("sline",sline);
 }


 int price_xone(int hlines,double &sr[])
 //determines if price is in sr zone
 {
   double pad=PAD;

   for(int i=0;i<=hlines;i++)
     if(btn(sr[i]-pad,Bid,sr[i]+pad))
       return i;
   return -1;
 }


 int fill_sr(double &sr[])
 //puts hline values into sr array and returns number of hlines
 {
   int i,
     hline_count=0,
     num_of_objects=ObjectsTotal();
   string object_name;

   ArrayInitialize(sr,0);
   for(i=0;i<num_of_objects;i++)
     {
       object_name=ObjectName(i);
       if(hline_count<12 && ObjectType(object_name)==OBJ_HLINE)
         {
           hline_count++;
           ArrayResize(sr,hline_count);
           sr[hline_count]=NormalizeDouble(ObjectGet(object_name,OBJPROP_PRICE1),Digits);
         }
       else
         Alert("Arraysize of 12 EXCEEDED!");
     }
   return hline_count;
 }


 void trantr()
 //trade ntr
 {
   bool
     buysel_lines_set=(ii.buyline>0 && ii.selline>0);
  
   if(buysel_lines_set)
     {
       if(Bid>ii.buyline)
         {
           ii.tkt=OrderSend(Symbol(),0,LT,Ask,0,Ask-SLTP,Ask+SLTP);
           ii.osl=Ask-TS*Point;
         }
       if(Bid<ii.selline)
         {
           ii.tkt=OrderSend(Symbol(),1,LT,Bid,0,Bid+SLTP,Bid-SLTP);
           ii.osl=Bid+TS*Point;
         }
     }
 }


 void traxit()
 //trailing xit
 {
     if(OrderSelect(ii.tkt,SELECT_BY_TICKET))
     {
       bool
         close_the_trade=false;
       int
         bs=OrderType();
       double
         oop=OrderOpenPrice(),
         ocp=OrderClosePrice();

       switch(bs)
         {
         case 0:
           if(Dpts(ii.osl,Bid)>TS)
             ii.osl=Bid-TS*Point;
           if(Bid<ii.osl)
             close_the_trade=true;
           break;
         case 1:
           if(Dpts(Ask,ii.osl)>TS)
             ii.osl=Ask+TS*Point;Comment(ii.osl);
           if(Ask>ii.osl)
             close_the_trade=true;
           break;
         }
      
       if(close_the_trade && OrderClose(ii.tkt,LT,ocp,0))
         reset();            
     }
 }


 void reset()
 //resets various items to initial values
 {
   ii.tkt=-1;
   ii.buyline=-1;
   ii.selline=-1;
 }


 void maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);
 }

 double Dprs(double pI,double pF)
 //difference between two prices
 {
   return (pF-pI);
 }

 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }

 double avgslope(int bI,int bF,double &ma[])
 //calculates avgslope using theil-sen concept
   {
    int
    iters=bI*(bI-1)/2;
    double
    acc=0;
    for(int i=bF;i<bI;i++)
       for(int j=i+1;j<=bI;j++)
          acc+=incline(j,ma[j],i,ma[i]);
    return acc/iters;
   }

 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
 {
   int
     Dbar=bI-bF;
   return Dpts(vI,vF)/Dbar;
 }

 bool btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }


 bool is_new_bar()
 //checks to see if we have a new bar
 {
   int
     tf=tfs[0];
   static datetime lastbartime;
   datetime
     curbartime=iTime(NULL,tf,0);
   if(lastbartime!=curbartime)
     {
       lastbartime=curbartime;
       return (true);
     }
   else
     return(false);
 }


 void showlasterror()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }

 void hline(string objlabel,double price)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
 }
  
 void displayitem(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 //
 //SPECIAL FUNCTIONS
 //
 int OnInit()
 {
   reset();
   tfs[0]=1;tfs[1]=5;tfs[2]=15;tfs[3]=30;tfs[4]=60;tfs[5]=240;
   return(INIT_SUCCEEDED);
 }


 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

**** code v2 using self-generating hlines and improve traxit
 //xonesr.mq4

 //DESCRIPTION
 /*
 xonesr lays out hlines to form xones from which to trade
 */

 //TODO
 /*
 traxit -brkevner -stealther
 sline cycling period
 get proper turning points for hline barcounts
 hlines on 00 prices?
 */


 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>


 //
 //CONSTANTS
 //
 #define sp "  "
 #define spp "    "

 #define LT 0.1
 #define SLTP 1200.0*Point
 #define NTR_DIST 60*Point
 #define PAD 10*Point



 //
 //EXTERNS
 //


 //
 //GLOBALS
 //
 int tfs[6];


 //
 //STRUCTURES
 //
 struct T_indiinfo
 //market condition status by indicator
 {
   //sr parameters
   double sr[12];                                /* sr values from chart */
   int total_hlines;                             /* determines total number of hlines */
   double buyline,selline;                       /* buy and sell lines to be crossed */

   //slines
   double h[9],l[9];                             /* hilo incline arrays from 0-8 for 2^x bars */

   //trade parameters
   bool spreadOK;                                /* spread should be < 12 */
   int tkt;                                      /* tkt number */
   double osl;                                   /* order stop limit */
  
 };

 T_indiinfo ii;                                  /* setup ii structure variable */


 //
 //FUNCTIONS
 //
 void OnTick()
 {
   //  if(is_new_bar())
   //hliner();

   if(is_new_bar())                              /* on each new bar get the ii */
     get_ii();

   int
     axn=price_xone(ii.total_hlines,ii.sr);      /* gets active xone number for price */

   if(axn!=-1)                                   /* if there is valid active xone number */
     set_buysel_lines(ii.sr[axn],ii.buyline,ii.selline);
  
   if(ii.tkt==-1)                                /* if no trades then consider ntr */
     trantr();
   else                                          /* otherwise plan xit */
     traxit();

 }


 void get_ii()
 //determines all relevant market conditions
 {
   //sr parameters filling
   ii.total_hlines=fill_sr(ii.sr);               /* find sr and get hline count */

   //sline filling
   fill_slines(ii.h,ii.l);

   //other parameters
   ii.spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12);
 }


 void set_buysel_lines(double aline,double &bline,double &sline)
 //sets the buysel lines from active sr
 {
   double
     ntr_dist=NTR_DIST,
     bs_fract_1=.5,
     bs_fract_2=1-bs_fract_1;
   bline=aline+bs_fract_1*ntr_dist; //hline("bline",bline);
   sline=aline-bs_fract_2*ntr_dist; //hline("sline",sline);
 }


 int price_xone(int hlines,double &sr[])
 //determines if price is in sr zone
 {
   double pad=PAD;

   for(int i=0;i<=hlines;i++)
     if(btn(sr[i]-pad,Bid,sr[i]+pad))
       return i;
   return -1;
 }


 int fill_sr(double &sr[])
 //puts hline values into sr array and returns number of hlines
 {
   int i,
     hline_count=0,
     num_of_objects=ObjectsTotal();
   string object_name;

   ArrayInitialize(sr,0);
   for(i=0;i<num_of_objects;i++)
     {
       object_name=ObjectName(i);
       if(ObjectType(object_name)==OBJ_HLINE)
         if(hline_count<12)
           {
             hline_count++;
             ArrayResize(sr,hline_count);
             sr[hline_count]=NormalizeDouble(ObjectGet(object_name,OBJPROP_PRICE1),Digits);
           }
         else
           printf("%s","Arraysize of 12 EXCEEDED!");
     }
   return hline_count;
 }


 void fill_slines(double &h[],double &l[])
 //fills the slope values
 { int i,b,
     tf=tfs[0];
   double hib,lob,
     hi1=iHigh(NULL,tf,1),
     lo1=iLow(NULL,tf,1);
  
   for(i=0;i<9;i++)                              /* slines for S(2,4,8)  M(16,32,64)  L(128,256,512) */
     {
       b=(int)pow(2,i+1);
       hib=iHigh(NULL,tf,b);
       lob=iLow(NULL,tf,b);
       h[i]=incline(b,hib,1,hi1);
       l[i]=incline(b,lob,1,lo1);
     }
 }

 void hliner()
 //draws hlines on chart
 {
   int i,j,
     hi_barcount,lo_barcount,
     min_bar_count=4,
     bar_look_back=144;                          /* bar look back */
   bool htaken[],ltaken[];
   ArrayResize(htaken,bar_look_back);ArrayResize(ltaken,bar_look_back);
   ArrayInitialize(htaken,false);ArrayInitialize(ltaken,false);
   double hih,hil,loh,lol,hi_sum,lo_sum,
     hi_raverage=0,
     lo_raverage=0,
     band=120*Point;
  
   for(i=1;i<bar_look_back;i++)
     {
       hih=High[i]+band;hil=High[i]-band;
       loh=Low[i]+band;lol=Low[i]-band;

       hi_barcount=0;lo_barcount=0;
       hi_sum=High[i];lo_sum=Low[i];
       j=i+1;
       while(j<bar_look_back && (hi_barcount<min_bar_count && lo_barcount<min_bar_count))
         {
           if(!htaken[j])
             if(ttp(j,"hi"))
               if(btn(hih,High[j],hil))
                 { 
                   htaken[j]=true;
                   hi_barcount++;
                   hi_raverage=raverage(hi_sum,hi_barcount,High[j],1);
                   //printf("%i %i  %.5f %.5f  %.5f",i,j,High[i],High[j],hi_raverage);
                   hi_sum+=High[j];
                 }
           if(!ltaken[j])
             if(ttp(j,"lo"))
                if(btn(loh,Low[j],lol))
                  {
                    ltaken[j]=true;
                    lo_barcount++;
                    lo_raverage=raverage(lo_sum,lo_barcount,Low[j],1);
                    //printf("%i %i  %.5f %.5f  %.5f",i,j,Low[i],Low[j],lo_raverage);
                    lo_sum+=Low[j];
                  }
           j++;
         }
         if(hi_barcount>=min_bar_count)
           hline("hi"+IntegerToString(j),hi_raverage,Blue);
         if(lo_barcount>=min_bar_count)
           hline("lo"+IntegerToString(j),Low[j],Red);
     }
 }


 bool ttp(int b,string hilo)
 //hilo is true turning point
 {
   if(hilo=="hi")
     if(High[b]>=High[b-1] && High[b]>=High[b+1])
       return true;
   if(hilo=="lo")
     if(Low[b]<=Low[b-1] && Low[b]<=Low[b+1])
       return true;
   return false;
 }


 void trantr()
 //trade ntr
 {
   double
     oslamt=120*Point;
   bool
     buysel_lines_set=(ii.buyline>0 && ii.selline>0);
   string mode="xpl";
  
   if(buysel_lines_set)
     {
       if(mode=="xpl")
         {
           if(Bid>ii.buyline)
             {
               ii.tkt=OrderSend(Symbol(),0,LT,Ask,0,Ask-SLTP,Ask+SLTP);
               ii.osl=Ask-oslamt;
             }
           if(Bid<ii.selline)
             {
               ii.tkt=OrderSend(Symbol(),1,LT,Bid,0,Bid+SLTP,Bid-SLTP);
               ii.osl=Bid+oslamt;
             }
         }
      
       if(mode=="rng")
         {
           if(Bid>ii.buyline)
             {
               ii.tkt=OrderSend(Symbol(),1,LT,Bid,0,Bid+SLTP,Bid-SLTP);
               ii.osl=Bid+oslamt;
             }
           if(Bid<ii.selline)
             {
               ii.tkt=OrderSend(Symbol(),0,LT,Ask,0,Ask-SLTP,Ask+SLTP);
               ii.osl=Ask-oslamt;
             }
         }
     }
 }


 void traxit()
 //trailing xit
 {

   if(OrderSelect(ii.tkt,SELECT_BY_TICKET))
     {
       int
         bs=OrderType();

       if(OrderProfit()>0)
         {
           int
             trsl=0;
           double newosl,
             oop=OrderOpenPrice(),
             dpt=fabs(Dpts(oop,Bid));

           if(dpt>60) trsl=30;
           if(dpt>120) trsl=60;
          
           if(trsl>=30)
             switch(bs)
               {
               case 0:
                 newosl=oop+trsl*Point;
                 if(newosl>ii.osl) ii.osl=newosl;
                 break;
               case 1:
                 newosl=oop-trsl*Point;
                 if(newosl<ii.osl) ii.osl=newosl;
                 break;
               }
         }

       if(((bs==0 && Bid<ii.osl) || (bs==1 && Bid>ii.osl))
          && OrderClose(ii.tkt,LT,OrderClosePrice(),0))
         reset();
     }
 }


 void reset()
 //resets various items to initial values
 {
   ii.tkt=-1;
   ii.buyline=-1;
   ii.selline=-1;
 }


 void maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);
 }

 double Dprs(double pI,double pF)
 //difference between two prices
 {
   return (pF-pI);
 }

 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }


 double raverage(double oldavg,double oldweight,double newitm,double newweight)
 //running average
 {
   double
     newaverage=(oldavg+newitm)/(oldweight+newweight);
   return newaverage;
 }

 double avgslope(int bI,int bF,double &ma[])
 //calculates avgslope using theil-sen concept
   {
    int
    iters=bI*(bI-1)/2;
    double
    acc=0;
    for(int i=bF;i<bI;i++)
       for(int j=i+1;j<=bI;j++)
          acc+=incline(j,ma[j],i,ma[i]);
    return acc/iters;
   }

 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
 {
   int
     Dbar=bI-bF;
   return Dpts(vI,vF)/Dbar;
 }

 bool btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }


 bool is_new_bar()
 //checks to see if we have a new bar
 {
   int
     tf=tfs[0];
   static datetime lastbartime;
   datetime
     curbartime=iTime(NULL,tf,0);
   if(lastbartime!=curbartime)
     {
       lastbartime=curbartime;
       return (true);
     }
   else
     return(false);
 }


 void showlasterror()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }


 void hline(string objlabel,double price,color clr)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
 }

 
 void displayitem(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 //
 //SPECIAL FUNCTIONS
 //
 int OnInit()
 {
   reset();
   tfs[0]=1;tfs[1]=5;tfs[2]=15;tfs[3]=30;tfs[4]=60;tfs[5]=240;
   return(INIT_SUCCEEDED);
 }


 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

**** code v3 imposing rigid structure using hlines 100pts apart

*** multf
 trade once every hour based on multi timeframe situation
*** nul2nul
 uses mode patterns particularly NUL to ntr
 can likely be done on lower tf with refined traxit
**** concept
 nul movement masl<x && atr<y is the calm before a storm
 we try to identify these and wait on either side (possibly with ntrs fractionated by masl.
 we xit (tighten sl) when another nul is encountered.
**** code v1 produces good results for some periods but generally loses
 the traxit is not quite working as it should
 curious how it generally loses
 probably can work well with enough tweaking though the idea of nul2nul may have to change

 //nul2nul.mq4

 //DESCRIP
 /*
 uses NUL mode to ntrxit
 */

 //TODO
 /*
 NULLIX
 1m look for nul and wait for lix
 when nul appears again, tighten sl

 set up more descriptive modes such as 
 LIX+,LIX- etc


 create sl placements based on atr,ma,fpatterns

 set up totalorder protection

 develop noise function
 work in trailer possibly through noise function
 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>

 //////////////////////////////////////////////////////////////

 //
 //CONSTANTS
 //
 #define sp "  "
 #define spp "    "

 #define LT 0.1
 #define SLTP 1200.0*Point
 #define SLMIN 30*Point
 #define ATRMIN 60
 #define MASLMIN 0.6


 //
 //EXTERNS
 //
 //extern int Etfx;


 //
 //GLOBALS
 //
 double sl;
 int Gtf[6];
 int tkt=-1;
 int tfx=0;



 //
 //STRUCTURES
 //
 struct T_indi_info
 {
   //mode
   string currmode,prevmode;                     //rng,lix,fax,nul determined by atr and masl

   //bar behavior
   string bb3,bb6;                               //bar behavior 3,6
  
   //fractals
   string fletter[7];                            //n or u
   int fbarnum[7];                               //bar number
   double fbarval[7];                            //bar value
   double frhythm6,frhythmdev;                   //fractal rhythm for 6 fractals
   string fp6;                                   //fractal patterns

   //atr
   double atr;                                   //atr value 6 bars watching for compression

   //ma incline
   double masl;                                  //ma slope values long and short on closes
 };


 T_indi_info ii;

 //
 //FUNCTIONS
 //

 void OnTick()
 //runs the main code
 {
   int 
     tf=Gtf[tfx],
     zonenum=-1;
  
   if(is_new_bar())                              //get indicator info and trademerit only on every new bar
     fill_indi_info(tf);
   Comment(ii.prevmode,sp,ii.currmode);
   if(tkt==-1)                              //no trade active
     tryntr();                                 //try a strategy
   else
     traxit();                                 //use trailing exit since we have a trade
 }


 void tryntr()
 //when mode is nul watch for lix
 {
   bool
     ntrBUY=(ii.prevmode=="LIX+" && (ii.currmode=="LIX+" || ii.currmode=="FAX+")),
     ntrSEL=(ii.prevmode=="LIX-" && (ii.currmode=="LIX-" || ii.currmode=="FAX-"));
  
   if(ntrBUY)
     {
     tkt=OrderSend(Symbol(),0,LT,Ask,0,Ask-SLTP,Ask+SLTP);
     sl=Ask-SLMIN;
     }
   if(ntrSEL)
     {
     tkt=OrderSend(Symbol(),1,LT,Bid,0,Bid+SLTP,Bid-SLTP);
     sl=Bid+SLMIN;
     }
 }


 void traxit()
 //trailing stoploss xit
 {
   if(OrderSelect(tkt,SELECT_BY_TICKET))
     {
       int bs=OrderType();
       double newsl,
         slamt=60*Point,
         op=OrderOpenPrice(),
         df=fabs(Dpts(op,Bid));
       bool 
         xitSEL=(ii.currmode=="NUL" && (ii.prevmode=="LIX-" || ii.prevmode=="FAX-")),
         xitBUY=(ii.currmode=="NUL" && (ii.prevmode=="LIX+" || ii.prevmode=="FAX+"));

       if(df>40) slamt=20*Point;
       if(df>60) slamt=30*Point;
       if(df>120) slamt=40*Point;

      
       if(bs==0 && xitBUY)
         sl=Bid-ii.atr;
       else
         {
           newsl=Bid-slamt;
           if(newsl>sl) sl=newsl;
         }

       if(bs==1 && xitSEL)
         sl=Ask+ii.atr;
       else
         {
           newsl=Ask+slamt;
           if(newsl<sl) sl=newsl;
         }

       hline("sl",sl);

       if(bs==0 && Bid<sl)
         if(OrderClose(tkt,LT,OrderClosePrice(),0))
           tkt=-1;

       if(bs==1 && Ask>sl)
         if(OrderClose(tkt,LT,OrderClosePrice(),0))
           tkt=-1;
     }
 }


 void fill_indi_info(int tf)
 //fills the T_indi_info array
 {
   //fractal info 
   int i,b;
   double frn,fru;
  
   i=0;b=0;
   while(i<6)
     {
       b++;
       frn=iFractals(NULL,tf,MODE_UPPER,b);
       fru=iFractals(NULL,tf,MODE_LOWER,b);
       if(frn)
         {
           ii.fletter[i]="n";
           ii.fbarnum[i]=b;
           ii.fbarval[i]=frn;
           i++;
         }
       if(fru)
         {
           ii.fletter[i]="u";
           ii.fbarnum[i]=b;
           ii.fbarval[i]=fru;
           i++;
         }
     }

   //fractal patterns
   ii.fp6="";
   for(i=5;i>=0;i--)
       ii.fp6+=ii.fletter[i];
  
   //fractal rhythm for 6 appearances
   double barnumdeltas[5];
   for(i=0;i<5;i++)
     barnumdeltas[i]=ii.fbarnum[i+1]-ii.fbarnum[i];
   ii.frhythm6=iMAOnArray(barnumdeltas,0,5,0,MODE_SMA,0);
   ii.frhythmdev=iStdDevOnArray(barnumdeltas,0,5,0,MODE_SMA,0);

   //atr info in points
   ii.atr=iATR(NULL,tf,6,0)/Point;

   //bar behavior determinations
   double
     hwbb3=Dpts(High[3],High[1])/2,
     lwbb3=Dpts(Low[3],Low[1])/2,
     hwbb6=Dpts(High[7],High[1])/6,
     lwbb6=Dpts(Low[7],Low[1])/6;
   ii.bb3=bar_behavior(hwbb3,lwbb3);
   ii.bb6=bar_behavior(hwbb6,lwbb6);

   //ma info collection
   double ma[4]; ArrayInitialize(ma,0);
   for(b=1;b<4;b++)
     ma[b]=iMA(NULL,tf,12,0,MODE_SMA,PRICE_CLOSE,b);
   ii.masl=avgslope_per_min(tf,ma);

   //mode determination
   ii.prevmode=ii.currmode;
  
   if(ii.atr<ATRMIN && fabs(ii.masl)<MASLMIN)    //insignificant movement - waiting period
     ii.currmode="NUL";
   if(ii.atr<ATRMIN && ii.masl<-MASLMIN)         //little explorer
     ii.currmode="LIX-";
   if(ii.atr<ATRMIN && ii.masl>+MASLMIN)
     ii.currmode="LIX+";
   if(ii.atr>ATRMIN && ii.masl<-MASLMIN)         //fast explorer
     ii.currmode="FAX-";                              
   if(ii.atr>ATRMIN && ii.masl>+MASLMIN)
     ii.currmode="FAX+";                              
   if(ii.atr>ATRMIN && fabs(ii.masl)<MASLMIN)    //ranger
     ii.currmode="RNG";

   //printf("%s  %f %f",ii.currmode,ii.atr,ii.masl);
 }


 string bar_behavior(double hi,double lo)
 //determines if bars are well-behaved by virtue of hilo relations
 {
   double
     ubnd=+MASLMIN,
     lbnd=-MASLMIN;
   bool
     min=(btn(lbnd,hi,ubnd) && btn(lbnd,lo,ubnd)),
     pos=(hi>ubnd && lo>ubnd),
     neg=(hi<lbnd && lo<lbnd);

   if(min) return "min";
   if(pos) return "pos";
   if(neg) return "neg";
   return "bbb";                                 //badly behaving bars
 }



 bool is_new_bar()
 //checks to see if we have a new bar
 {
   static datetime lastbartime;
   datetime
     curbartime=Time[0];
   if(lastbartime!=curbartime)
     {
       lastbartime=curbartime;
       return (true);
     }
   else
     return(false);
 }


 double maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);

   if(minbar>maxbar)
     return Dpts(minval,maxval);
   else
     return Dpts(maxval,minval);
 }


 double Dprs(double pI,double pF)
 //difference between two prices
 {
   return (pF-pI);
 }


 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }


 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf giving points per bar
 {
   int
     Dbar=bI-bF;
   return Dpts(vI,vF)/Dbar;
 }


 double avgslope_per_min(int tf,double &arr[])
 //calculates average slope in points per min using theil-sen concept when arr index matches bar number
 {
   double acc,masl;
   int
     arrsize=ArraySize(arr),
     begbar=arrsize-1,
     iters=begbar*(begbar-1)/2;

   acc=0;
   for(int i=begbar;i>1;i--)
     for(int f=i-1;f>0;f--) {
       acc+=Dpts(arr[i],arr[f])/((i-f)*tf);      //points per min
     }
   masl=acc/iters;
   return masl;
 }


 bool btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }


 bool CanDoTrade()
 //checks if trading is ok via total orders, spread
 {
   bool
     equityOK=(AccountEquity()>6000),
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12);
   return (equityOK && spreadOK);
 }


 void showlasterror()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }


 void hline(string objlabel,double price)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
 }


 void displaytxt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 //
 //SPECIAL FUNCTIONS
 //
 int OnInit()
 {
   Gtf[0]=1;Gtf[1]=5;Gtf[2]=15;Gtf[3]=30;Gtf[4]=60;Gtf[5]=240;
   //fpatts="nnnn-4 nnnu-1 nnun-2 nnuu+2 nunn-2 nunu+1 nuun-1 nuuu+3 unnn-3 unnu+1 unun-1 unuu+2 uunn-2 uunu+2 uuun+1 uuuu+4";
   return(INIT_SUCCEEDED);
 }


 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

*** tickunnu
 use the speed of the computer to evaluate and place trades
 we look for a small profit each time but are set to make large gains too
 use an auto adjusting range
**** code v1 with the rather pointless but interesting init_unnu that varies
 //tickunnu.mq4

 //DESCRIP
 /*
 tickunnu uses ticks to trade
 */

 //TODO
 /*
 init_unnu should set un based on masl

 set up totalorder protection
 develop noise function
 work in trailer possibly through noise function
 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>

 //////////////////////////////////////////////////////////////

 //
 //CONSTANTS
 //
 #define sp "  "
 #define LT 0.1
 #define SLTP 1200.0*Point
 #define PAD 6*Point
 #define MINatr 60
 #define MINmasl 0.6


 //
 //EXTERNS
 //



 //
 //GLOBALS
 //
 int Gtf[6];
 int tfx=0;


 //
 //STRUCTURES
 //
 struct T_indi_info
 {
   //mode
   string mode;                                  //rng,lix,fax,nul determined by atr and masl

   //bar behavior
   string bb3,bb6;                               //bar behavior 3,6
  
   //fractals
   string fletter[7];                            //n or u
   int fbarnum[7];                               //bar number
   double fbarval[7];                            //bar value
   double fzh[7];                                //zone hi boundary
   double fzl[7];                                //zone lo boundary
   double frhythm6,frhythmdev;                   //fractal rhythm for 6 fractals
   string fp6;                                   //fractal patterns

   //atr
   double atr;                                   //atr value 6 bars watching for compression

   //unnu
   bool dunnu;                                   //unnu has been set

   //ma incline
   double masl;                                  //ma slope values long and short on closes
   double maslsl;                                //slope of the slopes can indicate swings

   //tickets
   int tkt;                                      //buysel ticket numbers

   //trade parameters
   int bs;                                       //buysel value
   double Bop,Sop,Bsl,Ssl;                       //buysel open price and stoploss
 };


 T_indi_info ii;


 //
 //FUNCTIONS
 //

 void OnTick()
 //runs the main code
 {
   int 
     tf=Gtf[tfx];

   if(is_new_bar())                              //get indicator info and trademerit only on every new bar
     fill_indi_info(tf);

   if(!ii.dunnu)
     init_unnu();
   else
     {
     if(ii.tkt==-1)                              //no trade active
       ii.bs=try_to_trade();                     //look to trade
     else
       traxit();
     }
 }


 void traxit()
 //trailing stop loss
 {
   double Nsl;
  
   switch(ii.bs)
     {
     case 0:
       if(Bid<ii.Bsl)
         {
           if(OrderClose(ii.tkt,LT,Bid,0))
             reset_trade_parameters();
         }
       else
         {
           Nsl=Bid-set_unnu()*Point;
           if(Nsl>ii.Bsl)
             ii.Bsl=Nsl;
           hline("u",ii.Bsl,Red);
         }
       break;
     case 1:
       if(Ask>ii.Ssl)
         {
           if(OrderClose(ii.tkt,LT,Ask,0))
             reset_trade_parameters();
         }
       else
         {
           Nsl=Ask+set_unnu()*Point;
           if(Nsl<ii.Ssl)
             ii.Ssl=Nsl;
           hline("n",ii.Ssl,Blue);
         }
       break;
     }

 }


 void reset_trade_parameters()
 //sets all trade parameters to -1
 {
   ii.tkt=-1;
   ii.bs=-1;
   ii.Bop=-1;
   ii.Sop=-1;
   ii.Bsl=-1;
   ii.Ssl=-1;
   ii.dunnu=false;
   ObjectDelete("n");
   ObjectDelete("u");
 }


 int try_to_trade()
 //watches if price goes past trigger points
 {
   if(Ask>ii.Bop)                                //price is above buy trigger
     {
       ii.tkt=OrderSend(Symbol(),0,LT,Ask,0,Ask-SLTP,Ask+SLTP);
       return 0;
     }
   if(Bid<ii.Sop)                                //price is below sel trigger
     {
       ii.tkt=OrderSend(Symbol(),1,LT,Bid,0,Bid+SLTP,Bid-SLTP);
       return 1;
     }
   return -1;
 }


 void init_unnu()
 //initializes the unnu
 {
   static double u=Bid,n=Ask;
  
   if(Dpts(u,n)<set_unnu())
     {
       if(Bid<u) u=Bid;
       if(Ask>n) n=Ask;
     }
   else
     {
       ii.dunnu=true;
       ii.Bop=n; ii.Sop=u;
       ii.Bsl=u; ii.Ssl=n;
       u=Bid;n=Ask;
     }
   hline("n",n,Blue);
   hline("u",u,Red);
 }


 double set_unnu()
 //sets the unnu value
 {
   if(ii.atr<MINatr/2)
     return MINatr/2;
   else
     return
       ii.atr;
 }


 void fill_indi_info(int tf)
 //fills the T_indi_info array
 {
   //fractal info 
   int i,b;
   double frn,fru;
  
   i=0;b=0;
   while(i<6)
     {
       b++;
       frn=iFractals(NULL,tf,MODE_UPPER,b);
       fru=iFractals(NULL,tf,MODE_LOWER,b);
       if(frn)
         {
           ii.fletter[i]="n";
           ii.fbarnum[i]=b;
           ii.fbarval[i]=frn;
           i++;
         }
       if(fru)
         {
           ii.fletter[i]="u";
           ii.fbarnum[i]=b;
           ii.fbarval[i]=fru;
           i++;
         }
     }

   //fractal patterns
   ii.fp6="";
   for(i=5;i>=0;i--)
       ii.fp6+=ii.fletter[i];
  
   //fractal rhythm for 6 appearances
   double barnumdeltas[5];
   for(i=0;i<5;i++)
     barnumdeltas[i]=ii.fbarnum[i+1]-ii.fbarnum[i];
   ii.frhythm6=iMAOnArray(barnumdeltas,0,5,0,MODE_SMA,0);
   ii.frhythmdev=iStdDevOnArray(barnumdeltas,0,5,0,MODE_SMA,0);

   //atr info in points
   ii.atr=iATR(NULL,tf,6,0)/Point;

   //bar behavior determinations
   double
     hwbb3=Dpts(High[3],High[1])/2,
     lwbb3=Dpts(Low[3],Low[1])/2,
     hwbb6=Dpts(High[7],High[1])/6,
     lwbb6=Dpts(Low[7],Low[1])/6;
   ii.bb3=bar_behavior(hwbb3,lwbb3);
   ii.bb6=bar_behavior(hwbb6,lwbb6);

   //ma info collection
   double ma[4]; ArrayInitialize(ma,0);
   for(b=1;b<4;b++)
     ma[b]=iMA(NULL,tf,12,0,MODE_SMA,PRICE_CLOSE,b);
   ii.masl=avgslope_per_min(tf,ma);

   //mode determination
   if(ii.atr>MINatr && fabs(ii.masl)<MINmasl)
     ii.mode="RNG";
   if(ii.atr<MINatr && fabs(ii.masl)>MINmasl)
     ii.mode="LIX";
   if(ii.atr>MINatr && fabs(ii.masl)>MINmasl)
     ii.mode="FAX";
   if(ii.atr<MINatr && fabs(ii.masl)<MINmasl)
     ii.mode="NUL";
 }

 string bar_behavior(double hi,double lo)
 //determines if bars are well-behaved by virtue of hilo relations
 {
   double
     ubnd=+MINmasl,
     lbnd=-MINmasl;
   bool
     min=(btn(lbnd,hi,ubnd) && btn(lbnd,lo,ubnd)),
     pos=(hi>ubnd && lo>ubnd),
     neg=(hi<lbnd && lo<lbnd);

   if(min) return "min";
   if(pos) return "pos";
   if(neg) return "neg";
   return "bbb";                                 //badly behaving bars
 }


 bool is_new_bar()
 //checks to see if we have a new bar
 {
   static datetime lastbartime;
   datetime
     curbartime=Time[0];
   if(lastbartime!=curbartime)
     {
       lastbartime=curbartime;
       return (true);
     }
   else
     return(false);
 }


 double avgslope_per_min(int tf,double &arr[])
 //calculates average slope in points per min using theil-sen concept when arr index matches bar number
 {
   double acc,masl;
   int
     arrsize=ArraySize(arr),
     begbar=arrsize-1,
     iters=begbar*(begbar-1)/2;

   acc=0;
   for(int i=begbar;i>1;i--)
     for(int f=i-1;f>0;f--) {
       acc+=Dpts(arr[i],arr[f])/((i-f)*tf);      //points per min
     }
   masl=acc/iters;
   return masl;
 }


 bool btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }


 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }


 bool CanDoTrade()
 //checks if trading is ok via total orders, spread
 {
   bool
     equityOK=(AccountEquity()>6000),
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12);
   return (equityOK && spreadOK);
 }


 void showlasterror()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }


 void hline(string objlabel,double price,color clr)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
 }


 void displaytxt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 //
 //SPECIAL FUNCTIONS
 //
 int OnInit()
 {
   ii.dunnu=false;
   ii.tkt=-1;
   Gtf[0]=1;Gtf[1]=5;Gtf[2]=15;Gtf[3]=30;Gtf[4]=60;Gtf[5]=240;
   return(INIT_SUCCEEDED);
 }


 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

**** code v2 with frac
 not great results but usually a small profit - too many trades mostly though
 //tickunnu.mq4

 //DESCRIP
 /*
 tickunnu uses ticks to trade
 */

 //TODO
 /*
 init_unnu should set un based on masl and atr

 set up totalorder protection
 develop noise function
 work in trailer possibly through noise function
 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>

 //////////////////////////////////////////////////////////////

 //
 //CONSTANTS
 //
 #define sp "  "
 #define LT 0.1
 #define SLTP 1200.0*Point
 #define PAD 6*Point
 #define MINatr 60
 #define MINmasl 0.6


 //
 //EXTERNS
 //



 //
 //GLOBALS
 //
 int Gtf[6];
 int tfx=0;


 //
 //STRUCTURES
 //
 struct T_indi_info
 {
   //mode
   string mode;                                  //rng,lix,fax,nul determined by atr and masl

   //bar behavior
   string bb3,bb6;                               //bar behavior 3,6
  
   //fractals
   string fletter[7];                            //n or u
   int fbarnum[7];                               //bar number
   double fbarval[7];                            //bar value
   double fzh[7];                                //zone hi boundary
   double fzl[7];                                //zone lo boundary
   double frhythm6,frhythmdev;                   //fractal rhythm for 6 fractals
   string fp6;                                   //fractal patterns

   //atr
   double atr;                                   //atr value 6 bars watching for compression

   //unnu
   bool dunnu;                                   //unnu has been set

   //ma incline
   double masl;                                  //ma slope values long and short on closes

   //tickets
   int tkt;                                      //buysel ticket numbers

   //trade parameters
   int bs;                                       //buysel value
   double Bop,Sop,Bsl,Ssl;                       //buysel open price and stoploss
 };


 T_indi_info ii;


 //
 //FUNCTIONS
 //

 void OnTick()
 //runs the main code
 {
   int 
     tf=Gtf[tfx];

   if(is_new_bar())                              //get indicator info and trademerit only on every new bar
     fill_indi_info(tf);

   if(!ii.dunnu)
     init_unnu();
   else
     {
     if(ii.tkt==-1)                              //no trade active
       ii.bs=try_to_trade();                     //look to trade
     else
       traxit();
     }
 }


 void traxit()
 //trailing stop loss
 {
   double Nsl;
   
   switch(ii.bs)
     {
     case 0:
       if(Bid<ii.Bsl)
         {
           if(OrderClose(ii.tkt,LT,Bid,0))
             reset_trade_parameters();
         }
       else
         {
           Nsl=Bid-set_unnu()*Point;
           if(Nsl>ii.Bsl)
             ii.Bsl=Nsl;
           hline("u",ii.Bsl,Red);
         }
       break;
     case 1:
       if(Ask>ii.Ssl)
         {
           if(OrderClose(ii.tkt,LT,Ask,0))
             reset_trade_parameters();
         }
       else
         {
           Nsl=Ask+set_unnu()*Point;
           if(Nsl<ii.Ssl)
             ii.Ssl=Nsl;
           hline("n",ii.Ssl,Blue);
         }
       break;
     }
 }


 void reset_trade_parameters()
 //sets all trade parameters to -1
 {
   ii.tkt=-1;
   ii.bs=-1;
   ii.Bop=-1;
   ii.Sop=-1;
   ii.Bsl=-1;
   ii.Ssl=-1;
   ii.dunnu=false;
   ObjectDelete("n");
   ObjectDelete("u");
 }


 int try_to_trade()
 //watches if price goes past trigger points
 {
   if(Ask>ii.Bop)                                //price is above buy trigger
     {
       ii.tkt=OrderSend(Symbol(),0,LT,Ask,0,Ask-SLTP,Ask+SLTP);
       return 0;
     }
   if(Bid<ii.Sop)                                //price is below sel trigger
     {
       ii.tkt=OrderSend(Symbol(),1,LT,Bid,0,Bid+SLTP,Bid-SLTP);
       return 1;
     }
   return -1;
 }


 void init_unnu()
 //initializes the unnu
 {
   double u,n,
     ufrac=.5,nfrac=.5,
     pr=Bid,
     unnu=set_unnu();

   frac_unnu(ufrac,nfrac);Comment(ii.masl,sp,sp,ufrac,sp,nfrac);
  
   u=pr-ufrac*unnu*Point;
   n=pr+nfrac*unnu*Point;
  
   ii.dunnu=true;
   ii.Bop=n; ii.Sop=u;
   ii.Bsl=u; ii.Ssl=n;

   hline("n",n,Blue);
   hline("u",u,Red);
 }


 double set_unnu()
 //sets the unnu value
 {
   double
     unnu=ii.atr;
   if(unnu<MINatr)
     unnu=MINatr;
   return unnu;
 }


 void frac_unnu(double &ufrac,double &nfrac)
 //calculate unnu fraction based on masl
 {
   double
     frac=.5,
     masl=fabs(ii.masl);
   bool posincl=(ii.masl>=0);
  
   if(0<=masl)
     frac=.5;
   if(0.6<=masl)
     frac=.6;
   if(1.2<masl)
     frac=.7;
   if(1.8<masl)
     frac=.8;
   if(2.4<masl)
     frac=.9;

   if(posincl)
     {
       ufrac=frac;
       nfrac=1-ufrac;
     }
   else
     {
       ufrac=1-frac;
       nfrac=frac;
     }
 }


 void fill_indi_info(int tf)
 //fills the T_indi_info array
 {
   //fractal info 
   int i,b;
   double frn,fru;
  
   i=0;b=0;
   while(i<6)
     {
       b++;
       frn=iFractals(NULL,tf,MODE_UPPER,b);
       fru=iFractals(NULL,tf,MODE_LOWER,b);
       if(frn)
         {
           ii.fletter[i]="n";
           ii.fbarnum[i]=b;
           ii.fbarval[i]=frn;
           i++;
         }
       if(fru)
         {
           ii.fletter[i]="u";
           ii.fbarnum[i]=b;
           ii.fbarval[i]=fru;
           i++;
         }
     }

   //fractal patterns
   ii.fp6="";
   for(i=5;i>=0;i--)
       ii.fp6+=ii.fletter[i];
  
   //fractal rhythm for 6 appearances
   double barnumdeltas[5];
   for(i=0;i<5;i++)
     barnumdeltas[i]=ii.fbarnum[i+1]-ii.fbarnum[i];
   ii.frhythm6=iMAOnArray(barnumdeltas,0,5,0,MODE_SMA,0);
   ii.frhythmdev=iStdDevOnArray(barnumdeltas,0,5,0,MODE_SMA,0);

   //atr info in points
   ii.atr=iATR(NULL,tf,6,0)/Point;

   //bar behavior determinations
   double
     hwbb3=Dpts(High[3],High[1])/2,
     lwbb3=Dpts(Low[3],Low[1])/2,
     hwbb6=Dpts(High[7],High[1])/6,
     lwbb6=Dpts(Low[7],Low[1])/6;
   ii.bb3=bar_behavior(hwbb3,lwbb3);
   ii.bb6=bar_behavior(hwbb6,lwbb6);

   //ma info collection
   double ma[4]; ArrayInitialize(ma,0);
   for(b=1;b<4;b++)
     ma[b]=iMA(NULL,tf,12,0,MODE_SMA,PRICE_CLOSE,b);
   ii.masl=avgslope_per_min(tf,ma);//Comment(ii.masl,sp,sp,ma[1],sp,ma[2],sp,ma[3]);

   //mode determination
   if(ii.atr>MINatr && fabs(ii.masl)<MINmasl)
     ii.mode="RNG";
   if(ii.atr<MINatr && fabs(ii.masl)>MINmasl)
     ii.mode="LIX";
   if(ii.atr>MINatr && fabs(ii.masl)>MINmasl)
     ii.mode="FAX";
   if(ii.atr<MINatr && fabs(ii.masl)<MINmasl)
     ii.mode="NUL";
 }

 string bar_behavior(double hi,double lo)
 //determines if bars are well-behaved by virtue of hilo relations
 {
   double
     ubnd=+MINmasl,
     lbnd=-MINmasl;
   bool
     min=(btn(lbnd,hi,ubnd) && btn(lbnd,lo,ubnd)),
     pos=(hi>ubnd && lo>ubnd),
     neg=(hi<lbnd && lo<lbnd);

   if(min) return "min";
   if(pos) return "pos";
   if(neg) return "neg";
   return "bbb";                                 //badly behaving bars
 }


 bool is_new_bar()
 //checks to see if we have a new bar
 {
   static datetime lastbartime;
   datetime
     curbartime=Time[0];
   if(lastbartime!=curbartime)
     {
       lastbartime=curbartime;
       return (true);
     }
   else
     return(false);
 }


 double avgslope_per_min(int tf,double &arr[])
 //calculates average slope in points per min using theil-sen concept when arr index matches bar number
 {
   double acc,masl;
   int
     arrsize=ArraySize(arr),
     begbar=arrsize-1,
     iters=begbar*(begbar-1)/2;

   acc=0;
   for(int i=begbar;i>1;i--)
     for(int f=i-1;f>0;f--) {
       acc+=Dpts(arr[i],arr[f])/((i-f)*tf);      //points per min
     }
   masl=acc/iters;
   return masl;
 }


 bool btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }


 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }


 bool CanDoTrade()
 //checks if trading is ok via total orders, spread
 {
   bool
     equityOK=(AccountEquity()>6000),
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12);
   return (equityOK && spreadOK);
 }


 void showlasterror()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }


 void hline(string objlabel,double price,color clr)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
 }


 void displaytxt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 //
 //SPECIAL FUNCTIONS
 //
 int OnInit()
 {
   ii.dunnu=false;
   ii.tkt=-1;
   Gtf[0]=1;Gtf[1]=5;Gtf[2]=15;Gtf[3]=30;Gtf[4]=60;Gtf[5]=240;
   return(INIT_SUCCEEDED);
 }


 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

**** code v3 with extended traxit ideas
 //tickunnu.mq4

 //DESCRIP
 /*
 tickunnu uses ticks to trade
 */

 //TODO
 /*
 incorporate highly intelligent traxit
 make ntr take into account fractal keypoints and distance of entry from them

 init_unnu should set un based on masl and atr DONE



 set up totalorder protection
 develop noise function
 work in trailer possibly through noise function
 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>

 //////////////////////////////////////////////////////////////

 //
 //CONSTANTS
 //
 #define sp "  "
 #define LT 0.1
 #define SLTP 1200.0*Point
 #define PAD 6*Point
 #define MINatr 60
 #define MINmasl 0.6


 //
 //EXTERNS
 //



 //
 //GLOBALS
 //
 int Gtf[6];
 int tfx=0;


 //
 //STRUCTURES
 //
 struct T_indi_info
 {
   //mode
   string mode;                                  //rng,lix,fax,nul determined by atr and masl

   //bar behavior
   string bb3,bb6;                               //bar behavior 3,6
  
   //fractals
   string fletter[7];                            //n or u
   int fbarnum[7];                               //bar number
   double fbarval[7];                            //bar value
   double fzh[7];                                //zone hi boundary
   double fzl[7];                                //zone lo boundary
   double frhythm6,frhythmdev;                   //fractal rhythm for 6 fractals
   string fp6;                                   //fractal patterns

   //atr
   double atr;                                   //atr value 6 bars watching for compression

   //unnu
   bool dunnu;                                   //unnu has been set

   //ma incline
   double masl;                                  //ma slope values long and short on closes

   //tickets
   int tkt;                                      //buysel ticket numbers

   //trade parameters
   int bs;                                       //buysel value
   double Bop,Sop,Bsl,Ssl;                       //buysel open price and stoploss
 };


 T_indi_info ii;


 //
 //FUNCTIONS
 //

 void OnTick()
 //runs the main code
 {
   int 
     tf=Gtf[tfx];

   if(is_new_bar())                              //get indicator info and trademerit only on every new bar
     fill_indi_info(tf);

   if(!ii.dunnu)
     init_unnu();
   else
     {
     if(ii.tkt==-1)                              //no trade active
       ii.bs=try_to_trade();                     //look to trade
     else
       traxit();
     }
 }


 void traxit()
 //trailing stop loss
 {
   double
     Nsl=0,
     deltapts=0;

   if(OrderSelect(ii.tkt,SELECT_BY_TICKET))
     switch(ii.bs)
       {
       case 0:
         if(Bid<ii.Bsl)
           {
             if(OrderClose(ii.tkt,LT,Bid,0))
               reset_trade_parameters();
           }
         else
           {
             deltapts=Dpts(OrderOpenPrice(),Bid);
            
             if(deltapts<40)
               Nsl=Bid-set_unnu()*Point;
             if(deltapts>40)
               Nsl=Bid-20*Point;
             if(deltapts>60)
               Nsl=Bid-15*Point;
             if(deltapts>60)
               Nsl=Bid-10*Point;              
            
             if(Nsl>ii.Bsl)
               ii.Bsl=Nsl;
            
             hline("u",ii.Bsl,Red);
           }
         break;
       case 1:
         if(Ask>ii.Ssl)
           {
             if(OrderClose(ii.tkt,LT,Ask,0))
               reset_trade_parameters();
           }
         else
           {
             deltapts=Dpts(Ask,OrderOpenPrice());
            
             if(deltapts<40)
               Nsl=Ask+set_unnu()*Point;
             if(deltapts>40)
               Nsl=Ask+20*Point;
             if(deltapts>60)
               Nsl=Ask+15*Point;
             if(deltapts>60)
               Nsl=Ask+10*Point;              
            
             if(Nsl<ii.Ssl)
               ii.Ssl=Nsl;
            
             hline("n",ii.Ssl,Blue);
           }
         break;
       }
 }


 void reset_trade_parameters()
 //sets all trade parameters to -1
 {
   ii.tkt=-1;
   ii.bs=-1;
   ii.Bop=-1;
   ii.Sop=-1;
   ii.Bsl=-1;
   ii.Ssl=-1;
   ii.dunnu=false;
   ObjectDelete("n");
   ObjectDelete("u");
 }


 int try_to_trade()
 //watches if price goes past trigger points
 {
   if(Ask>ii.Bop)                                //price is above buy trigger
     {
       ii.tkt=OrderSend(Symbol(),0,LT,Ask,0,Ask-SLTP,Ask+SLTP);
       return 0;
     }
   if(Bid<ii.Sop)                                //price is below sel trigger
     {
       ii.tkt=OrderSend(Symbol(),1,LT,Bid,0,Bid+SLTP,Bid-SLTP);
       return 1;
     }
   return -1;
 }


 void init_unnu()
 //initializes the unnu
 {
   double u,n,
     ufrac=.5,nfrac=.5,
     pr=Bid,
     unnu=set_unnu();

   frac_unnu(ufrac,nfrac);
  
   u=pr-ufrac*unnu*Point;
   n=pr+nfrac*unnu*Point;
  
   ii.dunnu=true;
   ii.Bop=n; ii.Sop=u;
   ii.Bsl=u; ii.Ssl=n;

   hline("n",n,Blue);
   hline("u",u,Red);
 }


 double set_unnu()
 //sets the unnu value
 {
   double
     unnu=ii.atr;
   if(unnu<MINatr)
     unnu=MINatr;
   return unnu;
 }


 void frac_unnu(double &ufrac,double &nfrac)
 //calculate unnu fraction based on masl
 {
   double
     frac=.5,
     masl=fabs(ii.masl);
   bool posincl=(ii.masl>=0);
  
   if(0<=masl)
     frac=.5;
   if(0.6<=masl)
     frac=.6;
   if(1.2<masl)
     frac=.7;
   if(1.8<masl)
     frac=.8;
   if(2.4<masl)
     frac=.9;

   if(posincl)
     {
       ufrac=frac;
       nfrac=1-ufrac;
     }
   else
     {
       ufrac=1-frac;
       nfrac=frac;
     }
 }


 void fill_indi_info(int tf)
 //fills the T_indi_info array
 {
   //fractal info 
   int i,b;
   double frn,fru;
  
   i=0;b=0;
   while(i<6)
     {
       b++;
       frn=iFractals(NULL,tf,MODE_UPPER,b);
       fru=iFractals(NULL,tf,MODE_LOWER,b);
       if(frn)
         {
           ii.fletter[i]="n";
           ii.fbarnum[i]=b;
           ii.fbarval[i]=frn;
           i++;
         }
       if(fru)
         {
           ii.fletter[i]="u";
           ii.fbarnum[i]=b;
           ii.fbarval[i]=fru;
           i++;
         }
     }

   //fractal patterns
   ii.fp6="";
   for(i=5;i>=0;i--)
       ii.fp6+=ii.fletter[i];
  
   //fractal rhythm for 6 appearances
   double barnumdeltas[5];
   for(i=0;i<5;i++)
     barnumdeltas[i]=ii.fbarnum[i+1]-ii.fbarnum[i];
   ii.frhythm6=iMAOnArray(barnumdeltas,0,5,0,MODE_SMA,0);
   ii.frhythmdev=iStdDevOnArray(barnumdeltas,0,5,0,MODE_SMA,0);

   //atr info in points
   ii.atr=iATR(NULL,tf,6,0)/Point;

   //bar behavior determinations
   double
     hwbb3=Dpts(High[3],High[1])/2,
     lwbb3=Dpts(Low[3],Low[1])/2,
     hwbb6=Dpts(High[7],High[1])/6,
     lwbb6=Dpts(Low[7],Low[1])/6;
   ii.bb3=bar_behavior(hwbb3,lwbb3);
   ii.bb6=bar_behavior(hwbb6,lwbb6);

   //ma info collection
   double ma[4]; ArrayInitialize(ma,0);
   for(b=1;b<4;b++)
     ma[b]=iMA(NULL,tf,12,0,MODE_SMA,PRICE_CLOSE,b);
   ii.masl=avgslope_per_min(tf,ma);//Comment(ii.masl,sp,sp,ma[1],sp,ma[2],sp,ma[3]);

   //mode determination
   if(ii.atr>MINatr && fabs(ii.masl)<MINmasl)
     ii.mode="RNG";
   if(ii.atr<MINatr && fabs(ii.masl)>MINmasl)
     ii.mode="LIX";
   if(ii.atr>MINatr && fabs(ii.masl)>MINmasl)
     ii.mode="FAX";
   if(ii.atr<MINatr && fabs(ii.masl)<MINmasl)
     ii.mode="NUL";
 }

 string bar_behavior(double hi,double lo)
 //determines if bars are well-behaved by virtue of hilo relations
 {
   double
     ubnd=+MINmasl,
     lbnd=-MINmasl;
   bool
     min=(btn(lbnd,hi,ubnd) && btn(lbnd,lo,ubnd)),
     pos=(hi>ubnd && lo>ubnd),
     neg=(hi<lbnd && lo<lbnd);

   if(min) return "min";
   if(pos) return "pos";
   if(neg) return "neg";
   return "bbb";                                 //badly behaving bars
 }


 bool is_new_bar()
 //checks to see if we have a new bar
 {
   static datetime lastbartime;
   datetime
     curbartime=Time[0];
   if(lastbartime!=curbartime)
     {
       lastbartime=curbartime;
       return (true);
     }
   else
     return(false);
 }


 double avgslope_per_min(int tf,double &arr[])
 //calculates average slope in points per min using theil-sen concept when arr index matches bar number
 {
   double acc,masl;
   int
     arrsize=ArraySize(arr),
     begbar=arrsize-1,
     iters=begbar*(begbar-1)/2;

   acc=0;
   for(int i=begbar;i>1;i--)
     for(int f=i-1;f>0;f--) {
       acc+=Dpts(arr[i],arr[f])/((i-f)*tf);      //points per min
     }
   masl=acc/iters;
   return masl;
 }


 bool btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }


 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }


 bool CanDoTrade()
 //checks if trading is ok via total orders, spread
 {
   bool
     equityOK=(AccountEquity()>6000),
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12);
   return (equityOK && spreadOK);
 }


 void showlasterror()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }


 void hline(string objlabel,double price,color clr)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
   ObjectSet(objlabel,OBJPROP_COLOR,clr);
 }


 void displaytxt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 //
 //SPECIAL FUNCTIONS
 //
 int OnInit()
 {
   ii.dunnu=false;
   ii.tkt=-1;
   Gtf[0]=1;Gtf[1]=5;Gtf[2]=15;Gtf[3]=30;Gtf[4]=60;Gtf[5]=240;
   return(INIT_SUCCEEDED);
 }


 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

*** mody
 work with pa indicators that help to determine mode

 1. rng,lix,fax,nul these patterns tend to hold for several bars usually
 modes may flow into each other separated by nul
 rationale (except at news announcements)
 - it takes a lot of money to turn things around
 - price movement possibly resembles shm

 2. well-behaved bars
 wb3,6 - well behaved 3,6 bars where both mah,mal have same incline

 3. fractuns
 these are the patterns including imbalances

 4. higher tf influences
 these will provide the forest picture

**** code v1 still trying to use fractalxoner
 fractalxoner seems to be too complex and has too many issues such as which fractals should be active
 over nov the best it did was 153 and with over 1000 trades
 using mody ideas may have helped, but better we go right to mody and use fractals as a part of the mode setting

 //mody.mq4

 //DESCRIP
 /*
 fractalxoner uses fractals to determine trading zones with the xonerator concept
 */

 //TODO
 /*
 setup ntrxit

 check logic thoroughly
 try not moving sl till another fractal does it - slightly better results it seems
 don't use actual sl and trail through other fractals
 alter entrygap using ma inclines


 why only 1 trade when Csltp=120? print out data to file to figure out.
 figure out why usdjpy did so consistently poorly - is it usepoint type thing?

 create sl placements based on atr,ma,fpatterns

 set up totalorder protection


 develop noise function
 work in trailer possibly through noise function
 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>

 //////////////////////////////////////////////////////////////

 //
 //CONSTANTS
 //
 #define sp "  "
 #define Clt 0.1
 #define Csltp 1200.0*Point
 #define Czonesize 12*Point
 #define Centrygap 36*Point
 #define Cpad 6*Point
 #define Catrmin 60
 #define Cmaslmin 0.6


 //
 //EXTERNS
 //
 //extern int Etfx;
 extern int tfx;

 //
 //GLOBALS
 //
 int Gtf[6];
 string fpatts;



 //
 //STRUCTURES
 //
 struct T_indi_info
 {
   //mode
   string mode;                                  //rng,lix,fax,nul determined by atr and masl

   //bar behavior
   string bb3,bb6;                               //bar behavior 3,6
  
   //fractals
   string fletter[7];                            //n or u
   int fbarnum[7];                               //bar number
   double fbarval[7];                            //bar value
   double fzh[7];                                //zone hi boundary
   double fzl[7];                                //zone lo boundary
   double frhythm6,frhythmdev;                   //fractal rhythm for 6 fractals
   string fp6;                                   //fractal patterns

   //atr
   double atr;                                   //atr value 6 bars watching for compression

   //ma incline
   double masl;                                  //ma slope values long and short on closes
   double maslsl;                                //slope of the slopes can indicate swings

   //tickets
   int tkt;                                      //buysel ticket numbers

   //trade parameters
   int bs;                                       //buysel value
   double Bop,Sop,Bsl,Ssl;                       //buysel op and sl triggers
   bool trade_parameters_set;                    //trade parameters are set
 };


 T_indi_info ii;

 //
 //FUNCTIONS
 //

 void OnTick()
 //runs the main code
 {
   int 
     tf=Gtf[tfx],
     zonenum=-1;
  
   if(is_new_bar())                              //get indicator info and trademerit only on every new bar
     fill_indi_info(tf);

  
   zonenum=get_zone_number();                    //identify the zone price is in
  
   if(zonenum>-1)                                //if in a zone set triggers for op and sl
     set_triggers_inzone(zonenum);
  
   if(ii.trade_parameters_set)
     if(ii.tkt==-1)                              //no trade active
       ii.bs=try_to_trade();                     //look to trade
     else
       trailerxit();                             //use trailing exit since we have a trade

 }


 void trailerxit()
 //trailing stop loss
 {
   double Nsl;                                   //new sl trigger

   if(OrderSelect(ii.tkt,SELECT_BY_TICKET))
     {
       switch(ii.bs)
         {
         case 0:
           if(Bid<ii.Bsl)
             {
               if(OrderClose(ii.tkt,Clt,OrderClosePrice(),0))
                 reset_trade_parameters();
             }
           else
             {
               Nsl=Bid-Centrygap;
               if(Nsl>ii.Bsl)
                 ii.Bsl=Nsl;
             }
           break;
         case 1:
           if(Ask>ii.Ssl)
             {
               if(OrderClose(ii.tkt,Clt,OrderClosePrice(),0))
                 reset_trade_parameters();
             }
           else
             {
               Nsl=Ask+Centrygap;
               if(Nsl<ii.Ssl)
                 ii.Ssl=Nsl;
             }
           break;
         default:
           Alert("problem");
         }
     }
 }


 int try_to_trade()
 //watches if price goes past a trigger point
 {
   if(Ask>ii.Bop)                                //price is above buy trigger
     {
       ii.tkt=OrderSend(Symbol(),0,Clt,Ask,0,Ask-Csltp,Ask+Csltp);
       return 0;
     }
   if(Bid<ii.Sop)                                //price is below sel trigger
     {
       ii.tkt=OrderSend(Symbol(),1,Clt,Bid,0,Bid+Csltp,Bid-Csltp);
       return 1;
     }
   return -1;
 }


 void set_triggers_inzone(int zn)
 //sets trade triggers when price is inside a zone
 { 
   ii.Bop=ii.fbarval[zn]+entrygap();             //Buy open point
   ii.Sop=ii.fbarval[zn]-entrygap();             //Sel open point
   ii.Bsl=ii.Sop+Cpad;                           //Buy sl point
   ii.Ssl=ii.Bop-Cpad;                           //Sel sl point
   ii.trade_parameters_set=true;
 }

 double entrygap()
 //determines the Bsl,Ssl entry distances from fractal value
 {
   return Centrygap;
 }

 void reset_trade_parameters()
 //sets all trade parameters to -1
 {
   ii.tkt=-1;
   ii.bs=-1;
   ii.Bop=-1;
   ii.Sop=-1;
   ii.Bsl=-1;
   ii.Ssl=-1;
   ii.trade_parameters_set=false;
 }
  

 int get_zone_number()
 //checks that price is in zone
 {
   int i=0;
   while(!btn(ii.fzl[i],Bid,ii.fzh[i]) && i<6)
     i++;
   if(btn(0,i,6))                                //use only fully established fractals
     return i;
   return -1;
 }


 void fill_indi_info(int tf)
 //fills the T_indi_info array
 {
   //fractal info 
   int i,b;
   double frn,fru;
  
   i=0;b=0;
   while(i<6)
     {
       b++;
       frn=iFractals(NULL,tf,MODE_UPPER,b);
       fru=iFractals(NULL,tf,MODE_LOWER,b);
       if(frn)
         {
           ii.fletter[i]="n";
           ii.fbarnum[i]=b;
           ii.fbarval[i]=frn;
           ii.fzh[i]=ii.fbarval[i]+Czonesize;
           ii.fzl[i]=ii.fbarval[i]-Czonesize;
           i++;
         }
       if(fru)
         {
           ii.fletter[i]="u";
           ii.fbarnum[i]=b;
           ii.fbarval[i]=fru;
           ii.fzh[i]=ii.fbarval[i]+Czonesize;
           ii.fzl[i]=ii.fbarval[i]-Czonesize;
           i++;
         }
     }

   //fractal patterns
   ii.fp6="";
   for(i=5;i>=0;i--)
       ii.fp6+=ii.fletter[i];
  
   //fractal rhythm for 6 appearances
   double barnumdeltas[5];
   for(i=0;i<5;i++)
     barnumdeltas[i]=ii.fbarnum[i+1]-ii.fbarnum[i];
   ii.frhythm6=iMAOnArray(barnumdeltas,0,5,0,MODE_SMA,0);
   ii.frhythmdev=iStdDevOnArray(barnumdeltas,0,5,0,MODE_SMA,0);

   //atr info in points
   ii.atr=iATR(NULL,tf,6,0)/Point;

   //bar behavior determinations
   double
     hwbb3=Dpts(High[3],High[1])/2,
     lwbb3=Dpts(Low[3],Low[1])/2,
     hwbb6=Dpts(High[7],High[1])/6,
     lwbb6=Dpts(Low[7],Low[1])/6;
   ii.bb3=bar_behavior(hwbb3,lwbb3);
   ii.bb6=bar_behavior(hwbb6,lwbb6);

   //ma info collection
   double ma[4]; ArrayInitialize(ma,0);
   for(b=1;b<4;b++)
     ma[b]=iMA(NULL,tf,12,0,MODE_SMA,PRICE_CLOSE,b);
   ii.masl=avgslope_per_min(tf,ma);

   //mode determination
   if(ii.atr>Catrmin && fabs(ii.masl)<Cmaslmin)
     ii.mode="RNG";
   if(ii.atr<Catrmin && fabs(ii.masl)>Cmaslmin)
     ii.mode="LIX";
   if(ii.atr>Catrmin && fabs(ii.masl)>Cmaslmin)
     ii.mode="FAX";
   if(ii.atr<Catrmin && fabs(ii.masl)<Cmaslmin)
     ii.mode="NUL";
 }

 string bar_behavior(double hi,double lo)
 //determines if bars are well-behaved by virtue of hilo relations
 {
   double
     ubnd=+Cmaslmin,
     lbnd=-Cmaslmin;
   bool
     min=(btn(lbnd,hi,ubnd) && btn(lbnd,lo,ubnd)),
     pos=(hi>ubnd && lo>ubnd),
     neg=(hi<lbnd && lo<lbnd);

   if(min) return "min";
   if(pos) return "pos";
   if(neg) return "neg";
   return "bbb";                                 //badly behaving bars
 }


 bool is_new_bar()
 //checks to see if we have a new bar
 {
   static datetime lastbartime;
   datetime
     curbartime=Time[0];
   if(lastbartime!=curbartime)
     {
       lastbartime=curbartime;
       return (true);
     }
   else
     return(false);
 }


 double maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);

   if(minbar>maxbar)
     return Dpts(minval,maxval);
   else
     return Dpts(maxval,minval);
 }

 double Dprs(double pI,double pF)
 //difference between two prices
 {
   return (pF-pI);
 }

 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }

 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf giving points per bar
 {
   int
     Dbar=bI-bF;
   return Dpts(vI,vF)/Dbar;
 }


 double avgslope_per_min(int tf,double &arr[])
 //calculates average slope in points per min using theil-sen concept when arr index matches bar number
 {
   double acc,masl;
   int
     arrsize=ArraySize(arr),
     begbar=arrsize-1,
     iters=begbar*(begbar-1)/2;

   acc=0;
   for(int i=begbar;i>1;i--)
     for(int f=i-1;f>0;f--) {
       acc+=Dpts(arr[i],arr[f])/((i-f)*tf);      //points per min
     }
   masl=acc/iters;
   return masl;
 }


 bool btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }


 bool CanDoTrade()
 //checks if trading is ok via total orders, spread
 {
   bool
     equityOK=(AccountEquity()>6000),
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12);
   return (equityOK && spreadOK);
 }

 void showlasterror()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }

 void hline(string objlabel,double price)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
 }
  
 void displaytxt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 //
 //SPECIAL FUNCTIONS
 //
 int OnInit()
 {
   ii.tkt=-1;
   ii.bs=-1;
   Gtf[0]=1;Gtf[1]=5;Gtf[2]=15;Gtf[3]=30;Gtf[4]=60;Gtf[5]=240;
   fpatts="nnnn-4 nnnu-1 nnun-2 nnuu+2 nunn-2 nunu+1 nuun-1 nuuu+3 unnn-3 unnu+1 unun-1 unuu+2 uunn-2 uunu+2 uuun+1 uuuu+4";
   return(INIT_SUCCEEDED);
 }


 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

*** fractalxoner
**** code v1 working inzone with pending orders
 pending orders don't zero out when deleted
 also, wroeder agrees that pending orders are excessive for ea since it is on-call always
 //fractalxoner.mq4

 //DESCRIP
 /*
 fractalxoner uses fractals to determine trading zones with the xonerator concept
 */

 //TODO
 /*
 redo without pending orders
 management routine for trailing stop

 trailer
 develop noise function
 work in trailer possibly through noise function
 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>

 //////////////////////////////////////////////////////////////

 //
 //CONSTANTS
 //
 #define sp "  "
 #define Clt 0.1
 #define Csltp 600.0*Point
 #define Czonegap 10*Point
 #define Centrygap 20*Point
 #define Cpad 6*Point


 //
 //EXTERNS
 //
 //extern int Etfx;

 //
 //GLOBALS
 //
 int Gtf[6];
 string fpatts;


 //
 //STRUCTURES
 //
 struct T_indicator_info
 {
   //fractals
   string fletter[7];                            //n or u
   int fbarnum[7];                               //bar number
   double fbarval[7];                            //bar value
   double fzh[7];                                //zone hi boundary
   double fzl[7];                                //zone lo boundary
   double frhythm6,frhythmdev;                   //fractal rhythm for 6 fractals
   string fp6;                                   //fractal patterns

   //atr
   double atrval;                                //atr value 6 bars watching for compression

   //ma incline
   double sma,lma;                               //ma slope values long and short on closes

   //tickets
   int Btkt,Stkt;                                //buysel ticket numbers
 };


 //
 //FUNCTIONS
 //
 void main()
 {
   int 
     tfx=1,
     tf=Gtf[tfx],
     zonenum=-1;
   static T_indicator_info ii;


   if(is_new_bar())                                //get indicator info and trademerit only on every new bar
       fill_indicator_info(tf,ii);

   zonenum=get_zone_number(ii);
   if(zonenum>-1)
     set_trades_inzone(zonenum,ii);
   else
     manage_trades(ii);

 }

 void manage_trades(T_indicator_info &ii)
 //manages trades when price is not inside a zone
 {
   bool od,
     OSbuy=(OrderSelect(ii.Btkt,SELECT_BY_TICKET)),
     Abuy=(OrderType()==OP_BUY),                 //active buy
     Pbuy=(OrderType()==OP_BUYSTOP),             //pending buy
     buy0=(!Abuy && !Pbuy),                      //no buys
     OSsel=(OrderSelect(ii.Stkt,SELECT_BY_TICKET)),
     Asel=(OrderType()==OP_SELL),                //active sel
     Psel=(OrderType()==OP_SELLSTOP),            //pending sel
     sel0=(!Asel && !Psel);                      //no sels

   Comment(buy0,sp,Abuy,sp,Pbuy);
  
   if(Abuy && sel0)                          //active buy, no sels
     trailer(ii.Btkt);                       //trail with buytkt
   if(buy0 && Asel)                          //no buys, active sel
     trailer(ii.Stkt);                       //trail with seltkt
   if(Abuy && Psel)                          //active buy, but pending sel
     od=OrderDelete(ii.Stkt);                //delete pending sel
   if(Pbuy && Asel)                          //active sel, but pending buy
     od=OrderDelete(ii.Btkt);                //delete pending buy

   if(Abuy && Asel)                              //both buy and sel are active an unlikely situation
     od=close_both_orders(ii.Btkt,ii.Stkt);
 }

 void trailer(int tkt)
 //trailing stop loss
 {
   //Comment(tkt);
 }

 void set_trades_inzone(int zn,T_indicator_info &ii)
 //sets trade orders when price is inside a zone
 {
   double Bsl,Ssl,
     Bop=0,Sop=0;
   bool
     Btkt=(ii.Btkt>0),
     Stkt=(ii.Stkt>0);

   if(!Btkt && !Stkt)                            //no buy no sel
     {
       Bop=ii.fbarval[zn]+Centrygap;
       Sop=ii.fbarval[zn]-Centrygap;
       Bsl=Sop+Cpad;
       Ssl=Bop-Cpad;
       ii.Btkt=OrderSend(Symbol(),OP_BUYSTOP,Clt,Bop,0,Bsl,0,"buy",111);
       ii.Stkt=OrderSend(Symbol(),OP_SELLSTOP,Clt,Sop,0,Ssl,0,"sel",111);      
     }
   if(Btkt && !Stkt)                             //is buy but no sel
     {
       Sop=ii.fbarval[zn]-Centrygap;
       Ssl=Bop-Cpad;
       ii.Stkt=OrderSend(Symbol(),OP_SELLSTOP,Clt,Sop,0,Ssl,0,"sel",111);      
     }
   if(!Btkt && Stkt)                             //no buy but is sel
     {
       Bop=ii.fbarval[zn]+Centrygap;
       Bsl=Sop+Cpad;
       ii.Btkt=OrderSend(Symbol(),OP_BUYSTOP,Clt,Bop,0,Bsl,0,"buy",111);
     }
 }


 bool close_both_orders(int Btkt,int Stkt)
 //closes both active orders if they exist simultaneously
 {
   if(OrderClose(Btkt,Clt,Bid,0) && OrderClose(Stkt,Clt,Ask,0))
     return true;
   else
     return false;
 }

 int get_zone_number(T_indicator_info &ii)
 //checks that price is in zone
 {
   int i=0;
   while(!btn(ii.fzl[i],Bid,ii.fzh[i]) && i<6)
     i++;
   if(btn(-1,i,6))
      return i;
   return -1;
 }

 void fill_indicator_info(int tf,T_indicator_info &ii)
 //fills the T_indicator_info array
 {
   //fractal info 
   int i,b;
   double frn,fru;
  
   i=0;b=0;
   while(i<6)
     {
       b++;
       frn=iFractals(NULL,tf,MODE_UPPER,b);
       fru=iFractals(NULL,tf,MODE_LOWER,b);
       if(frn)
         {
           ii.fletter[i]="n";
           ii.fbarnum[i]=b;
           ii.fbarval[i]=frn;
           ii.fzh[i]=ii.fbarval[i]+Czonegap;
           ii.fzl[i]=ii.fbarval[i]-Czonegap;
           i++;
         }
       if(fru)
         {
           ii.fletter[i]="u";
           ii.fbarnum[i]=b;
           ii.fbarval[i]=fru;
           ii.fzh[i]=ii.fbarval[i]+Czonegap;
           ii.fzl[i]=ii.fbarval[i]-Czonegap;
           i++;
         }
     }

   //fractal patterns
   ii.fp6="";
   for(i=5;i>=0;i--)
       ii.fp6+=ii.fletter[i];
  
   //fractal rhythm for 6 appearances
   double barnumdeltas[5];
   for(i=0;i<5;i++)
     barnumdeltas[i]=ii.fbarnum[i+1]-ii.fbarnum[i];
   ii.frhythm6=iMAOnArray(barnumdeltas,0,5,0,MODE_SMA,0);
   ii.frhythmdev=iStdDevOnArray(barnumdeltas,0,5,0,MODE_SMA,0);

   //atr info
   ii.atrval=iATR(NULL,tf,6,0)/Point;

   //ma info
   double ma[4]; ArrayInitialize(ma,0);
   for(b=1;b<4;b++)
     ma[b]=iMA(NULL,tf,3,0,MODE_SMA,PRICE_CLOSE,b);
   ii.sma=avgslope(ma);

 }


 // *** may want to develop a fractal version of this so we get truer turning points
 double maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);

   if(minbar>maxbar)
     return Dpts(minval,maxval);
   else
     return Dpts(maxval,minval);
 }

 double Dprs(double pI,double pF)
 //difference between two prices
 {
   return (pF-pI);
 }

 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }

 bool btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }

 double avgslope(double &arr[])
 //calculates average slope per bar using theil-sen concept when arr index matches bar number
 {
   double acc;
   int
     arrsize=ArraySize(arr),
     numbars=arrsize-1,
     iters=numbars*(numbars-1)/2;

   acc=0;
   for(int i=numbars;i>1;i--)
     for(int j=i-1;j>0;j--)
       acc+=incline(i,arr[i],j,arr[j]);
   return acc/iters;
 }

 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
 {
   int
     Dbar=bI-bF;
   return Dpts(vI,vF)/Dbar;
 }

 bool is_new_bar()
 //checks to see if we have a new bar
 {
   static datetime lastbartime;
   datetime
     curbartime=Time[0];
   if(lastbartime!=curbartime)
     {
       lastbartime=curbartime;
       return (true);
     }
   else
     return(false);
 }

 bool CanDoTrade()
 //checks if trading is ok via total orders, spread
 {
   bool
     equityOK=(AccountEquity()>6000),
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12);
   return (equityOK && spreadOK);
 }


 bool OpenOrderExists()
 //acknowledges existence of an open order
 {
   for(int p=OrdersTotal()-1;p>=0;p--)
     if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
      return true;
   return false;
 }

 void showlasterror()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }

 void hline(string objlabel,double price)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
 }
  
 void displaytxt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 //
 //SPECIAL FUNCTIONS
 //
 int OnInit()
 {
   //s.bs=-1;
   Gtf[0]=1;Gtf[1]=5;Gtf[2]=15;Gtf[3]=30;Gtf[4]=60;Gtf[5]=240;
   fpatts="nnnn-4 nnnu-1 nnun-2 nnuu+2 nunn-2 nunu+1 nuun-1 nuuu+3 unnn-3 unnu+1 unun-1 unuu+2 uunn-2 uunu+2 uuun+1 uuuu+4";
   return(INIT_SUCCEEDED);
 }

 void OnDeinit(const int reason)
 {
  
 }

 void OnTick()
 {
   main();
 }



 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

**** code v2 no pending orders fixed sl
 fairly good results on one day in larger tfs and 120pt sl on EURUSD
 consistent loss on USDJPY ... curious ...
 we should be able to determine sl via atr,ma,fpatts

 //fractalxoner.mq4

 //DESCRIP
 /*
 fractalxoner uses fractals to determine trading zones with the xonerator concept
 */

 //TODO
 /*
 check logic thoroughly
 create sl placements based on atr,ma,fpatterns
 set up totalorder protection

 trailer
 develop noise function
 work in trailer possibly through noise function
 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>

 //////////////////////////////////////////////////////////////

 //
 //CONSTANTS
 //
 #define sp "  "
 #define Clt 0.1
 #define Csltp 600.0*Point
 #define Czonegap 10*Point
 #define Centrygap 20*Point
 #define Cpad 6*Point


 //
 //EXTERNS
 //
 //extern int Etfx;

 //
 //GLOBALS
 //
 int Gtf[6];
 string fpatts;


 //
 //STRUCTURES
 //
 struct T_indicator_info
 {
   //fractals
   string fletter[7];                            //n or u
   int fbarnum[7];                               //bar number
   double fbarval[7];                            //bar value
   double fzh[7];                                //zone hi boundary
   double fzl[7];                                //zone lo boundary
   double frhythm6,frhythmdev;                   //fractal rhythm for 6 fractals
   string fp6;                                   //fractal patterns

   //atr
   double atrval;                                //atr value 6 bars watching for compression

   //ma incline
   double sma,lma;                               //ma slope values long and short on closes

   //tickets
   int tkt;                                      //buysel ticket numbers

   //trade parameters
   int bs;                                       //buysel value
   double Bop,Sop,Bsl,Ssl;                       //buysel op and sl triggers
 };


 T_indicator_info ii;

 //
 //FUNCTIONS
 //
 void main()
 {
   int 
     tfx=1,
     tf=Gtf[tfx],
     zonenum=-1;

   if(is_new_bar())                              //get indicator info and trademerit only on every new bar
       fill_indicator_info(tf);

   zonenum=get_zone_number();                    //identify the zone
  
   if(zonenum>-1)                                //if inzone set triggers
     set_triggers_inzone(zonenum);

   if(ii.tkt==-1)                                //no trade active
     ii.bs=try_trade();                          //look to trade
   else
     trailerxit();                               //use trailing exit since we have a trade

 }


 void trailerxit()
 //trailing stop loss
 {
   double Nsl;                                   //new sl trigger

   if(OrderSelect(ii.tkt,SELECT_BY_TICKET))
     {
       switch(ii.bs)
         {
         case 0:
           if(Bid<ii.Bsl)
             {
               if(OrderClose(ii.tkt,Clt,OrderClosePrice(),0))
                 reset_trade_parameters();
             }
           else
             {
               Nsl=Bid-Centrygap;
               if(Nsl>ii.Bsl)
                 ii.Bsl=Nsl;
             }
           break;
         case 1:
           if(Ask>ii.Ssl)
             {
               if(OrderClose(ii.tkt,Clt,OrderClosePrice(),0))
                 reset_trade_parameters();
             }
           else
             {
               Nsl=Ask+Centrygap;
               if(Nsl<ii.Ssl)
                 ii.Ssl=Nsl;
             }
           break;
         default:
           Alert("problem");
         }
     }
 }


 int try_trade()
 //watches if price goes past a trigger point
 {
   if(Bid>ii.Bop)                                //price is above buy trigger
     {
       ii.tkt=OrderSend(Symbol(),0,Clt,Ask,0,Ask-Csltp,Ask+Csltp);
       return 0;
     }
   if(Bid<ii.Sop)                                //price is below sel trigger
     {
       ii.tkt=OrderSend(Symbol(),1,Clt,Bid,0,Bid+Csltp,Bid-Csltp);
       return 1;
     }
   return -1;
 }


 void set_triggers_inzone(int zn)
 //sets trade triggers when price is inside a zone
 {
   ii.Bop=ii.fbarval[zn]+Centrygap;
   ii.Sop=ii.fbarval[zn]-Centrygap;
   ii.Bsl=ii.Sop+Cpad;
   ii.Ssl=ii.Bop-Cpad;
 }


 void reset_trade_parameters()
 //sets all trade parameters to -1
 {
   ii.tkt=-1;
   ii.bs=-1;
   ii.Bop=-1;
   ii.Sop=-1;
   ii.Bsl=-1;
   ii.Ssl=-1;
 }
  

 int get_zone_number()
 //checks that price is in zone
 {
   int i=0;
   while(!btn(ii.fzl[i],Bid,ii.fzh[i]) && i<6)
     i++;
   if(btn(-1,i,6))
      return i;
   return -1;
 }


 bool is_new_bar()
 //checks to see if we have a new bar
 {
   static datetime lastbartime;
   datetime
     curbartime=Time[0];
   if(lastbartime!=curbartime)
     {
       lastbartime=curbartime;
       return (true);
     }
   else
     return(false);
 }


 void fill_indicator_info(int tf)
 //fills the T_indicator_info array
 {
   //fractal info 
   int i,b;
   double frn,fru;
  
   i=0;b=0;
   while(i<6)
     {
       b++;
       frn=iFractals(NULL,tf,MODE_UPPER,b);
       fru=iFractals(NULL,tf,MODE_LOWER,b);
       if(frn)
         {
           ii.fletter[i]="n";
           ii.fbarnum[i]=b;
           ii.fbarval[i]=frn;
           ii.fzh[i]=ii.fbarval[i]+Czonegap;
           ii.fzl[i]=ii.fbarval[i]-Czonegap;
           i++;
         }
       if(fru)
         {
           ii.fletter[i]="u";
           ii.fbarnum[i]=b;
           ii.fbarval[i]=fru;
           ii.fzh[i]=ii.fbarval[i]+Czonegap;
           ii.fzl[i]=ii.fbarval[i]-Czonegap;
           i++;
         }
     }

   //fractal patterns
   ii.fp6="";
   for(i=5;i>=0;i--)
       ii.fp6+=ii.fletter[i];
  
   //fractal rhythm for 6 appearances
   double barnumdeltas[5];
   for(i=0;i<5;i++)
     barnumdeltas[i]=ii.fbarnum[i+1]-ii.fbarnum[i];
   ii.frhythm6=iMAOnArray(barnumdeltas,0,5,0,MODE_SMA,0);
   ii.frhythmdev=iStdDevOnArray(barnumdeltas,0,5,0,MODE_SMA,0);

   //atr info
   ii.atrval=iATR(NULL,tf,6,0)/Point;

   //ma info
   double ma[4]; ArrayInitialize(ma,0);
   for(b=1;b<4;b++)
     ma[b]=iMA(NULL,tf,3,0,MODE_SMA,PRICE_CLOSE,b);
   ii.sma=avgslope(ma);

 }


 // *** may want to develop a fractal version of this so we get truer turning points
 double maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);

   if(minbar>maxbar)
     return Dpts(minval,maxval);
   else
     return Dpts(maxval,minval);
 }

 double Dprs(double pI,double pF)
 //difference between two prices
 {
   return (pF-pI);
 }

 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }

 bool btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }

 double avgslope(double &arr[])
 //calculates average slope per bar using theil-sen concept when arr index matches bar number
 {
   double acc;
   int
     arrsize=ArraySize(arr),
     numbars=arrsize-1,
     iters=numbars*(numbars-1)/2;

   acc=0;
   for(int i=numbars;i>1;i--)
     for(int j=i-1;j>0;j--)
       acc+=incline(i,arr[i],j,arr[j]);
   return acc/iters;
 }

 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
 {
   int
     Dbar=bI-bF;
   return Dpts(vI,vF)/Dbar;
 }

 bool CanDoTrade()
 //checks if trading is ok via total orders, spread
 {
   bool
     equityOK=(AccountEquity()>6000),
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12);
   return (equityOK && spreadOK);
 }

 void showlasterror()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }

 void hline(string objlabel,double price)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
 }
  
 void displaytxt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 //
 //SPECIAL FUNCTIONS
 //
 int OnInit()
 {
   ii.tkt=-1;
   ii.bs=-1;
   Gtf[0]=1;Gtf[1]=5;Gtf[2]=15;Gtf[3]=30;Gtf[4]=60;Gtf[5]=240;
   fpatts="nnnn-4 nnnu-1 nnun-2 nnuu+2 nunn-2 nunu+1 nuun-1 nuuu+3 unnn-3 unnu+1 unun-1 unuu+2 uunn-2 uunu+2 uuun+1 uuuu+4";
   return(INIT_SUCCEEDED);
 }

 void OnDeinit(const int reason)
 {
  
 }

 void OnTick()
 {
   main();
 }



 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

**** code v3 avgslope fixed mode re-introduced
 //fractalxoner.mq4

 //DESCRIP
 /*
 fractalxoner uses fractals to determine trading zones with the xonerator concept
 */

 //TODO
 /*

 check logic thoroughly
 try not moving sl till another fractal does it - slightly better results it seems
 don't use actual sl and trail through other fractals
 alter entrygap using ma inclines


 why only 1 trade when Csltp=120? print out data to file to figure out.
 figure out why usdjpy did so consistently poorly - is it usepoint type thing?

 create sl placements based on atr,ma,fpatterns

 set up totalorder protection


 develop noise function
 work in trailer possibly through noise function
 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>

 //////////////////////////////////////////////////////////////

 //
 //CONSTANTS
 //
 #define sp "  "
 #define Clt 0.1
 #define Csltp 1200.0*Point
 #define Czonesize 12*Point
 #define Centrygap 36*Point
 #define Cpad 6*Point
 #define Catrmin 60
 #define Cmaslmin 12



 //
 //EXTERNS
 //
 //extern int Etfx;

 //
 //GLOBALS
 //
 int Gtf[6];
 string fpatts;


 //
 //STRUCTURES
 //
 struct T_indicator_info
 {
   //mode
   string mode;                                  //determined by atr and masl
  
   //fractals
   string fletter[7];                            //n or u
   int fbarnum[7];                               //bar number
   double fbarval[7];                            //bar value
   double fzh[7];                                //zone hi boundary
   double fzl[7];                                //zone lo boundary
   double frhythm6,frhythmdev;                   //fractal rhythm for 6 fractals
   string fp6;                                   //fractal patterns

   //atr
   double atr;                                   //atr value 6 bars watching for compression

   //ma incline
   double masl;                                  //ma slope values long and short on closes

   //tickets
   int tkt;                                      //buysel ticket numbers

   //trade parameters
   int bs;                                       //buysel value
   double Bop,Sop,Bsl,Ssl;                       //buysel op and sl triggers
   bool trade_parameters_set;                    //trade parameters are set
 };


 T_indicator_info ii;

 //
 //FUNCTIONS
 //
 void OnTick()
 {
   int 
     tfx=3,
     tf=Gtf[tfx],
     zonenum=-1;


   if(is_new_bar())                              //get indicator info and trademerit only on every new bar
       fill_indicator_info(tf);

   zonenum=get_zone_number();                    //identify the zone price is in
  
   if(zonenum>-1)                                //if in a zone set triggers for op and sl
     set_triggers_inzone(zonenum);
  
   if(ii.trade_parameters_set)
     if(ii.tkt==-1)                              //no trade active
       ii.bs=try_to_trade();                     //look to trade
     else
       trailerxit();                             //use trailing exit since we have a trade

 }


 void trailerxit()
 //trailing stop loss
 {
   double Nsl;                                   //new sl trigger

   if(OrderSelect(ii.tkt,SELECT_BY_TICKET))
     {
       switch(ii.bs)
         {
         case 0:
           if(Bid<ii.Bsl)
             {
               if(OrderClose(ii.tkt,Clt,OrderClosePrice(),0))
                 reset_trade_parameters();
             }
           else
             {
               Nsl=Bid-Centrygap;
               if(Nsl>ii.Bsl)
                 ii.Bsl=Nsl;
             }
           break;
         case 1:
           if(Ask>ii.Ssl)
             {
               if(OrderClose(ii.tkt,Clt,OrderClosePrice(),0))
                 reset_trade_parameters();
             }
           else
             {
               Nsl=Ask+Centrygap;
               if(Nsl<ii.Ssl)
                 ii.Ssl=Nsl;
             }
           break;
         default:
           Alert("problem");
         }
     }
 }


 int try_to_trade()
 //watches if price goes past a trigger point
 {
   if(Ask>ii.Bop)                                //price is above buy trigger
     {
       ii.tkt=OrderSend(Symbol(),0,Clt,Ask,0,Ask-Csltp,Ask+Csltp);
       return 0;
     }
   if(Bid<ii.Sop)                                //price is below sel trigger
     {
       ii.tkt=OrderSend(Symbol(),1,Clt,Bid,0,Bid+Csltp,Bid-Csltp);
       return 1;
     }
   return -1;
 }


 void set_triggers_inzone(int zn)
 //sets trade triggers when price is inside a zone
 { 
   ii.Bop=ii.fbarval[zn]+entrygap();             //Buy open point
   ii.Sop=ii.fbarval[zn]-entrygap();             //Sel open point
   ii.Bsl=ii.Sop+Cpad;                           //Buy sl point
   ii.Ssl=ii.Bop-Cpad;                           //Sel sl point
   ii.trade_parameters_set=true;

   //hline("Bsl",ii.Bsl);
   //hline("Ssl",ii.Ssl);
   //Comment(ii.fbarval[zn]);
   //printf("%d %s%g %s%g %s%g %s%g",zn,"Bop=",ii.Bop,"Bsl=",ii.Bsl,"Sop=",ii.Sop,"Ssl=",ii.Ssl);
 }

 double entrygap()
 //determines the Bsl,Ssl entry distances from fractal value
 {
   return Centrygap;
 }

 void reset_trade_parameters()
 //sets all trade parameters to -1
 {
   ii.tkt=-1;
   ii.bs=-1;
   ii.Bop=-1;
   ii.Sop=-1;
   ii.Bsl=-1;
   ii.Ssl=-1;
   ii.trade_parameters_set=false;
 }
  

 int get_zone_number()
 //checks that price is in zone
 {
   int i=0;
   while(!btn(ii.fzl[i],Bid,ii.fzh[i]) && i<6)
     i++;
   if(btn(0,i,6))                                //use only fully established fractals
     return i;
   return -1;
 }


 void fill_indicator_info(int tf)
 //fills the T_indicator_info array
 {
   //fractal info 
   int i,b;
   double frn,fru;
  
   i=0;b=0;
   while(i<6)
     {
       b++;
       frn=iFractals(NULL,tf,MODE_UPPER,b);
       fru=iFractals(NULL,tf,MODE_LOWER,b);
       if(frn)
         {
           ii.fletter[i]="n";
           ii.fbarnum[i]=b;
           ii.fbarval[i]=frn;
           ii.fzh[i]=ii.fbarval[i]+Czonesize;
           ii.fzl[i]=ii.fbarval[i]-Czonesize;
           i++;
         }
       if(fru)
         {
           ii.fletter[i]="u";
           ii.fbarnum[i]=b;
           ii.fbarval[i]=fru;
           ii.fzh[i]=ii.fbarval[i]+Czonesize;
           ii.fzl[i]=ii.fbarval[i]-Czonesize;
           i++;
         }
     }

   //fractal patterns
   ii.fp6="";
   for(i=5;i>=0;i--)
       ii.fp6+=ii.fletter[i];
  
   //fractal rhythm for 6 appearances
   double barnumdeltas[5];
   for(i=0;i<5;i++)
     barnumdeltas[i]=ii.fbarnum[i+1]-ii.fbarnum[i];
   ii.frhythm6=iMAOnArray(barnumdeltas,0,5,0,MODE_SMA,0);
   ii.frhythmdev=iStdDevOnArray(barnumdeltas,0,5,0,MODE_SMA,0);

   //atr info in points
   ii.atr=iATR(NULL,tf,6,0)/Point;

   //ma info
   double ma[4]; ArrayInitialize(ma,0);
   for(b=1;b<4;b++)
     ma[b]=iMA(NULL,tf,12,0,MODE_SMA,PRICE_CLOSE,b);
   ii.masl=avgslope_per_min(tf,ma);

   //mode determination
   if(ii.atr>Catrmin && ii.masl<Cmaslmin)        //rng ranger activity
     ii.mode="RNG";
   if(ii.atr<Catrmin && ii.masl<Cmaslmin)        //fat fast trend activity
     ii.mode="FAT";
   if(ii.atr<Catrmin && ii.masl>Cmaslmin)        //ret reduced trend activity
     ii.mode="RET";
   if(ii.atr<Catrmin && ii.masl<Cmaslmin)        //nul null activity
     ii.mode="NUL";

   Comment(ii.mode,sp,sp,ii.atr,"<>",Catrmin,sp,sp,ii.masl,"<>",Cmaslmin);
  
 }


 bool is_new_bar()
 //checks to see if we have a new bar
 {
   static datetime lastbartime;
   datetime
     curbartime=Time[0];
   if(lastbartime!=curbartime)
     {
       lastbartime=curbartime;
       return (true);
     }
   else
     return(false);
 }


 double maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);

   if(minbar>maxbar)
     return Dpts(minval,maxval);
   else
     return Dpts(maxval,minval);
 }

 double Dprs(double pI,double pF)
 //difference between two prices
 {
   return (pF-pI);
 }

 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }

 bool btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }

 double avgslope_per_min(int tf,double &arr[])
 //calculates average slope in points per min using theil-sen concept when arr index matches bar number
 {
   double acc,masl;
   int
     arrsize=ArraySize(arr),
     begbar=arrsize-1,
     iters=arrsize*(arrsize-1)/2;

   acc=0;
   for(int i=begbar;i>1;i--)
     for(int j=i-1;j>0;j--)
       acc+=incline(i,arr[i],j,arr[j]);
   masl=acc/iters/tf;
   return masl;
 }


 double avgslope_per_bar(double &arr[])
 //calculates average slope in points per bar using theil-sen concept when arr index matches bar number
 {
   double acc,masl;
   int
     arrsize=ArraySize(arr),
     begbar=arrsize-1,
     iters=arrsize*(arrsize-1)/2;

   acc=0;
   for(int i=begbar;i>1;i--)
     for(int j=i-1;j>0;j--)
       acc+=incline(i,arr[i],j,arr[j]);
   masl=acc/iters;
   return masl;
 }

 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf giving points per bar
 {
   int
     Dbar=bI-bF;
   return Dpts(vI,vF)/Dbar;
 }

 bool CanDoTrade()
 //checks if trading is ok via total orders, spread
 {
   bool
     equityOK=(AccountEquity()>6000),
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12);
   return (equityOK && spreadOK);
 }

 void showlasterror()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }

 void hline(string objlabel,double price)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
 }
  
 void displaytxt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 //
 //SPECIAL FUNCTIONS
 //
 int OnInit()
 {
   ii.tkt=-1;
   ii.bs=-1;
   Gtf[0]=1;Gtf[1]=5;Gtf[2]=15;Gtf[3]=30;Gtf[4]=60;Gtf[5]=240;
   fpatts="nnnn-4 nnnu-1 nnun-2 nnuu+2 nunn-2 nunu+1 nuun-1 nuuu+3 unnn-3 unnu+1 unun-1 unuu+2 uunn-2 uunu+2 uuun+1 uuuu+4";
   return(INIT_SUCCEEDED);
 }



 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

**** code v4 mode analyser setup
 //fractalxoner.mq4

 //DESCRIP
 /*
 fractalxoner uses fractals to determine trading zones with the xonerator concept
 */

 //TODO
 /*

 check logic thoroughly
 try not moving sl till another fractal does it - slightly better results it seems
 don't use actual sl and trail through other fractals
 alter entrygap using ma inclines


 why only 1 trade when Csltp=120? print out data to file to figure out.
 figure out why usdjpy did so consistently poorly - is it usepoint type thing?

 create sl placements based on atr,ma,fpatterns

 set up totalorder protection


 develop noise function
 work in trailer possibly through noise function
 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>

 //////////////////////////////////////////////////////////////

 //
 //CONSTANTS
 //
 #define sp "  "
 #define Clt 0.1
 #define Csltp 1200.0*Point
 #define Czonesize 12*Point
 #define Centrygap 36*Point
 #define Cpad 6*Point
 #define Catrmin 60
 #define Cmaslmin 0.6



 //
 //EXTERNS
 //
 //extern int Etfx;

 //
 //GLOBALS
 //
 int Gtf[6];
 string fpatts;


 //
 //STRUCTURES
 //
 struct T_indicator_info
 {
   //mode
   string mode;                                  //determined by atr and masl
  
   //fractals
   string fletter[7];                            //n or u
   int fbarnum[7];                               //bar number
   double fbarval[7];                            //bar value
   double fzh[7];                                //zone hi boundary
   double fzl[7];                                //zone lo boundary
   double frhythm6,frhythmdev;                   //fractal rhythm for 6 fractals
   string fp6;                                   //fractal patterns

   //atr
   double atr;                                   //atr value 6 bars watching for compression

   //ma incline
   double masl;                                  //ma slope values long and short on closes

   //tickets
   int tkt;                                      //buysel ticket numbers

   //trade parameters
   int bs;                                       //buysel value
   double Bop,Sop,Bsl,Ssl;                       //buysel op and sl triggers
   bool trade_parameters_set;                    //trade parameters are set
 };


 T_indicator_info ii;

 //
 //FUNCTIONS
 //
 void OnTick()
 {
   int 
     tfx=2,
     tf=Gtf[tfx],
     zonenum=-1;

   if(is_new_bar())                              //get indicator info and trademerit only on every new bar
       fill_indicator_info(tf);


   /* zonenum=get_zone_number();                    //identify the zone price is in */
  
   /* if(zonenum>-1)                                //if in a zone set triggers for op and sl */
   /*   set_triggers_inzone(zonenum); */
  
   /* if(ii.trade_parameters_set) */
   /*   if(ii.tkt==-1)                              //no trade active */
   /*     ii.bs=try_to_trade();                     //look to trade */
   /*   else */
   /*     trailerxit();                             //use trailing exit since we have a trade */

 }


 void trailerxit()
 //trailing stop loss
 {
   double Nsl;                                   //new sl trigger

   if(OrderSelect(ii.tkt,SELECT_BY_TICKET))
     {
       switch(ii.bs)
         {
         case 0:
           if(Bid<ii.Bsl)
             {
               if(OrderClose(ii.tkt,Clt,OrderClosePrice(),0))
                 reset_trade_parameters();
             }
           else
             {
               Nsl=Bid-Centrygap;
               if(Nsl>ii.Bsl)
                 ii.Bsl=Nsl;
             }
           break;
         case 1:
           if(Ask>ii.Ssl)
             {
               if(OrderClose(ii.tkt,Clt,OrderClosePrice(),0))
                 reset_trade_parameters();
             }
           else
             {
               Nsl=Ask+Centrygap;
               if(Nsl<ii.Ssl)
                 ii.Ssl=Nsl;
             }
           break;
         default:
           Alert("problem");
         }
     }
 }


 int try_to_trade()
 //watches if price goes past a trigger point
 {
   if(Ask>ii.Bop)                                //price is above buy trigger
     {
       ii.tkt=OrderSend(Symbol(),0,Clt,Ask,0,Ask-Csltp,Ask+Csltp);
       return 0;
     }
   if(Bid<ii.Sop)                                //price is below sel trigger
     {
       ii.tkt=OrderSend(Symbol(),1,Clt,Bid,0,Bid+Csltp,Bid-Csltp);
       return 1;
     }
   return -1;
 }


 void set_triggers_inzone(int zn)
 //sets trade triggers when price is inside a zone
 { 
   ii.Bop=ii.fbarval[zn]+entrygap();             //Buy open point
   ii.Sop=ii.fbarval[zn]-entrygap();             //Sel open point
   ii.Bsl=ii.Sop+Cpad;                           //Buy sl point
   ii.Ssl=ii.Bop-Cpad;                           //Sel sl point
   ii.trade_parameters_set=true;
 }

 double entrygap()
 //determines the Bsl,Ssl entry distances from fractal value
 {
   return Centrygap;
 }

 void reset_trade_parameters()
 //sets all trade parameters to -1
 {
   ii.tkt=-1;
   ii.bs=-1;
   ii.Bop=-1;
   ii.Sop=-1;
   ii.Bsl=-1;
   ii.Ssl=-1;
   ii.trade_parameters_set=false;
 }
  

 int get_zone_number()
 //checks that price is in zone
 {
   int i=0;
   while(!btn(ii.fzl[i],Bid,ii.fzh[i]) && i<6)
     i++;
   if(btn(0,i,6))                                //use only fully established fractals
     return i;
   return -1;
 }


 void fill_indicator_info(int tf)
 //fills the T_indicator_info array
 {
   //fractal info 
   int i,b;
   double frn,fru;
  
   i=0;b=0;
   while(i<6)
     {
       b++;
       frn=iFractals(NULL,tf,MODE_UPPER,b);
       fru=iFractals(NULL,tf,MODE_LOWER,b);
       if(frn)
         {
           ii.fletter[i]="n";
           ii.fbarnum[i]=b;
           ii.fbarval[i]=frn;
           ii.fzh[i]=ii.fbarval[i]+Czonesize;
           ii.fzl[i]=ii.fbarval[i]-Czonesize;
           i++;
         }
       if(fru)
         {
           ii.fletter[i]="u";
           ii.fbarnum[i]=b;
           ii.fbarval[i]=fru;
           ii.fzh[i]=ii.fbarval[i]+Czonesize;
           ii.fzl[i]=ii.fbarval[i]-Czonesize;
           i++;
         }
     }

   //fractal patterns
   ii.fp6="";
   for(i=5;i>=0;i--)
       ii.fp6+=ii.fletter[i];
  
   //fractal rhythm for 6 appearances
   double barnumdeltas[5];
   for(i=0;i<5;i++)
     barnumdeltas[i]=ii.fbarnum[i+1]-ii.fbarnum[i];
   ii.frhythm6=iMAOnArray(barnumdeltas,0,5,0,MODE_SMA,0);
   ii.frhythmdev=iStdDevOnArray(barnumdeltas,0,5,0,MODE_SMA,0);

   //atr info in points
   ii.atr=iATR(NULL,tf,6,0)/Point;

   //ma info
   double ma[4]; ArrayInitialize(ma,0);
   for(b=1;b<4;b++)
     ma[b]=iMA(NULL,tf,12,0,MODE_SMA,PRICE_CLOSE,b);
   ii.masl=avgslope_per_min(tf,ma);

   //mode determination
   if(ii.atr>Catrmin && fabs(ii.masl)<Cmaslmin)        //rng ranger activity
     ii.mode="RNG";
   if(ii.atr>Catrmin && fabs(ii.masl)>Cmaslmin)        //fat fast trend activity
     ii.mode="FAT";
   if(ii.atr<Catrmin && fabs(ii.masl)>Cmaslmin)        //ret reduced trend activity
     ii.mode="RET";
   if(ii.atr<Catrmin && fabs(ii.masl)<Cmaslmin)        //nul null activity
     ii.mode="NUL";

   printf("%s  %f %f",ii.mode,ii.atr,ii.masl);
  
 }


 bool is_new_bar()
 //checks to see if we have a new bar
 {
   static datetime lastbartime;
   datetime
     curbartime=Time[0];
   if(lastbartime!=curbartime)
     {
       lastbartime=curbartime;
       return (true);
     }
   else
     return(false);
 }


 double maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);

   if(minbar>maxbar)
     return Dpts(minval,maxval);
   else
     return Dpts(maxval,minval);
 }

 double Dprs(double pI,double pF)
 //difference between two prices
 {
   return (pF-pI);
 }

 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }

 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf giving points per bar
 {
   int
     Dbar=bI-bF;
   return Dpts(vI,vF)/Dbar;
 }


 double avgslope_per_min(int tf,double &arr[])
 //calculates average slope in points per min using theil-sen concept when arr index matches bar number
 {
   double acc,masl;
   int
     arrsize=ArraySize(arr),
     begbar=arrsize-1,
     iters=begbar*(begbar-1)/2;

   acc=0;
   for(int i=begbar;i>1;i--)
     for(int f=i-1;f>0;f--) {
       acc+=Dpts(arr[i],arr[f])/((i-f)*tf);      //points per min
     }
   masl=acc/iters;
   return masl;
 }


 bool btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }


 bool CanDoTrade()
 //checks if trading is ok via total orders, spread
 {
   bool
     equityOK=(AccountEquity()>6000),
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12);
   return (equityOK && spreadOK);
 }

 void showlasterror()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }

 void hline(string objlabel,double price)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
 }
  
 void displaytxt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 //
 //SPECIAL FUNCTIONS
 //
 int OnInit()
 {printf("%s","**START**");
   ii.tkt=-1;
   ii.bs=-1;
   Gtf[0]=1;Gtf[1]=5;Gtf[2]=15;Gtf[3]=30;Gtf[4]=60;Gtf[5]=240;
   fpatts="nnnn-4 nnnu-1 nnun-2 nnuu+2 nunn-2 nunu+1 nuun-1 nuuu+3 unnn-3 unnu+1 unun-1 unuu+2 uunn-2 uunu+2 uuun+1 uuuu+4";
   return(INIT_SUCCEEDED);
 }



 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

*** funticipate
 funticipates the price motion from fractal patterns and ma slopes

 unnu concepts extended and developed through fractals
 determining trend through fractals is unreliable
 mode idea should be utilized too

 NEED TO CHANGE status to work with fractal interpretations
 fractal imbalance seems very interesting! in straight alternating sequence, examining 3 is sufficient because we will get either hilohi un or lohilo nu. however, if alteration is broken and we get hilolo or lohihi the chances are probably greater that we will have a sel or buy opportunity.
 - should be examined in different tfs and in conjunction with unnu
 - alternating hilo vs repeating hilo
 - fractal slope
 - which zone from established hilo

 fractal patterns
 p2 nn nu un uu
 p3 nnn nnu nun nuu unn unu uun uuu
 p4 nnnn nnnu nnun nnuu nunn nunu nuun nuuu unnn unnu unun unuu uunn uunu uuun uuuu
 of these only some are likely to be important because
 a) fit into npu nup upn unp idea
 b) show imbalance

 trial values below take imbalance into account, but should be used with masl3
 nnnn-4 nnnu-1 nnun-2 nnuu+2 nunn-2 nunu+1 nuun-1 nuuu+3 unnn-3 unnu+1 unun-1 unuu+2 uunn-2 uunu+2 uuun+1 uuuu+4
 shouldn't assume strength by virtue of pattern - just a direction
 if big move then just be on correct side


 atr value
 use atr to determine which tf to work in
 or use low implosion to be ready for a explosion

 masl
 moving average slope possibly with an atr filter can set rng mode

 trailer
 develop noise function
 work in trailer possibly through noise function

**** code v1 fpatts assigned a number
 a good start but the patterns should be employed more effectively and coordinated with atr,masl3

 //funnu.mq4

 //DESCRIP
 /*
 unnu uses hilo price patterns to trade
 */

 //TODO
 /*
 patterns should each be dealt with appropriately rather than being given a number.
 never make a trade where sltp ratio is a bad one

 fractal imbalance seems very interesting! in straight alternating sequence, examining 3 is sufficient because we will get either hilohi un or lohilo nu. however, if alteration is broken and we get hilolo or lohihi the chances are probably greater that we will have a sel or buy opportunity.
 - should be examined in different tfs and in conjunction with unnu
 - alternating hilo vs repeating hilo
 - fractal slope
 - which zone from established hilo

 fractal patterns
 fp2 nn nu un uu
 fp3 nnn nnu nun nuu unn unu uun uuu
 fp4 nnnn nnnu nnun nnuu nunn nunu nuun nuuu unnn unnu unun unuu uunn uunu uuun uuuu
 of these only some are likely to be important because
 a) fit into npu nup upn unp idea where p2 shows the way others supporting by imbalance agreement or neutral alterations
 b) show imbalance

 fractal rhythm
 can use rhythm6 and rhythmdev to guess at next fractal appearance
 if opposite-to-last fractal doesn't appear then the immediate trend may continue

 atr value
 use atr to determine which tf to work in
 or use low implosion to be ready for a explosion

 masl
 moving average slope possibly with an atr filter can set rng mode

 trailer
 develop noise function
 work in trailer possibly through noise function
 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>

 //////////////////////////////////////////////////////////////

 //
 //CONSTANTS
 //
 #define sp "  "
 #define lt 0.1
 #define sltp 600.0*Point
 #define mxmnT 120

 //
 //EXTERNS
 //
 //extern int tfx;

 //
 //GLOBALS
 //
 int tfs[6];
 string fpatts;


 //
 //STRUCTURES
 //
 struct indicatinfo
 {
   //fractals
   string fletter[7];                            //n or u
   int fbarnum[7];                               //bar number
   double fbarval[7];                            //bar value
   double frhythm6,frhythmdev;                   //fractal rhythm for 6 fractals
   string fp6;                                   //fractal patterns

   //atr
   double atrval;                                //atr value 6 bars watching for compression

   //ma incline
   double masl3;                                  //ma slope value for 3 bars on closes
 };


 //
 //FUNCTIONS
 //
 void main()
 {
   int
     tfx=2,
     tf=tfs[tfx];
   indicatinfo indinf;

   if(IsNewBar())                                //get indicator info and trademerit only on every new bar
     {
       fillindicatinfo(tf,indinf);
       trademerit(tf,indinf);
     }



   /*
   if(CanDoTrade())                              //tradable
     {
       status();
       ntrxit();
     }
   else
     Comment("Trading is not possible at this moment!");
   */
 }

 int trademerit(int tf,indicatinfo &ii)
 //analyzes the fractal data in groups of 2,3,4,6 returning integer value of how good the trade is
 {
   int 
     tmval=0,                                    //trade merit value
     minatr=30,
     minmasl3=10;
   bool
     xpl=(ii.atrval>minatr && fabs(ii.masl3)>minmasl3),
     rng=(ii.atrval>minatr && fabs(ii.masl3)<minmasl3),
     wee=(ii.atrval<minatr && fabs(ii.masl3)>minmasl3),
     nil=(ii.atrval<minatr && fabs(ii.masl3)<minmasl3);

  
  
   if(!nil)
     {
       if(xpl)                                   //explorer mode
         tmval=xplmode(ii);
       if(rng)                                   //ranger mode
         {}
       if(wee)                                   //weak mode
         {}
     }
   Comment(ii.atrval,sp,ii.masl3,sp,ii.fp6,sp,tmval);
  
   //identify fp2 and give value based on npu nup upn unp

   //support from fp3,fp4 alternation or imbalance

   //support from masl

   return tmval;
 }

 int xplmode(indicatinfo &ii)
 //explorer mode computations
 {
   int pos,val;
   string fp4=StringSubstr(ii.fp6,2,4);
  
   pos=StringFind(fpatts,fp4,0);
   val=(int)StringToInteger(StringSubstr(fpatts,pos+4,2));Comment(fp4,sp,pos,sp,val);

   return val;
 }

 void fillindicatinfo(int tf,indicatinfo &ii)
 //fills the indicatinfo array
 {
   //fractal info 
   int i,b;
   double frn,fru;
  
   i=0;b=0;
   while(i<6)
     {
       b++;
       frn=iFractals(NULL,tf,MODE_UPPER,b);
       fru=iFractals(NULL,tf,MODE_LOWER,b);
       if(frn)
         {
           ii.fletter[i]="n";
           ii.fbarnum[i]=b;
           ii.fbarval[i]=frn;
           i++;
         }
       if(fru)
         {
           ii.fletter[i]="u";
           ii.fbarnum[i]=b;
           ii.fbarval[i]=fru;
           i++;
         }
     }

   //fractal rhythm for 6 appearances
   double barnumdeltas[5];
   for(i=0;i<5;i++)
     barnumdeltas[i]=ii.fbarnum[i+1]-ii.fbarnum[i];
   ii.frhythm6=iMAOnArray(barnumdeltas,0,5,0,MODE_SMA,0);
   ii.frhythmdev=iStdDevOnArray(barnumdeltas,0,5,0,MODE_SMA,0);

   //fractal patterns
   ii.fp6="";
   for(i=5;i>=0;i--)
     ii.fp6+=ii.fletter[i];
  
   //atr info
   ii.atrval=iATR(NULL,tf,6,0)/Point;

   //ma info
   double ma[4]; ArrayInitialize(ma,0);
   for(b=1;b<4;b++)
     ma[b]=iMA(NULL,tf,3,0,MODE_SMA,PRICE_CLOSE,b);
   ii.masl3=avgslope(ma);

 }


 // *** may want to develop a fractal version of this so we get truer turning points
 double maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);

   if(minbar>maxbar)
     return Dpts(minval,maxval);
   else
     return Dpts(maxval,minval);
 }

 double Dprs(double pI,double pF)
 //difference between two prices
 {
   return (pF-pI);
 }

 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }

 bool btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }

 double avgslope(double &arr[])
 //calculates average slope per bar using theil-sen concept when arr index matches bar number
 {
   double acc;
   int
     arrsize=ArraySize(arr),
     numbars=arrsize-1,
     iters=numbars*(numbars-1)/2;

   acc=0;
   for(int i=numbars;i>1;i--)
     for(int j=i-1;j>0;j--)
       acc+=incline(i,arr[i],j,arr[j]);
   return acc/iters;
 }

 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
 {
   int
     Dbar=bI-bF;
   return Dpts(vI,vF)/Dbar;
 }

 bool IsNewBar()
 //checks to see if we have a new bar
 {
   static datetime lastbartime;
   datetime
     curbartime=Time[0];
   if(lastbartime!=curbartime)
     {
       lastbartime=curbartime;
       return (true);
     }
   else
     return(false);
 }

 bool CanDoTrade()
 //checks if trading is ok via total orders, spread
 {
   bool
     equityOK=(AccountEquity()>6000),
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12);
   return (equityOK && spreadOK);
 }


 bool OpenOrderExists()
 //acknowledges existence of an open order
 {
   for(int p=OrdersTotal()-1;p>=0;p--)
     if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
      return true;
   return false;
 }

 void showlasterror()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }

 void hline(string objlabel,double price)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
 }
  
 void displaytxt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 //
 //SPECIAL FUNCTIONS
 //
 int OnInit()
 {
   //s.tkt=-1;
   //s.bs=-1;
   tfs[0]=1;tfs[1]=5;tfs[2]=15;tfs[3]=30;tfs[4]=60;tfs[5]=240;
   fpatts="nnnn-4 nnnu-1 nnun-2 nnuu+2 nunn-2 nunu+1 nuun-1 nuuu+3 unnn-3 unnu+1 unun-1 unuu+2 uunn-2 uunu+2 uuun+1 uuuu+4";
   return(INIT_SUCCEEDED);
 }

 void OnDeinit(const int reason)
 {
  
 }

 void OnTick()
 {
   main();
 }



 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */



 /*
 void status()
 //determines all relevant marketconditions
 {
   int maxbar,minbar;
   double pad;
    
   //set tf,pr
   s.tf=tfs[tfx];
   s.pr=(Bid+Ask)/2;

   //mxmn computations
   s.mxmn=maxmin(s.tf,13,1,maxbar,s.maxval,minbar,s.minval);
   pad=0.12*fabs(s.mxmn);
   if(pad>48) pad=48;
   pad*=Point;
  
   //pattern detection ***will need to finetune these
   s.npu=false;s.upn=false;s.nup=false;s.unp=false;
   s.upn=(s.mxmn>0 && btn(s.minval,s.pr,s.maxval-pad));
   s.npu=(s.mxmn<0 && btn(s.minval+pad,s.pr,s.maxval));
   s.unp=(s.mxmn>0 && s.pr>s.maxval+pad);
   s.nup=(s.mxmn<0 && s.pr<s.minval-pad);

 }

 void ntrxit()
 //ntrxit mechanisms
 {
   bool
     noord=(s.tkt==-1),
     notbs=(s.bs==-1),
     mxmnOK=(!btn(-mxmnT,s.mxmn,+mxmnT));

   if(noord && mxmnOK)                           //tradeless
     {
       if(s.upn)
         {s.bs=1;s.op=Bid;s.sl=s.maxval;s.tp=s.minval;}
       if(s.npu)
         {s.bs=0;s.op=Ask;s.sl=s.minval;s.tp=s.maxval;}
       if(s.unp)
         {s.bs=0;s.op=Ask;s.sl=s.minval;s.tp=Ask+sltp;}
       if(s.nup)
         {s.bs=1;s.op=Bid;s.sl=s.maxval;s.tp=Bid-sltp;}
       if(!notbs)
         s.tkt=OrderSend(Symbol(),s.bs,lt,s.op,0,s.sl,s.tp);
     }
   else                                          //in a trade because !noord
     {
       if(OpenOrderExists())
         {
           //manage it


         }
       else                                      //sltp out of the trad
         {
           s.tkt=-1;
           s.bs=-1;
         }
     }
 }
 */

**** code v2 fpatts counted with some bash help in comment
 //astats.mq4

 //DESCRIP
 /*
 does stats
 */

 //TODO
 /*

 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>

 //////////////////////////////////////////////////////////////

 //
 //CONSTANTS
 //
 #define sp "  "


 //
 //EXTERNS
 //

 //
 //GLOBALS
 //
 int tfs[6];
 string fpatts;

 //
 //STRUCTURES
 //
 struct indicatinfo
 {
   //fractals
   string fletter[7];                            //n or u
   int fbarnum[7];                               //bar number
   double fbarval[7];                            //bar value
   double frhythm6,frhythmdev;                   //fractal rhythm for 6 fractals
   string fp6;                                   //fractal patterns

   //atr
   double atrval;                                //atr value 6 bars watching for compression

   //ma incline
   double masl3;                                  //ma slope value for 3 bars on closes
 };


 //
 //FUNCTIONS
 //
 void main()
 {
   int
     tfx=0,
     tf=tfs[tfx];
   indicatinfo indinf;

  
   if(IsNewBar())                                //get indicator info and trademerit only on every new bar
     {
       fillindicatinfo(tf,indinf);
       patterncount(tf,indinf);
     }
 }

 void patterncount(int tf,indicatinfo &ii)
 //counts bars within time period
 {
    datetime beg=D'2016.11.01 00:00';
    datetime end=D'2016.11.01 03:10';
    datetime now=TimeCurrent();
    static int kount[16];
    string fp4;
    static string fp4old;
    int j;
   
    if(btn(beg,now,end))
      {
        fp4=StringSubstr(ii.fp6,2,4);

        if(fp4!=fp4old)
          {
            fp4old=fp4;
            j=StringFind(fpatts,fp4)/7;
            kount[j]++;
          }
      }
    else
      {
        if(now>end)
          {
          for(int i=0;i<16;i++)
            printf("%s %d", StringSubstr(fpatts,i*7,4),kount[i]);
          ExpertRemove();
          //tail -n 18 20161130.log | head -n 16 | cut -d':' -f5 to get just the data
          }
      }
 }

 void fillindicatinfo(int tf,indicatinfo &ii)
 //fills the indicatinfo array
 {
   //fractal info 
   int i,b;
   double frn,fru;
  
   i=0;b=0;
   while(i<6)
     {
       b++;
       frn=iFractals(NULL,tf,MODE_UPPER,b);
       fru=iFractals(NULL,tf,MODE_LOWER,b);
       if(frn)
         {
           ii.fletter[i]="n";
           ii.fbarnum[i]=b;
           ii.fbarval[i]=frn;
           i++;
         }
       if(fru)
         {
           ii.fletter[i]="u";
           ii.fbarnum[i]=b;
           ii.fbarval[i]=fru;
           i++;
         }
     }

   //fractal rhythm for 6 appearances
   double barnumdeltas[5];
   for(i=0;i<5;i++)
     barnumdeltas[i]=ii.fbarnum[i+1]-ii.fbarnum[i];
   ii.frhythm6=iMAOnArray(barnumdeltas,0,5,0,MODE_SMA,0);
   ii.frhythmdev=iStdDevOnArray(barnumdeltas,0,5,0,MODE_SMA,0);

   //fractal patterns
   ii.fp6="";
   for(i=5;i>=0;i--)
     ii.fp6+=ii.fletter[i];
  
   //atr info
   ii.atrval=iATR(NULL,tf,6,0)/Point;

   //ma info
   double ma[4]; ArrayInitialize(ma,0);
   for(b=1;b<4;b++)
     ma[b]=iMA(NULL,tf,3,0,MODE_SMA,PRICE_CLOSE,b);
   ii.masl3=avgslope(ma);

 }


 // *** may want to develop a fractal version of this so we get truer turning points
 double maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);

   if(minbar>maxbar)
     return Dpts(minval,maxval);
   else
     return Dpts(maxval,minval);
 }

 double Dprs(double pI,double pF)
 //difference between two prices
 {
   return (pF-pI);
 }

 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }

 bool btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }

 double avgslope(double &arr[])
 //calculates average slope per bar using theil-sen concept when arr index matches bar number
 {
   double acc;
   int
     arrsize=ArraySize(arr),
     numbars=arrsize-1,
     iters=numbars*(numbars-1)/2;

   acc=0;
   for(int i=numbars;i>1;i--)
     for(int j=i-1;j>0;j--)
       acc+=incline(i,arr[i],j,arr[j]);
   return acc/iters;
 }

 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
 {
   int
     Dbar=bI-bF;
   return Dpts(vI,vF)/Dbar;
 }

 bool IsNewBar()
 //checks to see if we have a new bar
 {
   static datetime lastbartime;
   datetime
     curbartime=Time[0];
   if(lastbartime!=curbartime)
     {
       lastbartime=curbartime;
       return (true);
     }
   else
     return(false);
 }

 bool CanDoTrade()
 //checks if trading is ok via total orders, spread
 {
   bool
     equityOK=(AccountEquity()>6000),
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12);
   return (equityOK && spreadOK);
 }


 bool OpenOrderExists()
 //acknowledges existence of an open order
 {
   for(int p=OrdersTotal()-1;p>=0;p--)
     if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
      return true;
   return false;
 }

 void showlasterror()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }

 void hline(string objlabel,double price)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
 }
  
 void displaytxt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 //
 //SPECIAL FUNCTIONS
 //
 int OnInit()
 {
   //s.tkt=-1;
   //s.bs=-1;
   tfs[0]=1;tfs[1]=5;tfs[2]=15;tfs[3]=30;tfs[4]=60;tfs[5]=240;
   fpatts="nnnn-4 nnnu-1 nnun-2 nnuu+2 nunn-2 nunu+1 nuun-1 nuuu+3 unnn-3 unnu+1 unun-1 unuu+2 uunn-2 uunu+2 uuun+1 uuuu+4";
   return(INIT_SUCCEEDED);
 }

 void OnDeinit(const int reason)
 {
  
 }

 void OnTick()
 {
   main();
 }



 /*
 MetaQuotes Software Corp
 https://www.mql5.com

*** unnu (from llpatts)
 rewrite in present formatting
**** code last llpatts version to be redone - outperforms moder optimizations
 161001-08
 | 228.60 | 4 | 0.00 | 57.15 |  61.10 | 0.60% | Esltp=620 | Etfx=3 |
 | 185.60 | 4 | 0.00 | 46.40 |  58.50 | 0.57% | Esltp=680 | Etfx=3 |
 | 181.60 | 4 | 0.00 | 45.40 |  58.50 | 0.57% | Esltp=660 | Etfx=3 |
 | 179.60 | 4 | 0.00 | 44.90 |  58.50 | 0.57% | Esltp=650 | Etfx=3 |
 | 170.60 | 4 | 0.00 | 42.65 |  61.10 | 0.60% | Esltp=640 | Etfx=2 |
 | 168.60 | 4 | 0.00 | 42.15 |  61.10 | 0.60% | Esltp=630 | Etfx=2 |
 | 154.60 | 4 | 0.00 | 38.65 |  61.10 | 0.60% | Esltp=560 | Etfx=2 |
 | 144.00 | 5 | 3.00 | 28.80 | 109.50 | 1.08% | Esltp=720 | Etfx=5 |
 | 143.10 | 6 | 3.35 | 23.85 |  71.50 | 0.70% | Esltp=510 | Etfx=3 |
 | 126.40 | 5 | 2.78 | 25.28 | 103.80 | 1.04% | Esltp=710 | Etfx=1 |
 | 123.40 | 5 | 2.81 | 24.68 | 100.80 | 1.01% | Esltp=680 | Etfx=1 |
 | 122.40 | 5 | 2.83 | 24.48 |  99.80 | 1.00% | Esltp=670 | Etfx=1 | 

 161008-15
 | 80.30 |  8 | 1.65 | 10.04 | 130.60 | 1.30% | Esltp=620 | Etfx=1 |
 | 78.30 |  8 | 1.65 |  9.79 | 126.60 | 1.26% | Esltp=600 | Etfx=1 |
 | 77.30 |  8 | 1.66 |  9.66 | 124.60 | 1.24% | Esltp=590 | Etfx=1 |
 | 48.10 | 46 | 1.20 |  1.05 |  89.70 | 0.89% | Esltp=120 | Etfx=0 |
 | 44.80 |  8 | 1.31 |  5.60 | 132.60 | 1.32% | Esltp=630 | Etfx=1 |

 161015-22
 | 170.00 | 6 | 4.27 | 28.33 | 79.10 | 0.77% | Esltp=520 | Etfx=2 |
 | 167.00 | 6 | 4.27 | 27.83 | 78.10 | 0.76% | Esltp=510 | Etfx=3 |
 | 164.00 | 6 | 4.28 | 27.33 | 77.10 | 0.75% | Esltp=500 | Etfx=3 |
 | 161.90 | 7 | 4.05 | 23.13 | 91.60 | 0.90% | Esltp=530 | Etfx=1 |
 | 146.90 | 8 | 4.05 | 18.36 | 86.60 | 0.85% | Esltp=480 | Etfx=1 |
 | 141.00 | 8 | 4.36 | 17.63 | 67.90 | 0.67% | Esltp=420 | Etfx=0 |
 | 135.10 | 6 | 3.08 | 22.52 | 94.10 | 0.92% | Esltp=500 | Etfx=0 |
 | 135.00 | 8 | 4.38 | 16.88 | 65.90 | 0.65% | Esltp=400 | Etfx=0 |
 | 126.80 | 8 | 3.58 | 15.85 | 90.70 | 0.89% | Esltp=440 | Etfx=1 |
 | 111.00 | 4 | 5.81 | 27.75 | 71.90 | 0.71% | Esltp=670 | Etfx=5 |
 | 103.00 | 4 | 5.46 | 25.75 | 71.90 | 0.71% | Esltp=630 | Etfx=4 |




 //+------------------------------------------------------------------+
 //|                                                      llpatts.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+

 /*

 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>

 #define sp "  "

 extern int Esltp;
 extern int Etfx;
 int Epad=48;


 /*
 incorporates patterns in multiple tf to determine ntrxit
 */

 int
 tkt=0,
 barsInChart=0,
 bs=-1;
 double
 lt=0.1,oo=0,sl=0,tp=0;
 bool zz;
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 struct tfcombos
 //timeframe combinations
   {
    int               L,S;
   };
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 struct status
 //single timeframe situation
   {
    //hi and lo info
    int               hibar,lobar;
    double            hival,loval;

    //patterns HAL,LAH,HLA,LHA,AHL,ALH
    string            pattern;

    //deltas between hilo and point movement from last turn
    double            Dhilo,Dpomo;

    //longterm trend
    double            ltrend;
 /*
    //bs,oo,sl,tp
    int               bs;
    double            oo,sl,tp;

    //orderselect info
    double            orderprofit;
    int               ordertype;
 */
   };
 tfcombos tfc[6];
 status Ss,Ls;
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OnInit()
   {
    tfc[0].S=01;tfc[0].L=05;
    tfc[1].S=05;tfc[1].L=30;
    tfc[2].S=05;tfc[2].L=60;
    tfc[3].S=15;tfc[3].L=60;
    tfc[4].S=30;tfc[4].L=240;
    tfc[5].S=60;tfc[5].L=240;
    return(INIT_SUCCEEDED);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {
    //getparameters(1);
    int tfx=Etfx;
    getstatus(tfc[tfx].S,Ss);showstatus("S",1000,Ss);
    getstatus(tfc[tfx].L,Ls);showstatus("L",1200,Ls);

    if(CanDoTrade())
      {
       double sltp=Esltp*Point;
       if(Ls.pattern=="HAL" && Ss.pattern=="HAL") {bs=0;oo=Ask;sl=oo-sltp;tp=oo+sltp;}
       if(Ls.pattern=="LAH" && Ss.pattern=="LAH") {bs=1;oo=Bid;sl=oo+sltp;tp=oo-sltp;}
       tkt=OrderSend(Symbol(),bs,lt,oo,0,sl,tp);
      }
    if(OrderSelect(tkt,SELECT_BY_TICKET))
      {
       switch(OrderType())
         {
          case  0:
             if(Ls.pattern=="HLA" || Ls.pattern=="ALH") zz=OrderClose(tkt,lt,oo,0);
             break;
          case  1:
             if(Ls.pattern=="LHA" || Ls.pattern=="AHL") zz=OrderClose(tkt,lt,oo,0);
             break;
         }

      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void getstatus(int tf,status &s)
 //finds various aspects of Sstatus
   {
    bool truehi=false,truelo=false;
    double Dhiloinc,pad=Epad*Point;
    int Dhilobar=1,barstep=12,barF=1,barI=barF+barstep;

 //get hilo info   
    while(truehi==false && truelo==false)
      {
       maxmin(tf,barI,barF,s.hibar,s.hival,s.lobar,s.loval);
       truehi=turnpoint(tf,s.hibar,s.hival,"hi");
       truelo=turnpoint(tf,s.lobar,s.loval,"lo");
       barF=barI+1;
       barI=barF+barstep;
      }
     
    //BUY: HAL,LHA,AHL  SEL:LAH,HLA,ALH
    //Rangers
    if((Bid<s.hival && Bid>s.loval+pad) && s.hibar>s.lobar) {s.pattern="HAL";return;}
    if((Bid<s.hival-pad && Bid>s.loval) && s.lobar>s.hibar) {s.pattern="LAH";return;}
    //Explorers
    if(Bid>s.hival+pad && s.lobar>s.hibar) {s.pattern="LHA";return;}
    if(Bid<s.loval-pad && s.hibar>s.lobar) {s.pattern="HLA";return;}
    //Breakouts  
    if(Bid>s.hival+pad && s.hibar>s.lobar) {s.pattern="AHL";return;}
    if(Bid<s.loval-pad && s.lobar>s.hibar) {s.pattern="ALH";return;}   

    if(s.lobar!=s.hibar) Dhilobar=s.lobar-s.hibar;
    Dhiloinc=Dpts(s.loval,s.hival)/Dhilobar;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void showstatus(string LS,int colstart,status &s)
 //shows status
   {
 //initialize line values
    int l[5];ArrayInitialize(l,0);for(int i=1;i<5;i++) l[i]=i*12;

    display(LS,s.pattern,0,colstart,l[1],Blue);

   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double ltrend(int tf,int bI,int bF)
 //calculates longterm trend
   {
    double
    vI=medianvalue(iHigh(NULL,tf,bI),iLow(NULL,tf,bI)),
    vF=medianvalue(iHigh(NULL,tf,bF),iLow(NULL,tf,bF));
    return incline(bI,vI,bF,vF);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double medianvalue(double hi,double lo)
 //calculates midpoint from hi and lo
   {
    return 0.5*(hi+lo);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool turnpoint(int tf,int bar,double val,string hiloitem)
 //determines if hilo are true turning points
   {
    double v[5];

    v[0]=val;

    if(hiloitem=="hi")
      {
       v[1]=iHigh(NULL,tf,bar+2);
       v[2]=iHigh(NULL,tf,bar+1);
       v[3]=iHigh(NULL,tf,bar-1);
       v[4]=iHigh(NULL,tf,bar-2);
       if(ArrayMaximum(v)==0) return true;
      }
    if(hiloitem=="lo")
      {
       v[1]=iLow(NULL,tf,bar+2);
       v[2]=iLow(NULL,tf,bar+1);
       v[3]=iLow(NULL,tf,bar-1);
       v[4]=iLow(NULL,tf,bar-2);
       if(ArrayMinimum(v)==0) return true;
      }
    return false;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
   {
    maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
    maxval=iHigh(NULL,tf,maxbar);
    minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
    minval=iLow(NULL,tf,minbar);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
   {
    return (pF-pI)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
   {
    int
    Dbar=bI-bF;
    return Dpts(vI,vF)/Dbar;
   }
 //+------------------------------------------------------------------+
 //|TRADEABLE                                                         |
 //+------------------------------------------------------------------+
 bool CanDoTrade()
 //checks if trading is ok via new bar, total orders, spread
   {
    int aords,pords;
    bool
    newbarOK=(barsInChart<Bars),
    spreadOK=(MarketInfo(NULL,MODE_SPREAD)<9),
    noordsOK=(OrdersForSymbol(aords,pords)==0);
    barsInChart=Bars;
    return (newbarOK && spreadOK && noordsOK);
   }
 //+------------------------------------------------------------------+
 //|TRADEABLE                                                         |
 //+------------------------------------------------------------------+
 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
   {
    aords=0;pords=0;
    for(int p=OrdersTotal()-1;p>=0;p--)
       if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
         {
          if(OrderType()>1 && OrderType()<6)
             pords++;
          if(OrderType()==OP_BUY || OrderType()==OP_SELL)
             aords++;
         }
    return aords+pords;
   }
 //+------------------------------------------------------------------+
 //|DISPLAY                                                           |
 //+------------------------------------------------------------------+
 void showlasterror()
 //prints last error message
   {
    int
    errnum=GetLastError();
    if(errnum!=ERR_NO_ERROR)
       Comment(errnum,sp,ErrorDescription(errnum));
    else
       Comment(ERR_NO_ERROR);
   }
 //+------------------------------------------------------------------+
 //|DISPLAY                                                           |
 //+------------------------------------------------------------------+
 string YI2S(int x)
 //integer to string
   {
    return IntegerToString(x);
   }
 //+------------------------------------------------------------------+
 //|DISPLAY                                                           |
 //+------------------------------------------------------------------+
 string YD2S(double x,int d)
 //double to string
   {
    return DoubleToString(x,d);
   }
 //+------------------------------------------------------------------+
 //|DISPLAY                                                           |
 //+------------------------------------------------------------------+
 void display(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
   {
    ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
    ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
    ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
    ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
    ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void getparameters(int n)
 //sets the parameters for trading
   {
    switch(n)
      {
       case  1:
 Esltp=400; 	Etfx=4;
          break;
       case  2:
 Esltp=150; 	Etfx=0;
          break;
       case  3:
 Esltp=1000; Etfx=1;
          break;
       case  4:

          break;
       case  5:

          break;
       case  6:

          break;
       case  7:

          break;
       case  8:

          break;
       case  9:

          break;
       default:
          break;
      }
   }

 //+------------------------------------------------------------------+

**** code rewrite without finding true turning point
 reasonably ok but not as good, so do with fractals next
 also, possibly replace sltp with xit points

 //unnu.mq4

 //DESCRIP
 /*
 unnu uses hilo price patterns to trade
 */

 //TODO
 /*
 improve sl settings - getting too many meaningless trades on 1m
 work in trl
 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>


 //
 //CONSTANTS
 //
 #define sp "  "
 #define lt 0.1
 #define sltp 600.0*Point
 #define mxmnT 120

 //
 //EXTERNS
 //
 extern int tfx;

 //
 //GLOBALS
 //
 int tfs[6];


 //
 //STRUCTURES
 //
 struct status
 {
   //timeframe,price
   int tf;                                       //timeframe
   double pr;                                    //pr set to avg of bid,ask

   //modes
   int mode;                                     //indicated by -ve to +ve integers for trend strength

   //hilo values
   double maxval,minval;                         //maxmin values
   double mxmn;                                  //maxmin difference in points

   //patterns npu,upn,nup,unp
   bool npu,upn,nup,unp;                         //unnu patterns

   //longterm trend
   double            ltrend;
  
   //order parameters
   int tkt;                                      //tkt number
   int bs;                                       //buysel value
   double op,sl,tp;                              //open price,stoploss,takeprofit
   bool inbuy,insel;                             //in buysel trade already?
 };

 status s;

 //
 //FUNCTIONS
 //
 void main()
 {
   if(CanDoTrade())                              //tradable
     {
       status();
       ntrxit();
     }
   else
     Comment("Trading is not possible at this moment!");
 }



 void status()
 //determines all relevant marketconditions
 {
   int maxbar,minbar;
   double pad;
    
   //set tf,pr
   s.tf=tfs[tfx];
   s.pr=(Bid+Ask)/2;

   //mxmn computations
   s.mxmn=maxmin(s.tf,13,1,maxbar,s.maxval,minbar,s.minval);
   pad=0.12*fabs(s.mxmn);
   if(pad>48) pad=48;
   pad*=Point;
  
   //pattern detection ***will need to finetune these
   s.npu=false;s.upn=false;s.nup=false;s.unp=false;
   s.upn=(s.mxmn>0 && btn(s.minval,s.pr,s.maxval-pad));
   s.npu=(s.mxmn<0 && btn(s.minval+pad,s.pr,s.maxval));
   s.unp=(s.mxmn>0 && s.pr>s.maxval+pad);
   s.nup=(s.mxmn<0 && s.pr<s.minval-pad);

 }

 void ntrxit()
 //ntrxit mechanisms
 {
   bool
     noord=(s.tkt==-1),
     notbs=(s.bs==-1),
     mxmnOK=(!btn(-mxmnT,s.mxmn,+mxmnT));

   if(noord && mxmnOK)                           //tradeless
     {
       if(s.upn)
         {s.bs=1;s.op=Bid;s.sl=s.maxval;s.tp=s.minval;}
       if(s.npu)
         {s.bs=0;s.op=Ask;s.sl=s.minval;s.tp=s.maxval;}
       /*if(s.unp)
         {s.bs=0;s.op=Ask;s.sl=s.minval;s.tp=Ask+sltp;}
       if(s.nup)
         {s.bs=1;s.op=Bid;s.sl=s.maxval;s.tp=Bid-sltp;}*/
       if(!notbs)
         s.tkt=OrderSend(Symbol(),s.bs,lt,s.op,0,s.sl,s.tp);
     }
   else                                          //in a trade because !noord
     {
       if(OpenOrderExists())
         {
           //manage it


         }
       else                                      //sltp out of the trad
         {
           s.tkt=-1;
           s.bs=-1;
         }
     }
 }


 // *** may want to develop a fractal version of this so we get truer turning points
 double maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);

   if(minbar>maxbar)
     return Dpts(minval,maxval);
   else
     return Dpts(maxval,minval);
 }

 double Dprs(double pI,double pF)
 //difference between two prices
 {
   return (pF-pI);
 }

 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }

 bool btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }

 double avgslope(double &arr[])
 //calculates average slope using theil-sen concept when arr index matches bar number
 {
   double acc;
   int
     arrsize=ArraySize(arr),
     numbars=arrsize-1,
     iters=numbars*(numbars-1)/2;

   acc=0;
   for(int i=numbars;i>1;i--)
     for(int j=i-1;j>0;j--)
       acc+=incline(i,arr[i],j,arr[j]);
   return acc/iters;
 }

 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
 {
   int
     Dbar=bI-bF;
   return Dpts(vI,vF)/Dbar;
 }

 bool CanDoTrade()
 //checks if trading is ok via total orders, spread
 {
   bool
     equityOK=(AccountEquity()>6000),
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12);
   return (equityOK && spreadOK);
 }


 bool OpenOrderExists()
 //acknowledges existence of an open order
 {
   for(int p=OrdersTotal()-1;p>=0;p--)
     if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
      return true;
   return false;
 }

 void showlasterror()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }

 void hline(string objlabel,double price)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
 }
  
 void displaytxt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 //
 //SPECIAL FUNCTIONS
 //
 int OnInit()
 {
   s.tkt=-1;
   s.bs=-1;
   tfs[0]=1;tfs[1]=5;tfs[2]=15;tfs[3]=30;tfs[4]=60;tfs[5]=240;
   return(INIT_SUCCEEDED);
 }

 void OnDeinit(const int reason)
 {
  
 }

 void OnTick()
 {
   main();
 }



 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

*** moder
 quantify modes and utilize ranger approach for all entries
**** code v1 just testing things out - no trading
 //moder.mq4

 //DESCRIP
 /*
 all is a quantifiable mode based on incline and hilo analyses
 */

 //TODO
 /*

 closeness of individual hilo6 to help determine mode
 - problem is values need to be normalizes so as not to be affected by tf
 - compute average deviation of each from mean as percent of max hilo delta

 figure out how to interpret hlinclines

 mxmn values can coordinate with inclines

 ====
 hli may be used in various tfs to coordinate trading
 work in sr
 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>


 //
 //CONSTANTS
 //
 #define sp "  "
 #define lt 0.1
 #define sltp 600.0*Point

 //
 //EXTERNS
 //
 //extern int tfx;

 //
 //GLOBALS
 //
 int tfs[6],tfx=0;


 //
 //STRUCTURES
 //
 struct status
 {
   //pr
   double pr;                                    //pr set to avg of bid,ask

   //modes
   int mode;                                     //indicated by -ve to +ve integers for trend strength

   //get mxmn data

   int mxbar,mnbar;                              //maxmin bar numbers
   double mxval,mnval;                           //maxmin bar values

   //hilo variations
   double vx;                                     //variation index
   int mxmn;                                     //maxmin difference in points for 6 bars

   //hilo inclines
   double h[7];                                     //hi inclines
   double l[7];                                     //lo inclines
  
   //order parameters
   int tkt;                                      //tkt number
   int bs;                                       //buysel value
   bool inbuy,insel;                             //in trade already?
 };

 status s;

 //
 //FUNCTIONS
 //
 void main()
 {
   status();
   //ntrxit();
 }


 void hilovariations(int tf,int bI)
 //computes level of variations for hilo
 {
   int mxbar,mnbar;
   double mxval,mnval;

   s.mxmn=maxmin(tfs[tfx],7,1,mxbar,mxval,mnbar,mnval);
 }

 void status()
 //determines all relevant marketconditions
 {
   //set pr
   s.pr=(Bid+Ask)/2;
  
   //get mxmn
   s.mxmn=maxmin(tfs[tfx],7,1,s.mxbar,s.mxval,s.mnbar,s.mnval);

   //get inclines
   hiloinclines(tfs[tfx],6);
 }

 void hiloinclines(int tf,int bI)
 //calculates inclines and avg for hilo from bar 6-2 with bar 1
 {
       int
         k=bI-1;

       for(int i=2;i<bI+1;i++)
         {
           s.h[i]=incline(i,iHigh(NULL,tfs[tfx],i),1,iHigh(NULL,tfs[tfx],1));
           s.l[i]=incline(i,iLow(NULL,tfs[tfx],i),1,iLow(NULL,tfs[tfx],1));
           s.h[1]+=s.h[i];s.l[1]+=s.l[i];        //incline sums in element 1
         }
       s.h[0]=s.h[1]/k;s.l[0]=s.l[1]/k;          //incline avgs in element 0
 }

 /*
 void hli()
 //determines hilo inclines btn bar 1 and bars 2,3,4,6
 {
   double
     h[7],l[7],hav,lav;
   int
     d0=4;
  
   ArrayInitialize(h,0);ArrayInitialize(l,0);
   hav=0;lav=0;
   for(int i=2;i<7;i++)                          //calculate inclines 6-2 and avgs
     {
       h[i]=incline(i,iHigh(NULL,tfs[tfx],i),1,iHigh(NULL,tfs[tfx],1));
       l[i]=incline(i,iLow(NULL,tfs[tfx],i),1,iLow(NULL,tfs[tfx],1));
       hav+=h[i];lav+=l[i];
     }
   hav/=5;lav/=5;
  
   if(btn(-d0,hav,+d0) && btn(-d0,lav,+d0))      //neutral incline criteria
     {
       s.hlival=0;                               //incline val says no trade preference
       s.xpl=false;                              //xpl mode deactivated
     }
   else
     {
       //criteria
       bool
         huavg=h[6]<hav,                         //hi u buy
         luavg=l[6]<lav,                         //lo u buy
         hnavg=h[6]>hav,                         //hi n sel
         lnavg=l[6]>lav;                         //lo n sel
      
       if(luavg)                                 //buy strength
         {
           s.hlival=+1;
           if(huavg)
             s.hlival=+2;
         }
       if(hnavg)                                 //sel strength
         {
           s.hlival=-1;
           if(lnavg)
             s.hlival=-2;
         }
       if((huavg && lnavg) || (hnavg && luavg))
         s.hlival=0;                          //incline val says no trade preference
       s.xpl=true;                               //xpl mode active
     }
 }

 void ntrxit()
 //ntrxit trades based on situation
 {
   bool buy,sel;                                 //buysel likelihood computed from various indicators
   double op=0,sl=0,tp=0;
   int Dhilomin=40;
  
   buy=s.hlival>0;
   sel=s.hlival<0;

   if(s.tkt==-1)                                 //tkt value nonexistent and atr gives sufficient room
     {  s.xpl=false;
       if(s.xpl)                                 //xpl mode active
         {
           if(buy)
             {
               s.bs=0;op=Ask;sl=Ask-sltp;tp=Ask+sltp;
             }
           if(sel)
             {
               s.bs=1;op=Bid;sl=Bid+sltp;tp=Bid-sltp;
             }
         }
       else                                      //!xpl mode active
         {Comment(s.Dhilo,sp,s.maxbar);
           double pad=6*Point;
           if(s.Dhilo<-Dhilomin)                 //nu buy pattern
             {
               s.bs=0;op=Ask;sl=s.minval-pad;tp=s.maxval-pad;
             }
           if(s.Dhilo>+Dhilomin)                 //un sel pattern
             {
               s.bs=1;op=Bid;sl=s.maxval+pad;tp=s.minval+pad;
             }
          }
       s.tkt=OrderSend(Symbol(),s.bs,lt,op,0,sl,tp);
     }
   else                                          //otherwise use tkt value to get order details
     {
       if(OrderSelect(s.tkt,SELECT_BY_TICKET) && !s.xpl)
         {
           s.bs=OrderType();
           s.inbuy=(s.bs==0);
           s.insel=(s.bs==1);
           if((s.inbuy && sel) ||                //inbuy with sel or
              (s.insel && buy))                  //insel with buy
               if(OrderClose(s.tkt,lt,OrderClosePrice(),0))
                 s.tkt=-1;                       //close order and reset tkt value to nonexistent
         }
     }
 }

 */

 int maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);

   if(minbar>maxbar)
     return (int)Dpts(minval,maxval);
   else
     return (int)Dpts(maxval,minval);
 }

 double Dprs(double pI,double pF)
 //difference between two prices
 {
   return (pF-pI);
 }

 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }

 bool btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }

 double avgslope(double &arr[])
 //calculates average slope using theil-sen concept when arr index matches bar number
 {
   double acc;
   int
     arrsize=ArraySize(arr),
     numbars=arrsize-1,
     iters=numbars*(numbars-1)/2;

   acc=0;
   for(int i=numbars;i>1;i--)
     for(int j=i-1;j>0;j--)
       acc+=incline(i,arr[i],j,arr[j]);
   return acc/iters;
 }

 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
 {
   int
     Dbar=bI-bF;
   return Dpts(vI,vF)/Dbar;
 }

 bool CanDoTrade()
 //checks if trading is ok via total orders, spread
 {
   int
     aords,pords;
   bool
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12),
     noordsOK=(OrdersForSymbol(aords,pords)==0);
   return (noordsOK && spreadOK);
 }

 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
 {
   aords=0;pords=0;
   for(int p=OrdersTotal()-1;p>=0;p--)
     if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
       {
         if(OrderType()>1 && OrderType()<6)
           pords++;
         if(OrderType()==OP_BUY || OrderType()==OP_SELL)
           aords++;
       }
   return aords+pords;
 }

 void showlasterror()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }

 void hline(string objlabel,double price)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
 }
  
 void displaytxt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 //
 //SPECIAL FUNCTIONS
 //
 int OnInit()
 {
   s.tkt=-1;
   s.bs=-1;
   tfs[0]=1;tfs[1]=5;tfs[2]=15;tfs[3]=30;tfs[4]=60;tfs[5]=240;
   return(INIT_SUCCEEDED);
 }

 void OnDeinit(const int reason)
 {
  
 }

 void OnTick()
 {
   main();
 }



 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

**** code v2 several indicators worked out without un
 //moder.mq4

 //DESCRIP
 /*
 all is a quantifiable mode based on incline and hilo analyses
 */

 //TODO
 /*

 minimize computations - no need to keep recalculating bars 6-1 for every tick


 indicator notes

 1. find tf where |s.mxmnV|>120 (this value can be externed may be)
 2. look for trade via other criteria in that tf
 3. s.mxmnV can be used with patterns un,uu,nu,nn especially if confirmed by s.inclX
 4. s.inclX can determine mode and ntrxit

 inclX
 - show type of movement -ve,neutral,+ve

 hilo0
 - low values means sr formed useful when inclX is -1,0,+1
 - high values means significant movement


 ====
 hli may be used in various tfs to coordinate trading
 work in sr as well
 ntrxit from accummulated data

   */
 
 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>


 //
 //CONSTANTS
 //
 #define sp "  "
 #define lt 0.1
 #define sltp 600.0*Point

 //
 //EXTERNS
 //
 //extern int tfx;

 //
 //GLOBALS
 //
 int tfs[6],tfx=0;
 int bInit=6,bFina=1,Dif=bInit-bFina;

 //
 //STRUCTURES
 //
 struct status
 {

   //pr
   double pr;                                    //pr set to avg of bid,ask

   //modes
   int mode;                                     //indicated by -ve to +ve integers for trend strength

   //hilo values data
   double harr[7],larr[7];                       //hilo values arrays
   double mxval,mnval;                           //maxmin values over 6 bars
   double mxmnV;                                 //maxmin difference in points for 6 bars

   //hilo0 variations
   bool hvar0,lvar0;                             //hilo variations effectively 0 for particular tf

   //hilo inclines
   int inclX;                                    //incline indeX -3,-2,-1,0,+1,+2,+3

 
   //order parameters
   int tkt;                                      //tkt number
   int bs;                                       //buysel value
   bool inbuy,insel;                             //in trade already?
 };

 status s;

 //
 //FUNCTIONS
 //
 void main()
 {
   status();
   //ntrxit();
 }


 void status()
 //determines all relevant marketconditions
 {
   int
     tf=tfs[tfx];
  
   //set pr
   s.pr=(Bid+Ask)/2;

   //values array data
   valarr(tf,bInit,bFina,s.harr,s.larr);

   //mxmn computations
   s.mxmnV=mxmn(bInit,bFina,s.harr,s.larr,s.mxval,s.mnval);

   //slope computations
   s.inclX=hlslopes(bInit,bFina,s.harr,s.larr);  //BUY+3+2 SEL-3-2 TRL0+1-1 HLD0 look for rng trades

   //hilo variation computations sets hvar0,lvar0 to true (sr formed) or false
   hlvars(s.harr,s.larr);


 }

 void valarr(int tf,int bI,int bF,double &hv[],double &lv[])
 //fills values array
 {
   for(int b=bI;b>=bF;b--)                           //hilo values for b6-b1
     { 
       hv[b]=iHigh(NULL,tf,b);
       lv[b]=iLow(NULL,tf,b);
     }
 }


 double mxmn(int bI,int bF,double &hv[],double &lv[],double &mxval,double &mnval)
 //maxmin calculations of array values
 {
   int
     tfx=0;

   int
     mxb=ArrayMaximum(hv,bI,bF),
     mnb=ArrayMinimum(lv,bI,bF);
   mxval=hv[mxb];
   mnval=lv[mnb];

   if(mnb>mxb)
     return Dpts(mnval,mxval);
   else
     return Dpts(mxval,mnval);
 }


 int hlslopes(int bI,int bF,double &hv[],double &lv[])
 //calculates the hilo inclines
 {
   double hslp[7],lslp[7];
   ArrayInitialize(hslp,0);ArrayInitialize(lslp,0);
   int
     d0=4;
   for(int b=bI;b>=bF+1;b--)
     {
       hslp[b]=incline(b,hv[b],bF,hv[bF]);
       lslp[b]=incline(b,lv[b],bF,lv[bF]);
       hslp[1]+=hslp[b];
       lslp[1]+=lslp[b];
     }
   hslp[0]=hslp[1]/Dif;
   lslp[0]=lslp[1]/Dif;
  
   int                                           //hilo inclines - possibly think of different representation, acceleration?
     hincl=0,
     lincl=0;

   if(btn(-d0,hslp[0],+d0))                      //hslp in d0 zone
     hincl=0;
   else
     {
       if(hslp[6]<0 && hslp[0]<hslp[6])          //na-2 hi going strongly n SEL
         hincl=-2;
       if(hslp[6]<0 && hslp[0]>hslp[6])          //na-1 hi going n SEL
         hincl=-1;      
       if(hslp[6]>0 && hslp[0]>hslp[6])          //ua+1 hi going u HLD
         hincl=+1;
       if(hslp[6]>0 && hslp[0]<hslp[6])          //ud=0 hi weakening u TRL
         hincl=0;
     }

   if(btn(-d0,lslp[0],+d0))                      //lslp in d0 zone
     lincl=0;
   else
     {
       if(lslp[6]>0 && lslp[0]>lslp[6])          //ua+2 lo going strongly u BUY
         lincl=+2;
       if(lslp[6]>0 && lslp[0]<lslp[6])          //ua+1 lo going u BUY
         lincl=+1;
       if(lslp[6]<0 && lslp[0]<lslp[6])          //na-1 lo going n HLD
         lincl=-1;
       if(lslp[6]<0 && lslp[0]>lslp[6])          //nd=0 lo weakening n TRL
         lincl=0;      
     }

   return hincl+lincl;
   }


 void hlvars(double &hv[],double &lv[])
 //determines whether hilo variations over the 6 bars effectively 0 for the tf
 {
   int ep[6],                                    //epsilon tf limits
     bars=6;                                     //bars examined
   ep[0]=6;ep[1]=12;ep[2]=24;ep[3]=36;ep[4]=48;ep[5]=60;
   double
     epsilon=ep[tfx],
     hvar=Dpts(hv[ArrayMinimum(hv,bars,1)],hv[ArrayMaximum(hv,bars,1)]),
     lvar=Dpts(lv[ArrayMinimum(lv,bars,1)],lv[ArrayMaximum(lv,bars,1)]);

   if(hvar<epsilon)
     s.hvar0=true;
   else
     s.hvar0=false;
   if(lvar<epsilon)
     s.lvar0=true;
   else
     s.lvar0=false;
 }




 /*
 void hli()
 //determines hilo inclines btn bar 1 and bars 2,3,4,6
 {
   double
     h[7],l[7],hav,lav;
   int
     d0=4;
  
   ArrayInitialize(h,0);ArrayInitialize(l,0);
   hav=0;lav=0;
   for(int i=2;i<7;i++)                          //calculate inclines 6-2 and avgs
     {
       h[i]=incline(i,iHigh(NULL,tfs[tfx],i),1,iHigh(NULL,tfs[tfx],1));
       l[i]=incline(i,iLow(NULL,tfs[tfx],i),1,iLow(NULL,tfs[tfx],1));
       hav+=h[i];lav+=l[i];
     }
   hav/=5;lav/=5;
  
   if(btn(-d0,hav,+d0) && btn(-d0,lav,+d0))      //neutral incline criteria
     {
       s.hlival=0;                               //incline val says no trade preference
       s.xpl=false;                              //xpl mode deactivated
     }
   else
     {
       //criteria
       bool
         huavg=h[6]<hav,                         //hi u buy
         luavg=l[6]<lav,                         //lo u buy
         hnavg=h[6]>hav,                         //hi n sel
         lnavg=l[6]>lav;                         //lo n sel
      
       if(luavg)                                 //buy strength
         {
           s.hlival=+1;
           if(huavg)
             s.hlival=+2;
         }
       if(hnavg)                                 //sel strength
         {
           s.hlival=-1;
           if(lnavg)
             s.hlival=-2;
         }
       if((huavg && lnavg) || (hnavg && luavg))
         s.hlival=0;                          //incline val says no trade preference
       s.xpl=true;                               //xpl mode active
     }
 }

 void ntrxit()
 //ntrxit trades based on situation
 {
   bool buy,sel;                                 //buysel likelihood computed from various indicators
   double op=0,sl=0,tp=0;
   int Dhilomin=40;
  
   buy=s.hlival>0;
   sel=s.hlival<0;

   if(s.tkt==-1)                                 //tkt value nonexistent and atr gives sufficient room
     {  s.xpl=false;
       if(s.xpl)                                 //xpl mode active
         {
           if(buy)
             {
               s.bs=0;op=Ask;sl=Ask-sltp;tp=Ask+sltp;
             }
           if(sel)
             {
               s.bs=1;op=Bid;sl=Bid+sltp;tp=Bid-sltp;
             }
         }
       else                                      //!xpl mode active
         {Comment(s.Dhilo,sp,s.maxbar);
           double pad=6*Point;
           if(s.Dhilo<-Dhilomin)                 //nu buy pattern
             {
               s.bs=0;op=Ask;sl=s.minval-pad;tp=s.maxval-pad;
             }
           if(s.Dhilo>+Dhilomin)                 //un sel pattern
             {
               s.bs=1;op=Bid;sl=s.maxval+pad;tp=s.minval+pad;
             }
          }
       s.tkt=OrderSend(Symbol(),s.bs,lt,op,0,sl,tp);
     }
   else                                          //otherwise use tkt value to get order details
     {
       if(OrderSelect(s.tkt,SELECT_BY_TICKET) && !s.xpl)
         {
           s.bs=OrderType();
           s.inbuy=(s.bs==0);
           s.insel=(s.bs==1);
           if((s.inbuy && sel) ||                //inbuy with sel or
              (s.insel && buy))                  //insel with buy
               if(OrderClose(s.tkt,lt,OrderClosePrice(),0))
                 s.tkt=-1;                       //close order and reset tkt value to nonexistent
         }
     }
 }

 */



 double Dprs(double pI,double pF)
 //difference between two prices
 {
   return (pF-pI);
 }

 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }

 bool btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }

 double avgslope(double &arr[])
 //calculates average slope using theil-sen concept when arr index matches bar number
 {
   double acc;
   int
     arrsize=ArraySize(arr),
     numbars=arrsize-1,
     iters=numbars*(numbars-1)/2;

   acc=0;
   for(int i=numbars;i>1;i--)
     for(int j=i-1;j>0;j--)
       acc+=incline(i,arr[i],j,arr[j]);
   return acc/iters;
 }

 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
 {
   int
     Dbar=bI-bF;
   if(Dbar==0) Dbar=1;
   return Dpts(vI,vF)/Dbar;
 }

 bool CanDoTrade()
 //checks if trading is ok via total orders, spread
 {
   int
     aords,pords;
   bool
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12),
     noordsOK=(OrdersForSymbol(aords,pords)==0);
   return (noordsOK && spreadOK);
 }

 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
 {
   aords=0;pords=0;
   for(int p=OrdersTotal()-1;p>=0;p--)
     if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
       {
         if(OrderType()>1 && OrderType()<6)
           pords++;
         if(OrderType()==OP_BUY || OrderType()==OP_SELL)
           aords++;
       }
   return aords+pords;
 }

 void showlasterror()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }

 void hline(string objlabel,double price)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
 }
  
 void displaytxt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 //
 //SPECIAL FUNCTIONS
 //
 int OnInit()
 {
   s.tkt=-1;
   s.bs=-1;
   tfs[0]=1;tfs[1]=5;tfs[2]=15;tfs[3]=30;tfs[4]=60;tfs[5]=240;
   return(INIT_SUCCEEDED);
 }

 void OnDeinit(const int reason)
 {
  
 }

 void OnTick()
 {
   main();
 }



 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

**** code v3 attempt to have tfx determined by mxmn size - hasn't worked yet
 //moder.mq4

 //DESCRIP
 /*
 all is a quantifiable mode based on incline and hilo analyses
 */

 //TODO
 /*

 minimize computations - no need to keep recalculating bars 6-1 for every tick


 indicator notes

 1. find tf where |s.mxmnV|>120 (this value can be externed may be)
 2. look for trade via other criteria in that tf
 3. s.mxmnV can be used with patterns un,uu,nu,nn especially if confirmed by s.inclX
 4. s.inclX can determine mode and ntrxit

 inclX
 - show type of movement -ve,neutral,+ve

 hilo0
 - low values means sr formed useful when inclX is -1,0,+1
 - high values means significant movement


 ====
 hli may be used in various tfs to coordinate trading
 work in sr as well
 ntrxit from accummulated data

   */
 
 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>


 //
 //CONSTANTS
 //
 #define sp "  "
 #define lt 0.1
 #define sltp 600.0*Point

 //
 //EXTERNS
 //
 //extern int tfx;

 //
 //GLOBALS
 //
 int tfs[6];
 int bInit=6,bFina=1,Dif=bInit-bFina;

 //
 //STRUCTURES
 //
 struct status
 {

   //timeframe index
   int tfx;
  
   //pr
   double pr;                                    //pr set to avg of bid,ask

   //modes
   int mode;                                     //indicated by -ve to +ve integers for trend strength

   //hilo values data
   double harr[7],larr[7];                       //hilo values arrays
   double mxval,mnval;                           //maxmin values over 6 bars
   double mxmnV;                                 //maxmin difference in points for 6 bars

   //hilo0 variations
   bool hvar0,lvar0;                             //hilo variations effectively 0 for particular tf

   //hilo inclines
   int inclX;                                    //incline indeX -3,-2,-1,0,+1,+2,+3

 
   //order parameters
   int tkt;                                      //tkt number
   int bs;                                       //buysel value
   bool inbuy,insel;                             //in trade already?
 };

 status s;

 //
 //FUNCTIONS
 //
 void main()
 {
   status();
   //ntrxit();
 }


 void status()
 //determines all relevant marketconditions
 {
   //set pr
   s.pr=(Bid+Ask)/2;

   //mxmn computations
   mxmn(bInit,bFina,s.harr,s.larr,s.mxval,s.mnval);

   //slope computations
   //s.inclX=hlslopes(bInit,bFina,s.harr,s.larr);  //BUY+3+2 SEL-3-2 TRL0+1-1 HLD0 look for rng trades

   //hilo variation computations sets hvar0,lvar0 to true (sr formed) or false
   //hlvars(s.harr,s.larr);


 }


 void mxmn(int bI,int bF,double &hv[],double &lv[],double &mxv,double &mnv)
 //maxmin calculations of array values
 {
   double mxmn;
   int mxb,mnb,
     mxmnT=120;                                  //minimum mxmnV threshold

   s.tfx=-1;
   mxmn=0;
   while(fabs(s.mxmnV)<mxmnT)
     {
       s.tfx++;
       for(int b=bI;b>=bF;b--)                   //hilo values for b6-b1
         { 
           hv[b]=iHigh(NULL,tfs[s.tfx],b);
           lv[b]=iLow(NULL,tfs[s.tfx],b);
         }
       mxb=ArrayMaximum(hv,bI,bF);
       mnb=ArrayMinimum(lv,bI,bF);
       mxv=hv[mxb];
       mnv=lv[mnb];
       if(mnb>mxb)
         s.mxmnV=Dpts(mnv,mxv);
       else
         s.mxmnV=Dpts(mxv,mnv);
     }
   Comment(s.tfx,sp,tfs[s.tfx]);
 }


 int hlslopes(int bI,int bF,double &hv[],double &lv[])
 //calculates the hilo inclines
 {
   double hslp[7],lslp[7];
   ArrayInitialize(hslp,0);ArrayInitialize(lslp,0);
   int
     d0=4;
   for(int b=bI;b>=bF+1;b--)
     {
       hslp[b]=incline(b,hv[b],bF,hv[bF]);
       lslp[b]=incline(b,lv[b],bF,lv[bF]);
       hslp[1]+=hslp[b];
       lslp[1]+=lslp[b];
     }
   hslp[0]=hslp[1]/Dif;
   lslp[0]=lslp[1]/Dif;
  
   int                                           //hilo inclines - possibly think of different representation, acceleration?
     hincl=0,
     lincl=0;

   if(btn(-d0,hslp[0],+d0))                      //hslp in d0 zone
     hincl=0;
   else
     {
       if(hslp[6]<0 && hslp[0]<hslp[6])          //na-2 hi going strongly n SEL
         hincl=-2;
       if(hslp[6]<0 && hslp[0]>hslp[6])          //na-1 hi going n SEL
         hincl=-1;      
       if(hslp[6]>0 && hslp[0]>hslp[6])          //ua+1 hi going u HLD
         hincl=+1;
       if(hslp[6]>0 && hslp[0]<hslp[6])          //ud=0 hi weakening u TRL
         hincl=0;
     }

   if(btn(-d0,lslp[0],+d0))                      //lslp in d0 zone
     lincl=0;
   else
     {
       if(lslp[6]>0 && lslp[0]>lslp[6])          //ua+2 lo going strongly u BUY
         lincl=+2;
       if(lslp[6]>0 && lslp[0]<lslp[6])          //ua+1 lo going u BUY
         lincl=+1;
       if(lslp[6]<0 && lslp[0]<lslp[6])          //na-1 lo going n HLD
         lincl=-1;
       if(lslp[6]<0 && lslp[0]>lslp[6])          //nd=0 lo weakening n TRL
         lincl=0;      
     }

   return hincl+lincl;
   }


 void hlvars(double &hv[],double &lv[])
 //determines whether hilo variations over the 6 bars effectively 0 for the tf
 {
   int ep[6],                                    //epsilon tf limits
     bars=6;                                     //bars examined
   ep[0]=6;ep[1]=12;ep[2]=24;ep[3]=36;ep[4]=48;ep[5]=60;
   double
     epsilon=ep[s.tfx],
     hvar=Dpts(hv[ArrayMinimum(hv,bars,1)],hv[ArrayMaximum(hv,bars,1)]),
     lvar=Dpts(lv[ArrayMinimum(lv,bars,1)],lv[ArrayMaximum(lv,bars,1)]);

   if(hvar<epsilon)
     s.hvar0=true;
   else
     s.hvar0=false;
   if(lvar<epsilon)
     s.lvar0=true;
   else
     s.lvar0=false;
 }




 /*
 void hli()
 //determines hilo inclines btn bar 1 and bars 2,3,4,6
 {
   double
     h[7],l[7],hav,lav;
   int
     d0=4;
  
   ArrayInitialize(h,0);ArrayInitialize(l,0);
   hav=0;lav=0;
   for(int i=2;i<7;i++)                          //calculate inclines 6-2 and avgs
     {
       h[i]=incline(i,iHigh(NULL,tfs[tfx],i),1,iHigh(NULL,tfs[tfx],1));
       l[i]=incline(i,iLow(NULL,tfs[tfx],i),1,iLow(NULL,tfs[tfx],1));
       hav+=h[i];lav+=l[i];
     }
   hav/=5;lav/=5;
  
   if(btn(-d0,hav,+d0) && btn(-d0,lav,+d0))      //neutral incline criteria
     {
       s.hlival=0;                               //incline val says no trade preference
       s.xpl=false;                              //xpl mode deactivated
     }
   else
     {
       //criteria
       bool
         huavg=h[6]<hav,                         //hi u buy
         luavg=l[6]<lav,                         //lo u buy
         hnavg=h[6]>hav,                         //hi n sel
         lnavg=l[6]>lav;                         //lo n sel
      
       if(luavg)                                 //buy strength
         {
           s.hlival=+1;
           if(huavg)
             s.hlival=+2;
         }
       if(hnavg)                                 //sel strength
         {
           s.hlival=-1;
           if(lnavg)
             s.hlival=-2;
         }
       if((huavg && lnavg) || (hnavg && luavg))
         s.hlival=0;                          //incline val says no trade preference
       s.xpl=true;                               //xpl mode active
     }
 }

 void ntrxit()
 //ntrxit trades based on situation
 {
   bool buy,sel;                                 //buysel likelihood computed from various indicators
   double op=0,sl=0,tp=0;
   int Dhilomin=40;
  
   buy=s.hlival>0;
   sel=s.hlival<0;

   if(s.tkt==-1)                                 //tkt value nonexistent and atr gives sufficient room
     {  s.xpl=false;
       if(s.xpl)                                 //xpl mode active
         {
           if(buy)
             {
               s.bs=0;op=Ask;sl=Ask-sltp;tp=Ask+sltp;
             }
           if(sel)
             {
               s.bs=1;op=Bid;sl=Bid+sltp;tp=Bid-sltp;
             }
         }
       else                                      //!xpl mode active
         {Comment(s.Dhilo,sp,s.maxbar);
           double pad=6*Point;
           if(s.Dhilo<-Dhilomin)                 //nu buy pattern
             {
               s.bs=0;op=Ask;sl=s.minval-pad;tp=s.maxval-pad;
             }
           if(s.Dhilo>+Dhilomin)                 //un sel pattern
             {
               s.bs=1;op=Bid;sl=s.maxval+pad;tp=s.minval+pad;
             }
          }
       s.tkt=OrderSend(Symbol(),s.bs,lt,op,0,sl,tp);
     }
   else                                          //otherwise use tkt value to get order details
     {
       if(OrderSelect(s.tkt,SELECT_BY_TICKET) && !s.xpl)
         {
           s.bs=OrderType();
           s.inbuy=(s.bs==0);
           s.insel=(s.bs==1);
           if((s.inbuy && sel) ||                //inbuy with sel or
              (s.insel && buy))                  //insel with buy
               if(OrderClose(s.tkt,lt,OrderClosePrice(),0))
                 s.tkt=-1;                       //close order and reset tkt value to nonexistent
         }
     }
 }

 */



 double Dprs(double pI,double pF)
 //difference between two prices
 {
   return (pF-pI);
 }

 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }

 bool btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }

 double avgslope(double &arr[])
 //calculates average slope using theil-sen concept when arr index matches bar number
 {
   double acc;
   int
     arrsize=ArraySize(arr),
     numbars=arrsize-1,
     iters=numbars*(numbars-1)/2;

   acc=0;
   for(int i=numbars;i>1;i--)
     for(int j=i-1;j>0;j--)
       acc+=incline(i,arr[i],j,arr[j]);
   return acc/iters;
 }

 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
 {
   int
     Dbar=bI-bF;
   if(Dbar==0) Dbar=1;
   return Dpts(vI,vF)/Dbar;
 }

 bool CanDoTrade()
 //checks if trading is ok via total orders, spread
 {
   int
     aords,pords;
   bool
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12),
     noordsOK=(OrdersForSymbol(aords,pords)==0);
   return (noordsOK && spreadOK);
 }

 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
 {
   aords=0;pords=0;
   for(int p=OrdersTotal()-1;p>=0;p--)
     if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
       {
         if(OrderType()>1 && OrderType()<6)
           pords++;
         if(OrderType()==OP_BUY || OrderType()==OP_SELL)
           aords++;
       }
   return aords+pords;
 }

 void showlasterror()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }

 void hline(string objlabel,double price)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
 }
  
 void displaytxt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 //
 //SPECIAL FUNCTIONS
 //
 int OnInit()
 {
   s.tkt=-1;
   s.bs=-1;
   tfs[0]=1;tfs[1]=5;tfs[2]=15;tfs[3]=30;tfs[4]=60;tfs[5]=240;
   return(INIT_SUCCEEDED);
 }

 void OnDeinit(const int reason)
 {
  
 }

 void OnTick()
 {
   main();
 }



 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

**** code v4 using mxmnT and tfx
 161001-08
 | 98.50 | 3 | 0.00 | 32.83 | 52.00 | 0.52% | tfx=4 | mxmnT=240 |
 | 87.30 | 4 | 8.79 | 21.82 | 52.00 | 0.52% | tfx=4 | mxmnT=230 |
 | 87.30 | 4 | 8.79 | 21.82 | 52.00 | 0.52% | tfx=4 | mxmnT=220 |
 | 87.30 | 4 | 8.79 | 21.82 | 52.00 | 0.52% | tfx=4 | mxmnT=210 |
 | 73.00 | 6 | 3.64 | 12.17 | 52.00 | 0.52% | tfx=4 | mxmnT=180 |
 | 73.00 | 6 | 3.64 | 12.17 | 52.00 | 0.52% | tfx=4 | mxmnT=170 |
 | 73.00 | 6 | 3.64 | 12.17 | 52.00 | 0.52% | tfx=4 | mxmnT=160 |
 | 73.00 | 6 | 3.64 | 12.17 | 52.00 | 0.52% | tfx=4 | mxmnT=150 |
 | 70.50 | 7 | 3.33 | 10.07 | 52.00 | 0.52% | tfx=4 | mxmnT=140 |
 | 70.50 | 7 | 3.33 | 10.07 | 52.00 | 0.52% | tfx=4 | mxmnT=130 |
 | 70.50 | 7 | 3.33 | 10.07 | 52.00 | 0.52% | tfx=4 | mxmnT=120 |
 | 70.50 | 7 | 3.33 | 10.07 | 52.00 | 0.52% | tfx=4 | mxmnT=110 |
 | 70.50 | 7 | 3.33 | 10.07 | 52.00 | 0.52% | tfx=4 | mxmnT=100 |
 | 70.50 | 7 | 3.33 | 10.07 | 52.00 | 0.52% | tfx=4 | mxmnT=90  |
 | 70.50 | 7 | 3.33 | 10.07 | 52.00 | 0.52% | tfx=4 | mxmnT=80  |
 | 70.50 | 7 | 3.33 | 10.07 | 52.00 | 0.52% | tfx=4 | mxmnT=70  |
 | 70.50 | 7 | 3.33 | 10.07 | 52.00 | 0.52% | tfx=4 | mxmnT=60  |
 | 70.50 | 7 | 3.33 | 10.07 | 52.00 | 0.52% | tfx=4 | mxmnT=50  |
 | 70.50 | 7 | 3.33 | 10.07 | 52.00 | 0.52% | tfx=4 | mxmnT=40  |
 | 70.40 | 5 | 3.51 | 14.08 | 52.00 | 0.52% | tfx=4 | mxmnT=200 |
 | 70.40 | 5 | 3.51 | 14.08 | 52.00 | 0.52% | tfx=4 | mxmnT=190 |
 | 50.30 | 3 | 4.75 | 16.77 | 21.30 | 0.21% | tfx=2 | mxmnT=190 |
 | 50.30 | 3 | 4.75 | 16.77 | 21.30 | 0.21% | tfx=2 | mxmnT=180 |
 | 50.30 | 3 | 4.75 | 16.77 | 21.30 | 0.21% | tfx=2 | mxmnT=170 |
 | 50.30 | 3 | 4.75 | 16.77 | 21.30 | 0.21% | tfx=2 | mxmnT=160 |
 | 46.60 | 2 | 4.48 | 23.30 | 14.40 | 0.14% | tfx=2 | mxmnT=240 |
 | 46.60 | 2 | 4.48 | 23.30 | 14.40 | 0.14% | tfx=2 | mxmnT=230 |
 | 46.60 | 2 | 4.48 | 23.30 | 14.40 | 0.14% | tfx=2 | mxmnT=220 |
 | 46.60 | 2 | 4.48 | 23.30 | 14.40 | 0.14% | tfx=2 | mxmnT=210 |
 | 46.60 | 2 | 4.48 | 23.30 | 14.40 | 0.14% | tfx=2 | mxmnT=200 |

 161008-15 all same profit at highend
 | 69.00 | 2 | 0.00 | 34.50 | 25.40 | 0.25% | tfx=4 | mxmnT=180 |
 | 69.00 | 2 | 0.00 | 34.50 | 25.40 | 0.25% | tfx=4 | mxmnT=170 |
 | 69.00 | 2 | 0.00 | 34.50 | 25.40 | 0.25% | tfx=4 | mxmnT=160 |
 | 69.00 | 2 | 0.00 | 34.50 | 25.40 | 0.25% | tfx=4 | mxmnT=150 |
 | 69.00 | 2 | 0.00 | 34.50 | 25.40 | 0.25% | tfx=4 | mxmnT=140 |

 161015-22
 | 60.00 | 11 | 4.09 | 5.45 | 26.80 | 0.27% | tfx=2 | mxmnT=160 |
 | 57.50 | 15 | 3.33 | 3.83 | 32.10 | 0.32% | tfx=2 | mxmnT=140 |
 | 55.90 | 11 | 3.88 | 5.08 | 29.90 | 0.30% | tfx=2 | mxmnT=170 |
 | 55.90 | 29 | 2.22 | 1.93 | 34.70 | 0.35% | tfx=2 | mxmnT=110 |
 | 52.40 | 27 | 2.39 | 1.94 | 28.00 | 0.28% | tfx=2 | mxmnT=120 |
 | 52.00 | 10 | 3.23 | 5.20 | 33.80 | 0.34% | tfx=2 | mxmnT=180 |
 | 51.70 | 26 | 2.34 | 1.99 | 35.60 | 0.36% | tfx=2 | mxmnT=130 |
 | 46.80 | 14 | 2.41 | 3.34 | 39.10 | 0.39% | tfx=2 | mxmnT=150 |
 | 45.00 | 48 | 1.69 | 0.94 | 43.50 | 0.43% | tfx=2 | mxmnT=80  |

 161022-29 all same profit 
 | 45.80 | 13 | 3.42 | 3.52 | 54.70 | 0.54% | tfx=5 | mxmnT=240 |
 | 45.80 | 13 | 3.42 | 3.52 | 54.70 | 0.54% | tfx=5 | mxmnT=230 |
 | 45.80 | 13 | 3.42 | 3.52 | 54.70 | 0.54% | tfx=5 | mxmnT=220 |
 | 45.80 | 13 | 3.42 | 3.52 | 54.70 | 0.54% | tfx=5 | mxmnT=210 |
 | 45.80 | 13 | 3.42 | 3.52 | 54.70 | 0.54% | tfx=5 | mxmnT=200 |
 | 45.80 | 13 | 3.42 | 3.52 | 54.70 | 0.54% | tfx=5 | mxmnT=190 |
 | 45.80 | 13 | 3.42 | 3.52 | 54.70 | 0.54% | tfx=5 | mxmnT=180 |


 many times there was profit but by the time the exit condition showed up, it was lost

 //moder.mq4

 //DESCRIP
 /*
 all is a quantifiable mode based on incline and hilo analyses
 */

 //TODO
 /*

 minimize computations - no need to keep recalculating bars 6-1 for every tick

 may need to make alignment with 12bar reading?

 indicator notes

 1. when |s.mxmnV|>120 (this value can be externed may be) we can proceed
 2. look for trade via other criteria
 3. s.mxmnV can be used with patterns un,uu,nu,nn especially if confirmed by s.inclX
 4. s.inclX can determine mode and ntrxit

 1inclX
 - show type of movement -ve,neutral,+ve

 hilo0
 - low values means sr formed useful when inclX is -1,0,+1 useful for rng mode
 - high values means significant movement


 ====
 hli may be used in various tfs to coordinate trading
 work in sr as well
 ntrxit from accummulated data

   */
 
 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>


 //
 //CONSTANTS
 //
 #define sp "  "
 #define lt 0.1
 #define sltp 600.0*Point


 //
 //EXTERNS
 //
 extern int tfx;
 extern int  mxmnT;

 //
 //GLOBALS
 //
 int tfs[6];
 int bInit=6,bFina=1,Dif=bInit-bFina;

 //
 //STRUCTURES
 //
 struct status
 {

   //pr
   double pr;                                    //pr set to avg of bid,ask

   //modes
   int mode;                                     //indicated by -ve to +ve integers for trend strength

   //hilo values data
   double harr[7],larr[7];                       //hilo values arrays
   double mxval,mnval;                           //maxmin values over 6 bars
   double mxmnV;                                 //maxmin difference in points for 6 bars

   //hilo0 variations
   bool hvar0,lvar0;                             //hilo variations effectively 0 for particular tf

   //hilo inclines
   int inclX;                                    //incline indeX -3,-2,-1,0,+1,+2,+3

 
   //order parameters
   int tkt;                                      //tkt number
   int bs;                                       //buysel value
   double op,sl,tp;                              //open price,stoploss,takeprofit
   bool inbuy,insel;                             //in buysel trade already?
 };

 status s;

 //
 //FUNCTIONS
 //
 void main()
 {
   status();
   ntrxit();
 }


 void status()
 //determines all relevant marketconditions
 {
   int
     tf=tfs[tfx];
  
   //set pr
   s.pr=(Bid+Ask)/2;

   //values array data
   valarr(tf,bInit,bFina,s.harr,s.larr);

   //mxmn computations
   s.mxmnV=mxmn(bInit,bFina,s.harr,s.larr,s.mxval,s.mnval);

   //slope computations
   s.inclX=hlslopes(bInit,bFina,s.harr,s.larr);  //BUY+3+2 SEL-3-2 TRL0+1-1 HLD0 look for rng trades

   //hilo variation computations sets hvar0,lvar0 to true (sr formed) or false
   hlvars(s.harr,s.larr);

 }


 void ntrxit()
 //ntrxit mechanisms
 {

   if(s.tkt==-1)                                 //tradeless
     {
       if(s.mxmnV>mxmnT)                         //enough movement
         {
           if(s.inclX>+1)                        //xplBUY
             {s.bs=0;s.op=Ask;s.sl=s.op-sltp;s.tp=s.op+sltp;}
           if(s.inclX<-1)                        //xplSEL
             {s.bs=1;s.op=Bid;s.sl=s.op+sltp;s.tp=s.op-sltp;}
           if(btn(-1,s.inclX,+1))                //rngBUYSEL
             {}
           s.tkt=OrderSend(Symbol(),s.bs,lt,s.op,0,s.sl,s.tp);
         }
       else
         Comment("no trading");
     }
   else                                          //trading
     {
       if(OrderSelect(s.tkt,SELECT_BY_TICKET))
         {
           if((s.bs==0 && s.inclX<0) || (s.bs==1 && s.inclX>0))
             if(OrderClose(s.tkt,lt,OrderClosePrice(),0))
               s.tkt=-1;                       
         }
     }
 }


 void valarr(int tf,int bI,int bF,double &hv[],double &lv[])
 //fills values array
 {
   for(int b=bI;b>=bF;b--)                           //hilo values for b6-b1
     { 
       hv[b]=iHigh(NULL,tf,b);
       lv[b]=iLow(NULL,tf,b);
     }
 }


 double mxmn(int bI,int bF,double &hv[],double &lv[],double &mxval,double &mnval)
 //maxmin calculations of array values
 {
   int
     mxb=ArrayMaximum(hv,bI,bF),
     mnb=ArrayMinimum(lv,bI,bF);
   mxval=hv[mxb];
   mnval=lv[mnb];

   if(mnb>mxb)
     return Dpts(mnval,mxval);
   else
     return Dpts(mxval,mnval);
 }


 int hlslopes(int bI,int bF,double &hv[],double &lv[])
 //calculates the hilo inclines
 {
   double hslp[7],lslp[7];
   ArrayInitialize(hslp,0);ArrayInitialize(lslp,0);
   int
     d0=4;
   for(int b=bI;b>=bF+1;b--)
     {
       hslp[b]=incline(b,hv[b],bF,hv[bF]);
       lslp[b]=incline(b,lv[b],bF,lv[bF]);
       hslp[1]+=hslp[b];
       lslp[1]+=lslp[b];
     }
   hslp[0]=hslp[1]/Dif;
   lslp[0]=lslp[1]/Dif;
  
   int                                           //hilo inclines - possibly think of different representation, acceleration?
     hincl=0,
     lincl=0;

   if(btn(-d0,hslp[0],+d0))                      //hslp in d0 zone
     hincl=0;
   else
     {
       if(hslp[6]<0 && hslp[0]<hslp[6])          //na-2 hi going strongly n SEL
         hincl=-2;
       if(hslp[6]<0 && hslp[0]>hslp[6])          //na-1 hi going n SEL
         hincl=-1;      
       if(hslp[6]>0 && hslp[0]>hslp[6])          //ua+1 hi going u HLD
         hincl=+1;
       if(hslp[6]>0 && hslp[0]<hslp[6])          //ud=0 hi weakening u TRL
         hincl=0;
     }

   if(btn(-d0,lslp[0],+d0))                      //lslp in d0 zone
     lincl=0;
   else
     {
       if(lslp[6]>0 && lslp[0]>lslp[6])          //ua+2 lo going strongly u BUY
         lincl=+2;
       if(lslp[6]>0 && lslp[0]<lslp[6])          //ua+1 lo going u BUY
         lincl=+1;
       if(lslp[6]<0 && lslp[0]<lslp[6])          //na-1 lo going n HLD
         lincl=-1;
       if(lslp[6]<0 && lslp[0]>lslp[6])          //nd=0 lo weakening n TRL
         lincl=0;      
     }

   return hincl+lincl;
   }


 void hlvars(double &hv[],double &lv[])
 //determines whether hilo variations over the 6 bars effectively 0 for the tf
 {
   int ep[6],                                    //epsilon tf limits
     bars=6;                                     //bars examined
   ep[0]=6;ep[1]=12;ep[2]=24;ep[3]=36;ep[4]=48;ep[5]=60;
   double
     epsilon=ep[tfx],
     hvar=Dpts(hv[ArrayMinimum(hv,bars,1)],hv[ArrayMaximum(hv,bars,1)]),
     lvar=Dpts(lv[ArrayMinimum(lv,bars,1)],lv[ArrayMaximum(lv,bars,1)]);

   if(hvar<epsilon)
     s.hvar0=true;
   else
     s.hvar0=false;
   if(lvar<epsilon)
     s.lvar0=true;
   else
     s.lvar0=false;
 }







 double Dprs(double pI,double pF)
 //difference between two prices
 {
   return (pF-pI);
 }

 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }

 bool btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }

 double avgslope(double &arr[])
 //calculates average slope using theil-sen concept when arr index matches bar number
 {
   double acc;
   int
     arrsize=ArraySize(arr),
     numbars=arrsize-1,
     iters=numbars*(numbars-1)/2;

   acc=0;
   for(int i=numbars;i>1;i--)
     for(int j=i-1;j>0;j--)
       acc+=incline(i,arr[i],j,arr[j]);
   return acc/iters;
 }

 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
 {
   int
     Dbar=bI-bF;
   if(Dbar==0) Dbar=1;
   return Dpts(vI,vF)/Dbar;
 }

 bool CanDoTrade()
 //checks if trading is ok via total orders, spread
 {
   int
     aords,pords;
   bool
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12),
     noordsOK=(OrdersForSymbol(aords,pords)==0);
   return (noordsOK && spreadOK);
 }

 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
 {
   aords=0;pords=0;
   for(int p=OrdersTotal()-1;p>=0;p--)
     if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
       {
         if(OrderType()>1 && OrderType()<6)
           pords++;
         if(OrderType()==OP_BUY || OrderType()==OP_SELL)
           aords++;
       }
   return aords+pords;
 }

 void showlasterror()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }

 void hline(string objlabel,double price)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
 }
  
 void displaytxt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 //
 //SPECIAL FUNCTIONS
 //
 int OnInit()
 {
   s.tkt=-1;
   s.bs=-1;
   tfs[0]=1;tfs[1]=5;tfs[2]=15;tfs[3]=30;tfs[4]=60;tfs[5]=240;
   return(INIT_SUCCEEDED);
 }

 void OnDeinit(const int reason)
 {
  
 }

 void OnTick()
 {
   main();
 }



 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

*** HiL
 continuing with the inclines of hilo to see if we can get improved slope detection
**** code v1 some good ideas developed - key being we focus on modes

 //hli.mq4

 //DESCRIP
 /*
 hli uses hilo incline to detect slope
 */

 //TODO
 /*
 organize xpl and !xpl structures appropriately into subroutines
 rng mode should depend on hilo inclines

 get bnd d0 trades improved possibly with trailing stops or other indicators

 figure out how to interpret hlinclines


 ====
 hli may be used in various tfs to coordinate trading
 work in sr
 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>


 //
 //CONSTANTS
 //
 #define sp "  "
 #define lt 0.1
 #define sltp 600.0*Point

 //
 //EXTERNS
 //
 //extern int tfx;

 //
 //GLOBALS
 //
 int tfs[6],tfx=3;


 //
 //STRUCTURES
 //
 struct status
 {
   //pr
   double pr;                                    //pr set to avg of bid,ask

   //modes
   string mode;                                  //xpl,rng,ntl

   //get Dhilo data
   int Dhilo;                                    //hilo difference in points
   int maxbar,minbar;                            //maxmin bar numbers
   double maxval,minval;                         //maxmin bar values
  
   //hli
   int hlival;                                   //values -1 sel, 0 neutral, +1 buy
  
   //order parameters
   int tkt;                                      //tkt number
   int bs;                                       //buysel value
   bool inbuy,insel;                             //in trade already?
 };

 status s;

 //
 //FUNCTIONS
 //
 void main()
 {
   status();
   ntrxit();
 }


 void status()
 //determines all relevant marketconditions
 {
   //set pr
   s.pr=(Bid+Ask)/2;
  
   //get Dhilo
   s.Dhilo=dhilo(tfs[tfx],7,1,s.maxbar,s.maxval,s.minbar,s.minval);

   //get hli
   hli();
 }

 void hli()
 //determines hilo inclines btn bar 1 and bars 2,3,4,6
 {
   double
     h[7],l[7],hav,lav;
   int
     d0=4;
  
   ArrayInitialize(h,0);ArrayInitialize(l,0);
   hav=0;lav=0;
   for(int i=2;i<7;i++)                          //calculate inclines 6-2 and avgs
     {
       h[i]=incline(i,iHigh(NULL,tfs[tfx],i),1,iHigh(NULL,tfs[tfx],1));
       l[i]=incline(i,iLow(NULL,tfs[tfx],i),1,iLow(NULL,tfs[tfx],1));
       hav+=h[i];lav+=l[i];
     }
   hav/=5;lav/=5;
  
   if(btn(-d0,hav,+d0) && btn(-d0,lav,+d0))      //neutral incline criteria
     {
       s.hlival=0;                               //incline val says no trade preference
       s.xpl=false;                              //xpl mode deactivated
     }
   else
     {
       //criteria
       bool
         huavg=h[6]<hav,                         //hi u buy
         luavg=l[6]<lav,                         //lo u buy
         hnavg=h[6]>hav,                         //hi n sel
         lnavg=l[6]>lav;                         //lo n sel
      
       if(luavg)                                 //buy strength
         {
           s.hlival=+1;
           if(huavg)
             s.hlival=+2;
         }
       if(hnavg)                                 //sel strength
         {
           s.hlival=-1;
           if(lnavg)
             s.hlival=-2;
         }
       /*if((huavg && lnavg) || (hnavg && luavg))
         s.hlival=0;*/                           //incline val says no trade preference
       s.xpl=true;                               //xpl mode active
     }
 }

 void ntrxit()
 //ntrxit trades based on situation
 {
   bool buy,sel;                                 //buysel likelihood computed from various indicators
   double op=0,sl=0,tp=0;
   int Dhilomin=40;
  
   buy=s.hlival>0;
   sel=s.hlival<0;

   if(s.tkt==-1)                                 //tkt value nonexistent and atr gives sufficient room
     {  s.xpl=false;
       if(s.xpl)                                 //xpl mode active
         {
           if(buy)
             {
               s.bs=0;op=Ask;sl=Ask-sltp;tp=Ask+sltp;
             }
           if(sel)
             {
               s.bs=1;op=Bid;sl=Bid+sltp;tp=Bid-sltp;
             }
         }
       else                                      //!xpl mode active
         {Comment(s.Dhilo,sp,s.maxbar);
           double pad=6*Point;
           if(s.Dhilo<-Dhilomin)                 //nu buy pattern
             {
               s.bs=0;op=Ask;sl=s.minval-pad;tp=s.maxval-pad;
             }
           if(s.Dhilo>+Dhilomin)                 //un sel pattern
             {
               s.bs=1;op=Bid;sl=s.maxval+pad;tp=s.minval+pad;
             }
          }
       s.tkt=OrderSend(Symbol(),s.bs,lt,op,0,sl,tp);
     }
   else                                          //otherwise use tkt value to get order details
     {
       if(OrderSelect(s.tkt,SELECT_BY_TICKET) && !s.xpl)
         {
           s.bs=OrderType();
           s.inbuy=(s.bs==0);
           s.insel=(s.bs==1);
           if((s.inbuy && sel) ||                //inbuy with sel or
              (s.insel && buy))                  //insel with buy
               if(OrderClose(s.tkt,lt,OrderClosePrice(),0))
                 s.tkt=-1;                       //close order and reset tkt value to nonexistent
         }
     }
 }

 int dhilo(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //delta hilo between bI and bF in points and sign indicating loss or gain
 {
   maxmin(tf,bI,bF,maxbar,maxval,minbar,minval);
   if(minbar>maxbar)
     return (int)Dpts(minval,maxval);
   else
     return (int)Dpts(maxval,minval);
 }

 void maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);
 }

 double Dprs(double pI,double pF)
 //difference between two prices
 {
   return (pF-pI);
 }

 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }

 bool btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }

 double avgslope(double &arr[])
 //calculates average slope using theil-sen concept when arr index matches bar number
 {
   double acc;
   int
     arrsize=ArraySize(arr),
     numbars=arrsize-1,
     iters=numbars*(numbars-1)/2;

   acc=0;
   for(int i=numbars;i>1;i--)
     for(int j=i-1;j>0;j--)
       acc+=incline(i,arr[i],j,arr[j]);
   return acc/iters;
 }

 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
 {
   int
     Dbar=bI-bF;
   return Dpts(vI,vF)/Dbar;
 }

 bool CanDoTrade()
 //checks if trading is ok via total orders, spread
 {
   int
     aords,pords;
   bool
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12),
     noordsOK=(OrdersForSymbol(aords,pords)==0);
   return (noordsOK && spreadOK);
 }

 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
 {
   aords=0;pords=0;
   for(int p=OrdersTotal()-1;p>=0;p--)
     if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
       {
         if(OrderType()>1 && OrderType()<6)
           pords++;
         if(OrderType()==OP_BUY || OrderType()==OP_SELL)
           aords++;
       }
   return aords+pords;
 }

 void showlasterror()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }

 void hline(string objlabel,double price)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
 }
  
 void displaytxt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 //
 //SPECIAL FUNCTIONS
 //
 int OnInit()
 {
   s.tkt=-1;
   s.bs=-1;
   tfs[0]=1;tfs[1]=5;tfs[2]=15;tfs[3]=30;tfs[4]=60;tfs[5]=240;
   return(INIT_SUCCEEDED);
 }

 void OnDeinit(const int reason)
 {
  
 }

 void OnTick()
 {
   main();
 }



 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

*** muda
 up and down between moving averages
 ma2 on hilo values
 find tf where Dhilo on avg are sufficiently large
 ntr on bouncing out of zone computed for each ma based on projections
 xit on zone near opposite side
 take slopes of ma into account
 possibly incorporate HLI ideas too

**** code v1 works reasonably well, but has problems
 doesn't always get trades
 squeezing mas makes movement quite difficult sometimes

 //muda.mq4

 //DESCRIP
 /*
 muda uses ma2 on hilo to move up,down in between
 */

 //TODO
 /*
 figure out how to handle breakouts
 track last 12 trades to evaluate success and determine alteration
 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>


 //
 //CONSTANTS
 //
 #define sp "  "
 #define lt 0.1
 #define sltp 600.0*Point

 //
 //EXTERNS
 //
 //extern int tfx;

 //
 //GLOBALS
 //
 int tfs[6],tfx=4;


 //
 //STRUCTURES
 //
 struct status
 {
   //pr
   double pr;                                    //pr set to avg of bid,ask
  
   //atr
   bool atrOK;                                   //atr value over xbars is sufficiently high

   //ntr zone
   bool bntrOK,sntrOK;                           //buysel ntr

   //xit zone
   double bxit,sxit;                             //buysel xit

   //order parameters
   int tkt;                                      //tkt number
   int bs;                                       //buysel value
   bool inbuy,insel;                             //in trade already?
 };

 status s;

 //
 //FUNCTIONS
 //
 void main()
 {
   status();
   ntrxit();
 }


 void status()
 //determines all relevant marketconditions
 {
   //set pr
   s.pr=(Bid+Ask)/2;
  
   //set tf
   int
     tf=tfs[tfx];

   //fill mas for 4 bars
   double
     himas[4],lomas[4];
   ArrayInitialize(himas,0);ArrayInitialize(lomas,0);

   for(int i=0;i<4;i++)
     {
       himas[i]=NormalizeDouble(iMA(NULL,tf,2,0,MODE_LWMA,PRICE_HIGH,i),Digits);
       lomas[i]=NormalizeDouble(iMA(NULL,tf,2,0,MODE_LWMA,PRICE_LOW,i),Digits);
     }

   //STATUS atrOK
   int
     atrmin=40,
     atr=(int)floor(iATR(NULL,tf,4,0)/Point);    //atr value over 4 bars
   s.atrOK=atr>atrmin;

   //STATUS bntr,sntr
   double
     atrfr=atr*.12*Point;                        //set atr fraction amount

   double                                        //hilo targets determined by relation btn bar1 and bar0
     hima=himas[1],loma=lomas[1];                          
   if(himas[1]>himas[0])                       //bar0 lower than bar1 so use bar0
       hima=himas[0];
   else
       hima=himas[1];
   if(lomas[1]<lomas[0])                         //bar0 higher than bar1 so use bar0
       loma=lomas[0];
   else
       loma=lomas[1];

   double                                        //set the hilo zone marks
     hizo=NormalizeDouble(hima-atrfr,Digits),
     lozo=NormalizeDouble(loma+atrfr,Digits);

   if(btn(hima,s.pr,hizo))                       //set bntrOK
     {
       s.sntrOK=true;
       s.sxit=s.pr+atrmin*Point;
     }
   else
     s.sntrOK=false;
   if(btn(loma,s.pr,lozo))                       //set sntrOK
     {
       s.bntrOK=true;
       s.bxit=s.pr-atrmin*Point;
     }
   else
     s.bntrOK=false;
 }

 void ntrxit()
 //ntrxit trades based on situation
 {
   bool buy,sel;                                 //buysel likelihood computed from various indicators

   buy=s.bntrOK;
   sel=s.sntrOK;

   if(s.tkt==-1 && s.atrOK)                      //tkt value nonexistent and atr gives sufficient room
     {
       if(buy) s.tkt=ntr(0);
       if(sel) s.tkt=ntr(1);
       //if(s.tkt==-1) showlasterror();
     }
   else                                          //otherwise use tkt value to get order details
     {
       if(OrderSelect(s.tkt,SELECT_BY_TICKET))
         {
           s.bs=OrderType();
           s.inbuy=(s.bs==0);
           s.insel=(s.bs==1);
           if((s.inbuy && sel) ||                //inbuy with sel or
              (s.insel && buy))                  //insel with buy
               if(OrderClose(s.tkt,lt,OrderClosePrice(),0))
                 s.tkt=-1;                       //close order and reset tkt value to nonexistent
         }
     }
 }


 int ntr(int bs)
 //places ntr order
 {
   double op=0,sl=0,tp=0;

   switch(bs)
     {
     case 0: op=Ask;sl=s.bxit;tp=Ask+sltp;break;
     case 1: op=Bid;sl=s.sxit;tp=Bid-sltp;break;
     }
   return OrderSend(Symbol(),bs,lt,op,0,sl,tp);
 }

 void maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);
 }

 double Dprs(double pI,double pF)
 //difference between two prices
 {
   return (pF-pI);
 }

 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }

 bool btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }

 double avgslope(double &arr[])
 //calculates average slope using theil-sen concept when arr index matches bar number
 {
   double acc;
   int
     arrsize=ArraySize(arr),
     numbars=arrsize-1,
     iters=numbars*(numbars-1)/2;

   acc=0;
   for(int i=numbars;i>1;i--)
     for(int j=i-1;j>0;j--)
       acc+=incline(i,arr[i],j,arr[j]);
   return acc/iters;
 }

 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
 {
   int
     Dbar=bI-bF;
   return Dpts(vI,vF)/Dbar;
 }

 bool CanDoTrade()
 //checks if trading is ok via total orders, spread
 {
   int
     aords,pords;
   bool
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12),
     noordsOK=(OrdersForSymbol(aords,pords)==0);
   return (noordsOK && spreadOK);
 }

 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
 {
   aords=0;pords=0;
   for(int p=OrdersTotal()-1;p>=0;p--)
     if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
       {
         if(OrderType()>1 && OrderType()<6)
           pords++;
         if(OrderType()==OP_BUY || OrderType()==OP_SELL)
           aords++;
       }
   return aords+pords;
 }

 void showlasterror()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }

 void hline(string objlabel,double price)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
 }
  
 void displaytxt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 //
 //SPECIAL FUNCTIONS
 //
 int OnInit()
 {
   s.tkt=-1;
   s.bs=-1;
   tfs[0]=1;tfs[1]=5;tfs[2]=15;tfs[3]=30;tfs[4]=60;tfs[5]=240;
   return(INIT_SUCCEEDED);
 }

 void OnDeinit(const int reason)
 {
  
 }

 void OnTick()
 {
   main();
 }



 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

*** ppa
 concept seems to be similar to high frequency trading especially if we can postulate a direction
 pure price action support resistance
 go in same/opposite direction after x points and switch with price action
 this idea led to huge profits when the spread was 2 pt and successful to 8pt
 unfortunately we can't find that program any more, but have re-created it
 take key sr into account
 try to incorporate cot concept so we get points in either way

 xplorer ranger setups so as to determine best approach
 - ranger doesn't seem to work better as v3 results indicate except in specific situations
 - need mechanism to identify these

 figure out atr relation to all this
 - seem to be fairly useless
 - what we really need is some way to detect flatness and hilo
 - again this suggests re-examining xoner

 2 parameters: mode,Estep
 - if there is sufficient movement xpl mode works really well
 - if there is sufficient movement, but flatness rng mode (or variation) can work
 - if there is insufficient movement nothing works understandably

 these 3 can be used in combo:

 dhl shows Dhilo for 12 bars
 - the value can be used to determine if trade is feasible or not in some situations
 - in !xpl it hilo can indicate turn around points

 dcl close deltas may give both present and future indications
 - look at close deltas from 6-2,1
 - the relation of these slopes may tell many things
 - identify useable patterns for specific situations

 ppastep by Dhl somehow though this doesn't take into account the internal variations 
 - ppastep should relate in some fashion to the Dhilo since we need room to move
 - if pr is near a hilo then xpl=false at least on a first try (variation of the xoner idea)


 idea: adjust Estep and mode depending on whether trades are successful or not
 - if loss it means prices didn't go in correct direction far enough
   - make Estep larger so that things aren't hit as easily
   - make Estep smaller so that it works within the established movement
   - the intent is that the price movement will continually optimize Estep

 focus on small periods of time rather than large ones for analysis because the latter only gives some sort of average anyway. try to work Estep and modes together because when optimization doesn't work in one mode, it can do quite well in the other. there may be a way to get the program to automatically adjust itself based on past performance, or possibly there are indicator combos that may be of use here.

 forget longterm analysis (can't seem to get the data to work consistently anyway). work with shortterm since these may likely be closer to reality than averages of huge number of points.

 build into status other indicators like atr, ma, hilo, un etc into the picture use various tf too for these.
 hilo should be static till broken rather than moving with lookback size.
 however, with un we should probably turn to fractals to bypass the conceptual problem.
 let's rethink this entire matter in terms of multiple indicators and test each of them.

 un should take its hilo based on some min distance not just the bar count. if min is not large enough, un should make hilo values the past ones. also contemplate the asymmetric un or aun.

 use text file to pick up manual changes in mode which may be useful in some situations - or perhaps the mode can change depending on situation automatically.


**** code v1 interesting for use of tkt array
 produced modest gains throughout 1608 and very good in last week

 //ppa.mq4

 //DESCRIP
 /*
 ppa uses pure price action for ntrxit
 */

 //TODO
 /*
 get good data set
 optimize
 simplify code since we are not using opencloseby
 figure out why 5 losses in a row on step=120
 xplorer ranger setups so as to determine best approach

 incorporate other indicators
 determine ongoing point gain/loss
 flatliner computation on hilo to establish ranging behavior over xbars
   - use thielsen slope
   - consider regression channel
 */


 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>


 //
 //CONSTANTS
 //
 #define sp "  "
 #define lt 0.1
 #define sltp 600.0*Point

 //
 //EXTERNS
 //
 int Estep;                                      //step size

 //
 //GLOBALS
 //


 //
 //STRUCTURES
 //
 struct Smarketconditions
 //market condition by indicator
 {
   //ppa
   double pr;                                    //pr as average of Bid and Ask
   double ubound,lbound;                         //upper,lower bounds from Bid
   double anchor;                                //floating anchor
   double delta;                                 //difference between Bid and anchor

   //order parameters
   bool canbuy,cansel;
   bool buyit,selit;
   int bs;
   double op,sl,tp;
   int tkt[2];                                   //tkt[0],tkt[1] holds buysel tkt numbers
 };

 Smarketconditions m;

 //
 //FUNCTIONS
 //
 void main()
 {
   params(01);
   marketconditions();
   orderhandler();

 }

 void marketconditions()
 //determines the marketconditions
 {
   //ppa
   double step=Estep*Point;
   static bool set;
   if(m.ubound==0 && m.lbound==0) set=false;

   m.pr=0.5*(Bid+Ask);                           //price as average of Bid and Ask
  
   if(!set)
     {
       m.ubound=m.pr+step;m.lbound=m.pr-step;    //upper and lower bounds from Bid
       m.anchor=m.pr;                            //set floating anchor
       set=true;
     }
  
   m.delta=Dpts(m.anchor,m.pr);                  //difference between Bid and anchor

   if(!btn(m.ubound,m.pr,m.lbound))              
     set=false;
 }

 void orderhandler()
 //places an order
 {
   if(m.delta>+Estep)                            //form buy details
     {m.bs=0;m.op=Ask;m.sl=Ask-sltp;m.tp=Ask+sltp;}
   if(m.delta<-Estep)                            //form sel details
     {m.bs=1;m.op=Bid;m.sl=Bid+sltp;m.tp=Bid-sltp;}

   if(m.bs>-1)                                   //place order if bs tkt is vacant
     if(m.tkt[m.bs]==-1)
         m.tkt[m.bs]=OrderSend(Symbol(),m.bs,lt,m.op,0,m.sl,m.tp);

   switch(m.bs)
     {
     case 0:
       if(m.tkt[1]>-1 && OrderClose(m.tkt[1],lt,Ask,0))
         m.tkt[1]=-1;
       break;
     case 1:
       if(m.tkt[0]>-1 && OrderClose(m.tkt[0],lt,Bid,0))
         m.tkt[0]=-1;
       break;
     }
 }

 void params(int n)
 //gets the parameters
 {
   switch(n)
     {
     case 01: Estep=120;break;
     }
 }

 void maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);
 }

 double Dprs(double pI,double pF)
 //difference between two prices
 {
   return (pF-pI);
 }

 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }

 double avgslope(int bI,int bF,double &ma[])
 //calculates avgslope using theil-sen concept
   {
    int
    iters=bI*(bI-1)/2;
    double
    acc=0;
    for(int i=bF;i<bI;i++)
       for(int j=i+1;j<=bI;j++)
          acc+=incline(j,ma[j],i,ma[i]);
    return acc/iters;
   }

 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
 {
   int
     Dbar=bI-bF;
   return Dpts(vI,vF)/Dbar;
 }

 bool btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }

 bool CanDoTrade()
 //checks if trading is ok via total orders, spread
 {
   int
     aords,pords;
   bool
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12),
     noordsOK=(OrdersForSymbol(aords,pords)==0);
   return (noordsOK && spreadOK);
 }

 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
 {
   aords=0;pords=0;
   for(int p=OrdersTotal()-1;p>=0;p--)
     if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
       {
         if(OrderType()>1 && OrderType()<6)
           pords++;
         if(OrderType()==OP_BUY || OrderType()==OP_SELL)
           aords++;
       }
   return aords+pords;
 }

 void showlasterror()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }

 void display(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 //
 //SPECIAL FUNCTIONS
 //
 int OnInit()
 {
   m.bs=-1;
   m.anchor=Bid;
   ArrayInitialize(m.tkt,-1);
   return(INIT_SUCCEEDED);
 }

 void OnDeinit(const int reason)
 {
  
 }

 void OnTick()
 {
   main();
 }



 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

**** code v2 generally good results
 depending on size of Estep we can reproduce past results of thousands, but by trading tens of thousands

 | 31 | 169.50 |  31 | 2.74 | 5.47 |  52.90 | 0.52% | 0.00000000 | Estep=92  |
 | 29 | 164.00 |  36 | 2.04 | 4.56 |  43.00 | 0.43% | 0.00000000 | Estep=88  |
 | 41 | 155.60 |  23 | 2.64 | 6.77 |  48.80 | 0.48% | 0.00000000 | Estep=112 |
 | 30 | 154.20 |  34 | 2.02 | 4.54 |  57.00 | 0.57% | 0.00000000 | Estep=90  |
 | 37 | 135.20 |  30 | 2.24 | 4.51 |  45.40 | 0.45% | 0.00000000 | Estep=104 |
 | 32 | 130.10 |  33 | 2.02 | 3.94 |  45.50 | 0.45% | 0.00000000 | Estep=94  |
 | 43 | 128.20 |  23 | 2.18 | 5.57 |  76.30 | 0.76% | 0.00000000 | Estep=116 |
 | 40 | 127.40 |  22 | 2.23 | 5.79 |  47.20 | 0.47% | 0.00000000 | Estep=110 |
 | 38 | 125.50 |  29 | 2.02 | 4.33 |  58.90 | 0.59% | 0.00000000 | Estep=106 |
 |  3 | 125.40 | 236 | 1.28 | 0.53 | 131.30 | 1.31% | 0.00000000 | Estep=34  |
 | 35 | 117.70 |  32 | 2.00 | 3.68 |  56.10 | 0.56% | 0.00000000 | Estep=100 |
 | 12 | 114.00 | 111 | 1.42 | 1.03 |  81.00 | 0.81% | 0.00000000 | Estep=52  |


 //ppa.mq4

 //DESCRIP
 /*
 ppa uses pure price action for ntrxit
 */

 //TODO
 /*
 get good data set
 optimize
 simplify code since we are not using opencloseby
 figure out why 5 losses in a row on step=120
 can we use trailer to lock in profits or is the built-in trailer fine?

 xplorer ranger setups so as to determine best approach
 figure out atr relation to all this
 incorporate other indicators
 determine ongoing point gain/loss
 flatliner computation on hilo to establish ranging behavior over xbars
   - use thielsen slope
   - consider regression channel
 */


 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>


 //
 //CONSTANTS
 //
 #define sp "  "
 #define lt 0.1
 #define sltp 600.0*Point

 //
 //EXTERNS
 //
 extern int Estep;

 //
 //GLOBALS
 //


 //
 //STRUCTURES
 //
 struct Sstatus
 //market condition status by indicator
 {
   //modes
   bool xpl,ran;                                 //explorer,ranger modes
  
   //ppa
   bool ualset;                                  //upper,anchor,lower is set?
   bool buy,sel;                                 //buysel ok?
   bool inbuy,insel;                             //in trade already?

   //order parameters
   int tkt;                                      //tkt number
   int bs;                                       //buysel value
 };

 Sstatus mcs;

 //
 //FUNCTIONS
 //
 void main()
 {
   //params(01);
   status(mcs);                                  //get status info
   orderhandler(mcs);                            //deal with order

 }


 void status(Sstatus &s)
 //determines all relevant marketconditions
 {
   //ppa
   static double
     anch,ubnd,lbnd;                             //anchor,upper and lower bounds stay static
   double
     pr=0.5*(Bid+Ask);                           //set price

   if(!s.ualset)                                 //set anchor,ubound,lbound and make ualset true
     {
       anch=pr;
       ubnd=anch+Estep*Point;                           
       lbnd=anch-Estep*Point;                           
       s.ualset=true;
     }

   s.buy=(pr>ubnd);                              //buy condition
   s.sel=(pr<lbnd);                              //sel condition
   if(s.buy || s.sel)                            //if going to buysel then reset ualset to original false
     s.ualset=false;

 }

 void orderhandler(Sstatus &s)
 //handles trade orders
 {
   if(s.tkt==-1)                                 //tkt value nonexistent so possible to place order
     {
       if(s.buy)
         s.tkt=OrderSend(Symbol(),0,lt,Ask,0,Ask-sltp,Ask+sltp);
       if(s.sel)
         s.tkt=OrderSend(Symbol(),1,lt,Bid,0,Bid+sltp,Bid-sltp);
     }
   else                                          //otherwise use tkt value to get order details
     {
       if(OrderSelect(s.tkt,SELECT_BY_TICKET))
         {
           s.bs=OrderType();
           s.inbuy=(s.bs==0);
           s.insel=(s.bs==1);
           if((s.inbuy && s.sel) ||              //inbuy with sel or
              (s.insel && s.buy))                //insel with buy
             {                                   //close order
               if(OrderClose(s.tkt,lt,OrderClosePrice(),0))
                 s.tkt=-1;                       //reset tkt value to nonexistent
             }
         }
     }
 }

 void params(int n)
 //gets the parameters
 {
   switch(n)
     {
     case 01: Estep=60;break;
     }
 }

 void maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);
 }

 double Dprs(double pI,double pF)
 //difference between two prices
 {
   return (pF-pI);
 }

 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }

 double avgslope(int bI,int bF,double &ma[])
 //calculates avgslope using theil-sen concept
   {
    int
    iters=bI*(bI-1)/2;
    double
    acc=0;
    for(int i=bF;i<bI;i++)
       for(int j=i+1;j<=bI;j++)
          acc+=incline(j,ma[j],i,ma[i]);
    return acc/iters;
   }

 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
 {
   int
     Dbar=bI-bF;
   return Dpts(vI,vF)/Dbar;
 }

 bool btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }

 bool CanDoTrade()
 //checks if trading is ok via total orders, spread
 {
   int
     aords,pords;
   bool
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12),
     noordsOK=(OrdersForSymbol(aords,pords)==0);
   return (noordsOK && spreadOK);
 }

 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
 {
   aords=0;pords=0;
   for(int p=OrdersTotal()-1;p>=0;p--)
     if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
       {
         if(OrderType()>1 && OrderType()<6)
           pords++;
         if(OrderType()==OP_BUY || OrderType()==OP_SELL)
           aords++;
       }
   return aords+pords;
 }

 void showlasterror()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }

 void hline(string objlabel,double price)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
 }
  
 void displayitem(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 //
 //SPECIAL FUNCTIONS
 //
 int OnInit()
 {
   mcs.ualset=false;
   mcs.bs=-1;
   mcs.tkt=-1;
   return(INIT_SUCCEEDED);
 }

 void OnDeinit(const int reason)
 {
  
 }

 void OnTick()
 {
   main();
 }



 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

**** code v3 incorporation of modes
 xplrng mode may not affect results as much as actual price movement since the system still depends on going 2Estep before there is breakeven. hence, the movement of the price must be used to determine what Estep is to be.

 | mode | 0806 | 0813 | 0820 |
 | xpl  | loss | loss | gain |
 | rng  | gain | loss | even | 

 //ppa.mq4

 //DESCRIP
 /*
 ppa uses pure price action for ntrxit
 */

 //TODO
 /*
 xplorer ranger setups so as to determine best approach
 figure out atr relation to all this
 2 parameters: mode,Estep

 incorporate other indicators
 determine ongoing point gain/loss
 flatliner computation on hilo to establish ranging behavior over xbars
   - use thielsen slope
   - consider regression channel
 */


 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>


 //
 //CONSTANTS
 //
 #define sp "  "
 #define lt 0.1
 #define sltp 600.0*Point

 //
 //EXTERNS
 //
 extern int Estep;

 //
 //GLOBALS
 //


 //
 //STRUCTURES
 //
 struct Sstatus
 //market condition status by indicator
 {
   //modes
   bool xpl;                                     //explorer mode or not
  
   //ppa
   bool ualset;                                  //upper,anchor,lower is set?
   bool buy,sel;                                 //buysel ok?
   bool inbuy,insel;                             //in trade already?

   //order parameters
   int tkt;                                      //tkt number
   int bs;                                       //buysel value
 };

 Sstatus mcs;

 //
 //FUNCTIONS
 //
 void main()
 {
   //params(01);
   status(mcs);                                  //get status info
   orderhandler(mcs);                            //deal with order

 }


 void status(Sstatus &s)
 //determines all relevant marketconditions
 {
   //mode
   s.xpl=true;
  
   //ppa
   static double
     anch,ubnd,lbnd;                             //anchor,upper and lower bounds stay static
   double
     pr=0.5*(Bid+Ask);                           //set price

   if(!s.ualset)                                 //set anchor,ubound,lbound and make ualset true
     {
       anch=pr;
       ubnd=anch+Estep*Point;                           
       lbnd=anch-Estep*Point;                           
       s.ualset=true;
     }

   s.buy=(pr>ubnd);                              //buy condition
   s.sel=(pr<lbnd);                              //sel condition
   if(s.buy || s.sel)                            //if going to buysel then reset ualset to original false
     s.ualset=false;

 }

 void orderhandler(Sstatus &s)
 //handles trade orders
 {
   if(s.tkt==-1)                                 //tkt value nonexistent so possible to place order
     {
       if(s.xpl)
         {
           if(s.buy) s.tkt=ntr(0);
           if(s.sel) s.tkt=ntr(1);
         }
       else
         {
           if(s.buy) s.tkt=ntr(1);
           if(s.sel) s.tkt=ntr(0);
         }
     }
   else                                          //otherwise use tkt value to get order details
     {
       if(OrderSelect(s.tkt,SELECT_BY_TICKET))
         {
           s.bs=OrderType();
           s.inbuy=(s.bs==0);
           s.insel=(s.bs==1);
           if((s.inbuy && s.sel) ||              //inbuy with sel or
              (s.insel && s.buy))                //insel with buy
             {                                   //close order
               if(OrderClose(s.tkt,lt,OrderClosePrice(),0))
                 s.tkt=-1;                       //reset tkt value to nonexistent
             }
         }
     }
 }

 int ntr(int bs)
 //places ntr order
 {
   double op=0,sl=0,tp=0;
  
   switch(bs)
     {
     case 0: op=Ask;sl=Ask-sltp;tp=Ask+sltp;break;
     case 1: op=Bid;sl=Bid+sltp;tp=Bid-sltp;break;
     }
   return OrderSend(Symbol(),bs,lt,op,0,sl,tp);
 }

 void params(int n)
 //gets the parameters
 {
   switch(n)
     {
     case 01: Estep=60;break;
     }
 }

 void maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);
 }

 double Dprs(double pI,double pF)
 //difference between two prices
 {
   return (pF-pI);
 }

 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }

 double avgslope(int bI,int bF,double &ma[])
 //calculates avgslope using theil-sen concept
   {
    int
    iters=bI*(bI-1)/2;
    double
    acc=0;
    for(int i=bF;i<bI;i++)
       for(int j=i+1;j<=bI;j++)
          acc+=incline(j,ma[j],i,ma[i]);
    return acc/iters;
   }

 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
 {
   int
     Dbar=bI-bF;
   return Dpts(vI,vF)/Dbar;
 }

 bool btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }

 bool CanDoTrade()
 //checks if trading is ok via total orders, spread
 {
   int
     aords,pords;
   bool
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12),
     noordsOK=(OrdersForSymbol(aords,pords)==0);
   return (noordsOK && spreadOK);
 }

 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
 {
   aords=0;pords=0;
   for(int p=OrdersTotal()-1;p>=0;p--)
     if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
       {
         if(OrderType()>1 && OrderType()<6)
           pords++;
         if(OrderType()==OP_BUY || OrderType()==OP_SELL)
           aords++;
       }
   return aords+pords;
 }

 void showlasterror()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }

 void hline(string objlabel,double price)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
 }
  
 void displayitem(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 //
 //SPECIAL FUNCTIONS
 //
 int OnInit()
 {
   mcs.ualset=false;
   mcs.bs=-1;
   mcs.tkt=-1;
   return(INIT_SUCCEEDED);
 }

 void OnDeinit(const int reason)
 {
  
 }

 void OnTick()
 {
   main();
 }



 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

**** code v4 use of hls indicator
 hls hilo status tries to provide confirmation of buysel trend along with ppa
 it works, but somewhat so-so, probably because the real issue is what should the ppastep be wrt some price movement.
 should ppastep be small to get into profit quickly (though you can get into too many trades), or should it be large so that you don't go in unless there is a large move of some significance?
 what can be devised that will provide a meaningful answer to this question?

 one particularly good development from this effort was to rewrite the avgslope routine as well as understand how to use the copyhigh and copylow subroutines.

 //ppa.mq4

 //DESCRIP
 /*
 ppa uses pure price action for ntrxit
 */

 //TODO
 /*
 get un indicator working based on hilo

 figure out atr relation to all this
 2 parameters: mode,ppastep

 incorporate other indicators
 determine ongoing point gain/loss
 flatliner computation on hilo to establish ranging behavior over xbars
   - use thielsen slope
   - consider regression channel
 */


 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>


 //
 //CONSTANTS
 //
 #define sp "  "
 #define lt 0.1
 #define sltp 600.0*Point

 //
 //EXTERNS
 //
 extern int ppastep;

 //
 //GLOBALS
 //
 int tfs[6];

 //
 //STRUCTURES
 //
 struct Sstatus
 //market condition status by indicator
 {
   //lasttrade
   bool tradeprofitable;                         //was last trade profitable?
  
   //modes
   bool xpl;                                     //explorer mode or not
  
   //ppa                                         //pure price action
   bool ualset;                                  //upper,anchor,lower is set?
   bool ppabuy,ppasel;                           //ppabuysel ok?

   //hls                                         //hilo slope analysis
   bool hlsbuy,hlssel;                           //hilo buysel
  
   //aun                                         //asymetric un
   int hibar,lobar;                              //hilo bars
   double hival,loval;                           //hilo values
   bool aunbuy,aunsel;                           //aunbuysel ok?
  
   //order parameters
   int tkt;                                      //tkt number
   int bs;                                       //buysel value
   bool inbuy,insel;                             //in trade already?

 };

 Sstatus mcs;

 //
 //FUNCTIONS
 //
 void main()
 {
   //params(01);
   status(mcs);                                  //get status info
   orderhandler(mcs);                            //deal with order

 }


 void status(Sstatus &s)
 //determines all relevant marketconditions
 {
   //mode
   s.xpl=true;
  
   //ppa
   ppastatus(s);

   //hls
   hlsstatus(s);
  
   //aun
   //aunstatus(s);

   /*
   //display data
   string ppaS="NIL";
   color ppaC=Gray;
   if(s.ppabuy){ppaS="BUY";ppaC=Blue;}
   if(s.ppasel){ppaS="SEL";ppaC=Red;}
   displaytxt("ppa","ppa="+ppaS,1,100,10,ppaC);

   string hlsS="NIL";
   color hlsC=Gray;
   if(s.hlsbuy && !s.hlssel){hlsS="BUY";hlsC=Blue;}
   if(s.hlssel && !s.hlsbuy){hlsS="SEL";hlsC=Red;}
   displaytxt("hls","hls="+hlsS,1,100,20,hlsC);  
   */
 }

 void ppastatus(Sstatus &s)
 //ppa status
 {
   static double
     anch,ubnd,lbnd;                             //anchor,upper and lower bounds stay static
   double
     pr=0.5*(Bid+Ask);                           //set price
  
   if(!s.ualset)                                 //set anchor,ubound,lbound and make ualset true
     {
       anch=pr;
       ubnd=anch+ppastep*Point;                           
       lbnd=anch-ppastep*Point;                           
       s.ualset=true;
     }

   s.ppabuy=(pr>ubnd);                           //buy if price above upper bound
   s.ppasel=(pr<lbnd);                           //sel if price below lower bound
   if(s.ppabuy || s.ppasel)                      //if going to buysel then reset ualset to original false
     s.ualset=false;
 }

 void hlsstatus(Sstatus &s)
 //hls status using thielsen slope analysis on 60m
 {
   int
     xrpoint=12;
   double
     hi[4],lo[4],hi3,lo3;

   CopyHigh(Symbol(),PERIOD_H1,0,4,hi);          //hi3 slope calculation
   ArraySetAsSeries(hi,true);
   hi3=avgslope(hi);
  
   CopyLow(Symbol(),PERIOD_H1,0,4,lo);           //lo3 slope calculation
   ArraySetAsSeries(lo,true);
   lo3=avgslope(lo);

   s.hlsbuy=(lo3>+xrpoint) && !(hi3<-xrpoint);   //buy if lo slopes up and hi doesn't slope down
   s.hlssel=(hi3<-xrpoint) && !(lo3>+xrpoint);   //buy if hi slopes down and lo doesn't slope up
 }

 void aunstatus(Sstatus &s)
 //aun status
 {
   int
     maxbar[6],minbar[6];
   double
     maxval[6],minval[6];

   for(int i=0;i<6;i++)
     {
       maxmin(tfs[i],12,0,maxbar[i],maxval[i],minbar[i],minval[i]);
     }
 }

 void orderhandler(Sstatus &s)
 //handles trade orders
 {
   bool buy,sel;                                 //buysel likelihood computed from various indicators

   buy=s.ppabuy;                                 
   sel=s.ppasel;
   //buy=s.ppabuy && s.hlsbuy;                                 
   //sel=s.ppasel && s.hlssel;
  
   if(s.tkt==-1)                                 //tkt value nonexistent so possible to place order
     {
       if(s.xpl)
         {
           if(buy) s.tkt=ntr(0);
           if(sel) s.tkt=ntr(1);
         }
       else
         {
           if(buy) s.tkt=ntr(1);
           if(sel) s.tkt=ntr(0);
         }
     }
   else                                          //otherwise use tkt value to get order details
     {
       if(OrderSelect(s.tkt,SELECT_BY_TICKET))
         {
           s.bs=OrderType();
           s.inbuy=(s.bs==0);
           s.insel=(s.bs==1);
           if((s.inbuy && sel) ||                //inbuy with sel or
              (s.insel && buy))                  //insel with buy
             {                                   //close order
               if(OrderClose(s.tkt,lt,OrderClosePrice(),0))
                 {
                   if(OrderProfit()>0)
                     s.tradeprofitable=true;
                   else
                     s.tradeprofitable=false;
                   s.tkt=-1;                     //reset tkt value to nonexistent
                 }
             }
         }
     }
 }

 int ntr(int bs)
 //places ntr order
 {
   double op=0,sl=0,tp=0;
  
   switch(bs)
     {
     case 0: op=Ask;sl=Ask-sltp;tp=Ask+sltp;break;
     case 1: op=Bid;sl=Bid+sltp;tp=Bid-sltp;break;
     }
   return OrderSend(Symbol(),bs,lt,op,0,sl,tp);
 }

 void params(int n)
 //gets the parameters
 {
   switch(n)
     {
     case 01: ppastep=60;break;
     }
 }

 void maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);
 }

 double Dprs(double pI,double pF)
 //difference between two prices
 {
   return (pF-pI);
 }

 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }

 bool btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }

 double avgslope(double &arr[])
 //calculates average slope using theil-sen concept when arr index matches bar number
 {
   double acc;
   int
     arrsize=ArraySize(arr),
     numbars=arrsize-1,
     iters=numbars*(numbars-1)/2;

   acc=0;
   for(int i=numbars;i>1;i--)
     for(int j=i-1;j>0;j--)
       acc+=incline(i,arr[i],j,arr[j]);
   return acc/iters;
 }

 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
 {
   int
     Dbar=bI-bF;
   return Dpts(vI,vF)/Dbar;
 }

 bool CanDoTrade()
 //checks if trading is ok via total orders, spread
 {
   int
     aords,pords;
   bool
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12),
     noordsOK=(OrdersForSymbol(aords,pords)==0);
   return (noordsOK && spreadOK);
 }

 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
 {
   aords=0;pords=0;
   for(int p=OrdersTotal()-1;p>=0;p--)
     if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
       {
         if(OrderType()>1 && OrderType()<6)
           pords++;
         if(OrderType()==OP_BUY || OrderType()==OP_SELL)
           aords++;
       }
   return aords+pords;
 }

 void showlasterror()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }

 void hline(string objlabel,double price)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
 }
  
 void displaytxt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 //
 //SPECIAL FUNCTIONS
 //
 int OnInit()
 {
   mcs.ualset=false;
   mcs.bs=-1;
   mcs.tkt=-1;
   return(INIT_SUCCEEDED);
 }

 void OnDeinit(const int reason)
 {
  
 }

 void OnTick()
 {
   main();
 }



 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

**** code v5 incorporates PA,HLI,HLD
 good on visual analysis so far

 //ppa.mq4

 //DESCRIP
 /*
 ppa uses pure price action for ntrxit
 */

 //TODO
 /*
 1. mode determination using dcl
 2. !xpl using hilo zones


 these 3 can be used in combo:

 dhl shows Dhilo for 12 bars
 - the value can be used to determine if trade is feasible or not in some situations
 - in !xpl it hilo can indicate turn around points

 dsl close deltas may give both present and future indications
 - look at close deltas from 6-2,1 computing their av
 - the relation of these slopes may tell many things
 - identify useable patterns for specific situations
 - a small av value suggests horizontal movement which can be used in !xpl if dhl large enough

 ppastep by Dhl somehow though this doesn't take into account the internal variations 
 - ppastep should relate in some fashion to the Dhilo since we need room to move
 - if pr is near a hilo then !xpl at least on a first try (variation of the xoner idea)

 ====

 get un indicator working based on hilo

 incorporate other indicators
 determine ongoing point gain/loss
 flatliner computation on hilo to establish ranging behavior over xbars
   - use thielsen slope
   - consider regression channel
 mode by delta2<mindelta use linear weighted maX
 - reason is this should work in any tf, where computing the actual incl may be awkward
 - simply looking at the difference btn last 2 ma values, should suggest slope mostly
 - forget this one for now

 */


 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>


 //
 //CONSTANTS
 //
 #define sp "  "
 #define lt 0.1
 #define sltp 600.0*Point


 //
 //EXTERNS
 //
 extern int PAstep;

 //
 //GLOBALS
 //
 int tfs[6],tfx=2;

 //
 //STRUCTURES
 //
 struct Sstatus
 //market condition status by indicator
 {
   //lasttrade
   bool tradeprofitable;                         //was last trade profitable?
  
   //modes
   bool xpl;                                     //explorer mode or not
  
   //PA                                          //price action
   bool ualset;                                  //upper,anchor,lower is set?
   int PAval;                                    //PAbuysel ok?

   //HLI                                         //hilo incline analysis
   int HLIval;                                   //HLI gives value +2,+1,0,-1,-2 for buysel strength 

   //HLD                                         //hilo delta for maxmin over 12 bars
   double HLDval;                                //HLD value between hilo to show movement distance
  
   //order parameters
   int tkt;                                      //tkt number
   int bs;                                       //buysel value
   bool inbuy,insel;                             //in trade already?

 };

 Sstatus mcs;

 //
 //FUNCTIONS
 //
 void main()
 {
   //params(01);
   status(mcs);                                  //get status info
   //orderhandler(mcs);                            //deal with order

 }


 void status(Sstatus &s)
 //determines all relevant marketconditions
 {
   //mode
   s.xpl=true;
  
   //PA                                          //price action
   //PAstatus(s);

   //HLI                                         //hilo inclines
   HLIstatus(s);
  
   //HLD                                         //hilo delta
   //HLDstatus(s);
  
   //aun
   //aunstatus(s);
 }

 void PAstatus(Sstatus &s)
 //PA status
 {
   static double
     anch,ubnd,lbnd;                             //anchor,upper and lower bounds stay static
   double
     pr=0.5*(Bid+Ask);                           //set price
  
   if(!s.ualset)                                 //set anchor,ubound,lbound and make ualset true
     {
       anch=pr;
       ubnd=anch+PAstep*Point;                           
       lbnd=anch-PAstep*Point;                           
       s.ualset=true;
     }

   s.PAval=0;
   if(pr>ubnd)
     s.PAval=+1;
   if(pr<lbnd)
     s.PAval=-1;
   if(s.PAval!=0)      //if going to buysel then reset ualset to original false
     s.ualset=false;
 }


 void HLDstatus(Sstatus &s)
 //determines the hilo values over 12 bars in chosen tf
 {
   int
     maxbar,minbar,
     tf=tfs[tfx];
   double
     maxval,minval;
  
   maxmin(tf,12,1,maxbar,maxval,minbar,minval);
   s.HLDval=Dpts(minval,maxval);
 }


 void HLIstatus(Sstatus &s)
 //determines hilo deltas btn bar 1 and bars 2,3,4,6
 {
   int
     h[7],l[7],hav,lav,k,
     tf=tfs[tfx],
     d0=4;
  
   ArrayInitialize(h,0);ArrayInitialize(l,0);
   hav=0;lav=0;k=0;
   for(int i=2;i<7;i++)
     {
       h[i]=(int)incline(i,iHigh(NULL,tf,i),1,iHigh(NULL,tf,1));
       l[i]=(int)incline(i,iLow(NULL,tf,i),1,iLow(NULL,tf,1));
       hav+=h[i];lav+=l[i];
     }
   hav/=5;lav/=5;
  
   if(btn(-d0,hav,+d0) && btn(-d0,lav,+d0))      //neutral
     {
       s.HLIval=0;                               //incline val says no trade preference
       s.xpl=false;                              //xpl mode deactivated
     }
   else
     {
       //criteria
       bool
         huavg=h[6]<hav,                         //hi u buy
         luavg=l[6]<lav,                         //lo u buy
         hnavg=h[6]>hav,                         //hi n sel
         lnavg=l[6]>lav;                         //lo u sel
 
       if(luavg)                                 //buy strength
         {
           s.HLIval=+1;
           if(huavg)
             s.HLIval=+2;
         }
       if(hnavg)                                 //sel strength
         {
           s.HLIval=-1;
           if(lnavg)
             s.HLIval=-2;
         }
       /*if((huavg && lnavg) || (hnavg && luavg))
         s.HLIval=0;*/                           //incline val says no trade preference
       s.xpl=true;                               //xpl mode active
     }
   Comment(s.xpl,sp,s.HLIval,sp,-d0,sp,hav,sp,+d0);

 }


 void orderhandler(Sstatus &s)
 //handles trade orders
 {
   bool buy,sel;                                 //buysel likelihood computed from various indicators

   buy=s.PAval==+1;                                 
   sel=s.PAval==-1;
  
   if(s.tkt==-1)                                 //tkt value nonexistent so possible to place order
     {
       if(s.xpl)
         {
           if(buy) s.tkt=ntr(0);
           if(sel) s.tkt=ntr(1);
         }
       else
         {
           if(buy) s.tkt=ntr(1);
           if(sel) s.tkt=ntr(0);
         }
     }
   else                                          //otherwise use tkt value to get order details
     {
       if(OrderSelect(s.tkt,SELECT_BY_TICKET))
         {
           s.bs=OrderType();
           s.inbuy=(s.bs==0);
           s.insel=(s.bs==1);
           if((s.inbuy && sel) ||                //inbuy with sel or
              (s.insel && buy))                  //insel with buy
             {                                   //close order
               if(OrderClose(s.tkt,lt,OrderClosePrice(),0))
                 {
                   if(OrderProfit()>0)
                     s.tradeprofitable=true;
                   else
                     s.tradeprofitable=false;
                   s.tkt=-1;                     //reset tkt value to nonexistent
                 }
             }
         }
     }
 }

 int ntr(int bs)
 //places ntr order
 {
   double op=0,sl=0,tp=0;
  
   switch(bs)
     {
     case 0: op=Ask;sl=Ask-sltp;tp=Ask+sltp;break;
     case 1: op=Bid;sl=Bid+sltp;tp=Bid-sltp;break;
     }
   return OrderSend(Symbol(),bs,lt,op,0,sl,tp);
 }

 void params(int n)
 //gets the parameters
 {
   switch(n)
     {
     case 01: PAstep=60;break;
     }
 }

 void maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);
 }

 double Dprs(double pI,double pF)
 //difference between two prices
 {
   return (pF-pI);
 }

 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }

 bool btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }

 double avgslope(double &arr[])
 //calculates average slope using theil-sen concept when arr index matches bar number
 {
   double acc;
   int
     arrsize=ArraySize(arr),
     numbars=arrsize-1,
     iters=numbars*(numbars-1)/2;

   acc=0;
   for(int i=numbars;i>1;i--)
     for(int j=i-1;j>0;j--)
       acc+=incline(i,arr[i],j,arr[j]);
   return acc/iters;
 }

 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
 {
   int
     Dbar=bI-bF;
   return Dpts(vI,vF)/Dbar;
 }

 bool CanDoTrade()
 //checks if trading is ok via total orders, spread
 {
   int
     aords,pords;
   bool
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12),
     noordsOK=(OrdersForSymbol(aords,pords)==0);
   return (noordsOK && spreadOK);
 }

 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
 {
   aords=0;pords=0;
   for(int p=OrdersTotal()-1;p>=0;p--)
     if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
       {
         if(OrderType()>1 && OrderType()<6)
           pords++;
         if(OrderType()==OP_BUY || OrderType()==OP_SELL)
           aords++;
       }
   return aords+pords;
 }

 void showlasterror()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }

 void hline(string objlabel,double price)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
 }
  
 void displaytxt(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);       
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner); 
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord); 
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord); 
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 //
 //SPECIAL FUNCTIONS
 //
 int OnInit()
 {
   mcs.ualset=false;
   mcs.bs=-1;
   mcs.tkt=-1;
   tfs[0]=1;tfs[1]=5;tfs[2]=15;tfs[3]=30;tfs[4]=60;tfs[5]=240;
   return(INIT_SUCCEEDED);
 }

 void OnDeinit(const int reason)
 {
  
 }

 void OnTick()
 {
   main();
 }



 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

**** code v6 pract using atr efforts - couldn't even optimize a profit on some days
 //pract.mq4

 //DESCRIP
 /*
 PRiceACTion uses price action with variable stepsize for ntrxit
 */

 //TODO
 /*
 incorporate ever changing stepsize based on something like atr - do this before trying trailing stop
 vary ntrxit sizes from being equal
 fractals may determine rhythm
 */


 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>


 //
 //CONSTANTS
 //
 #define sp "  "
 #define lt 0.1
 #define sltp 600.0*Point

 //
 //EXTERNS
 //
 extern int t;

 //
 //GLOBALS
 //
 double Estep;

 //
 //STRUCTURES
 //
 struct Sstatus
 //market condition status by indicator
 {
   //modes
   bool xpl,rng;                                 //explorer,rngger modes

   //atr value
   double atr;
  
   //ual setup
   bool ualset;                                  //upper,anchor,lower is set?
   bool buy,sel;                                 //buysel ok?
   bool inbuy,insel;                             //in trade already?

   //order parameters
   int tkt;                                      //tkt number
   int bs;                                       //buysel value
 };

 Sstatus s;

 //
 //FUNCTIONS
 //
 void main()
 {
   s.atr=iATR(NULL,t,12,0)/Point;
   Comment(s.atr);
   Estep=s.atr;
   status();                                  //get status info
   ntrxit();                            //deal with order
 }


 void status()
 //determines all relevant marketconditions
 {
   //
   static double
     ubnd,anch,lbnd;                             //anchor,upper and lower bounds stay static
   double
     pr=0.5*(Bid+Ask);                           //set price

   if(!s.ualset)                                 //set anchor,ubound,lbound and make ualset true
     {
       anch=pr;
       ubnd=anch+Estep*Point;                           
       lbnd=anch-Estep*Point;                           
       s.ualset=true;
     }

   s.buy=(pr>ubnd);                              //buy condition
   s.sel=(pr<lbnd);                              //sel condition
   if(s.buy || s.sel)                            //if in buysel then reset ualset to original false
     s.ualset=false;

 }

 void ntrxit()
 //handles trade orders
 {
   if(s.tkt==-1)                                 //tkt value nonexistent so possible to place order
     {
       if(s.buy)
         s.tkt=OrderSend(Symbol(),0,lt,Ask,0,Ask-sltp,Ask+sltp);
       if(s.sel)
         s.tkt=OrderSend(Symbol(),1,lt,Bid,0,Bid+sltp,Bid-sltp);
     }
   else                                          //otherwise use tkt value to get order details
     {
       if(OrderSelect(s.tkt,SELECT_BY_TICKET))
         {
           s.bs=OrderType();
           s.inbuy=(s.bs==0);
           s.insel=(s.bs==1);
           if((s.inbuy && s.sel) ||              //inbuy with sel or
              (s.insel && s.buy))                //insel with buy
             {                                   //close order
               if(OrderClose(s.tkt,lt,OrderClosePrice(),0))
                 s.tkt=-1;                       //reset tkt value to nonexistent
             }
         }
     }
 }


 void maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
 {
   maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
   maxval=iHigh(NULL,tf,maxbar);
   minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
   minval=iLow(NULL,tf,minbar);
 }

 double Dprs(double pI,double pF)
 //difference between two prices
 {
   return (pF-pI);
 }

 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
 {
   return (pF-pI)/Point;
 }

 double avgslope(int bI,int bF,double &ma[])
 //calculates avgslope using theil-sen concept
   {
    int
    iters=bI*(bI-1)/2;
    double
    acc=0;
    for(int i=bF;i<bI;i++)
       for(int j=i+1;j<=bI;j++)
          acc+=incline(j,ma[j],i,ma[i]);
    return acc/iters;
   }

 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
 {
   int
     Dbar=bI-bF;
   return Dpts(vI,vF)/Dbar;
 }

 bool btn(double a,double x,double b)
 //true if x lies between a and b regardless of order of entry of a,b
 {
   if((x>a && x<b) || (x>b && x<a))
     return true;
   else
     return false;
 }

 bool CanDoTrade()
 //checks if trading is ok via total orders, spread
 {
   int
     aords,pords;
   bool
     spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12),
     noordsOK=(OrdersForSymbol(aords,pords)==0);
   return (noordsOK && spreadOK);
 }

 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
 {
   aords=0;pords=0;
   for(int p=OrdersTotal()-1;p>=0;p--)
     if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
       {
         if(OrderType()>1 && OrderType()<6)
           pords++;
         if(OrderType()==OP_BUY || OrderType()==OP_SELL)
           aords++;
       }
   return aords+pords;
 }

 void showlasterror()
 //prints last error message
 {
   int
     errnum=GetLastError();
   if(errnum!=ERR_NO_ERROR)
     Comment(errnum,sp,ErrorDescription(errnum));
   else
     Comment(ERR_NO_ERROR);
 }

 void hline(string objlabel,double price)
 //draws horizontal line
 {
   ObjectDelete(objlabel);
   ObjectCreate(objlabel,OBJ_HLINE,0,Time[0],price);
 }
  
 void displayitem(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
 {
   ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
   ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
   ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
   ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
   ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
 }


 //
 //SPECIAL FUNCTIONS
 //
 int OnInit()
 {
   s.ualset=false;
   s.bs=-1;
   s.tkt=-1;
   return(INIT_SUCCEEDED);
 }

 void OnDeinit(const int reason)
 {
  
 }

 void OnTick()
 {
   main();
 }



 /*
 MetaQuotes Software Corp
 https://www.mql5.com
 */

*** tickle
 uses tick movement within a ticklezone to wait for a breakout past a sneezepoint
 this may not work because movements are likely to be hard to determine and likely minimal
*** un orginal from llpatts
 looking for un patterns using fractals instead of maxmin - not done yet.
 ideas from llpatts can still be incorporated in terms of multiple tfs

**** code v1
 has basic ideas, but results are only moderately good
 concepts are somewhat awkward to understand and therefore optimize
 a big problem is the fixed lookback
 - consider 10L 6H 4L(higher than 10)
 - we really have an uptrend, but it will be viewed as down since 10,6
 - based on this, perhaps using fractals makes more sense?


 ////+------------------------------------------------------------------+
 //|                                                    pradapter.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+
 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>

 #define sp "  "
 #define Glt 0.1

 /*
 status for market conditions and for trades
 ntrxit on quadrants
 play with E vars
 try different types of trailers
 */
 //+------------------------------------------------------------------+
 //| Global Variables                                                 |
 //+------------------------------------------------------------------+
 extern int Etfsx;
 extern int Estep;
 extern int EminDuns;

 int tfs[6],
 GbarsInChart=0;
 bool zz;
 //

 //+------------------------------------------------------------------+
 //| Market Condition Structure                                       |
 //+------------------------------------------------------------------+
 struct MarketConditions
 //shows statements of various indicators and appropriate trade setups
   {
    //hi and lo info
    int               hibar,lobar;
    double            hival,loval;

    //uncalc signal patterns nbu,ubn,nub,unb,bnu,bun and hilo delta, priceturn deltas
    string            pattern;
    double            Duns,Dprn,prnfr;

    //longterm trend
    double            ltrend;

    //bs,oo,sl,tp
    int               bs;
    double            oo,sl,tp;
   };
 //+------------------------------------------------------------------+
 //| Trade Data Structure                                             |
 //+------------------------------------------------------------------+
 struct TradeData
 //details what is happening with a trade
   {
    //trades in play info
    int               aords,pords;

    //orderselect info
    int               otype;
    double            oopenprice;
    double            oprofit;
    double            opointbal;
   };

 MarketConditions m;
 TradeData t;
 //+------------------------------------------------------------------+
 //| main control function                                            |
 //+------------------------------------------------------------------+
 void main()
   {
    static int tkt;

    getparameters(01);
    int tf=tfs[Etfsx];

 //get info about present market conditions
    marketconditions(tf);

    if(CanDoTrade())
      {
       tkt=OrderSend(Symbol(),m.bs,Glt,m.oo,0,m.sl,m.tp,m.pattern);
      }
     
    bool os=OrderSelect(tkt,SELECT_BY_TICKET);
    //tradedata(tkt,os);

   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void marketconditions(int tf)
 //finds various aspects of status
   {

 //use un info
    uncalc(tf,m.hibar,m.hival,m.lobar,m.loval,m.pattern);
    m.Duns=Dpts(m.loval,m.hival);
    if(m.lobar>m.hibar)
       m.Dprn=Dpts(m.hival,Bid);
    else
       m.Dprn=Dpts(m.loval,Bid);
    m.prnfr=m.Dprn/m.Duns;

 //fill oo,sl,tp
    if(m.pattern=="nbu") {m.bs=0;m.oo=Ask;m.sl=m.loval;m.tp=m.hival;}
    if(m.pattern=="ubn") {m.bs=1;m.oo=Bid;m.sl=m.hival;m.tp=m.loval;}
 //if(m.Spattern=="unb") {m.bs=0;m.oo=Ask;m.sl=m.loval;m.tp=m.oo+tp;}
 //if(m.Spattern=="nub") {m.bs=1;m.oo=Bid;m.sl=m.hival;m.tp=m.oo-tp;}
 //if(m.Spattern=="bnu") {m.bs=0;m.oo=Ask;m.sl=m.oo-tp;m.tp=m.oo+tp;}
 //if(m.Spattern=="bun") {m.bs=1;m.oo=Bid;m.sl=m.oo+tp;m.tp=m.oo-tp;}
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void tradedata(int tkt,bool os)
   {
    int tords=OrdersForSymbol(t.aords,t.pords);

    if(os)
      {
       t.otype=OrderType();
       t.oopenprice=OrderOpenPrice();
       if(t.otype==OP_BUY)
          t.opointbal=Dpts(t.oopenprice,Bid);
       else
          t.opointbal=Dpts(Bid,t.oopenprice);
       trailer(tkt,t.otype,t.oopenprice,t.opointbal);
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void trailer(int tkt,int otype,double oopenprice,double opointbal)
   {
    double step=Estep;

    if(opointbal>step)
      {
       if(otype==OP_BUY)
          m.sl=oopenprice+(step/2)*Point;
       else
          m.sl=oopenprice-(step/2)*Point;
       bool om=OrderModify(tkt,oopenprice,m.sl,m.tp,0);
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void uncalc(int tf,int &hibar,double &hival,int &lobar,double &loval,string &pattern)
 //determines legitimate uns bars with values and identifies HAL,LAH,LHA,HLA
   {
    bool un,nu;
    double pad=40*Point;

    maxmin(tf,12,1,hibar,hival,lobar,loval);

    un=lobar>hibar;
    nu=hibar>lobar;

    if(un && Bid>hival) {pattern="unb";return;}                 //buy
    if(nu && Bid<loval) {pattern="nub";return;}                 //sel
    if(nu && Bid>hival) {pattern="bnu";return;}                 //buy
    if(un && Bid<loval) {pattern="bun";return;}                 //sel
    if(nu && btn(Bid,hival,loval+pad)) {pattern="nbu";return;}  //buy
    if(un && btn(Bid,hival-pad,loval)) {pattern="ubn";return;}  //sel
   }
 //+------------------------------------------------------------------+
 //| parameter settings                                               |
 //+------------------------------------------------------------------+
 void getparameters(int n)
   {
    switch(n)
      {
       case  01:
          Etfsx=1;Estep=40;
          break;
       case  02:
          Etfsx=2;
          break;
       case  03:
          Etfsx=3;
          break;
       case  04:
          Etfsx=4;
          break;
       case  05:

          break;
       case  06:

          break;
       case  07:

          break;
       case  08:

          break;
       case  09:

          break;
       case  10:

          break;
       case  11:

          break;
       case  12:

          break;
       default:
          break;
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
   {
    maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
    maxval=iHigh(NULL,tf,maxbar);
    minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
    minval=iLow(NULL,tf,minbar);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
   {
    return (pF-pI)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
   {
    int
    Dbar=bI-bF;
    return Dpts(vI,vF)/Dbar;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool btn(double x,double a,double b)
 //true if x lies between a and b regardless of order of entry of a,b
   {
    if((x<a && x>b) || (x<b && x>a)) return true; else return false;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool CanDoTrade()
 //checks if trading is ok via new bar, total orders, spread
   {

    bool
    newbarOK=(GbarsInChart<Bars),
    DhiloOK=(m.Duns>EminDuns),
    spreadOK=(MarketInfo(NULL,MODE_SPREAD)<12);
    GbarsInChart=Bars;
    return (newbarOK && DhiloOK && spreadOK && noords());
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool noords()
   {
    int aords,pords;
    return OrdersForSymbol(aords,pords)==0;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
   {
    aords=0;pords=0;
    for(int p=OrdersTotal()-1;p>=0;p--)
       if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
         {
          if(OrderType()>1 && OrderType()<6)
             pords++;
          if(OrderType()==OP_BUY || OrderType()==OP_SELL)
             aords++;
         }
    return aords+pords;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void showlasterror()
 //prints last error message
   {
    int
    errnum=GetLastError();
    if(errnum!=ERR_NO_ERROR)
       Comment(errnum,sp,ErrorDescription(errnum));
    else
       Comment(ERR_NO_ERROR);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 string YI2S(int x)
 //integer to string
   {
    return IntegerToString(x);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 string YD2S(double x,int d)
 //double to string
   {
    return DoubleToString(x,d);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void display(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
   {
    ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
    ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
    ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
    ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
    ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
   }
 //+------------------------------------------------------------------+
 //| Expert initialization function                                   |
 //+------------------------------------------------------------------+
 int OnInit()
   {
    tfs[0]=1;tfs[1]=5;tfs[2]=15;tfs[3]=30;tfs[4]=60;tfs[5]=240;
    return(INIT_SUCCEEDED);
   }
 //+------------------------------------------------------------------+
 //| Expert deinitialization function                                 |
 //+------------------------------------------------------------------+
 void OnDeinit(const int reason)
   {

   }
 //+------------------------------------------------------------------+
 //| Expert tick function                                             |
 //+------------------------------------------------------------------+
 void OnTick()
   {
    main();
   }
 //+------------------------------------------------------------------+

*** llpatts
 NOTE: unnu is likely a refined version of llpatts
 looks for parallel patterns in different tf of hal,lah,hla,lha,ahl,alh to determine ntrxit. the main concept here is that a larger tf can establish the general trend while the smaller one gets you in and out when the pattern matches.

**** code just testing tfcombos and sltp

 160820-27
 | 224.50 | 10 | 3.48 | 22.45 | 54.90 | 0.53% | Esltp=450 | Etfx=0 |
 | 179.50 |  7 | 4.95 | 25.64 | 68.60 | 0.67% | Esltp=450 | Etfx=2 |
 | 174.30 |  7 | 4.44 | 24.90 | 68.60 | 0.67% | Esltp=450 | Etfx=3 |
 | 169.60 |  4 | 5.20 | 42.40 | 84.40 | 0.84% | Esltp=700 | Etfx=3 |
 | 169.60 |  4 | 5.20 | 42.40 | 84.40 | 0.84% | Esltp=700 | Etfx=2 |
 | 159.50 |  9 | 2.98 | 17.72 | 58.60 | 0.58% | Esltp=400 | Etfx=2 |
 | 154.60 |  4 | 4.83 | 38.65 | 84.40 | 0.84% | Esltp=650 | Etfx=3 |
 | 154.60 |  4 | 4.83 | 38.65 | 84.40 | 0.84% | Esltp=650 | Etfx=2 |

 160813-20
 | 105.20 | 85 | 1.28 |  1.24 |  79.00 | 0.79% | Esltp=100  | Etfx=0 |
 |  45.20 |  2 | 1.82 | 22.60 | 126.20 | 1.25% | Esltp=1000 | Etfx=1 |
 |  39.40 |  3 | 1.41 | 13.13 | 127.00 | 1.25% | Esltp=950  | Etfx=1 |
 |  39.40 |  3 | 1.44 | 13.13 | 122.00 | 1.21% | Esltp=900  | Etfx=1 |
 |  30.80 | 41 | 1.11 |  0.75 |  91.50 | 0.91% | Esltp=150  | Etfx=0 | 

 160806-13
 | 152.20 | 9 | 3.17 | 16.91 |  96.10 | 0.96% | Esltp=350  | Etfx=3 |
 | 143.40 | 5 | 3.87 | 28.68 |  56.60 | 0.56% | Esltp=500  | Etfx=3 |
 | 143.40 | 5 | 3.87 | 28.68 |  56.60 | 0.56% | Esltp=500  | Etfx=2 |
 | 132.20 | 9 | 3.20 | 14.69 |  86.10 | 0.86% | Esltp=300  | Etfx=3 |
 | 123.40 | 6 | 4.08 | 20.57 |  59.10 | 0.59% | Esltp=400  | Etfx=2 |
 | 121.90 | 6 | 4.05 | 20.32 |  59.10 | 0.59% | Esltp=400  | Etfx=3 |
 | 120.50 | 5 | 3.68 | 24.10 |  58.90 | 0.59% | Esltp=450  | Etfx=0 |
 | 119.90 | 2 | 0.00 | 59.95 |  90.10 | 0.89% | Esltp=1000 | Etfx=3 |
 | 119.20 | 8 | 2.70 | 14.90 | 106.60 | 1.06% | Esltp=350  | Etfx=1 |

 160730-0806  
 | 133.80 | 2 | 0.00 | 66.90 | 78.60 | 0.78% | Esltp=1000 | Etfx=3 |
 | 133.80 | 2 | 0.00 | 66.90 | 78.60 | 0.78% | Esltp=1000 | Etfx=2 |
 | 128.80 | 2 | 0.00 | 64.40 | 78.60 | 0.78% | Esltp=950  | Etfx=3 |
 | 128.80 | 2 | 0.00 | 64.40 | 78.60 | 0.78% | Esltp=950  | Etfx=2 |
 | 123.80 | 2 | 0.00 | 61.90 | 78.60 | 0.78% | Esltp=900  | Etfx=3 |
 | 123.80 | 2 | 0.00 | 61.90 | 78.60 | 0.78% | Esltp=900  | Etfx=2 |
 | 118.80 | 2 | 0.00 | 59.40 | 78.60 | 0.78% | Esltp=850  | Etfx=3 |
 | 118.80 | 2 | 0.00 | 59.40 | 78.60 | 0.78% | Esltp=850  | Etfx=2 |



 //+------------------------------------------------------------------+
 //|                                                      llpatts.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+

 /*

 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>

 #define sp "  "

 extern int Esltp;
 extern int Etfx;

 /*
 incorporates patterns in multiple tf to determine ntrxit
 */

 int
 Gtkt=0,
 GbarsInChart=0,
 Gbs=-1;
 double
 Glt=0.1,Goo=0,Gsl=0,Gtp=0;
 bool zz;
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 struct tfcombos
 //timeframe combinations
   {
    int               L,S;
   };
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 struct status
 //single timeframe situation
   {
    //hi and lo info
    int               hibar,lobar;
    double            hival,loval;

    //patterns HAL,LAH,HLA,LHA,AHL,ALH
    string            pattern;

    //deltas between hilo and point movement from last turn
    double            Dhilo,Dpomo;

    //longterm trend
    double            ltrend;
 /*
    //bs,oo,sl,tp
    int               bs;
    double            oo,sl,tp;

    //orderselect info
    double            orderprofit;
    int               ordertype;
 */
   };
 tfcombos tfc[6];
 status Ss,Ls;
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OnInit()
   {
    tfc[0].S=01;tfc[0].L=05;
    tfc[1].S=05;tfc[1].L=30;
    tfc[2].S=05;tfc[2].L=60;
    tfc[3].S=15;tfc[3].L=60;
    tfc[4].S=30;tfc[4].L=240;
    tfc[5].S=60;tfc[5].L=240;
    return(INIT_SUCCEEDED);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {
 //getparameters(5);
    int tfx=Etfx;
    getstatus(tfc[tfx].S,Ss);showstatus("S",1000,Ss);
    getstatus(tfc[tfx].L,Ls);showstatus("L",1200,Ls);

    if(CanDoTrade())
      {
       gettrade(Gbs,Goo,Gsl,Gtp);
       Gtkt=OrderSend(Symbol(),Gbs,Glt,Goo,0,Gsl,Gtp);
      }
   }
 void gettrade(int &bs,double &oo,double &sl,double &tp)
 //tries to setup a trade
 {
 double sltp=Esltp*Point;

 if(Ls.pattern=="HAL" && Ss.pattern=="HAL") {bs=0;oo=Ask;sl=oo-sltp;tp=oo+sltp;}
 if(Ls.pattern=="LAH" && Ss.pattern=="LAH") {bs=1;oo=Bid;sl=oo+sltp;tp=oo-sltp;}
 }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void getstatus(int tf,status &s)
 //finds various aspects of Sstatus
   {
    bool truehi=false,truelo=false;
    double Dhiloinc;
    int Dhilobar=1,barstep=12,barF=1,barI=barF+barstep;

 //get hilo info   
    while(truehi==false && truelo==false)
      {
       maxmin(tf,barI,barF,s.hibar,s.hival,s.lobar,s.loval);
       truehi=turnpoint(tf,s.hibar,s.hival,"hi");
       truelo=turnpoint(tf,s.lobar,s.loval,"lo");
       barF=barI+1;
       barI=barF+barstep;
      }
    if((Bid<s.hival && Bid>s.loval) && s.hibar>s.lobar) {s.pattern="HAL";return;}
    if((Bid<s.hival && Bid>s.loval) && s.lobar>s.hibar) {s.pattern="LAH";return;}
    if(Bid>s.hival && s.hibar>s.lobar) {s.pattern="AHL";return;}
    if(Bid<s.loval && s.lobar>s.hibar) {s.pattern="ALH";return;}
    if(Bid<s.loval && s.hibar>s.lobar) {s.pattern="HLA";return;}
    if(Bid>s.hival && s.lobar>s.hibar) {s.pattern="LHA";return;}

    if(s.lobar!=s.hibar) Dhilobar=s.lobar-s.hibar;
    Dhiloinc=Dpts(s.loval,s.hival)/Dhilobar;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void showstatus(string LS,int colstart,status &s)
 //shows status
   {
 //initialize line values
    int l[5];ArrayInitialize(l,0);for(int i=1;i<5;i++) l[i]=i*12;

    display(LS,s.pattern,0,colstart,l[1],Blue);

   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 /*
 //fill oo,sl,tp
 //   if(s.pattern=="HAL") {s.bs=0;s.oo=Ask;s.sl=s.oo-sltp;s.tp=s.oo+sltp;}
 //   if(s.pattern=="LAH") {s.bs=1;s.oo=Bid;s.sl=s.oo+sltp;s.tp=s.oo-sltp;}
 //if(s.Spattern=="AHL") {s.bs=0;s.oo=Ask;s.sl=s.oo-tp;s.tp=s.oo+tp;}
 //if(s.Spattern=="ALH") {s.bs=1;s.oo=Bid;s.sl=s.oo+tp;s.tp=s.oo-tp;}
 //if(s.Spattern=="LHA") {s.bs=0;s.oo=Ask;s.sl=s.Sloval;s.tp=s.oo+tp;}
 //if(s.Spattern=="HLA") {s.bs=1;s.oo=Bid;s.sl=s.Shival;s.tp=s.oo-tp;}


 //orderselect info
    if(OrderSelect(Gtkt,SELECT_BY_TICKET))
      {
       s.orderprofit=OrderProfit();
       s.ordertype=OrderType();
      }
 //initialize line spacing
    ArrayInitialize(l,0);
    for(int i=1;i<5;i++) l[i]=i*12;
 //display status
    display("tfx","tfx",0,col,l[1],Blue);
    display("bar","bar",0,col,l[2],Blue);
    display("val","val",0,col,l[3],Blue);
    display("pat","pat",0,col,l[4],Blue);

    display("tfx1",YI2S(tfx),0,col+spc,l[1],Blue);
    display("bar1",YI2S(s.hibar)+","+YI2S(s.lobar)+"="+YI2S(Dhilobar),0,col+spc,l[2],Blue);
    display("val1",YD2S(s.hival,5)+","+YD2S(s.loval,5)+"=>"+YD2S(Dhiloinc,0),0,col+spc,l[3],Blue);
    display("pat1",s.pattern,0,col+spc,l[4],Blue);

 //display("orderprofit","OrderProfit = "+DoubleToStr(s.orderprofit,2),1,200,90,Green);
 */
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double ltrend(int tf,int bI,int bF)
 //calculates longterm trend
   {
    double
    vI=medianvalue(iHigh(NULL,tf,bI),iLow(NULL,tf,bI)),
    vF=medianvalue(iHigh(NULL,tf,bF),iLow(NULL,tf,bF));
    return incline(bI,vI,bF,vF);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double medianvalue(double hi,double lo)
 //calculates midpoint from hi and lo
   {
    return 0.5*(hi+lo);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool turnpoint(int tf,int bar,double val,string hiloitem)
 //determines if hilo are true turning points
   {
    double v[5];

    v[0]=val;

    if(hiloitem=="hi")
      {
       v[1]=iHigh(NULL,tf,bar+2);
       v[2]=iHigh(NULL,tf,bar+1);
       v[3]=iHigh(NULL,tf,bar-1);
       v[4]=iHigh(NULL,tf,bar-2);
       if(ArrayMaximum(v)==0) return true;
      }
    if(hiloitem=="lo")
      {
       v[1]=iLow(NULL,tf,bar+2);
       v[2]=iLow(NULL,tf,bar+1);
       v[3]=iLow(NULL,tf,bar-1);
       v[4]=iLow(NULL,tf,bar-2);
       if(ArrayMinimum(v)==0) return true;
      }
    return false;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
   {
    maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
    maxval=iHigh(NULL,tf,maxbar);
    minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
    minval=iLow(NULL,tf,minbar);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
   {
    return (pF-pI)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
   {
    int
    Dbar=bI-bF;
    return Dpts(vI,vF)/Dbar;
   }
 //+------------------------------------------------------------------+
 //|TRADEABLE                                                         |
 //+------------------------------------------------------------------+
 bool CanDoTrade()
 //checks if trading is ok via new bar, total orders, spread
   {
    int aords,pords;
    bool
    newbarOK=(GbarsInChart<Bars),
    spreadOK=(MarketInfo(NULL,MODE_SPREAD)<9),
    noordsOK=(OrdersForSymbol(aords,pords)==0);
    GbarsInChart=Bars;
    return (newbarOK && spreadOK && noordsOK);
   }
 //+------------------------------------------------------------------+
 //|TRADEABLE                                                         |
 //+------------------------------------------------------------------+
 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
   {
    aords=0;pords=0;
    for(int p=OrdersTotal()-1;p>=0;p--)
       if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
         {
          if(OrderType()>1 && OrderType()<6)
             pords++;
          if(OrderType()==OP_BUY || OrderType()==OP_SELL)
             aords++;
         }
    return aords+pords;
   }
 //+------------------------------------------------------------------+
 //|DISPLAY                                                           |
 //+------------------------------------------------------------------+
 void showlasterror()
 //prints last error message
   {
    int
    errnum=GetLastError();
    if(errnum!=ERR_NO_ERROR)
       Comment(errnum,sp,ErrorDescription(errnum));
    else
       Comment(ERR_NO_ERROR);
   }
 //+------------------------------------------------------------------+
 //|DISPLAY                                                           |
 //+------------------------------------------------------------------+
 string YI2S(int x)
 //integer to string
   {
    return IntegerToString(x);
   }
 //+------------------------------------------------------------------+
 //|DISPLAY                                                           |
 //+------------------------------------------------------------------+
 string YD2S(double x,int d)
 //double to string
   {
    return DoubleToString(x,d);
   }
 //+------------------------------------------------------------------+
 //|DISPLAY                                                           |
 //+------------------------------------------------------------------+
 void display(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
   {
    ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
    ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
    ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
    ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
    ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void getparameters(int n)
 //sets the parameters for trading
   {
    switch(n)
      {
       case  1:

          break;
       case  2:

          break;
       case  3:

          break;
       case  4:

          break;
       case  5:

          break;
       case  6:

          break;
       case  7:

          break;
       case  8:

          break;
       case  9:

          break;
       default:
          break;
      }
   }

 //+------------------------------------------------------------------+

**** code using both pattern and sltp to xit
 the combo produced better results than each separate. this came as a surprise. however, there may be good reasons as to why: the pattern xit before sl while tp may be hit before a pattern forms.

 another interesting result was that parameter set 1 gave $240 0820-0827, but nearly -$200 between 0813-0820 while set 2 gave $116 for the latter and $240 with set 3 , suggesting we may be able to understand what is happening through the parameter sets.


 //+------------------------------------------------------------------+
 //|                                                      llpatts.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+

 /*

 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>

 #define sp "  "

 extern int Esltp;
 extern int Etfx;

 /*
 incorporates patterns in multiple tf to determine ntrxit
 */

 int
 tkt=0,
 barsInChart=0,
 bs=-1;
 double
 lt=0.1,oo=0,sl=0,tp=0;
 bool zz;
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 struct tfcombos
 //timeframe combinations
   {
    int               L,S;
   };
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 struct status
 //single timeframe situation
   {
    //hi and lo info
    int               hibar,lobar;
    double            hival,loval;

    //patterns HAL,LAH,HLA,LHA,AHL,ALH
    string            pattern;

    //deltas between hilo and point movement from last turn
    double            Dhilo,Dpomo;

    //longterm trend
    double            ltrend;
 /*
    //bs,oo,sl,tp
    int               bs;
    double            oo,sl,tp;

    //orderselect info
    double            orderprofit;
    int               ordertype;
 */
   };
 tfcombos tfc[6];
 status Ss,Ls;
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OnInit()
   {
    tfc[0].S=01;tfc[0].L=05;
    tfc[1].S=05;tfc[1].L=30;
    tfc[2].S=05;tfc[2].L=60;
    tfc[3].S=15;tfc[3].L=60;
    tfc[4].S=30;tfc[4].L=240;
    tfc[5].S=60;tfc[5].L=240;
    return(INIT_SUCCEEDED);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {
    getparameters(2);
    int tfx=Etfx;
    getstatus(tfc[tfx].S,Ss);showstatus("S",1000,Ss);
    getstatus(tfc[tfx].L,Ls);showstatus("L",1200,Ls);

    if(CanDoTrade())
      {
       double sltp=Esltp*Point;
       if(Ls.pattern=="HAL" && Ss.pattern=="HAL") {bs=0;oo=Ask;sl=oo-sltp;tp=oo+sltp;}
       if(Ls.pattern=="LAH" && Ss.pattern=="LAH") {bs=1;oo=Bid;sl=oo+sltp;tp=oo-sltp;}
       tkt=OrderSend(Symbol(),bs,lt,oo,0,sl,tp);
      }
    if(OrderSelect(tkt,SELECT_BY_TICKET))
      {
       switch(OrderType())
         {
          case  0:
             if(Ls.pattern=="LAH") zz=OrderClose(tkt,lt,oo,0);
             break;
          case  1:
             if(Ls.pattern=="HAL") zz=OrderClose(tkt,lt,oo,0);
             break;
         }

      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void getstatus(int tf,status &s)
 //finds various aspects of Sstatus
   {
    bool truehi=false,truelo=false;
    double Dhiloinc;
    int Dhilobar=1,barstep=12,barF=1,barI=barF+barstep;

 //get hilo info   
    while(truehi==false && truelo==false)
      {
       maxmin(tf,barI,barF,s.hibar,s.hival,s.lobar,s.loval);
       truehi=turnpoint(tf,s.hibar,s.hival,"hi");
       truelo=turnpoint(tf,s.lobar,s.loval,"lo");
       barF=barI+1;
       barI=barF+barstep;
      }
    if((Bid<s.hival && Bid>s.loval) && s.hibar>s.lobar) {s.pattern="HAL";return;}
    if((Bid<s.hival && Bid>s.loval) && s.lobar>s.hibar) {s.pattern="LAH";return;}
    if(Bid>s.hival && s.hibar>s.lobar) {s.pattern="AHL";return;}
    if(Bid<s.loval && s.lobar>s.hibar) {s.pattern="ALH";return;}
    if(Bid<s.loval && s.hibar>s.lobar) {s.pattern="HLA";return;}
    if(Bid>s.hival && s.lobar>s.hibar) {s.pattern="LHA";return;}

    if(s.lobar!=s.hibar) Dhilobar=s.lobar-s.hibar;
    Dhiloinc=Dpts(s.loval,s.hival)/Dhilobar;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void showstatus(string LS,int colstart,status &s)
 //shows status
   {
 //initialize line values
    int l[5];ArrayInitialize(l,0);for(int i=1;i<5;i++) l[i]=i*12;

    display(LS,s.pattern,0,colstart,l[1],Blue);

   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double ltrend(int tf,int bI,int bF)
 //calculates longterm trend
   {
    double
    vI=medianvalue(iHigh(NULL,tf,bI),iLow(NULL,tf,bI)),
    vF=medianvalue(iHigh(NULL,tf,bF),iLow(NULL,tf,bF));
    return incline(bI,vI,bF,vF);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double medianvalue(double hi,double lo)
 //calculates midpoint from hi and lo
   {
    return 0.5*(hi+lo);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool turnpoint(int tf,int bar,double val,string hiloitem)
 //determines if hilo are true turning points
   {
    double v[5];

    v[0]=val;

    if(hiloitem=="hi")
      {
       v[1]=iHigh(NULL,tf,bar+2);
       v[2]=iHigh(NULL,tf,bar+1);
       v[3]=iHigh(NULL,tf,bar-1);
       v[4]=iHigh(NULL,tf,bar-2);
       if(ArrayMaximum(v)==0) return true;
      }
    if(hiloitem=="lo")
      {
       v[1]=iLow(NULL,tf,bar+2);
       v[2]=iLow(NULL,tf,bar+1);
       v[3]=iLow(NULL,tf,bar-1);
       v[4]=iLow(NULL,tf,bar-2);
       if(ArrayMinimum(v)==0) return true;
      }
    return false;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
   {
    maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
    maxval=iHigh(NULL,tf,maxbar);
    minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
    minval=iLow(NULL,tf,minbar);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
   {
    return (pF-pI)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
   {
    int
    Dbar=bI-bF;
    return Dpts(vI,vF)/Dbar;
   }
 //+------------------------------------------------------------------+
 //|TRADEABLE                                                         |
 //+------------------------------------------------------------------+
 bool CanDoTrade()
 //checks if trading is ok via new bar, total orders, spread
   {
    int aords,pords;
    bool
    newbarOK=(barsInChart<Bars),
    spreadOK=(MarketInfo(NULL,MODE_SPREAD)<9),
    noordsOK=(OrdersForSymbol(aords,pords)==0);
    barsInChart=Bars;
    return (newbarOK && spreadOK && noordsOK);
   }
 //+------------------------------------------------------------------+
 //|TRADEABLE                                                         |
 //+------------------------------------------------------------------+
 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
   {
    aords=0;pords=0;
    for(int p=OrdersTotal()-1;p>=0;p--)
       if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
         {
          if(OrderType()>1 && OrderType()<6)
             pords++;
          if(OrderType()==OP_BUY || OrderType()==OP_SELL)
             aords++;
         }
    return aords+pords;
   }
 //+------------------------------------------------------------------+
 //|DISPLAY                                                           |
 //+------------------------------------------------------------------+
 void showlasterror()
 //prints last error message
   {
    int
    errnum=GetLastError();
    if(errnum!=ERR_NO_ERROR)
       Comment(errnum,sp,ErrorDescription(errnum));
    else
       Comment(ERR_NO_ERROR);
   }
 //+------------------------------------------------------------------+
 //|DISPLAY                                                           |
 //+------------------------------------------------------------------+
 string YI2S(int x)
 //integer to string
   {
    return IntegerToString(x);
   }
 //+------------------------------------------------------------------+
 //|DISPLAY                                                           |
 //+------------------------------------------------------------------+
 string YD2S(double x,int d)
 //double to string
   {
    return DoubleToString(x,d);
   }
 //+------------------------------------------------------------------+
 //|DISPLAY                                                           |
 //+------------------------------------------------------------------+
 void display(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
   {
    ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
    ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
    ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
    ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
    ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void getparameters(int n)
 //sets the parameters for trading
   {
    switch(n)
      {
       case  1:
 Esltp=400; 	Etfx=4;
          break;
       case  2:
 Esltp=150; 	Etfx=0;
          break;
       case  3:
 Esltp=1000;     Etfx=1;
          break;
       case  4:

          break;
       case  5:

          break;
       case  6:

          break;
       case  7:

          break;
       case  8:

          break;
       case  9:

          break;
       default:
          break;
      }
   }

 //+------------------------------------------------------------------+

**** code adding a pad for establishing patterns
 eurusd 160820-27
 | 200.00 | 14 |    6.00 | 14.29 | 29.60 | 0.29% | Esltp=200 | Etfx=5 | Epad=45 |
 | 200.00 | 14 |    6.00 | 14.29 | 29.60 | 0.29% | Esltp=200 | Etfx=5 | Epad=44 |
 | 200.00 | 14 |    6.00 | 14.29 | 29.60 | 0.29% | Esltp=200 | Etfx=5 | Epad=49 |
 | 200.00 | 14 |    6.00 | 14.29 | 29.60 | 0.29% | Esltp=200 | Etfx=5 | Epad=42 |
 | 200.00 | 14 |    6.00 | 14.29 | 29.60 | 0.29% | Esltp=200 | Etfx=5 | Epad=50 |
 | 200.00 | 14 |    6.00 | 14.29 | 29.60 | 0.29% | Esltp=200 | Etfx=5 | Epad=46 |
 | 200.00 | 14 |    6.00 | 14.29 | 29.60 | 0.29% | Esltp=200 | Etfx=5 | Epad=43 |
 | 200.00 | 14 |    6.00 | 14.29 | 29.60 | 0.29% | Esltp=200 | Etfx=5 | Epad=48 |
 | 200.00 | 14 |    6.00 | 14.29 | 29.60 | 0.29% | Esltp=200 | Etfx=5 | Epad=47 |
 | 194.90 |  4 | 1950.00 | 48.73 | 84.40 | 0.84% | Esltp=650 | Etfx=5 | Epad=43 |
 | 180.00 |  3 |    0.00 | 60.00 | 84.40 | 0.84% | Esltp=600 | Etfx=5 | Epad=36 |
 | 180.00 |  3 |    0.00 | 60.00 | 84.40 | 0.84% | Esltp=600 | Etfx=5 | Epad=49 |
 | 180.00 |  3 |    0.00 | 60.00 | 84.40 | 0.84% | Esltp=600 | Etfx=5 | Epad=29 |
 | 180.00 |  3 |    0.00 | 60.00 | 84.40 | 0.84% | Esltp=600 | Etfx=5 | Epad=31 |
 | 180.00 |  3 |    0.00 | 60.00 | 84.40 | 0.84% | Esltp=600 | Etfx=5 | Epad=48 |

 | 238.80 |  9 |  6.80 | 26.53 | 42.30 | 0.41% | Esltp=400 | Etfx=2 | Epad=85  |
 | 224.60 | 13 |  3.48 | 17.28 | 54.90 | 0.53% | Esltp=450 | Etfx=0 | Epad=0   |
 | 224.60 | 12 |  3.48 | 18.72 | 50.60 | 0.51% | Esltp=450 | Etfx=0 | Epad=15  |
 | 220.00 | 15 |  6.50 | 14.67 | 29.30 | 0.29% | Esltp=200 | Etfx=5 | Epad=90  |
 | 220.00 | 15 |  6.50 | 14.67 | 29.30 | 0.29% | Esltp=200 | Etfx=5 | Epad=75  |
 | 220.00 | 15 |  6.50 | 14.67 | 29.30 | 0.29% | Esltp=200 | Etfx=5 | Epad=80  |
 | 220.00 | 17 |  4.67 | 12.94 | 52.80 | 0.52% | Esltp=200 | Etfx=5 | Epad=100 |
 | 220.00 | 16 |  6.50 | 13.75 | 29.30 | 0.29% | Esltp=200 | Etfx=5 | Epad=65  |
 | 220.00 | 15 |  6.50 | 14.67 | 29.30 | 0.29% | Esltp=200 | Etfx=5 | Epad=85  |
 | 220.00 | 17 |  4.67 | 12.94 | 48.50 | 0.48% | Esltp=200 | Etfx=5 | Epad=95  |
 | 219.30 |  7 | 39.47 | 31.33 | 68.60 | 0.67% | Esltp=450 | Etfx=3 | Epad=70  |
 | 219.30 |  7 | 39.47 | 31.33 | 48.90 | 0.48% | Esltp=450 | Etfx=3 | Epad=85  |
 | 219.30 |  7 | 39.47 | 31.33 | 48.90 | 0.48% | Esltp=450 | Etfx=3 | Epad=100 |
 | 219.30 |  7 | 39.47 | 31.33 | 48.90 | 0.48% | Esltp=450 | Etfx=3 | Epad=80  |
 | 219.30 |  7 | 39.47 | 31.33 | 48.90 | 0.48% | Esltp=450 | Etfx=3 | Epad=95  |
 | 219.30 |  7 | 39.47 | 31.33 | 68.60 | 0.67% | Esltp=450 | Etfx=3 | Epad=75  |
 | 210.00 | 10 |  4.00 | 21.00 | 84.10 | 0.82% | Esltp=350 | Etfx=5 | Epad=100 |
 | 210.00 | 10 |  4.00 | 21.00 | 84.10 | 0.82% | Esltp=350 | Etfx=5 | Epad=95  |


 eurusd 160813-20
 | 133.80 | 92 | 1.36 |  1.45 |  94.90 | 0.95% | Esltp=100  | Etfx=0 | Epad=21 |
 | 123.80 | 91 | 1.33 |  1.36 |  96.40 | 0.96% | Esltp=100  | Etfx=0 | Epad=23 |
 | 113.80 | 88 | 1.32 |  1.29 |  97.10 | 0.97% | Esltp=100  | Etfx=0 | Epad=15 |
 | 113.80 | 88 | 1.32 |  1.29 |  97.10 | 0.97% | Esltp=100  | Etfx=0 | Epad=16 |
 | 110.90 | 91 | 1.31 |  1.22 |  69.00 | 0.69% | Esltp=100  | Etfx=0 | Epad=1  |
 | 108.40 | 87 | 1.30 |  1.25 |  90.70 | 0.91% | Esltp=100  | Etfx=0 | Epad=32 |
 | 103.80 | 87 | 1.29 |  1.19 |  97.10 | 0.97% | Esltp=100  | Etfx=0 | Epad=14 |
 | 100.90 | 92 | 1.27 |  1.10 |  69.00 | 0.69% | Esltp=100  | Etfx=0 | Epad=0  |
 |  93.80 | 93 | 1.25 |  1.01 |  69.00 | 0.69% | Esltp=100  | Etfx=0 | Epad=2  |
 |  73.80 | 86 | 1.20 |  0.86 |  74.10 | 0.74% | Esltp=100  | Etfx=0 | Epad=7  |
 |  73.80 | 87 | 1.19 |  0.85 |  94.10 | 0.94% | Esltp=100  | Etfx=0 | Epad=13 |
 |  67.80 | 86 | 1.18 |  0.79 |  91.00 | 0.91% | Esltp=100  | Etfx=0 | Epad=30 |
 |  57.80 | 87 | 1.15 |  0.66 |  90.70 | 0.91% | Esltp=100  | Etfx=0 | Epad=31 |
 |  50.40 |  3 | 2.02 | 16.80 | 126.20 | 1.25% | Esltp=1000 | Etfx=1 | Epad=24 |
 |  50.40 |  3 | 2.02 | 16.80 | 126.20 | 1.25% | Esltp=1000 | Etfx=1 | Epad=50 |

 | 153.80 | 90 | 1.44 |  1.71 |  97.10 | 0.97% | Esltp=100  | Etfx=0 | Epad=20 |
 | 113.80 | 88 | 1.32 |  1.29 |  97.10 | 0.97% | Esltp=100  | Etfx=0 | Epad=15 |
 | 103.20 | 89 | 1.28 |  1.16 |  90.60 | 0.90% | Esltp=100  | Etfx=0 | Epad=25 |
 | 100.90 | 92 | 1.27 |  1.10 |  69.00 | 0.69% | Esltp=100  | Etfx=0 | Epad=0  |
 |  83.80 | 89 | 1.22 |  0.94 |  84.10 | 0.84% | Esltp=100  | Etfx=0 | Epad=5  |
 |  83.80 | 90 | 1.22 |  0.93 |  84.10 | 0.84% | Esltp=100  | Etfx=0 | Epad=10 |
 |  55.60 |  8 | 1.46 |  6.95 |  87.60 | 0.87% | Esltp=400  | Etfx=0 | Epad=60 |
 |  50.40 |  3 | 2.02 | 16.80 | 126.20 | 1.25% | Esltp=1000 | Etfx=1 | Epad=65 |
 |  50.40 |  3 | 2.02 | 16.80 | 126.20 | 1.25% | Esltp=1000 | Etfx=1 | Epad=50 |


 usdjpy 160820-27
 | 208.44 | 14 | 2.98 | 14.89 |  82.17 | 0.80% | Esltp=350 | Etfx=0 | Epad=48 |
 | 208.44 | 14 | 2.98 | 14.89 |  82.17 | 0.80% | Esltp=350 | Etfx=0 | Epad=50 |
 | 158.97 | 11 | 2.99 | 14.45 |  92.00 | 0.90% | Esltp=400 | Etfx=0 | Epad=35 |
 | 158.97 | 11 | 2.99 | 14.45 |  92.00 | 0.90% | Esltp=400 | Etfx=0 | Epad=34 |
 | 158.88 | 11 | 2.99 | 14.44 |  92.00 | 0.90% | Esltp=400 | Etfx=0 | Epad=47 |
 | 158.88 | 11 | 2.99 | 14.44 |  92.00 | 0.90% | Esltp=400 | Etfx=0 | Epad=46 |
 | 158.88 | 11 | 2.99 | 14.44 |  92.00 | 0.90% | Esltp=400 | Etfx=0 | Epad=50 |
 | 158.87 | 10 | 2.99 | 15.89 |  92.00 | 0.90% | Esltp=400 | Etfx=0 | Epad=42 |
 | 158.87 | 10 | 2.99 | 15.89 |  92.00 | 0.90% | Esltp=400 | Etfx=0 | Epad=43 |
 | 158.87 | 10 | 2.99 | 15.89 |  92.00 | 0.90% | Esltp=400 | Etfx=0 | Epad=44 |
 | 154.06 | 11 | 2.82 | 14.01 | 102.88 | 1.00% | Esltp=400 | Etfx=0 | Epad=32 |
 | 151.23 | 19 | 2.09 |  7.96 | 108.95 | 1.06% | Esltp=350 | Etfx=0 | Epad=0  |
 | 151.22 | 19 | 2.09 |  7.96 | 104.99 | 1.02% | Esltp=350 | Etfx=0 | Epad=3  |
 | 148.96 | 17 | 2.24 |  8.76 | 101.86 | 0.99% | Esltp=300 | Etfx=0 | Epad=48 |

 | 208.44 | 14 | 2.98 | 14.89 |  82.17 | 0.80% | Esltp=350 | Etfx=0 | Epad=50 |
 | 185.73 | 17 | 3.09 | 10.93 |  63.22 | 0.63% | Esltp=300 | Etfx=0 | Epad=80 |
 | 180.56 | 12 | 6.24 | 15.05 |  64.73 | 0.65% | Esltp=350 | Etfx=0 | Epad=80 |
 | 151.23 | 19 | 2.09 |  7.96 | 108.95 | 1.06% | Esltp=350 | Etfx=0 | Epad=0  |
 | 149.01 | 17 | 2.24 |  8.77 | 101.84 | 0.99% | Esltp=300 | Etfx=0 | Epad=60 |
 | 148.98 | 17 | 2.24 |  8.76 | 101.86 | 0.99% | Esltp=300 | Etfx=0 | Epad=55 |
 | 148.96 | 17 | 2.24 |  8.76 | 101.86 | 0.99% | Esltp=300 | Etfx=0 | Epad=50 |
 | 145.96 | 13 | 3.11 | 11.23 |  76.57 | 0.75% | Esltp=350 | Etfx=0 | Epad=75 |
 | 145.62 | 14 | 2.40 | 10.40 |  76.57 | 0.75% | Esltp=350 | Etfx=0 | Epad=70 |
 | 138.66 | 14 | 2.32 |  9.90 |  82.17 | 0.80% | Esltp=350 | Etfx=0 | Epad=55 |
 | 138.65 | 14 | 2.32 |  9.90 |  82.17 | 0.80% | Esltp=350 | Etfx=0 | Epad=65 |
 | 138.65 | 14 | 2.32 |  9.90 |  82.17 | 0.80% | Esltp=350 | Etfx=0 | Epad=60 |
 | 138.65 | 13 | 2.32 | 10.67 |  82.17 | 0.80% | Esltp=350 | Etfx=0 | Epad=45 |
 | 138.55 | 14 | 2.32 |  9.90 |  82.27 | 0.81% | Esltp=350 | Etfx=0 | Epad=40 |
 | 136.11 |  5 | 3.13 | 27.22 |  67.36 | 0.66% | Esltp=650 | Etfx=2 | Epad=0  |
 | 136.11 |  5 | 3.13 | 27.22 |  67.36 | 0.66% | Esltp=650 | Etfx=2 | Epad=5  |
 | 136.05 |  5 | 3.13 | 27.21 |  67.36 | 0.66% | Esltp=650 | Etfx=2 | Epad=75 |
 | 136.05 |  5 | 3.13 | 27.21 |  67.36 | 0.66% | Esltp=650 | Etfx=2 | Epad=70 |
 | 136.05 |  5 | 3.13 | 27.21 |  67.36 | 0.66% | Esltp=650 | Etfx=2 | Epad=65 |
 | 136.05 |  5 | 3.13 | 27.21 |  67.36 | 0.66% | Esltp=650 | Etfx=2 | Epad=55 |
 | 136.05 |  5 | 3.13 | 27.21 |  67.36 | 0.66% | Esltp=650 | Etfx=2 | Epad=50 |
 | 136.05 |  5 | 3.13 | 27.21 |  67.36 | 0.66% | Esltp=650 | Etfx=2 | Epad=60 |


 usdjpy 160813-20
 | 259.22 |  6 | 28.61 | 43.20 | 99.88 | 0.97% | Esltp=900 | Etfx=1 | Epad=31 |
 | 259.22 |  6 | 28.61 | 43.20 | 99.88 | 0.97% | Esltp=900 | Etfx=1 | Epad=28 |
 | 259.22 |  6 | 28.61 | 43.20 | 99.88 | 0.97% | Esltp=900 | Etfx=1 | Epad=32 |
 | 259.22 |  6 | 28.61 | 43.20 | 99.88 | 0.97% | Esltp=900 | Etfx=1 | Epad=36 |
 | 259.22 |  6 | 28.61 | 43.20 | 99.88 | 0.97% | Esltp=900 | Etfx=1 | Epad=35 |
 | 259.21 |  6 | 28.60 | 43.20 | 99.88 | 0.97% | Esltp=900 | Etfx=1 | Epad=38 |
 | 259.19 |  6 | 28.60 | 43.20 | 99.88 | 0.97% | Esltp=900 | Etfx=1 | Epad=15 |
 | 259.19 |  6 | 28.60 | 43.20 | 99.88 | 0.97% | Esltp=900 | Etfx=1 | Epad=18 |
 | 259.19 |  6 | 28.60 | 43.20 | 99.88 | 0.97% | Esltp=900 | Etfx=1 | Epad=16 |
 | 259.19 |  7 | 28.60 | 37.03 | 99.88 | 0.97% | Esltp=900 | Etfx=1 | Epad=26 |
 | 259.19 |  6 | 28.60 | 43.20 | 99.88 | 0.97% | Esltp=900 | Etfx=1 | Epad=27 |
 | 259.19 |  6 | 28.60 | 43.20 | 99.88 | 0.97% | Esltp=900 | Etfx=1 | Epad=19 |
 | 259.19 |  6 | 28.60 | 43.20 | 99.88 | 0.97% | Esltp=900 | Etfx=1 | Epad=20 |
 | 259.13 |  6 | 28.31 | 43.19 | 99.88 | 0.97% | Esltp=900 | Etfx=1 | Epad=47 |
 | 259.13 |  6 | 28.31 | 43.19 | 99.88 | 0.97% | Esltp=900 | Etfx=1 | Epad=43 |
 | 259.13 |  6 | 28.31 | 43.19 | 99.88 | 0.97% | Esltp=900 | Etfx=1 | Epad=44 |
 | 259.13 |  6 | 28.60 | 43.19 | 99.88 | 0.97% | Esltp=900 | Etfx=1 | Epad=0  |
 | 257.88 | 20 |  4.44 | 12.89 | 68.16 | 0.68% | Esltp=250 | Etfx=0 | Epad=0  |
 | 206.30 | 10 |  4.16 | 20.63 | 89.20 | 0.89% | Esltp=650 | Etfx=1 | Epad=20 |
 | 206.30 | 10 |  4.16 | 20.63 | 89.20 | 0.89% | Esltp=650 | Etfx=1 | Epad=16 |
 | 206.30 | 10 |  4.16 | 20.63 | 89.20 | 0.89% | Esltp=650 | Etfx=1 | Epad=22 |

 | 259.22 |  6 |  28.61 | 43.20 |  99.88 | 0.97% | Esltp=900 | Etfx=1 | Epad=35  |
 | 259.19 |  7 |  28.60 | 37.03 |  99.88 | 0.97% | Esltp=900 | Etfx=1 | Epad=25  |
 | 259.19 |  6 |  28.60 | 43.20 |  99.88 | 0.97% | Esltp=900 | Etfx=1 | Epad=20  |
 | 259.19 |  6 |  28.60 | 43.20 |  99.88 | 0.97% | Esltp=900 | Etfx=1 | Epad=15  |
 | 259.13 |  6 |  28.31 | 43.19 |  99.88 | 0.97% | Esltp=900 | Etfx=1 | Epad=45  |
 | 259.13 |  6 |  28.60 | 43.19 |  99.88 | 0.97% | Esltp=900 | Etfx=1 | Epad=5   |
 | 259.13 |  6 |  28.60 | 43.19 |  99.88 | 0.97% | Esltp=900 | Etfx=1 | Epad=10  |
 | 259.13 |  6 |  28.60 | 43.19 |  99.88 | 0.97% | Esltp=900 | Etfx=1 | Epad=0   |
 | 259.11 |  6 |  28.30 | 43.18 |  99.88 | 0.97% | Esltp=900 | Etfx=1 | Epad=40  |
 | 257.88 | 20 |   4.44 | 12.89 |  68.16 | 0.68% | Esltp=250 | Etfx=0 | Epad=0   |
 | 251.73 |  6 | 133.49 | 41.95 |  95.83 | 0.93% | Esltp=850 | Etfx=1 | Epad=90  |
 | 244.24 |  5 |  27.01 | 48.85 |  99.88 | 0.97% | Esltp=850 | Etfx=1 | Epad=70  |
 | 244.24 |  5 |  27.01 | 48.85 |  99.88 | 0.97% | Esltp=850 | Etfx=1 | Epad=75  |
 | 244.24 |  5 |  27.01 | 48.85 |  99.88 | 0.97% | Esltp=850 | Etfx=1 | Epad=80  |
 | 244.23 |  6 |  27.01 | 40.71 |  99.88 | 0.97% | Esltp=850 | Etfx=1 | Epad=15  |
 | 244.23 |  7 |  27.01 | 34.89 |  99.88 | 0.97% | Esltp=850 | Etfx=1 | Epad=20  |
 | 243.95 |  6 |  26.18 | 40.66 |  99.89 | 0.97% | Esltp=850 | Etfx=1 | Epad=35  |
 | 243.90 |  5 |  26.17 | 48.78 |  99.89 | 0.97% | Esltp=850 | Etfx=1 | Epad=65  |
 | 243.90 |  5 |  26.17 | 48.78 |  99.89 | 0.97% | Esltp=850 | Etfx=1 | Epad=60  |
 | 243.90 |  5 |  26.17 | 48.78 |  99.89 | 0.97% | Esltp=850 | Etfx=1 | Epad=50  |
 | 243.85 |  6 |  25.91 | 40.64 |  99.89 | 0.97% | Esltp=850 | Etfx=1 | Epad=40  |
 | 232.93 | 19 |   3.33 | 12.26 |  79.65 | 0.80% | Esltp=250 | Etfx=0 | Epad=50  |
 | 219.03 |  5 |   3.42 | 43.81 | 105.53 | 1.04% | Esltp=900 | Etfx=1 | Epad=100 |
 | 219.03 |  5 |   3.42 | 43.81 | 105.53 | 1.04% | Esltp=900 | Etfx=1 | Epad=95  |
 | 206.30 | 10 |   4.16 | 20.63 |  89.20 | 0.89% | Esltp=650 | Etfx=1 | Epad=20  |
 | 200.83 |  7 |   3.35 | 28.69 | 109.81 | 1.09% | Esltp=850 | Etfx=1 | Epad=5   |
 | 200.83 |  7 |   3.35 | 28.69 | 109.81 | 1.09% | Esltp=850 | Etfx=1 | Epad=10  |
 | 200.83 |  7 |   3.35 | 28.69 | 109.81 | 1.09% | Esltp=850 | Etfx=1 | Epad=0   |
 | 200.69 |  5 |   3.35 | 40.14 | 100.47 | 1.00% | Esltp=850 | Etfx=1 | Epad=95  |
 | 200.69 |  5 |   3.35 | 40.14 | 100.47 | 1.00% | Esltp=850 | Etfx=1 | Epad=100 |


 //+------------------------------------------------------------------+
 //|                                                      llpatts.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+

 /*

 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>

 #define sp "  "

 extern int Esltp;
 extern int Etfx;
 extern int Epad;


 /*
 incorporates patterns in multiple tf to determine ntrxit
 */

 int
 tkt=0,
 barsInChart=0,
 bs=-1;
 double
 lt=0.1,oo=0,sl=0,tp=0;
 bool zz;
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 struct tfcombos
 //timeframe combinations
   {
    int               L,S;
   };
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 struct status
 //single timeframe situation
   {
    //hi and lo info
    int               hibar,lobar;
    double            hival,loval;

    //patterns HAL,LAH,HLA,LHA,AHL,ALH
    string            pattern;

    //deltas between hilo and point movement from last turn
    double            Dhilo,Dpomo;

    //longterm trend
    double            ltrend;
 /*
    //bs,oo,sl,tp
    int               bs;
    double            oo,sl,tp;

    //orderselect info
    double            orderprofit;
    int               ordertype;
 */
   };
 tfcombos tfc[6];
 status Ss,Ls;
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OnInit()
   {
    tfc[0].S=01;tfc[0].L=05;
    tfc[1].S=05;tfc[1].L=30;
    tfc[2].S=05;tfc[2].L=60;
    tfc[3].S=15;tfc[3].L=60;
    tfc[4].S=30;tfc[4].L=240;
    tfc[5].S=60;tfc[5].L=240;
    return(INIT_SUCCEEDED);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {
    //getparameters(1);
    int tfx=Etfx;
    getstatus(tfc[tfx].S,Ss);showstatus("S",1000,Ss);
    getstatus(tfc[tfx].L,Ls);showstatus("L",1200,Ls);

    if(CanDoTrade())
      {
       double sltp=Esltp*Point;
       if(Ls.pattern=="HAL" && Ss.pattern=="HAL") {bs=0;oo=Ask;sl=oo-sltp;tp=oo+sltp;}
       if(Ls.pattern=="LAH" && Ss.pattern=="LAH") {bs=1;oo=Bid;sl=oo+sltp;tp=oo-sltp;}
       tkt=OrderSend(Symbol(),bs,lt,oo,0,sl,tp);
      }
    if(OrderSelect(tkt,SELECT_BY_TICKET))
      {
       switch(OrderType())
         {
          case  0:
             if(Ls.pattern=="HLA" || Ls.pattern=="ALH") zz=OrderClose(tkt,lt,oo,0);
             break;
          case  1:
             if(Ls.pattern=="LHA" || Ls.pattern=="AHL") zz=OrderClose(tkt,lt,oo,0);
             break;
         }

      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void getstatus(int tf,status &s)
 //finds various aspects of Sstatus
   {
    bool truehi=false,truelo=false;
    double Dhiloinc,pad=Epad*Point;
    int Dhilobar=1,barstep=12,barF=1,barI=barF+barstep;

 //get hilo info   
    while(truehi==false && truelo==false)
      {
       maxmin(tf,barI,barF,s.hibar,s.hival,s.lobar,s.loval);
       truehi=turnpoint(tf,s.hibar,s.hival,"hi");
       truelo=turnpoint(tf,s.lobar,s.loval,"lo");
       barF=barI+1;
       barI=barF+barstep;
      }
     
    //BUY: HAL,LHA,AHL  SEL:LAH,HLA,ALH
    //Rangers
    if((Bid<s.hival && Bid>s.loval+pad) && s.hibar>s.lobar) {s.pattern="HAL";return;}
    if((Bid<s.hival-pad && Bid>s.loval) && s.lobar>s.hibar) {s.pattern="LAH";return;}
    //Explorers
    if(Bid>s.hival+pad && s.lobar>s.hibar) {s.pattern="LHA";return;}
    if(Bid<s.loval-pad && s.hibar>s.lobar) {s.pattern="HLA";return;}
    //Breakouts  
    if(Bid>s.hival+pad && s.hibar>s.lobar) {s.pattern="AHL";return;}
    if(Bid<s.loval-pad && s.lobar>s.hibar) {s.pattern="ALH";return;}   

    if(s.lobar!=s.hibar) Dhilobar=s.lobar-s.hibar;
    Dhiloinc=Dpts(s.loval,s.hival)/Dhilobar;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void showstatus(string LS,int colstart,status &s)
 //shows status
   {
 //initialize line values
    int l[5];ArrayInitialize(l,0);for(int i=1;i<5;i++) l[i]=i*12;

    display(LS,s.pattern,0,colstart,l[1],Blue);

   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double ltrend(int tf,int bI,int bF)
 //calculates longterm trend
   {
    double
    vI=medianvalue(iHigh(NULL,tf,bI),iLow(NULL,tf,bI)),
    vF=medianvalue(iHigh(NULL,tf,bF),iLow(NULL,tf,bF));
    return incline(bI,vI,bF,vF);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double medianvalue(double hi,double lo)
 //calculates midpoint from hi and lo
   {
    return 0.5*(hi+lo);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool turnpoint(int tf,int bar,double val,string hiloitem)
 //determines if hilo are true turning points
   {
    double v[5];

    v[0]=val;

    if(hiloitem=="hi")
      {
       v[1]=iHigh(NULL,tf,bar+2);
       v[2]=iHigh(NULL,tf,bar+1);
       v[3]=iHigh(NULL,tf,bar-1);
       v[4]=iHigh(NULL,tf,bar-2);
       if(ArrayMaximum(v)==0) return true;
      }
    if(hiloitem=="lo")
      {
       v[1]=iLow(NULL,tf,bar+2);
       v[2]=iLow(NULL,tf,bar+1);
       v[3]=iLow(NULL,tf,bar-1);
       v[4]=iLow(NULL,tf,bar-2);
       if(ArrayMinimum(v)==0) return true;
      }
    return false;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
   {
    maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
    maxval=iHigh(NULL,tf,maxbar);
    minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
    minval=iLow(NULL,tf,minbar);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
   {
    return (pF-pI)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
   {
    int
    Dbar=bI-bF;
    return Dpts(vI,vF)/Dbar;
   }
 //+------------------------------------------------------------------+
 //|TRADEABLE                                                         |
 //+------------------------------------------------------------------+
 bool CanDoTrade()
 //checks if trading is ok via new bar, total orders, spread
   {
    int aords,pords;
    bool
    newbarOK=(barsInChart<Bars),
    spreadOK=(MarketInfo(NULL,MODE_SPREAD)<9),
    noordsOK=(OrdersForSymbol(aords,pords)==0);
    barsInChart=Bars;
    return (newbarOK && spreadOK && noordsOK);
   }
 //+------------------------------------------------------------------+
 //|TRADEABLE                                                         |
 //+------------------------------------------------------------------+
 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
   {
    aords=0;pords=0;
    for(int p=OrdersTotal()-1;p>=0;p--)
       if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
         {
          if(OrderType()>1 && OrderType()<6)
             pords++;
          if(OrderType()==OP_BUY || OrderType()==OP_SELL)
             aords++;
         }
    return aords+pords;
   }
 //+------------------------------------------------------------------+
 //|DISPLAY                                                           |
 //+------------------------------------------------------------------+
 void showlasterror()
 //prints last error message
   {
    int
    errnum=GetLastError();
    if(errnum!=ERR_NO_ERROR)
       Comment(errnum,sp,ErrorDescription(errnum));
    else
       Comment(ERR_NO_ERROR);
   }
 //+------------------------------------------------------------------+
 //|DISPLAY                                                           |
 //+------------------------------------------------------------------+
 string YI2S(int x)
 //integer to string
   {
    return IntegerToString(x);
   }
 //+------------------------------------------------------------------+
 //|DISPLAY                                                           |
 //+------------------------------------------------------------------+
 string YD2S(double x,int d)
 //double to string
   {
    return DoubleToString(x,d);
   }
 //+------------------------------------------------------------------+
 //|DISPLAY                                                           |
 //+------------------------------------------------------------------+
 void display(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
   {
    ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
    ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
    ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
    ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
    ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void getparameters(int n)
 //sets the parameters for trading
   {
    switch(n)
      {
       case  1:
 Esltp=400; 	Etfx=4;
          break;
       case  2:
 Esltp=150; 	Etfx=0;
          break;
       case  3:
 Esltp=1000; Etfx=1;
          break;
       case  4:

          break;
       case  5:

          break;
       case  6:

          break;
       case  7:

          break;
       case  8:

          break;
       case  9:

          break;
       default:
          break;
      }
   }

 //+------------------------------------------------------------------+

*** nu
 from llpomo effort it seems as though LAHHAL pattern works best
 we see why here as well as the conceptual flaw:
 since lahhal performed significantly better than the others, we will use it.
 there is a conceptual flaw though that shows up in trending markets:
 consider uptrend
 1. you want nbu
 2. however, if you get into ubn, sl gets hit
 3. now if price goes up, you can't get nbu or in because there is no unb
 4. but if price goes down a bit you immediately get ubn

 getting in the wrong way can be disasterous in a trend

 in a range, it doesn't matter so much because nbu and ubn both have good chances

 solution would seem to be to either introduce unb and nbu or utilize fivonacci as incline filter for nu.

**** code with Etp,Etfsx,EbI,Eltrend
 | 185.00 | 14 | 3.37 | 0.71% | Etp=260 | Etfsx=0 | EbI=30 | Eltrendval=0.4 |
 | 180.00 |  8 | 5.29 | 0.55% | Etp=370 | Etfsx=1 | EbI=25 | Eltrendval=0.9 |
 | 173.60 |  4 | 0.00 | 0.61% | Etp=570 | Etfsx=1 | EbI=25 | Eltrendval=0.8 |
 | 154.60 |  8 | 4.56 | 0.66% | Etp=330 | Etfsx=1 | EbI=15 | Eltrendval=0.4 |
 | 151.50 | 23 | 2.13 | 0.50% | Etp=190 | Etfsx=0 | EbI=60 | Eltrendval=0.6 |
 | 145.00 | 13 | 2.81 | 0.60% | Etp=250 | Etfsx=1 | EbI=50 | Eltrendval=0.7 |
 | 138.80 |  4 | 5.75 | 0.81% | Etp=560 | Etfsx=0 | EbI=30 | Eltrendval=0.3 |
 | 136.20 |  4 | 9.11 | 0.50% | Etp=510 | Etfsx=3 | EbI=20 | Eltrendval=0.7 |
 | 136.00 |  6 | 3.62 | 0.64% | Etp=470 | Etfsx=1 | EbI=45 | Eltrendval=0.7 |
 | 127.20 |  4 | 8.57 | 0.50% | Etp=480 | Etfsx=3 | EbI=45 | Eltrendval=0.9 |
 | 126.00 |  3 | 0.00 | 0.61% | Etp=570 | Etfsx=3 | EbI=40 | Eltrendval=0.8 |
 | 126.00 |  3 | 0.00 | 0.61% | Etp=570 | Etfsx=3 | EbI=25 | Eltrendval=0.4 |
 | 125.10 |  5 | 3.55 | 1.05% | Etp=490 | Etfsx=0 | EbI=60 | Eltrendval=0.4 |
 | 124.80 |  4 | 5.95 | 0.55% | Etp=500 | Etfsx=2 | EbI=50 | Eltrendval=0.7 | 


 eurusd 160817-24
 | 209.00 |  7 | 29.86 | 0.26% | Etp=330 | Etfsx=1 | EbI=20 | Eltrendval=1 |
 | 208.20 |  8 | 26.02 | 0.26% | Etp=280 | Etfsx=1 | EbI=20 | Eltrendval=1 |
 | 204.20 |  7 | 29.17 | 0.26% | Etp=320 | Etfsx=1 | EbI=20 | Eltrendval=1 |
 | 199.20 | 14 | 14.23 | 0.26% | Etp=170 | Etfsx=1 | EbI=20 | Eltrendval=1 |
 | 198.20 |  7 | 28.31 | 0.26% | Etp=310 | Etfsx=1 | EbI=20 | Eltrendval=1 |

 compare successful parameters with unsuccessful ones
 | 209.00 |  7 |  0.00 | 0.26% | Etp=330 | Etfsx=1 | EbI=20 | Eltrendval=1  |
 | 208.20 |  8 |  0.00 | 0.26% | Etp=280 | Etfsx=1 | EbI=20 | Eltrendval=1  |
 | 204.20 |  7 |  0.00 | 0.26% | Etp=320 | Etfsx=1 | EbI=20 | Eltrendval=1  |
 | 199.20 | 14 | 12.72 | 0.26% | Etp=170 | Etfsx=1 | EbI=20 | Eltrendval=1  |
 | 198.20 |  7 |  0.00 | 0.26% | Etp=310 | Etfsx=1 | EbI=20 | Eltrendval=1  |
 | 194.20 |  8 |  0.00 | 0.33% | Etp=260 | Etfsx=1 | EbI=20 | Eltrendval=2  |
 | 194.20 |  8 |  0.00 | 0.33% | Etp=260 | Etfsx=1 | EbI=20 | Eltrendval=1  |
 | 189.40 |  6 |  0.00 | 0.31% | Etp=330 | Etfsx=0 | EbI=50 | Eltrendval=1  |
 | 188.30 |  9 |  0.00 | 0.33% | Etp=220 | Etfsx=1 | EbI=20 | Eltrendval=1  |
 | 180.30 |  9 |  0.00 | 0.33% | Etp=210 | Etfsx=1 | EbI=20 | Eltrendval=2  |
 | 180.30 |  9 |  0.00 | 0.33% | Etp=210 | Etfsx=1 | EbI=20 | Eltrendval=1  |
 | 180.20 |  9 |  7.44 | 0.44% | Etp=280 | Etfsx=1 | EbI=40 | Eltrendval=1  |
 |   0.50 |  5 |  1.01 | 0.91% | Etp=380 | Etfsx=0 | EbI=20 | Eltrendval=4  |
 |   0.40 | 26 |  1.01 | 0.34% | Etp=50  | Etfsx=3 | EbI=50 | Eltrendval=9  |
 |   0.30 | 10 |  1.00 | 0.58% | Etp=210 | Etfsx=2 | EbI=50 | Eltrendval=3  |
 |   0.30 |  4 |  1.01 | 0.22% | Etp=130 | Etfsx=0 | EbI=20 | Eltrendval=8  |
 |   0.20 |  6 |  1.00 | 0.89% | Etp=310 | Etfsx=0 | EbI=50 | Eltrendval=2  |
 |   0.20 |  6 |  1.00 | 0.91% | Etp=320 | Etfsx=0 | EbI=50 | Eltrendval=2  |
 |   0.20 | 16 |  1.00 | 0.44% | Etp=120 | Etfsx=2 | EbI=20 | Eltrendval=4  |
 |   0.20 | 14 |  1.00 | 0.37% | Etp=120 | Etfsx=2 | EbI=20 | Eltrendval=5  |
 |   0.10 |  4 |  1.00 | 0.53% | Etp=260 | Etfsx=2 | EbI=40 | Eltrendval=7  |
 |   0.10 |  4 |  1.00 | 0.34% | Etp=250 | Etfsx=0 | EbI=20 | Eltrendval=7  |
 |   0.10 |  4 |  1.00 | 0.48% | Etp=330 | Etfsx=3 | EbI=40 | Eltrendval=12 |
 |   0.10 | 12 |  1.00 | 0.71% | Etp=190 | Etfsx=2 | EbI=60 | Eltrendval=4  |
 |   0.10 |  6 |  1.00 | 0.26% | Etp=80  | Etfsx=2 | EbI=60 | Eltrendval=7  |
 |   0.10 |  4 |  1.00 | 0.34% | Etp=150 | Etfsx=4 | EbI=20 | Eltrendval=8  |
 |   0.10 | 28 |  1.00 | 0.26% | Etp=40  | Etfsx=4 | EbI=10 | Eltrendval=5  |
 |   0.00 |  6 |  1.00 | 0.44% | Etp=160 | Etfsx=4 | EbI=10 | Eltrendval=1  |
 |   0.00 |  2 |  1.00 | 0.54% | Etp=250 | Etfsx=4 | EbI=10 | Eltrendval=8  |
 |   0.00 |  4 |  1.00 | 0.82% | Etp=330 | Etfsx=0 | EbI=60 | Eltrendval=3  |
 |   0.00 |  4 |  1.00 | 0.84% | Etp=330 | Etfsx=3 | EbI=10 | Eltrendval=1  |
 |   0.00 |  8 |  1.00 | 0.43% | Etp=260 | Etfsx=2 | EbI=20 | Eltrendval=1  |
 |   0.00 |  8 |  1.00 | 0.42% | Etp=250 | Etfsx=2 | EbI=20 | Eltrendval=1  |
 |   0.00 |  4 |  1.00 | 0.85% | Etp=450 | Etfsx=2 | EbI=40 | Eltrendval=3  |
 |   0.00 |  2 |  1.00 | 0.58% | Etp=440 | Etfsx=4 | EbI=40 | Eltrendval=2  |
 |   0.00 |  2 |  1.00 | 0.60% | Etp=310 | Etfsx=4 | EbI=10 | Eltrendval=4  |
 |   0.00 |  8 |  1.00 | 0.37% | Etp=210 | Etfsx=2 | EbI=20 | Eltrendval=5  |
 |   0.00 |  4 |  1.00 | 0.92% | Etp=440 | Etfsx=1 | EbI=40 | Eltrendval=3  |
 |   0.00 | 12 |  1.00 | 0.40% | Etp=90  | Etfsx=4 | EbI=10 | Eltrendval=1  |
 |   0.00 |  2 |  1.00 | 0.58% | Etp=440 | Etfsx=4 | EbI=40 | Eltrendval=3  |
 |   0.00 |  2 |  1.00 | 0.63% | Etp=340 | Etfsx=4 | EbI=10 | Eltrendval=4  |
 |   0.00 |  2 |  1.00 | 0.58% | Etp=440 | Etfsx=4 | EbI=30 | Eltrendval=3  |




 usdjpy 160817-24
 | 310.26 | 8 | 18.58 | 0.57% | Etp=470 | Etfsx=1 | EbI=10 | Eltrendval=2.5 |
 | 310.26 | 8 | 18.58 | 0.57% | Etp=470 | Etfsx=1 | EbI=10 | Eltrendval=2.4 |
 | 310.26 | 8 | 18.58 | 0.57% | Etp=470 | Etfsx=1 | EbI=10 | Eltrendval=2.6 |
 | 310.26 | 8 | 18.58 | 0.57% | Etp=470 | Etfsx=1 | EbI=10 | Eltrendval=2.2 |
 | 303.27 | 8 | 18.18 | 0.42% | Etp=460 | Etfsx=1 | EbI=10 | Eltrendval=2.6 |
 | 303.27 | 8 | 18.18 | 0.42% | Etp=460 | Etfsx=1 | EbI=10 | Eltrendval=2.5 |
 | 303.27 | 8 | 18.18 | 0.42% | Etp=460 | Etfsx=1 | EbI=10 | Eltrendval=2.4 |
 | 296.31 | 8 | 17.79 | 0.42% | Etp=450 | Etfsx=1 | EbI=10 | Eltrendval=2.5 |


 compare successful parameters with unsuccessful ones
 | 310.26 |   8 | 18.58 | 0.57% | Etp=470 | Etfsx=1 | EbI=10 | Eltrendval=2.5  |
 | 310.26 |   8 | 18.58 | 0.57% | Etp=470 | Etfsx=1 | EbI=10 | Eltrendval=2.4  |
 | 310.26 |   8 | 18.58 | 0.57% | Etp=470 | Etfsx=1 | EbI=10 | Eltrendval=2.6  |
 | 310.26 |   8 | 18.58 | 0.57% | Etp=470 | Etfsx=1 | EbI=10 | Eltrendval=2.2  |
 | 303.27 |   8 | 18.18 | 0.42% | Etp=460 | Etfsx=1 | EbI=10 | Eltrendval=2.6  |
 | 303.27 |   8 | 18.18 | 0.42% | Etp=460 | Etfsx=1 | EbI=10 | Eltrendval=2.5  |
 | 303.27 |   8 | 18.18 | 0.42% | Etp=460 | Etfsx=1 | EbI=10 | Eltrendval=2.4  |
 | 296.31 |   8 | 17.79 | 0.42% | Etp=450 | Etfsx=1 | EbI=10 | Eltrendval=2.5  |
 | 296.31 |   8 | 17.79 | 0.42% | Etp=450 | Etfsx=1 | EbI=10 | Eltrendval=2.6  |
 | 296.31 |   8 | 17.79 | 0.42% | Etp=450 | Etfsx=1 | EbI=10 | Eltrendval=2.4  |
 | 289.33 |   8 | 17.39 | 0.42% | Etp=440 | Etfsx=1 | EbI=10 | Eltrendval=2.6  |
 | 289.33 |   8 | 17.39 | 0.42% | Etp=440 | Etfsx=1 | EbI=10 | Eltrendval=2.5  |
 | 289.33 |   8 | 17.39 | 0.42% | Etp=440 | Etfsx=1 | EbI=10 | Eltrendval=2.4  |
 | 282.36 |   8 | 17.00 | 0.42% | Etp=430 | Etfsx=1 | EbI=10 | Eltrendval=2.4  |
 | 282.36 |   8 | 17.00 | 0.42% | Etp=430 | Etfsx=1 | EbI=10 | Eltrendval=2.5  |
 |   0.08 |   2 |  1.00 | 0.54% | Etp=410 | Etfsx=0 | EbI=10 | Eltrendval=7.9  |
 |   0.08 |  16 |  1.00 | 0.61% | Etp=140 | Etfsx=2 | EbI=10 | Eltrendval=8    |
 |   0.08 |   4 |  1.00 | 1.19% | Etp=550 | Etfsx=1 | EbI=60 | Eltrendval=7.4  |
 |   0.07 |   8 |  1.00 | 0.50% | Etp=200 | Etfsx=3 | EbI=40 | Eltrendval=6    |
 |   0.07 |   6 |  1.00 | 0.35% | Etp=220 | Etfsx=3 | EbI=10 | Eltrendval=12.9 |
 |   0.01 |   2 |  1.00 | 0.11% | Etp=80  | Etfsx=0 | EbI=50 | Eltrendval=5.7  |
 |   0.01 |   2 |  1.00 | 0.08% | Etp=50  | Etfsx=0 | EbI=40 | Eltrendval=9.4  |
 |   0.01 |   2 |  1.00 | 0.26% | Etp=200 | Etfsx=2 | EbI=40 | Eltrendval=12.4 |
 |   0.00 |   2 |  1.00 | 0.07% | Etp=40  | Etfsx=0 | EbI=50 | Eltrendval=8.8  |
 |   0.00 |   2 |  1.00 | 0.15% | Etp=80  | Etfsx=0 | EbI=50 | Eltrendval=11.7 |
 |   0.00 |   2 |  1.00 | 0.15% | Etp=80  | Etfsx=0 | EbI=50 | Eltrendval=12   |
 |   0.00 |   2 |  1.00 | 0.08% | Etp=40  | Etfsx=0 | EbI=50 | Eltrendval=11.2 |
 |   0.00 |   2 |  1.00 | 0.02% | Etp=10  | Etfsx=0 | EbI=20 | Eltrendval=8.2  |
 |   0.00 |   6 |  1.00 | 0.05% | Etp=20  | Etfsx=0 | EbI=20 | Eltrendval=6.5  |
 |   0.00 |   2 |  1.00 | 0.15% | Etp=80  | Etfsx=0 | EbI=50 | Eltrendval=11.9 |
 |   0.00 |   2 |  1.00 | 0.12% | Etp=90  | Etfsx=0 | EbI=40 | Eltrendval=9.9  |
 |   0.00 |   2 |  1.00 | 0.02% | Etp=10  | Etfsx=0 | EbI=20 | Eltrendval=8    |
 |   0.00 |   2 |  1.00 | 0.06% | Etp=30  | Etfsx=0 | EbI=30 | Eltrendval=9.1  |
 |   0.00 |   2 |  1.00 | 0.02% | Etp=10  | Etfsx=0 | EbI=40 | Eltrendval=13.1 |
 |   0.00 |   2 |  1.00 | 0.30% | Etp=240 | Etfsx=2 | EbI=40 | Eltrendval=12.6 |


 //+------------------------------------------------------------------+
 //|                                                           nu.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+

 /*
 clean up program
 incorporate incline detection which is essential for trending markets
 entry for LAHHAL should not be too close to turning point
 adapt so program detects symbol and uses appropriate parameters
 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>


 #define sp "  "

 /*
 incorporates the npuupn pattern to determine entries
 */

 extern int Etp;
 extern int Etfsx;
 extern int EbI;
 extern double Eltrendval;

 int tfs[5],
 Gtkt=0,
 GbarsInChart=0;
 double
 Glt=0.1;
 bool zz;
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 struct status
 //single timeframe situation
   {
    //hi and lo info
    int               hibar,lobar;
    double            hival,loval;

    //patterns nbu,ubn,nub,unb,bnu,bun
    string            pattern;

    //deltas between hilo and point movement from last turn
    double            Dhilo,Dpomo;

    //longterm trend
    double            ltrend;

    //bs,oo,sl,tp
    int               bs;
    double            oo,sl,tp;

    //orderselect info
    double            orderprofit;
    int               ordertype;
   };

 status Gs;
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OnInit()
   {
    tfs[0]=1;tfs[1]=5;tfs[2]=15;tfs[3]=30;tfs[4]=60;
    return(INIT_SUCCEEDED);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {
    getparameters(01);
    int tf=tfs[Etfsx];
    getstatus(tf,Gs);

    if(CanDoTrade())
       Gtkt=OrderSend(Symbol(),Gs.bs,Glt,Gs.oo,0,Gs.sl,Gs.tp,Gs.pattern);

   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void getstatus(int tfx,status &s)
 //finds various aspects of status
   {
    double
    tp=Etp*Point;
    int l[5],
    bF=1,
    col=1200,spc=60,
    tkt=Gtkt;

 //initialize line spacing
    ArrayInitialize(l,0);
    for(int i=1;i<5;i++) l[i]=i*12;

 //get hilo info
    hilo(tfx,s.hibar,s.hival,s.lobar,s.loval,s.pattern);
    int Dhilobar=s.lobar-s.hibar;
    if(Dhilobar==0) Dhilobar=1;
    double Dhiloinc=Dpts(s.loval,s.hival)/Dhilobar;

 //get longterm trend
    s.ltrend=ltrend(tfx,EbI,bF);

 //fill oo,sl,tp
    if(s.pattern=="nbu" && s.ltrend>+Eltrendval) {s.bs=0;s.oo=Ask;s.sl=s.oo-tp;s.tp=s.oo+tp;}
    if(s.pattern=="ubn" && s.ltrend<-Eltrendval) {s.bs=1;s.oo=Bid;s.sl=s.oo+tp;s.tp=s.oo-tp;}
 //if(s.Spattern=="AHL") {s.bs=0;s.oo=Ask;s.sl=s.oo-tp;s.tp=s.oo+tp;}
 //if(s.Spattern=="ALH") {s.bs=1;s.oo=Bid;s.sl=s.oo+tp;s.tp=s.oo-tp;}
 //if(s.Spattern=="LHA") {s.bs=0;s.oo=Ask;s.sl=s.Sloval;s.tp=s.oo+tp;}
 //if(s.Spattern=="HLA") {s.bs=1;s.oo=Bid;s.sl=s.Shival;s.tp=s.oo-tp;}

 //orderselect info
    if(OrderSelect(Gtkt,SELECT_BY_TICKET))
      {
       s.orderprofit=OrderProfit();
       s.ordertype=OrderType();
      }

 //display status
    display("par","params "+YI2S(Etp)+" "+YI2S(Etfsx)+" "+YI2S(EbI)+" "+YD2S(s.ltrend,2),2,0,5,Red);

    display("tfx","tfx",0,col,l[1],Blue);
    display("bar","bar",0,col,l[2],Blue);
    display("val","val",0,col,l[3],Blue);
    display("pat","pat",0,col,l[4],Blue);

    display("tfx1",YI2S(tfx),0,col+spc,l[1],Blue);
    display("bar1",YI2S(s.hibar)+","+YI2S(s.lobar)+"="+YI2S(Dhilobar),0,col+spc,l[2],Blue);
    display("val1",YD2S(s.hival,5)+","+YD2S(s.loval,5)+"=>"+YD2S(Dhiloinc,0),0,col+spc,l[3],Blue);
    display("pat1",s.pattern,0,col+spc,l[4],Blue);

 //display("orderprofit","OrderProfit = "+DoubleToStr(s.orderprofit,2),1,200,90,Green);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double ltrend(int tf,int bI,int bF)
 //calculates longterm trend
   {
    double
    vI=medianvalue(iHigh(NULL,tf,bI),iLow(NULL,tf,bI)),
    vF=medianvalue(iHigh(NULL,tf,bF),iLow(NULL,tf,bF));
    return incline(bI,vI,bF,vF);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double medianvalue(double hi,double lo)
 //calculates midpoint from hi and lo
   {
    return 0.5*(hi+lo);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void hilo(int tf,int &hibar,double &hival,int &lobar,double &loval,string &pattern)
 //determines legitimate hilo bars with values and identifies HAL,LAH,LHA,HLA
   {
    int barstep=12,barF=1,barI=barF+barstep;
    bool leghi=false,leglo=false;

    while(leghi==false && leglo==false)
      {
       maxmin(tf,barI,barF,hibar,hival,lobar,loval);
       leghi=turnpoint(tf,hibar,hival,"hi");
       leglo=turnpoint(tf,lobar,loval,"lo");
       barF=barI+1;
       barI=barF+barstep;
      }
    if((Bid<hival && Bid>loval) && hibar>lobar) {pattern="nbu";return;}
    if((Bid<hival && Bid>loval) && lobar>hibar) {pattern="ubn";return;}
    if(Bid>hival && hibar>lobar) {pattern="bnu";return;}
    if(Bid<loval && lobar>hibar) {pattern="bun";return;}
    if(Bid<loval && hibar>lobar) {pattern="nub";return;}
    if(Bid>hival && lobar>hibar) {pattern="unb";return;}
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool turnpoint(int tf,int bar,double val,string hiloitem)
 //determines if hilo are true turning points
   {
    double v[5];

    v[0]=val;

    if(hiloitem=="hi")
      {
       v[1]=iHigh(NULL,tf,bar+2);
       v[2]=iHigh(NULL,tf,bar+1);
       v[3]=iHigh(NULL,tf,bar-1);
       v[4]=iHigh(NULL,tf,bar-2);
       if(ArrayMaximum(v)==0) return true;
      }
    if(hiloitem=="lo")
      {
       v[1]=iLow(NULL,tf,bar+2);
       v[2]=iLow(NULL,tf,bar+1);
       v[3]=iLow(NULL,tf,bar-1);
       v[4]=iLow(NULL,tf,bar-2);
       if(ArrayMinimum(v)==0) return true;
      }
    return false;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void getparameters(int n)
 //sets the parameters for trading
   {
    switch(n)
      {
       case  01:
          Etp=370;    Etfsx=1;    EbI=25;    Eltrendval=0.9;
          break;
       case  02:
          Etp=330;    Etfsx=1;    EbI=15;    Eltrendval=0.4;
          break;
       case  03:
          Etp=510;    Etfsx=3;    EbI=20;    Eltrendval=0.7;

          break;
       case  04:

          break;
       case  05:

          break;
       case  06:

          break;
       case  07:

          break;
       case  08:

          break;
       case  09:

          break;
       case  10:

          break;
       case  11:

          break;
       case  12:

          break;
       default:
          break;
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
   {
    maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
    maxval=iHigh(NULL,tf,maxbar);
    minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
    minval=iLow(NULL,tf,minbar);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
   {
    return (pF-pI)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
   {
    int
    Dbar=bI-bF;
    return Dpts(vI,vF)/Dbar;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool CanDoTrade()
 //checks if trading is ok via new bar, total orders, spread
   {
    int aords,pords;
    bool
    newbarOK=(GbarsInChart<Bars),
    spreadOK=(MarketInfo(NULL,MODE_SPREAD)<9),
    noordsOK=(OrdersForSymbol(aords,pords)==0);
    GbarsInChart=Bars;
    return (newbarOK && spreadOK && noordsOK);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
   {
    aords=0;pords=0;
    for(int p=OrdersTotal()-1;p>=0;p--)
       if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
         {
          if(OrderType()>1 && OrderType()<6)
             pords++;
          if(OrderType()==OP_BUY || OrderType()==OP_SELL)
             aords++;
         }
    return aords+pords;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void showlasterror()
 //prints last error message
   {
    int
    errnum=GetLastError();
    if(errnum!=ERR_NO_ERROR)
       Comment(errnum,sp,ErrorDescription(errnum));
    else
       Comment(ERR_NO_ERROR);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 string YI2S(int x)
 //integer to string
   {
    return IntegerToString(x);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 string YD2S(double x,int d)
 //double to string
   {
    return DoubleToString(x,d);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void display(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
   {
    ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
    ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
    ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
    ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
    ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
   }

 //+------------------------------------------------------------------+
  
*** llpomo
 parallel point movement - a point version of parama
 this removes the conceptual flaw of low slopes

 6 patterns for price and bar positions

 Rangers
 - HAL: H>L A btn
 H
   A
  L
 - LAH: L>H A btn
  H
   A
 L

 Explorers
 - HLA: H>L A<L
 H
  L
   A
 - LHA: L>H A>H
   A
  H
 L

 Breakouts
 - AHL: H>L A>H 
   A
 H
  L
 - ALH: L>H A<L
  H
 L
   A  


 R: HAL & LAH indicate ranger movement, so ntr when A is x from nearest.
 E: HLA & LHA indicate strong directional movement, so ntr right away
 B: AHL & ALH indicate breakout from range, so ntr is ok


 individual testing goals:
 see which patterns perform consistently to give minimal profit in which tfs
 therefore, sl set below turning with tp equal size.

 1. test B with sl at turning, then tp=sl
 2. test E with sl at turning, then tp=sl
 3. test R with ntr x from turning, then tp=sl

 R better than E better than B
 testing R on various months in different tfs with varying tp produced interesting results which need to be understood properly

**** code basic testing E
 //+------------------------------------------------------------------+
 //|                                                       llpomo.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+

 /*
 optimize is small time segments and identify useable parameters
 understand what is happening with the program and parameters
 get more data for other pairs to test
 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #define sp "  "

 /*

 */

 extern int Etp;

 int tfs[5],
 GbF=1,
 GbI=3,
 Gtkt=0,
 GbarsInChart=0,
 GtimeframeIndex=0;
 double
 Glt=0.1;
 bool zz;
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 struct status
 //Large and Small timeframe situation
   {
    //hi and lo info
    int               Lhibar,Shibar,Llobar,Slobar;
    double            Lhival,Lloval,Shival,Sloval;

    //patterns HAL,LAH,SHA,HLA
    string            Lpattern,Spattern;

    //deltas between hilo and point movement from last turn
    double            LDhilo,SDhilo;
    double            LDpomo,SDpomo;

    //bs
    int               bs;
    double            oo,sl,tp;

    //orderselect info
    double            orderprofit;
    int               ordertype;
   };

 status Gs;
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OnInit(){return(INIT_SUCCEEDED);}
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {
    int Ltf=5,Stf=1;

    getstatus(Ltf,Stf,Gs);

    if(CanDoTrade(GbarsInChart))
       Gtkt=OrderSend(Symbol(),Gs.bs,Glt,Gs.oo,0,Gs.sl,Gs.tp);

   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void getstatus(int Ltfx,int Stfx,status &s)
 //finds various aspects of status
   {
    double
    tp=Etp*Point;
    int
    Lcol=1000,Scol=1200,spc=60,
    l1=10,l2=20,l3=30,l4=40,l5=50,
    tkt=Gtkt,
    bF=GbF,
    bI=GbI;


 //get hilo info
    hilo(Ltfx,s.Lhibar,s.Lhival,s.Llobar,s.Lloval,s.Lpattern);
    hilo(Stfx,s.Shibar,s.Shival,s.Slobar,s.Sloval,s.Spattern);
    int DLhilobar=s.Llobar-s.Lhibar,DShilobar=s.Slobar-s.Shibar;
    double DLhiloinc=Dpts(s.Lloval,s.Lhival)/DLhilobar,DShiloinc=Dpts(s.Sloval,s.Shival)/DShilobar;

 //fill oo,sl,tp
    if(s.Spattern=="LHA") {s.bs=0;s.oo=Ask;s.sl=s.Sloval;s.tp=s.oo+tp;}//Dpts(s.sl,s.oo)*Point;}
    if(s.Spattern=="HLA") {s.bs=1;s.oo=Bid;s.sl=s.Shival;s.tp=s.oo-tp;}//Dpts(s.oo,s.sl)*Point;}

 //orderselect info
    if(OrderSelect(Gtkt,SELECT_BY_TICKET))
      {
       s.orderprofit=OrderProfit();
       s.ordertype=OrderType();
      }

 //display status

    display("tfx","tfx",0,Lcol,l1,Blue);
    display("bar","bar",0,Lcol,l2,Blue);
    display("val","val",0,Lcol,l3,Blue);
    display("pat","pat",0,Lcol,l4,Blue);

    display("Ltfx",YI2S(Ltfx),0,Lcol+spc,l1,Blue);
    display("Lbar",YI2S(s.Lhibar)+","+YI2S(s.Llobar)+"="+YI2S(DLhilobar),0,Lcol+spc,l2,Blue);
    display("Lval",YD2S(s.Lhival,5)+","+YD2S(s.Lloval,5)+"=>"+YD2S(DLhiloinc,0),0,Lcol+spc,l3,Blue);
    display("Lpat",s.Lpattern,0,Lcol+spc,l4,Blue);

    display("Stfx",YI2S(Stfx),0,Scol+spc,l1,Blue);
    display("Sbar",YI2S(s.Shibar)+","+YI2S(s.Slobar)+"="+YI2S(DShilobar),0,Scol+spc,l2,Blue);
    display("Sval",YD2S(s.Shival,5)+","+YD2S(s.Sloval,5)+"=>"+YD2S(DShiloinc,0),0,Scol+spc,l3,Blue);
    display("Spat",s.Spattern,0,Scol+spc,l4,Blue);

 //display("orderprofit","OrderProfit = "+DoubleToStr(s.orderprofit,2),1,200,90,Green);

   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void hilo(int tf,int &hibar,double &hival,int &lobar,double &loval,string &pattern)
 //determines hilo bars with values and identifies HAL,LAH,LHA,HLA
   {
    int barstep=12,barF=1,barI=barF+barstep;
    bool leghi=false,leglo=false;

    while(leghi==false && leglo==false)
      {
       maxmin(tf,barI,barF,hibar,hival,lobar,loval);
       leghi=turnpoint(tf,hibar,hival,"hi");
       leglo=turnpoint(tf,lobar,loval,"lo");
       barF=barI+1;
       barI=barF+barstep;
      }
    if(Bid>hival && hibar>lobar) {pattern="AHL";return;}
    if(Bid<loval && lobar>hibar) {pattern="ALH";return;}
    if(Bid<loval && hibar>lobar) {pattern="HLA";return;}
    if(Bid>hival && lobar>hibar) {pattern="LHA";return;}
    if((Bid<hival && Bid>loval) && hibar>lobar) {pattern="HAL";return;}
    if((Bid<hival && Bid>loval) && lobar>hibar) {pattern="LAH";return;}
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool turnpoint(int tf,int bar,double val,string hiloitem)
 //determines if hilo are true turning points
   {
    double v[5];

    v[0]=val;

    if(hiloitem=="hi")
      {
       v[1]=iHigh(NULL,tf,bar+2);
       v[2]=iHigh(NULL,tf,bar+1);
       v[3]=iHigh(NULL,tf,bar-1);
       v[4]=iHigh(NULL,tf,bar-2);
       if(ArrayMaximum(v)==0) return true;
      }
    if(hiloitem=="lo")
      {
       v[1]=iLow(NULL,tf,bar+2);
       v[2]=iLow(NULL,tf,bar+1);
       v[3]=iLow(NULL,tf,bar-1);
       v[4]=iLow(NULL,tf,bar-2);
       if(ArrayMinimum(v)==0) return true;
      }
    return false;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 string YI2S(int x)
 //integer to string
   {
    return IntegerToString(x);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 string YD2S(double x,int d)
 //double to string
   {
    return DoubleToString(x,d);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void getparameters(int n)
 //sets the parameters for trading
   {
    switch(n)
      {
       case  01:

          break;
       case  02:

          break;
       case  03:

          break;
       case  04:

          break;
       case  05:

          break;
       case  06:

          break;
       case  07:

          break;
       case  08:

          break;
       case  09:

          break;
       case  10:

          break;
       case  11:

          break;
       case  12:

          break;
       default:
          break;
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double avgslope(int bI,int bF,double &ma[])
 //calculates avgslope using theil-sen concept
   {
    int
    iters=bI*(bI-1)/2;
    double
    acc=0;
    for(int i=bF;i<bI;i++)
       for(int j=i+1;j<=bI;j++)
          acc+=incline(j,ma[j],i,ma[i]);
    return acc/iters;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
   {
    maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
    maxval=iHigh(NULL,tf,maxbar);
    minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
    minval=iLow(NULL,tf,minbar);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
   {
    return (pF-pI)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
   {
    int
    Dbar=bI-bF;
    return Dpts(vI,vF)/Dbar;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool CanDoTrade(int &barsInchart)
 //checks various conditions to see if trade is permitted
   {
    bool
    newbar=(barsInchart!=Bars);
    double
    spread=MarketInfo(NULL,MODE_SPREAD);
    int aords,pords,
    tords=OrdersForSymbol(aords,pords);

    barsInchart=Bars;
    return ((tords==0) && newbar && (spread<9));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of orders that have been placed for a particular symbol
   {
    aords=0;pords=0;
    for(int p=OrdersTotal()-1;p>=0;p--)
       //+------------------------------------------------------------------+
       //|                                                                  |
       //+------------------------------------------------------------------+
       if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
         {
          if(OrderType()>1 && OrderType()<6)
             pords++;
          if(OrderType()==OP_BUY || OrderType()==OP_SELL)
             aords++;
         }
    return aords+pords;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void display(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
   {
    ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
    ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
    ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
    ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
    ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
   }

 //+------------------------------------------------------------------+

**** code testing R with varying tp in 1-60 tfs
 surprisingly R (HAL and LAH) produced better results than even E (B was poor)
 some for months different tf worked better than others which is also unexpected

 here's why R may work reasonably well without modification:
 1. in trending environments if it catches the correct incline HAL buy or LAH sel then the trend keeps it going to the tp. the catches are qualified by the turning point function, so you don't get too many entries.
 2. in ranging situations it has a 50-50 chance of getting sltp which is likely why we sometimes see zigzags.
 3. spikes are also 50-50 sltp.

 a good modification may be to work in a trend filter along the lines of fivonacci to evalulate the goodness of the trend and work LAH and HAL through those.


 jun
 | 573.40 |  58 | 1.45 |  9.89 | 319.30 | 3.16% | Etp=540 | Etfsx=0 |
 | 496.20 | 255 | 1.17 |  1.95 | 195.50 | 1.89% | Etp=250 | Etfsx=0 |
 | 467.70 | 121 | 1.24 |  3.87 | 353.80 | 3.49% | Etp=360 | Etfsx=0 |
 | 436.10 |  41 | 1.49 | 10.64 | 345.90 | 3.43% | Etp=550 | Etfsx=2 |
 | 425.70 | 111 | 1.22 |  3.84 | 333.90 | 3.29% | Etp=380 | Etfsx=0 |
 | 381.20 |  97 | 1.21 |  3.93 | 353.10 | 3.47% | Etp=410 | Etfsx=0 |
 | 331.10 | 104 | 1.17 |  3.18 | 385.10 | 3.79% | Etp=400 | Etfsx=0 |
 | 329.20 |  51 | 1.28 |  6.45 | 497.50 | 4.88% | Etp=540 | Etfsx=3 |
 | 306.60 | 137 | 1.14 |  2.24 | 380.90 | 3.76% | Etp=340 | Etfsx=0 |
 | 297.80 |  90 | 1.18 |  3.31 | 469.00 | 4.64% | Etp=400 | Etfsx=3 |
 | 287.20 |  64 | 1.20 |  4.49 | 363.40 | 3.60% | Etp=490 | Etfsx=0 |
 | 228.10 |  49 | 1.18 |  4.66 | 390.50 | 3.90% | Etp=570 | Etfsx=4 |

 may
 | 281.70 |  24 | 1.95 | 11.74 | 171.60 | 1.71% | Etp=370 | Etfsx=3 |
 | 239.40 | 130 | 1.26 |  1.84 | 173.70 | 1.73% | Etp=160 | Etfsx=0 |
 | 220.30 |  47 | 1.43 |  4.69 | 139.70 | 1.39% | Etp=270 | Etfsx=3 |
 | 219.50 |  84 | 1.30 |  2.61 | 122.90 | 1.21% | Etp=200 | Etfsx=0 |
 | 177.00 |  12 | 1.76 | 14.75 | 178.70 | 1.73% | Etp=580 | Etfsx=3 |
 | 164.50 | 138 | 1.17 |  1.19 | 183.40 | 1.82% | Etp=150 | Etfsx=0 |

 apr
 | 449.40 |  58 | 1.60 |  7.75 | 141.90 | 1.37% | Etp=340 | Etfsx=0 |
 | 439.40 |  59 | 1.59 |  7.45 | 138.90 | 1.35% | Etp=330 | Etfsx=0 |
 | 391.30 |  19 | 2.37 | 20.59 | 170.50 | 1.65% | Etp=520 | Etfsx=1 |
 | 349.70 |  64 | 1.43 |  5.46 | 171.50 | 1.66% | Etp=310 | Etfsx=0 |
 | 346.40 | 170 | 1.26 |  2.04 | 207.60 | 1.98% | Etp=180 | Etfsx=1 |
 | 285.40 |  22 | 1.86 | 12.97 | 173.00 | 1.68% | Etp=440 | Etfsx=0 |
 | 272.30 | 292 | 1.14 |  0.93 | 335.00 | 3.32% | Etp=140 | Etfsx=0 |
 | 249.10 |  14 | 2.01 | 17.79 | 194.20 | 1.86% | Etp=550 | Etfsx=0 |
 | 237.50 |  22 | 1.63 | 10.80 | 178.70 | 1.75% | Etp=470 | Etfsx=1 |
 | 236.70 |  82 | 1.25 |  2.89 | 163.40 | 1.58% | Etp=260 | Etfsx=1 |

 mar
 | 423.10 | 476 | 1.14 | 0.89 | 291.80 | 2.83% | Etp=140 | Etfsx=0 |
 | 206.70 |  75 | 1.18 | 2.76 | 292.00 | 2.80% | Etp=330 | Etfsx=3 |
 | 157.30 |  26 | 1.23 | 6.05 | 258.70 | 2.50% | Etp=600 | Etfsx=0 |
 | 156.00 |  28 | 1.23 | 5.57 | 269.90 | 2.60% | Etp=550 | Etfsx=4 |
 | 102.40 |  84 | 1.08 | 1.22 | 470.70 | 4.47% | Etp=330 | Etfsx=2 |


 //+------------------------------------------------------------------+
 //|                                                       llpomo.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+

 /*
 optimize is small time segments and identify useable parameters
 understand what is happening with the program and parameters
 get more data for other pairs to test
 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>


 #define sp "  "

 /*

 */

 extern int Etp;
 extern int Etfsx;

 int tfs[5],
 GbF=1,
 GbI=3,
 Gtkt=0,
 GbarsInChart=0,
 GtimeframeIndex=0;
 double
 Glt=0.1;
 bool zz;
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 struct status
 //Large and Small timeframe situation
   {
    //hi and lo info
    int               Lhibar,Shibar,Llobar,Slobar;
    double            Lhival,Lloval,Shival,Sloval;

    //patterns HAL,LAH,SHA,HLA
    string            Lpattern,Spattern;

    //deltas between hilo and point movement from last turn
    double            LDhilo,SDhilo;
    double            LDpomo,SDpomo;

    //bs
    int               bs;
    double            oo,sl,tp;

    //orderselect info
    double            orderprofit;
    int               ordertype;
   };

 status Gs;
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OnInit()
   {
    tfs[0]=1;tfs[1]=5;tfs[2]=15;tfs[3]=30;tfs[4]=60;
    return(INIT_SUCCEEDED);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {
    int Ltf=5,Stf=tfs[Etfsx];

    getstatus(Ltf,Stf,Gs);

    if(CanDoTrade(GbarsInChart))
       Gtkt=OrderSend(Symbol(),Gs.bs,Glt,Gs.oo,0,Gs.sl,Gs.tp,Gs.Spattern);

   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void getstatus(int Ltfx,int Stfx,status &s)
 //finds various aspects of status
   {
    double
    tp=Etp*Point;
    int
    tkt=Gtkt,
    bF=GbF,
    bI=GbI;

    lasterror();
 //get hilo info
    hilo(Ltfx,s.Lhibar,s.Lhival,s.Llobar,s.Lloval,s.Lpattern);
    hilo(Stfx,s.Shibar,s.Shival,s.Slobar,s.Sloval,s.Spattern);
    int DLhilobar=s.Llobar-s.Lhibar,DShilobar=s.Slobar-s.Shibar;
    if(DLhilobar==0) DLhilobar=1; if(DShilobar==0) DShilobar=1;
    double DLhiloinc=Dpts(s.Lloval,s.Lhival)/DLhilobar,DShiloinc=Dpts(s.Sloval,s.Shival)/DShilobar;

 //fill oo,sl,tp
    if(s.Spattern=="HAL") {s.bs=0;s.oo=Ask;s.sl=s.oo-tp;s.tp=s.oo+tp;}
    if(s.Spattern=="LAH") {s.bs=1;s.oo=Bid;s.sl=s.oo+tp;s.tp=s.oo-tp;}
    if(s.Spattern=="AHL") {s.bs=0;s.oo=Ask;s.sl=s.oo-tp;s.tp=s.oo+tp;}
    if(s.Spattern=="ALH") {s.bs=1;s.oo=Bid;s.sl=s.oo+tp;s.tp=s.oo-tp;}
    if(s.Spattern=="LHA") {s.bs=0;s.oo=Ask;s.sl=s.Sloval;s.tp=s.oo+tp;}
    if(s.Spattern=="HLA") {s.bs=1;s.oo=Bid;s.sl=s.Shival;s.tp=s.oo-tp;}



 //orderselect info
    if(OrderSelect(Gtkt,SELECT_BY_TICKET))
      {
       s.orderprofit=OrderProfit();
       s.ordertype=OrderType();
      }

 //display status
 /*
    display("tfx","tfx",0,Lcol,l1,Blue);
    display("bar","bar",0,Lcol,l2,Blue);
    display("val","val",0,Lcol,l3,Blue);
    display("pat","pat",0,Lcol,l4,Blue);

    display("Ltfx",YI2S(Ltfx),0,Lcol+spc,l1,Blue);
    display("Lbar",YI2S(s.Lhibar)+","+YI2S(s.Llobar)+"="+YI2S(DLhilobar),0,Lcol+spc,l2,Blue);
    display("Lval",YD2S(s.Lhival,5)+","+YD2S(s.Lloval,5)+"=>"+YD2S(DLhiloinc,0),0,Lcol+spc,l3,Blue);
    display("Lpat",s.Lpattern,0,Lcol+spc,l4,Blue);

    display("Stfx",YI2S(Stfx),0,Scol+spc,l1,Blue);
    display("Sbar",YI2S(s.Shibar)+","+YI2S(s.Slobar)+"="+YI2S(DShilobar),0,Scol+spc,l2,Blue);
    display("Sval",YD2S(s.Shival,5)+","+YD2S(s.Sloval,5)+"=>"+YD2S(DShiloinc,0),0,Scol+spc,l3,Blue);
    display("Spat",s.Spattern,0,Scol+spc,l4,Blue);
 */
 //display("orderprofit","OrderProfit = "+DoubleToStr(s.orderprofit,2),1,200,90,Green);

   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void hilo(int tf,int &hibar,double &hival,int &lobar,double &loval,string &pattern)
 //determines legitimate hilo bars with values and identifies HAL,LAH,LHA,HLA
   {
    int barstep=12,barF=1,barI=barF+barstep;
    bool leghi=false,leglo=false;

    while(leghi==false && leglo==false)
      {
       maxmin(tf,barI,barF,hibar,hival,lobar,loval);
       leghi=turnpoint(tf,hibar,hival,"hi");
       leglo=turnpoint(tf,lobar,loval,"lo");
       barF=barI+1;
       barI=barF+barstep;
      }
    if(Bid>hival && hibar>lobar) {pattern="AHL";return;}
    if(Bid<loval && lobar>hibar) {pattern="ALH";return;}
    if(Bid<loval && hibar>lobar) {pattern="HLA";return;}
    if(Bid>hival && lobar>hibar) {pattern="LHA";return;}
    if((Bid<hival && Bid>loval) && hibar>lobar) {pattern="HAL";return;}
    if((Bid<hival && Bid>loval) && lobar>hibar) {pattern="LAH";return;}
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool turnpoint(int tf,int bar,double val,string hiloitem)
 //determines if hilo are true turning points
   {
    double v[5];

    v[0]=val;

    if(hiloitem=="hi")
      {
       v[1]=iHigh(NULL,tf,bar+2);
       v[2]=iHigh(NULL,tf,bar+1);
       v[3]=iHigh(NULL,tf,bar-1);
       v[4]=iHigh(NULL,tf,bar-2);
       if(ArrayMaximum(v)==0) return true;
      }
    if(hiloitem=="lo")
      {
       v[1]=iLow(NULL,tf,bar+2);
       v[2]=iLow(NULL,tf,bar+1);
       v[3]=iLow(NULL,tf,bar-1);
       v[4]=iLow(NULL,tf,bar-2);
       if(ArrayMinimum(v)==0) return true;
      }
    return false;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 string YI2S(int x)
 //integer to string
   {
    return IntegerToString(x);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 string YD2S(double x,int d)
 //double to string
   {
    return DoubleToString(x,d);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void getparameters(int n)
 //sets the parameters for trading
   {
    switch(n)
      {
       case  01:
          Etp=240;Etfsx=2;
          break;
       case  02:
          Etp=480;Etfsx=3;
          break;
       case  03:

          break;
       case  04:

          break;
       case  05:

          break;
       case  06:

          break;
       case  07:

          break;
       case  08:

          break;
       case  09:

          break;
       case  10:

          break;
       case  11:

          break;
       case  12:

          break;
       default:
          break;
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double avgslope(int bI,int bF,double &ma[])
 //calculates avgslope using theil-sen concept
   {
    int
    iters=bI*(bI-1)/2;
    double
    acc=0;
    for(int i=bF;i<bI;i++)
       for(int j=i+1;j<=bI;j++)
          acc+=incline(j,ma[j],i,ma[i]);
    return acc/iters;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
   {
    maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
    maxval=iHigh(NULL,tf,maxbar);
    minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
    minval=iLow(NULL,tf,minbar);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
   {
    return (pF-pI)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
   {
    int
    Dbar=bI-bF;
    return Dpts(vI,vF)/Dbar;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool CanDoTrade(int &barsInchart)
 //checks various conditions to see if trade is permitted
   {
    bool
    newbar=(barsInchart!=Bars);
    double
    spread=MarketInfo(NULL,MODE_SPREAD);
    int aords,pords,
    tords=OrdersForSymbol(aords,pords);

    barsInchart=Bars;
    return ((tords==0) && newbar && (spread<9));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of orders that have been placed for a particular symbol
   {
    aords=0;pords=0;
    for(int p=OrdersTotal()-1;p>=0;p--)
       //+------------------------------------------------------------------+
       //|                                                                  |
       //+------------------------------------------------------------------+
       if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
         {
          if(OrderType()>1 && OrderType()<6)
             pords++;
          if(OrderType()==OP_BUY || OrderType()==OP_SELL)
             aords++;
         }
    return aords+pords;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void lasterror()
 //prints last error message
   {
    int
    errnum=GetLastError();
    if(errnum!=ERR_NO_ERROR)
       Comment(errnum,sp,ErrorDescription(errnum));
    else
       Comment(ERR_NO_ERROR);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void display(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
   {
    ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
    ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
    ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
    ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
    ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
   }

 //+------------------------------------------------------------------+
**** code lahhal pattern
 since lahhal performed significantly better than the others, we will use it.
 there is a conceptual flaw though that shows up in trending markets:
 consider uptrend
 1. you want HAL
 2. however, if you get into LAH, sl gets hit
 3. now if price goes up, you can't get HAL or in because there is no LHA
 4. but if price goes down a bit you immediately get LAH

 getting in the wrong way can be disasterous in a trend

 in a range, it doesn't matter so much because HAL and LAH both have good chances

 solution would seem to be to either introduce LHA and HLA or utilize fivonacci as incline filter for LAHHAL.

 //+------------------------------------------------------------------+
 //|                                                       lahhal.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+

 /*
 clean up program
 incorporate incline detection which is essential for trending markets
 entry for LAHHAL should not be too close to turning point
 adapt so program detects symbol and uses appropriate parameters
 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #include <stdlib.mqh>
 #include <stderror.mqh>


 #define sp "  "

 /*
 incorporates the LAHHAL pattern to determine entries
 */

 extern int Etp;
 extern int Etfsx;

 int tfs[5],
 GbF=1,
 GbI=3,
 Gtkt=0,
 GbarsInChart=0;
 double
 Glt=0.1;
 bool zz;
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 struct status
 //Large and Small timeframe situation
   {
    //hi and lo info
    int               Lhibar,Shibar,Llobar,Slobar;
    double            Lhival,Lloval,Shival,Sloval;

    //patterns HAL,LAH,HLA,LHA,AHL,ALH
    string            Lpattern,Spattern;

    //deltas between hilo and point movement from last turn
    double            LDhilo,SDhilo;
    double            LDpomo,SDpomo;

    //bs,oo,sl,tp
    int               bs;
    double            oo,sl,tp;

    //orderselect info
    double            orderprofit;
    int               ordertype;
   };

 status Gs;
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OnInit()
   {
    tfs[0]=1;tfs[1]=5;tfs[2]=15;tfs[3]=30;tfs[4]=60;
    return(INIT_SUCCEEDED);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {
    getparameters(01);
    int Ltf=5,Stf=tfs[Etfsx];
    getstatus(Ltf,Stf,Gs);

    if(CanDoTrade())
       Gtkt=OrderSend(Symbol(),Gs.bs,Glt,Gs.oo,0,Gs.sl,Gs.tp,Gs.Spattern);

   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void getstatus(int Ltfx,int Stfx,status &s)
 //finds various aspects of status
   {
    double
    tp=Etp*Point;
    int
    Lcol=1000,Scol=1200,spc=60,
    l1=12,l2=24,l3=36,l4=48,l5=60,
    tkt=Gtkt,
    bF=GbF,
    bI=GbI;

 //showlasterror();

 //get hilo info
    hilo(Ltfx,s.Lhibar,s.Lhival,s.Llobar,s.Lloval,s.Lpattern);
    hilo(Stfx,s.Shibar,s.Shival,s.Slobar,s.Sloval,s.Spattern);
    int DLhilobar=s.Llobar-s.Lhibar,DShilobar=s.Slobar-s.Shibar;
    if(DLhilobar==0) DLhilobar=1; if(DShilobar==0) DShilobar=1;
    double DLhiloinc=Dpts(s.Lloval,s.Lhival)/DLhilobar,DShiloinc=Dpts(s.Sloval,s.Shival)/DShilobar;

 //fill oo,sl,tp
    if(s.Spattern=="HAL") {s.bs=0;s.oo=Ask;s.sl=s.oo-tp;s.tp=s.oo+tp;}
    if(s.Spattern=="LAH") {s.bs=1;s.oo=Bid;s.sl=s.oo+tp;s.tp=s.oo-tp;}
 //if(s.Spattern=="AHL") {s.bs=0;s.oo=Ask;s.sl=s.oo-tp;s.tp=s.oo+tp;}
 //if(s.Spattern=="ALH") {s.bs=1;s.oo=Bid;s.sl=s.oo+tp;s.tp=s.oo-tp;}
 //if(s.Spattern=="LHA") {s.bs=0;s.oo=Ask;s.sl=s.Sloval;s.tp=s.oo+tp;}
 //if(s.Spattern=="HLA") {s.bs=1;s.oo=Bid;s.sl=s.Shival;s.tp=s.oo-tp;}

 //orderselect info
    if(OrderSelect(Gtkt,SELECT_BY_TICKET))
      {
       s.orderprofit=OrderProfit();
       s.ordertype=OrderType();
      }

 //display status
    display("par","params "+YI2S(Etp)+" "+YI2S(Etfsx),2,0,5,Red);

    display("tfx","tfx",0,Lcol,l1,Blue);
    display("bar","bar",0,Lcol,l2,Blue);
    display("val","val",0,Lcol,l3,Blue);
    display("pat","pat",0,Lcol,l4,Blue);

    display("Ltfx",YI2S(Ltfx),0,Lcol+spc,l1,Blue);
    display("Lbar",YI2S(s.Lhibar)+","+YI2S(s.Llobar)+"="+YI2S(DLhilobar),0,Lcol+spc,l2,Blue);
    display("Lval",YD2S(s.Lhival,5)+","+YD2S(s.Lloval,5)+"=>"+YD2S(DLhiloinc,0),0,Lcol+spc,l3,Blue);
    display("Lpat",s.Lpattern,0,Lcol+spc,l4,Blue);

    display("Stfx",YI2S(Stfx),0,Scol+spc,l1,Blue);
    display("Sbar",YI2S(s.Shibar)+","+YI2S(s.Slobar)+"="+YI2S(DShilobar),0,Scol+spc,l2,Blue);
    display("Sval",YD2S(s.Shival,5)+","+YD2S(s.Sloval,5)+"=>"+YD2S(DShiloinc,0),0,Scol+spc,l3,Blue);
    display("Spat",s.Spattern,0,Scol+spc,l4,Blue);

 //display("orderprofit","OrderProfit = "+DoubleToStr(s.orderprofit,2),1,200,90,Green);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void hilo(int tf,int &hibar,double &hival,int &lobar,double &loval,string &pattern)
 //determines legitimate hilo bars with values and identifies HAL,LAH,LHA,HLA
   {
    int barstep=12,barF=1,barI=barF+barstep;
    bool leghi=false,leglo=false;

    while(leghi==false && leglo==false)
      {
       maxmin(tf,barI,barF,hibar,hival,lobar,loval);
       leghi=turnpoint(tf,hibar,hival,"hi");
       leglo=turnpoint(tf,lobar,loval,"lo");
       barF=barI+1;
       barI=barF+barstep;
      }
    if(Bid>hival && hibar>lobar) {pattern="AHL";return;}
    if(Bid<loval && lobar>hibar) {pattern="ALH";return;}
    if(Bid<loval && hibar>lobar) {pattern="HLA";return;}
    if(Bid>hival && lobar>hibar) {pattern="LHA";return;}
    if((Bid<hival && Bid>loval) && hibar>lobar) {pattern="HAL";return;}
    if((Bid<hival && Bid>loval) && lobar>hibar) {pattern="LAH";return;}
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool turnpoint(int tf,int bar,double val,string hiloitem)
 //determines if hilo are true turning points
   {
    double v[5];

    v[0]=val;

    if(hiloitem=="hi")
      {
       v[1]=iHigh(NULL,tf,bar+2);
       v[2]=iHigh(NULL,tf,bar+1);
       v[3]=iHigh(NULL,tf,bar-1);
       v[4]=iHigh(NULL,tf,bar-2);
       if(ArrayMaximum(v)==0) return true;
      }
    if(hiloitem=="lo")
      {
       v[1]=iLow(NULL,tf,bar+2);
       v[2]=iLow(NULL,tf,bar+1);
       v[3]=iLow(NULL,tf,bar-1);
       v[4]=iLow(NULL,tf,bar-2);
       if(ArrayMinimum(v)==0) return true;
      }
    return false;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void getparameters(int n)
 //sets the parameters for trading
   {
    switch(n)
      {
       case  01:
          Etp=360;Etfsx=2; //1608 06-13
          break;
       case  02:

          break;
       case  03:

          break;
       case  04:

          break;
       case  05:

          break;
       case  06:

          break;
       case  07:

          break;
       case  08:

          break;
       case  09:

          break;
       case  10:

          break;
       case  11:

          break;
       case  12:

          break;
       default:
          break;
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double avgslope(int bI,int bF,double &ma[])
 //calculates avgslope using theil-sen concept
   {
    int
    iters=bI*(bI-1)/2;
    double
    acc=0;
    for(int i=bF;i<bI;i++)
       for(int j=i+1;j<=bI;j++)
          acc+=incline(j,ma[j],i,ma[i]);
    return acc/iters;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
   {
    maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
    maxval=iHigh(NULL,tf,maxbar);
    minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
    minval=iLow(NULL,tf,minbar);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
   {
    return (pF-pI)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
   {
    int
    Dbar=bI-bF;
    return Dpts(vI,vF)/Dbar;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool CanDoTrade()
 //checks if trading is ok via new bar, total orders, spread
   {
    int aords,pords;
    bool
    newbarOK=(GbarsInChart<Bars),
    spreadOK=(MarketInfo(NULL,MODE_SPREAD)<9),
    noordsOK=(OrdersForSymbol(aords,pords)==0);
    GbarsInChart=Bars;
    return (newbarOK && spreadOK && noordsOK);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of aords and pords that have been placed for a particular symbol
   {
    aords=0;pords=0;
    for(int p=OrdersTotal()-1;p>=0;p--)
       if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
         {
          if(OrderType()>1 && OrderType()<6)
             pords++;
          if(OrderType()==OP_BUY || OrderType()==OP_SELL)
             aords++;
         }
    return aords+pords;
   }
 ///////////////////////////////
 // various display functions //
 ///////////////////////////////

 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void showlasterror()
 //prints last error message
   {
    int
    errnum=GetLastError();
    if(errnum!=ERR_NO_ERROR)
       Comment(errnum,sp,ErrorDescription(errnum));
    else
       Comment(ERR_NO_ERROR);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 string YI2S(int x)
 //integer to string
   {
    return IntegerToString(x);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 string YD2S(double x,int d)
 //double to string
   {
    return DoubleToString(x,d);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void display(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
   {
    ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
    ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
    ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
    ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
    ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
   }

 //+------------------------------------------------------------------+

*** parama
 ntr on parallel in 2 tfs
 xit when there is conflict

 it is possible that success in one time segment necessitates poor showing in another. therefore, varying the parameters may be more sensible an idea that one would think it might. it may not be practical to do optimization on large data sets in one shot since each of these is composed of many small parts. better to identify the parts and optimize on them.

 therefore, 
 0. try some parameter combo
 1. pick a winning/losing segment
 2. examine the pa pattern
 3. optimize on the segment
 4. link the patter to the optimized parameters

**** code fixed 500p sltp
 no attempt to move with the slopes

 results 160102-160331 of one night and only 1/4 through
 | 700.10 | 62 | 1.77% | Epmal=12 | Epmas=21 | Etfx=1 | Eincl=8  | Eincs=5  |
 | 600.00 | 62 | 2.03% | Epmal=3  | Epmas=3  | Etfx=1 | Eincl=17 | Eincs=17 |
 | 600.00 | 62 | 1.90% | Epmal=27 | Epmas=6  | Etfx=2 | Eincl=2  | Eincs=16 |
 | 599.90 | 64 | 2.03% | Epmal=3  | Epmas=3  | Etfx=1 | Eincl=17 | Eincs=18 |
 | 599.90 | 56 | 2.21% | Epmal=12 | Epmas=18 | Etfx=2 | Eincl=14 | Eincs=18 |
 | 558.80 | 68 | 2.33% | Epmal=18 | Epmas=30 | Etfx=1 | Eincl=1  | Eincs=7  |
 | 550.20 | 59 | 2.76% | Epmal=18 | Epmas=6  | Etfx=2 | Eincl=18 | Eincs=4  |
 interesting that good results are coming from such a discrepancy of Epmal and Epmas though it is likely that with 500p sltp randomness effects override any intelligentness of ntrs especially in smaller tf. possibly different with larger tf situations.


 //+------------------------------------------------------------------+
 //|                                                       parama.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+

 /*

 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #define sp "  "

 /*
 maL in large tf, maS in small tf
 use maL for direction
 ntr when maS agrees
 xit when maS disagrees
 */

 /*
 EpmaL - periodmaL
 EpmaS - periodmaS
 Etfx  - timeframe index
 Eincl - minimum incline threshold L
 Eincs - minimum incline threshold S
 */
 extern int Epmal;
 extern int Epmas;
 extern int Etfx;
 extern double Eincl;
 extern double Eincs;

 int tfs[5],
 GbF=1,
 GbI=3,
 Gtkt=0,
 GbarsInChart=0,
 GtimeframeIndex=0;
 double
 Glt=0.1;
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 struct status
   {
    //ma item values
    double            meL[4],meS[4];
    double            inclinemaL,inclinemaS,crossmaS;

    //trade parameters
    string            mode;

    //amplitude (max,min difference of 1..x bars) calculation items            
    int               maxbar,minbar;
    double            maxval,minval,amplitude;

    //bs
    int               bs;
    double            oo,sl,tp;

    //orderselect info
    double            orderprofit;
    int               ordertype;

   };

 status Gs;
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OnInit()
   {
    tfs[0]=1;tfs[1]=5;tfs[2]=15;tfs[3]=30;tfs[4]=60;
    return(INIT_SUCCEEDED);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {
    Epmal=9;Epmas=9;
    Eincl=1.0;Eincs=1.0;
    Etfx=1;

    getstatus(Etfx,Gs);

    if(CanDoTrade(GbarsInChart))
       Gtkt=OrderSend(Symbol(),Gs.bs,Glt,Gs.oo,0,Gs.sl,Gs.tp);
    else
      {

         {

         }

      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void getstatus(int tfx,status &s)
 //finds various aspects of status
   {
    int
    mamode=MODE_EMA,
    tkt=Gtkt,
    bF=GbF,
    bI=GbI;

 //fill ma arrays with values
    for(int b=bF;b<=bI;b++)
      {
       s.meL[b]=iMA(NULL,tfs[tfx],Epmal,0,mamode,PRICE_MEDIAN,b);
       s.meS[b]=iMA(NULL,tfs[tfx-1],Epmas,0,mamode,PRICE_MEDIAN,b);
      }

 //calculate average inclines for ma
    s.inclinemaL=avgslope(bI,bF,s.meL);
    s.inclinemaS=avgslope(bI,bF,s.meS);

 //set mode
    s.mode="N";
    if(s.inclinemaL>+Eincl && s.inclinemaS>+Eincs) s.mode="Bntr";
    if(s.inclinemaL>+Eincl && s.inclinemaS<-Eincs) s.mode="Bxit";
    if(s.inclinemaL<-Eincl && s.inclinemaS<-Eincs) s.mode="Sntr";
    if(s.inclinemaL<-Eincl && s.inclinemaS>+Eincs) s.mode="Sxit";

 //determine bs,oo,sl,tp
    if(s.mode=="Bntr")
      {
       s.bs=OP_BUY;
       s.oo=Ask;
       s.sl=s.oo-500*Point;
       s.tp=s.oo+500*Point;
      }
    if(s.mode=="Sntr")
      {
       s.bs=OP_SELL;
       s.oo=Bid;
       s.sl=s.oo+500*Point;
       s.tp=s.oo-500*Point;
      }

 //orderselect info
    if(OrderSelect(Gtkt,SELECT_BY_TICKET))
      {
       s.orderprofit=OrderProfit();
       s.ordertype=OrderType();
      }

 //display status
    display("inclmaL","inclmaL = "+DoubleToStr(s.inclinemaL),1,200,0,Blue);
    display("inclmaS","inclmaS = "+DoubleToStr(s.inclinemaS),1,200,20,Blue);
    display("mode","mode = "+s.mode,1,200,70,Red);
    display("orderprofit","OrderProfit = "+DoubleToStr(s.orderprofit,2),1,200,90,Green);

   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double avgslope(int bI,int bF,double &ma[])
 //calculates avgslope using theil-sen concept
   {
    int
    iters=bI*(bI-1)/2;
    double
    acc=0;
    for(int i=bF;i<bI;i++)
       for(int j=i+1;j<=bI;j++)
          acc+=incline(j,ma[j],i,ma[i]);
    return acc/iters;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
   {
    maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
    maxval=iHigh(NULL,tf,maxbar);
    minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
    minval=iLow(NULL,tf,minbar);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
   {
    return (pF-pI)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
   {
    int
    Dbar=bI-bF;
    return Dpts(vI,vF)/Dbar;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool CanDoTrade(int &barsInchart)
 //checks various conditions to see if trade is permitted
   {
    bool
    newbar=(barsInchart!=Bars);
    double
    spread=MarketInfo(NULL,MODE_SPREAD);
    int aords,pords,
    tords=OrdersForSymbol(aords,pords);

    barsInchart=Bars;
    return ((tords==0) && newbar && (spread<9));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of orders that have been placed for a particular symbol
   {
    aords=0;pords=0;
    for(int p=OrdersTotal()-1;p>=0;p--)
       if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
         {
          if(OrderType()>1 && OrderType()<6)
             pords++;
          if(OrderType()==OP_BUY || OrderType()==OP_SELL)
             aords++;
         }
    return aords+pords;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void display(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
   {
    ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
    ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
    ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
    ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
    ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
   }

 //+------------------------------------------------------------------+

**** code xit by bxit and sxit on next smaller tf
 160724-160730
 | 200.10 | 4 | 0.39% | Epmal=15 | Epmas=24 | Etfx=1 | Eincl=18.5 | Eincs=9    |
 | 196.80 | 5 | 0.68% | Epmal=30 | Epmas=21 | Etfx=2 | Eincl=5    | Eincs=9.5  |
 | 190.40 | 7 | 0.68% | Epmal=9  | Epmas=15 | Etfx=2 | Eincl=5.5  | Eincs=11   |
 | 189.90 | 6 | 0.68% | Epmal=3  | Epmas=15 | Etfx=2 | Eincl=20   | Eincs=11   |
 | 189.90 | 6 | 0.68% | Epmal=6  | Epmas=12 | Etfx=2 | Eincl=10   | Eincs=12.5 |
 | 189.90 | 6 | 0.68% | Epmal=6  | Epmas=15 | Etfx=2 | Eincl=10   | Eincs=11   |
 | 189.90 | 6 | 0.68% | Epmal=3  | Epmas=15 | Etfx=2 | Eincl=11.5 | Eincs=11   |
 | 189.50 | 5 | 0.68% | Epmal=6  | Epmas=12 | Etfx=2 | Eincl=14   | Eincs=12   |
 | 189.50 | 5 | 0.68% | Epmal=3  | Epmas=15 | Etfx=2 | Eincl=15.5 | Eincs=10.5 |




 160102-160331
 | 962.30 | 160 | 1.65% | Epmal=3  | Epmas=18 | Etfx=4 | Eincl=15 | Eincs=1  |
 | 845.00 |  83 | 1.35% | Epmal=27 | Epmas=15 | Etfx=1 | Eincl=15 | Eincs=5  |
 | 841.90 |  85 | 1.81% | Epmal=24 | Epmas=18 | Etfx=1 | Eincl=15 | Eincs=5  |
 | 826.60 | 105 | 1.98% | Epmal=27 | Epmas=15 | Etfx=1 | Eincl=13 | Eincs=5  |
 | 808.70 |  89 | 1.20% | Epmal=24 | Epmas=18 | Etfx=1 | Eincl=17 | Eincs=3  |
 | 787.30 |  72 | 1.77% | Epmal=24 | Epmas=18 | Etfx=2 | Eincl=19 | Eincs=5  |
 | 777.20 | 105 | 2.08% | Epmal=3  | Epmas=18 | Etfx=4 | Eincl=15 | Eincs=5  |
 | 767.30 | 101 | 2.04% | Epmal=3  | Epmas=21 | Etfx=4 | Eincl=15 | Eincs=5  |
 | 756.30 |  99 | 2.57% | Epmal=3  | Epmas=6  | Etfx=4 | Eincl=13 | Eincs=17 |
 | 754.60 |  71 | 1.28% | Epmal=27 | Epmas=15 | Etfx=1 | Eincl=15 | Eincs=7  |
 | 754.60 | 111 | 1.52% | Epmal=27 | Epmas=15 | Etfx=1 | Eincl=15 | Eincs=3  |
 | 748.80 | 108 | 1.47% | Epmal=24 | Epmas=18 | Etfx=1 | Eincl=15 | Eincs=3  |
 | 732.20 | 119 | 3.94% | Epmal=3  | Epmas=6  | Etfx=4 | Eincl=3  | Eincs=15 |
 | 727.40 | 134 | 2.31% | Epmal=3  | Epmas=15 | Etfx=4 | Eincl=15 | Eincs=3  |
 | 718.20 | 140 | 2.10% | Epmal=3  | Epmas=15 | Etfx=4 | Eincl=13 | Eincs=3  |
 | 713.40 |  97 | 1.82% | Epmal=3  | Epmas=21 | Etfx=4 | Eincl=17 | Eincs=5  |
 | 712.20 | 142 | 3.00% | Epmal=3  | Epmas=18 | Etfx=4 | Eincl=15 | Eincs=3  |
 | 709.60 |  87 | 3.01% | Epmal=3  | Epmas=15 | Etfx=4 | Eincl=13 | Eincs=7  |
 | 708.20 |  56 | 1.99% | Epmal=6  | Epmas=24 | Etfx=2 | Eincl=7  | Eincs=15 |
 | 708.20 |  56 | 1.99% | Epmal=6  | Epmas=24 | Etfx=2 | Eincl=5  | Eincs=15 |



 //+------------------------------------------------------------------+
 //|                                                       parama.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+

 /*
 make adaptive to inclines
 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #define sp "  "

 /*
 maL in large tf, maS in small tf
 use maL for direction
 ntr when maS agrees
 xit when maS disagrees
 */

 /*
 EpmaL - periodmaL
 EpmaS - periodmaS
 Etfx  - timeframe index
 Eincl - minimum incline threshold L
 Eincs - minimum incline threshold S
 */
 extern int Epmal;
 extern int Epmas;
 extern int Etfx;
 extern double Eincl;
 extern double Eincs;

 int tfs[5],
 GbF=1,
 GbI=3,
 Gtkt=0,
 GbarsInChart=0,
 GtimeframeIndex=0;
 double
 Glt=0.1;
 bool zz;
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 struct status
   {
    //ma item values
    double            meL[4],meS[4];
    double            inclinemaL,inclinemaS,crossmaS;

    //trade parameters
    string            mode;

    //amplitude (max,min difference of 1..x bars) calculation items            
    int               maxbar,minbar;
    double            maxval,minval,amplitude;

    //bs
    int               bs;
    double            oo,sl,tp;

    //orderselect info
    double            orderprofit;
    int               ordertype;

   };

 status Gs;
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OnInit()
   {
    tfs[0]=1;tfs[1]=5;tfs[2]=15;tfs[3]=30;tfs[4]=60;
    return(INIT_SUCCEEDED);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {
    Epmal=9;Epmas=9;
    Eincl=1.0;Eincs=1.0;
    Etfx=3;

    getstatus(Etfx,Gs);

    if(CanDoTrade(GbarsInChart))
       Gtkt=OrderSend(Symbol(),Gs.bs,Glt,Gs.oo,0,Gs.sl,Gs.tp);
    else
      {
       if(OrderSelect(Gtkt,SELECT_BY_TICKET))
         {
          if(Gs.mode=="Bxit" || Gs.mode=="Sxit") zz=OrderClose(Gtkt,Glt,OrderClosePrice(),0,clrNONE);
         }
      }

   }

 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void getstatus(int tfx,status &s)
 //finds various aspects of status
   {
    int
    mamode=MODE_EMA,
    tkt=Gtkt,
    bF=GbF,
    bI=GbI;
    double
    sltp=500*Point;

 //fill ma arrays with values
    for(int b=bF;b<=bI;b++)
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
      {
       s.meL[b]=iMA(NULL,tfs[tfx],Epmal,0,mamode,PRICE_MEDIAN,b);
       s.meS[b]=iMA(NULL,tfs[tfx-1],Epmas,0,mamode,PRICE_MEDIAN,b);
      }

 //calculate average inclines for ma
    s.inclinemaL=avgslope(bI,bF,s.meL);
    s.inclinemaS=avgslope(bI,bF,s.meS);

 //set mode
    s.mode="N";
    if(s.inclinemaL>+Eincl && s.inclinemaS>+Eincs) s.mode="Bntr";
    if(s.inclinemaL>+Eincl && s.inclinemaS<-Eincs) s.mode="Bxit";
    if(s.inclinemaL<-Eincl && s.inclinemaS<-Eincs) s.mode="Sntr";
    if(s.inclinemaL<-Eincl && s.inclinemaS>+Eincs) s.mode="Sxit";
 //determine bs,oo,sl,tp
    if(s.mode=="Bntr")
      {
       s.bs=OP_BUY;
       s.oo=Ask;
       s.sl=s.oo-sltp;
       s.tp=s.oo+sltp;
      }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
    if(s.mode=="Sntr")
      {
       s.bs=OP_SELL;
       s.oo=Bid;
       s.sl=s.oo+sltp;
       s.tp=s.oo-sltp;
      }
 //orderselect info
    if(OrderSelect(Gtkt,SELECT_BY_TICKET))
      {
       s.orderprofit=OrderProfit();
       s.ordertype=OrderType();
      }

 //display status
    display("inclmaL","inclmaL = "+DoubleToStr(s.inclinemaL),1,200,0,Blue);
    display("inclmaS","inclmaS = "+DoubleToStr(s.inclinemaS),1,200,20,Blue);
    display("mode","mode = "+s.mode,1,200,70,Red);
    display("orderprofit","OrderProfit = "+DoubleToStr(s.orderprofit,2),1,200,90,Green);

   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double avgslope(int bI,int bF,double &ma[])
 //calculates avgslope using theil-sen concept
   {
    int
    iters=bI*(bI-1)/2;
    double
    acc=0;
    for(int i=bF;i<bI;i++)
       for(int j=i+1;j<=bI;j++)
          acc+=incline(j,ma[j],i,ma[i]);
    return acc/iters;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
   {
    maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
    maxval=iHigh(NULL,tf,maxbar);
    minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
    minval=iLow(NULL,tf,minbar);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
   {
    return (pF-pI)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
   {
    int
    Dbar=bI-bF;
    return Dpts(vI,vF)/Dbar;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool CanDoTrade(int &barsInchart)
 //checks various conditions to see if trade is permitted
   {
    bool
    newbar=(barsInchart!=Bars);
    double
    spread=MarketInfo(NULL,MODE_SPREAD);
    int aords,pords,
    tords=OrdersForSymbol(aords,pords);

    barsInchart=Bars;
    return ((tords==0) && newbar && (spread<9));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of orders that have been placed for a particular symbol
   {
    aords=0;pords=0;
    for(int p=OrdersTotal()-1;p>=0;p--)
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
       if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
         {
          if(OrderType()>1 && OrderType()<6)
             pords++;
          if(OrderType()==OP_BUY || OrderType()==OP_SELL)
             aords++;
         }
    return aords+pords;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void display(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
   {
    ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
    ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
    ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
    ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
    ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
   }

 //+------------------------------------------------------------------+

*** pamax (price action moving average cross)
 use ma9 for direction and ma3 for cross (which will happen quite often)
 60m looks useable, but so is any tf where we have movement
 if ma9>+x ntr when paxma3u; xit when paxma3d
 if ma9<-x ntr when paxma3d; xit when paxma3u

 create intelligent ts too

 pro
 - don't have to wait for shapes to form which might be advantageous in small tf
 - simple to implement, optimize, monitor and alter conditions due to concept
 - movements in ma9 direction are larger than in opposite
 - can adjust xit behavior depending on ma9
 - hope to get at least 50-100 points/hr
 - can work with other status markers

 con
 - can't think of any there will be lots of trades so we need to build efficiencies
 - may be awkward to do ranger, but we shall see

**** code v1
 just has simple ntr rule and fixed sltp - result is roughly breakeven
 no optimization
 best result seems to be on 15m

*** nucline
 variables:
 ni - null incline value
 lb - lookback candles
 nn - number of ni needed to establish a rhythm frequency
 rf - rhythm frequency

 premises:
 prices produce waves defined by ni
 these occur with fairly consistent rhythm
 the rf is well-behaved for the vast majority of price action

 methodology:
 look for turning points using null inclines <ni (different from fractals)
 establish rf based on nn


 get maxmin diff for bI which produces ni
 set B,R based on higher tf


**** code zero (nw)
 //+------------------------------------------------------------------+
 //|                                                      nucline.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+

 /*
 get null inclines to some number of nulls
 calculate avgrhythm
 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #define sp "  "

 /*
 look for turning points using null inclines <x
 get maxmin diff for bI which produces ni
 set B,R based on higher tf
 */

 extern int Gni;         //null incline
 extern int Gnn;         //number of nulls
 extern int Glb;         //lookback distance in candles

 int timeframes[5],
 Gtkt=0,
 GbarsInChart=0,
 GtimeframeIndex=0;
 double
 Glt=0.1;


 struct niF
 {
    //null incline format contains identifying barmark, incline value, approach
   
 }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 struct status
   {
    //incline array containing values for 60 bars
    double            arrinclines[61];

    //amplitude (max,min difference of 1..x bars) calculation items            
    int               maxbar,minbar;
    double            maxval,minval,amplitude;

    //bs BER
    int               bs;
    double            oo,sl,tp;
   };

 status Gs;
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OnInit()
   {
    timeframes[0]=1;timeframes[1]=5;timeframes[2]=15;timeframes[3]=30;timeframes[4]=60;
    return(INIT_SUCCEEDED);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {

    int
    tf=timeframes[0];

    statusfill(tf,20,Gs);

    if(CanDoTrade(GbarsInChart))
      {
       //Gtkt=OrderSend(Symbol(),stat.bs,Glt,stat.oo,0,stat.sl,stat.tp);
      }

   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void statusfill(int tf,int barMax,status &s)
 //determines status
   {
 //fill incline array
    for(int b=2;b<barMax;b++)
       s.arrinclines[b]=incline(b,iOpen(NULL,tf,b),1,iOpen(NULL,tf,1));
    Comment(s.arrinclines[11]);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 /*
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void status1(int tf,int bI,int bF,status &s)
 //determines various behavior aspects for nbars
   {
    double amptmp,accmax,accmin,avgmax,avgmin;
    int b,
    barsN=bI-bF+1,
    inclinesN=bI-1;
    string
    mode="N";

 //fill barV bF-bI with lo,hi,me
    for(b=bF;b<=bI;b++)
      {
       s.lo[b]=iLow(NULL,tf,b);
       s.hi[b]=iHigh(NULL,tf,b);
       s.me[b]=0.5*(s.lo[b]+s.hi[b]);
      }

 //add up the inclines from bx to bF
    s.lo[0]=0;s.me[0]=0;s.hi[0]=0;
    for(b=bF+1;b<=bI;b++)
      {
       s.lo[0]=s.lo[0]+incline(b,s.lo[b],bF,s.lo[bF]);
       s.hi[0]=s.hi[0]+incline(b,s.hi[b],bF,s.hi[bF]);
       s.me[0]=s.me[0]+incline(b,s.me[b],bF,s.me[bF]);
      }

 //calculate the average inclines for lo,hi,me
    s.inc_lo=s.lo[0]/inclinesN;
    s.inc_hi=s.hi[0]/inclinesN;
    s.inc_me=s.me[0]/inclinesN;

 //get maxmin data for 1..x bars and calculate amplitude
    maxmin(tf,bI,bF,s.maxbar,s.maxval,s.minbar,s.minval);
    s.amplitude=Dpts(s.minval,s.maxval);
    if(s.amplitude<30) amptmp=30;else amptmp=s.amplitude;

 //determine mean maxmin
    accmax=0;accmin=0;
    for(b=bF;b<=bI;b++)
    {
       accmax=accmax+iHigh(NULL,tf,b);
       accmin=accmin+iLow(NULL,tf,b);
    }
    avgmax=accmax/barsN;
    avgmin=accmin/barsN;

 //display status
    display("amplitude","amplitude = "+DoubleToStr(s.amplitude),1,200,0,Red);
    display("incl_hi","incl_hi = "+DoubleToStr(s.inc_hi),1,200,20,Red);
    display("incl_me","incl_me = "+DoubleToStr(s.inc_me),1,200,30,Red);
    display("incl_lo","incl_lo = "+DoubleToStr(s.inc_lo),1,200,40,Red);
    display("mode","mode = "+mode,1,200,60,Green);
    display("avgmax","avgmax = "+DoubleToStr(avgmax),1,200,70,Blue);
    display("avgmin","avgmin = "+DoubleToStr(avgmin),1,200,80,Blue); 
  
  }
 */

 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double extrapolate(int bI,double bIval,double avgincl)
 //extrapolates point from bI to bar0 given bIval and avgincline
   {
    return avgincl*Point*(bI)+bIval;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
   {
    maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
    maxval=iHigh(NULL,tf,maxbar);
    minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
    minval=iLow(NULL,tf,minbar);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
   {
    return (pF-pI)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
   {
    int
    Dbar=bI-bF;
    return Dpts(vI,vF)/Dbar;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool CanDoTrade(int &barsInchart)
 //checks various conditions to see if trade is permitted
   {
    bool
    newbar=(barsInchart!=Bars);
    double
    spread=MarketInfo(NULL,MODE_SPREAD);
    int aords,pords,
    tords=OrdersForSymbol(aords,pords);

    barsInchart=Bars;
    return ((tords==0) && newbar && (spread<9));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of orders that have been placed for a particular symbol
   {
    aords=0;pords=0;
    for(int p=OrdersTotal()-1;p>=0;p--)
       if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
         {
          if(OrderType()>1 && OrderType()<6)
             pords++;
          if(OrderType()==OP_BUY || OrderType()==OP_SELL)
             aords++;
         }
    return aords+pords;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void closepords()
 //clears pending orders
   {
    bool ordsel,orddel;
    for(int p=OrdersTotal()-1;p>=0;p--)
      {
       ordsel=OrderSelect(p,SELECT_BY_POS);
       if(OrderType()>1)
          orddel=OrderDelete(OrderTicket());
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void display(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
   {
    ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
    ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
    ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
    ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
    ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
   }

 /*
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void projector(int tf,int bI,int bF,int &bs,double &oo,double &sl,double &tp)
 //
   {
    double projV[3],inclacc[3],barV[3,3];
    int b,
    numb=bI-bF+1;
    ArrayInitialize(projV,0);
    ArrayResize(barV,numb+1);

 //fill barV bF-bI with lo,hi,me
    for(b=bF;b<=numb;b++)
      {
       barV[b,0]=iLow(NULL,tf,b);
       barV[b,2]=iHigh(NULL,tf,b);
       barV[b,1]=0.5*(barV[b,0]+barV[b,2]);
      }

 //add up the inclines from bx to bF  
    ArrayInitialize(inclacc,0);
    for(b=bF+1;b<=numb;b++)
      {
       inclacc[0]=inclacc[0]+incline(b,barV[b,0],bF,barV[bF,0]);
       inclacc[1]=inclacc[1]+incline(b,barV[b,1],bF,barV[bF,1]);
       inclacc[2]=inclacc[2]+incline(b,barV[b,2],bF,barV[bF,2]);
      }

 //calculate the avgincl for lo,hi,me and store in barV[0,x]
    for(int i=0;i<3;i++)
       barV[0,i]=inclacc[i]/(numb-1);

    for(int i=0;i<3;i++)
       projV[i]=extrapolate(1,barV[1,i],barV[0,i]);

    if(barV[0,1]>+Graexthresh)
      {
       //Comment("buy");
       bs=OP_BUYLIMIT;
       oo=projV[1]-Gslfactor*fabs(Dpts(projV[0],projV[1]))*Point;
       tp=projV[1]+Gtpfactor*fabs(Dpts(projV[2],projV[1]))*Point;
       sl=barV[2,1];
      }
    if(barV[0,1]<-Graexthresh)
      {
       Comment("sel");
       bs=OP_SELLLIMIT;
       oo=projV[1]+Gslfactor*fabs(Dpts(projV[2],projV[1]))*Point;
       tp=projV[1]-Gtpfactor*fabs(Dpts(projV[0],projV[1]))*Point;
       sl=barV[2,1];
       //*** figure out oo,sl,tp
       //*** use nul to launch explorer
      }
    if(barV[0,1]<+Graexthresh && barV[0,1]>-Graexthresh)
      {
       Comment("nul");
      }
   }
 */

 /*
       if(s.inc_me>0)
         {
          s.bs=1;
          s.oo=Bid;
          s.sl=s.maxval;
          s.tp=Bid-2*(s.sl-Bid);
         }
       if(s.inc_me<0)
         {
          s.bs=0;
          s.oo=Ask;
          s.sl=s.minval;
          s.tp=Ask+2*(Ask-s.sl);
         }
         */

 //+------------------------------------------------------------------+

**** code with queues and inclines (nw)
 //+------------------------------------------------------------------+
 //|                                                      nucline.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+

 /*
 figure out what should go into status
 get null inclines to some number of nulls when detectni=true
 calculate avgrhythm
 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #define sp "  "

 /*
 look for turning points using null inclines <x
 get maxmin diff for bI which produces ni
 set B,R based on higher tf
 */

 extern int Gni;         //null incline
 extern int Gnn;         //number of nulls
 extern int Glb;         //lookback distance in candles

 int timeframes[5],
 Gtkt=0,
 GbarsInChart=0,
 GtimeframeIndex=0,
 Gf=0,
 Gl=4;
 double
 Glt=0.1;
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 struct niF
   {
    //null incline format contains identifying barmark, incline value, nuances (noru)
    int               barmark;
    double            inclval;
    string            nuances;
   };
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 struct status
   {
    //form the ni array
    niF               loni[5],meni[5],hini[5];

    //amplitude (max,min difference of 1..x bars) calculation items            
    int               maxbar,minbar;
    double            maxval,minval,amplitude;

    //bs BER
    int               bs;
    double            oo,sl,tp;
   };

 status Gs;
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OnInit()
   {
    timeframes[0]=1;timeframes[1]=5;timeframes[2]=15;timeframes[3]=30;timeframes[4]=60;
    return(INIT_SUCCEEDED);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {

    int
    tf=timeframes[0];
    niF newni;

    for(int i=1;i<140;i++)
      {
       if(detectni(tf,i,i-2))
          Comment(i);
      }

   

 /*   queue(Gf,Gl);
    statusfill(newni,Gf,Gl,Gs);
   
    statusfill(tf,20,Gs);

    if(CanDoTrade(GbarsInChart))
      {
       //Gtkt=OrderSend(Symbol(),stat.bs,Glt,stat.oo,0,stat.sl,stat.tp);
      }
 */
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool detectni(int tf,int bI,int bF)
 //do we have ni
   {
    double inclVA[3];
    getinclines(tf,bI,bF,inclVA);
    if(fabs(inclVA[1])<5.0) return true; else return false;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void getinclines(int tf,int bI,int bF,double &inclVA[])
 //detects ni for hi,me,lo
   {
    double
    hiF=iHigh(NULL,tf,bF),
    hiI=iHigh(NULL,tf,bI),
    loF=iLow(NULL,tf,bF),
    loI=iLow(NULL,tf,bI),
    meF=(hiF+loF)/2,
    meI=(hiI+loI)/2;
    inclVA[0]=incline(bI,loI,bF,loF);
    inclVA[1]=incline(bI,meI,bF,meF);//Comment(meI,sp,meF,sp,inclVA[1]);
    inclVA[2]=incline(bI,hiI,bF,hiF);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void statusfill(niF &newni,int f,int l,status &s)
 //determine status for various items
   {
    s.meni[l].barmark=newni.barmark;
    s.meni[l].inclval=newni.inclval;
    s.meni[l].nuances=newni.nuances;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void queue(int &f,int &l)
 //queue items
   {
    int
    arrmax=5;

    f++;l++;
    f=(int)fmod(f,arrmax);
    l=(int)fmod(l,arrmax);


 //ni[l].barmark=newitem.barmark;
 //ni[l].inclval=newitem.inclval;
 //ni[l].aproach=newitem.aproach;

   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 /*
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void status1(int tf,int bI,int bF,status &s)
 //determines various behavior aspects for nbars
   {
    double amptmp,accmax,accmin,avgmax,avgmin;
    int b,
    barsN=bI-bF+1,
    inclinesN=bI-1;
    string
    mode="N";

 //fill barV bF-bI with lo,hi,me
    for(b=bF;b<=bI;b++)
      {
       s.lo[b]=iLow(NULL,tf,b);
       s.hi[b]=iHigh(NULL,tf,b);
       s.me[b]=0.5*(s.lo[b]+s.hi[b]);
      }

 //add up the inclines from bx to bF
    s.lo[0]=0;s.me[0]=0;s.hi[0]=0;
    for(b=bF+1;b<=bI;b++)
      {
       s.lo[0]=s.lo[0]+incline(b,s.lo[b],bF,s.lo[bF]);
       s.hi[0]=s.hi[0]+incline(b,s.hi[b],bF,s.hi[bF]);
       s.me[0]=s.me[0]+incline(b,s.me[b],bF,s.me[bF]);
      }

 //calculate the average inclines for lo,hi,me
    s.inc_lo=s.lo[0]/inclinesN;
    s.inc_hi=s.hi[0]/inclinesN;
    s.inc_me=s.me[0]/inclinesN;

 //get maxmin data for 1..x bars and calculate amplitude
    maxmin(tf,bI,bF,s.maxbar,s.maxval,s.minbar,s.minval);
    s.amplitude=Dpts(s.minval,s.maxval);
    if(s.amplitude<30) amptmp=30;else amptmp=s.amplitude;

 //determine mean maxmin
    accmax=0;accmin=0;
    for(b=bF;b<=bI;b++)
    {
       accmax=accmax+iHigh(NULL,tf,b);
       accmin=accmin+iLow(NULL,tf,b);
    }
    avgmax=accmax/barsN;
    avgmin=accmin/barsN;

 //display status
    display("amplitude","amplitude = "+DoubleToStr(s.amplitude),1,200,0,Red);
    display("incl_hi","incl_hi = "+DoubleToStr(s.inc_hi),1,200,20,Red);
    display("incl_me","incl_me = "+DoubleToStr(s.inc_me),1,200,30,Red);
    display("incl_lo","incl_lo = "+DoubleToStr(s.inc_lo),1,200,40,Red);
    display("mode","mode = "+mode,1,200,60,Green);
    display("avgmax","avgmax = "+DoubleToStr(avgmax),1,200,70,Blue);
    display("avgmin","avgmin = "+DoubleToStr(avgmin),1,200,80,Blue); 
  
  }
 */

 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double extrapolate(int bI,double bIval,double avgincl)
 //extrapolates point from bI to bar0 given bIval and avgincline
   {
    return avgincl*Point*(bI)+bIval;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
   {
    maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
    maxval=iHigh(NULL,tf,maxbar);
    minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
    minval=iLow(NULL,tf,minbar);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
   {
    return (pF-pI)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
   {
    int
    Dbar=bI-bF;
    return Dpts(vI,vF)/Dbar;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool CanDoTrade(int &barsInchart)
 //checks various conditions to see if trade is permitted
   {
    bool
    newbar=(barsInchart!=Bars);
    double
    spread=MarketInfo(NULL,MODE_SPREAD);
    int aords,pords,
    tords=OrdersForSymbol(aords,pords);

    barsInchart=Bars;
    return ((tords==0) && newbar && (spread<9));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of orders that have been placed for a particular symbol
   {
    aords=0;pords=0;
    for(int p=OrdersTotal()-1;p>=0;p--)
       if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
         {
          if(OrderType()>1 && OrderType()<6)
             pords++;
          if(OrderType()==OP_BUY || OrderType()==OP_SELL)
             aords++;
         }
    return aords+pords;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void closepords()
 //clears pending orders
   {
    bool ordsel,orddel;
    for(int p=OrdersTotal()-1;p>=0;p--)
      {
       ordsel=OrderSelect(p,SELECT_BY_POS);
       if(OrderType()>1)
          orddel=OrderDelete(OrderTicket());
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void display(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
   {
    ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
    ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
    ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
    ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
    ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
   }

 /*
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void projector(int tf,int bI,int bF,int &bs,double &oo,double &sl,double &tp)
 //
   {
    double projV[3],inclacc[3],barV[3,3];
    int b,
    numb=bI-bF+1;
    ArrayInitialize(projV,0);
    ArrayResize(barV,numb+1);

 //fill barV bF-bI with lo,hi,me
    for(b=bF;b<=numb;b++)
      {
       barV[b,0]=iLow(NULL,tf,b);
       barV[b,2]=iHigh(NULL,tf,b);
       barV[b,1]=0.5*(barV[b,0]+barV[b,2]);
      }

 //add up the inclines from bx to bF  
    ArrayInitialize(inclacc,0);
    for(b=bF+1;b<=numb;b++)
      {
       inclacc[0]=inclacc[0]+incline(b,barV[b,0],bF,barV[bF,0]);
       inclacc[1]=inclacc[1]+incline(b,barV[b,1],bF,barV[bF,1]);
       inclacc[2]=inclacc[2]+incline(b,barV[b,2],bF,barV[bF,2]);
      }

 //calculate the avgincl for lo,hi,me and store in barV[0,x]
    for(int i=0;i<3;i++)
       barV[0,i]=inclacc[i]/(numb-1);

    for(int i=0;i<3;i++)
       projV[i]=extrapolate(1,barV[1,i],barV[0,i]);

    if(barV[0,1]>+Graexthresh)
      {
       //Comment("buy");
       bs=OP_BUYLIMIT;
       oo=projV[1]-Gslfactor*fabs(Dpts(projV[0],projV[1]))*Point;
       tp=projV[1]+Gtpfactor*fabs(Dpts(projV[2],projV[1]))*Point;
       sl=barV[2,1];
      }
    if(barV[0,1]<-Graexthresh)
      {
       Comment("sel");
       bs=OP_SELLLIMIT;
       oo=projV[1]+Gslfactor*fabs(Dpts(projV[2],projV[1]))*Point;
       tp=projV[1]-Gtpfactor*fabs(Dpts(projV[0],projV[1]))*Point;
       sl=barV[2,1];
       //*** figure out oo,sl,tp
       //*** use nul to launch explorer
      }
    if(barV[0,1]<+Graexthresh && barV[0,1]>-Graexthresh)
      {
       Comment("nul");
      }
   }
 */

 /*
       if(s.inc_me>0)
         {
          s.bs=1;
          s.oo=Bid;
          s.sl=s.maxval;
          s.tp=Bid-2*(s.sl-Bid);
         }
       if(s.inc_me<0)
         {
          s.bs=0;
          s.oo=Ask;
          s.sl=s.minval;
          s.tp=Ask+2*(Ask-s.sl);
         }
         */

 //+------------------------------------------------------------------+

*** COT
 no sltp, just 2 orders of bs
 when one is triggered the other serves as a modifiable trailing stop
 when both are triggered we remove one and set a pending order as stop
 can use ideas from BER to determine situation
 the spacing between COT can vary depending on market conditions in tf such as maxmin of x candles and/or we can form some sort of nu via price movement rather than by candles
 also track length of waves over y candles and determine E/R based on where ntr is to be made as well as checking slope of next higher tf - this is a principle utilized in hasofine in that we used the higher tf to determine what to do in the lower one
 ma should correspond with bI
 try going in with pords rather than aords
 take median of maxmin and see where price is in relation to though ma could be clearer to determine if slope is level
*** BER breakout, explorer, ranger
 raex ideas seem fairly certain at present
 - ranger if x bars have amplitude, zeroslope, maxmins are fairly close
 - explorer if x bars have amplitude and slope
 breakout cannot be based on low amplitude except on 1m because higher tf rarely has sufficiently low ampl (results on 1m were weak)
 - the concept of breakout has little to do with ampl
 - breakout only when strong range limits are exceeded
 - use minampl of maxmin for bars to determine if breakout is feasible
 - otherwise raex approaches are more relevant

 monitor merit of raexbo continuously and display

**** code Breakout of small ampl
 GslopB 5,5,50
 GamplB 5,5,50
 GbI    3,1,8

 | 12 | 64.20 | 212 | 51.70 | 0.51% | GslopB=45 | GamplB=35 | GbI=4 |
 | 11 | 64.20 | 212 | 51.70 | 0.51% | GslopB=30 | GamplB=35 | GbI=4 |
 |  9 | 64.20 | 212 | 51.70 | 0.51% | GslopB=25 | GamplB=35 | GbI=4 |
 |  6 | 64.20 | 212 | 51.70 | 0.51% | GslopB=50 | GamplB=35 | GbI=4 |
 |  2 | 64.20 | 212 | 51.70 | 0.51% | GslopB=40 | GamplB=35 | GbI=4 |

 after this set, there is an interesting and sharp drop to

 | 10 | 26.80 | 323 | 67.20 | 0.67% | GslopB=40 | GamplB=10 | GbI=4 |
 |  8 | 26.80 | 323 | 67.20 | 0.67% | GslopB=25 | GamplB=10 | GbI=4 |
 |  7 | 26.80 | 323 | 67.20 | 0.67% | GslopB=5  | GamplB=10 | GbI=4 |




 //+------------------------------------------------------------------+
 //|                                                   pradiation.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+

 /*
 get B trades refined
 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #define sp "  "

 /*
 program trades on bars in raex modes
 using 3ma concept to determine ntrxit through projection
 beware of sl when there are significant slopes
 don't do mostly sel on uptrend and buy on downtrend
 */

 extern double  GslopB;
 extern double  GamplB;
 extern int     GbI;


 int timeframes[5],
 Gtkt=0,
 GbarsInChart=0,
 GtimeframeIndex=0;
 double
 Gminamp=30,
 GslopE=15,
 GamplE=30,
 GslopR=10,
 GamplR=50,
 Glt=0.1;
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 struct status
   {
    //contains the main components to determine the status of the market
    //such as incline values, amplitude, maxmin bars and values
    //from which the modes can be computed as well as
    //determination of bs,oo,sl,tp  

    //hi,me,lo values for bars 1..x
    double            hi[5],me[5],lo[5];

    //incline results for hi,me,lo
    double            inc_hi,inc_me,inc_lo;

    //amplitude (max,min difference of 1..x bars) calculation items            
    int               maxbar,minbar;
    double            maxval,minval,amplitude;

    //modeB,modeE,modeR;      mode qualities of Breakout, Explorer, Ranger
    int               modeB,modeE,modeR;

    //bs BER
    int               bs;
    double            oo,sl,tp;
   };

 status stat;
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OnInit()
   {
    timeframes[0]=1;timeframes[1]=5;timeframes[2]=15;timeframes[3]=30;timeframes[4]=60;
    //Gminamp=30;
    return(INIT_SUCCEEDED);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {
    int
    tf=timeframes[0];
    status(tf,GbI,1,stat);

   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void status(int tf,int bI,int bF,status &s)
 //determines mode (0-B,1-R,2-E) and its quality based on hilome of GbI
   {
    int btk,stk;
    double amptmp;
    int b,
    inclinesN=bI-1;
    string
    mode="N";

 //markettrade parameters
    bool
    spreadOK=MarketInfo(NULL,MODE_SPREAD)<9;
    int aords,pords,
    tords=OrdersForSymbol(aords,pords);

 if(aords>0) closepords();

 //fill barV bF-bI with lo,hi,me
    for(b=bF;b<=bI;b++)
      {
       s.lo[b]=iLow(NULL,tf,b);
       s.hi[b]=iHigh(NULL,tf,b);
       s.me[b]=0.5*(s.lo[b]+s.hi[b]);
      }

 //add up the inclines from bx to bF
    s.lo[0]=0;s.me[0]=0;s.hi[0]=0;
    for(b=bF+1;b<=bI;b++)
      {
       s.lo[0]=s.lo[0]+incline(b,s.lo[b],bF,s.lo[bF]);
       s.hi[0]=s.hi[0]+incline(b,s.hi[b],bF,s.hi[bF]);
       s.me[0]=s.me[0]+incline(b,s.me[b],bF,s.me[bF]);
      }

 //calculate the average inclines for lo,hi,me
    s.inc_lo=s.lo[0]/inclinesN;
    s.inc_hi=s.hi[0]/inclinesN;
    s.inc_me=s.me[0]/inclinesN;

 //get maxmin data for 1..x bars and calculate amplitude
    maxmin(tf,bI,bF,s.maxbar,s.maxval,s.minbar,s.minval);
    s.amplitude=Dpts(s.minval,s.maxval);
    if(s.amplitude<Gminamp) amptmp=Gminamp;else amptmp=s.amplitude;
 /* there can be more to all this depending on which bars the max and min occur*/

 //determine mode
    if(fabs(s.inc_me)<GslopB && s.amplitude<GamplB)
      {
       mode="B";
       double
       amplitude=amptmp*Point,
       ntramt=0.5*amplitude,
       boo=s.maxval+ntramt,
       soo=s.minval-ntramt,
       bsl=soo,
       btp=boo+amplitude,
       ssl=boo,
       stp=soo-amplitude;

       if(tords==0 && spreadOK)
         {
          btk=OrderSend(Symbol(),4,Glt,boo,0,bsl,btp);
          stk=OrderSend(Symbol(),5,Glt,soo,0,ssl,stp);
         }
       //tkt=OrderSend(Symbol(),s.bs,Glt,s.oo,0,s.sl,s.tp);
 /*if(Ask>boo)
         {
          s.bs=0;
          s.oo=Ask;
          s.sl=soo;
          s.tp=boo+amplitude;
         }
       if(Bid<soo)
         {
          s.bs=1;
          s.oo=Bid;
          s.sl=boo;
          s.tp=soo-amplitude;
         }*/
      }
    if(fabs(s.inc_me)>GslopE && s.amplitude>GamplE) mode="E";
    if(fabs(s.inc_me)<GslopR && s.amplitude>GamplR) mode="R";

 //display status
    display("amplitude","amplitude = "+DoubleToStr(s.amplitude),1,200,0,Red);
    display("incl_hi","incl_hi = "+DoubleToStr(s.inc_hi),1,200,20,Red);
    display("incl_me","incl_me = "+DoubleToStr(s.inc_me),1,200,30,Red);
    display("incl_lo","incl_lo = "+DoubleToStr(s.inc_lo),1,200,40,Red);
    display("mode","mode = "+mode,1,200,60,Green);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double extrapolate(int bI,double bIval,double avgincl)
 //extrapolates point from bI to bar0 given bIval and avgincline
   {
    return avgincl*Point*(bI)+bIval;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
   {
    maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
    maxval=iHigh(NULL,tf,maxbar);
    minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
    minval=iLow(NULL,tf,minbar);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
   {
    return (pF-pI)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
   {
    int
    Dbar=bI-bF;
    return Dpts(vI,vF)/Dbar;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of orders that have been placed for a particular symbol
   {
    aords=0;pords=0;
    for(int p=OrdersTotal()-1;p>=0;p--)
       if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
         {
          if(OrderType()>1 && OrderType()<6)
             pords++;
          if(OrderType()==OP_BUY || OrderType()==OP_SELL)
             aords++;
         }
    return aords+pords;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void closepords()
 //clears pending orders
   {
    bool ordsel,orddel;
    for(int p=OrdersTotal()-1;p>=0;p--)
      {
       ordsel=OrderSelect(p,SELECT_BY_POS);
       if(OrderType()>1)
          orddel=OrderDelete(OrderTicket());
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void display(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
   {
    ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
    ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
    ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
    ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
    ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
   }

 /*
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void projector(int tf,int bI,int bF,int &bs,double &oo,double &sl,double &tp)
 //
   {
    double projV[3],inclacc[3],barV[3,3];
    int b,
    numb=bI-bF+1;
    ArrayInitialize(projV,0);
    ArrayResize(barV,numb+1);

 //fill barV bF-bI with lo,hi,me
    for(b=bF;b<=numb;b++)
      {
       barV[b,0]=iLow(NULL,tf,b);
       barV[b,2]=iHigh(NULL,tf,b);
       barV[b,1]=0.5*(barV[b,0]+barV[b,2]);
      }

 //add up the inclines from bx to bF  
    ArrayInitialize(inclacc,0);
    for(b=bF+1;b<=numb;b++)
      {
       inclacc[0]=inclacc[0]+incline(b,barV[b,0],bF,barV[bF,0]);
       inclacc[1]=inclacc[1]+incline(b,barV[b,1],bF,barV[bF,1]);
       inclacc[2]=inclacc[2]+incline(b,barV[b,2],bF,barV[bF,2]);
      }

 //calculate the avgincl for lo,hi,me and store in barV[0,x]
    for(int i=0;i<3;i++)
       barV[0,i]=inclacc[i]/(numb-1);

    for(int i=0;i<3;i++)
       projV[i]=extrapolate(1,barV[1,i],barV[0,i]);

    if(barV[0,1]>+Graexthresh)
      {
       //Comment("buy");
       bs=OP_BUYLIMIT;
       oo=projV[1]-Gslfactor*fabs(Dpts(projV[0],projV[1]))*Point;
       tp=projV[1]+Gtpfactor*fabs(Dpts(projV[2],projV[1]))*Point;
       sl=barV[2,1];
      }
    if(barV[0,1]<-Graexthresh)
      {
       Comment("sel");
       bs=OP_SELLLIMIT;
       oo=projV[1]+Gslfactor*fabs(Dpts(projV[2],projV[1]))*Point;
       tp=projV[1]-Gtpfactor*fabs(Dpts(projV[0],projV[1]))*Point;
       sl=barV[2,1];
       //*** figure out oo,sl,tp
       //*** use nul to launch explorer
      }
    if(barV[0,1]<+Graexthresh && barV[0,1]>-Graexthresh)
      {
       Comment("nul");
      }
   }
 */

 //+------------------------------------------------------------------+

**** code working on R then E
 //+------------------------------------------------------------------+
 //|                                                          ber.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+

 /*
 get E and R figured out and then work on B (based on R)
 */

 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #define sp "  "

 /*
 program trades on bars in raex modes
 using 3ma concept to determine ntrxit through projection
 beware of sl when there are significant slopes
 don't do mostly sel on uptrend and buy on downtrend
 */

 extern int GtfIndex;
 extern int GbI;

 int timeframes[5],
 Gtkt=0,
 GbarsInChart=0,
 GtimeframeIndex=0;
 double
 GslopB=10,
 GamplB=10,
 GslopE=15,
 GamplE=30,
 GslopR=10,
 GamplR=50,
 Glt=0.1;
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 struct status
   {
    //contains the main components to determine the status of the market
    //such as incline values, amplitude, maxmin bars and values
    //from which the modes can be computed as well as
    //determination of bs,oo,sl,tp  

    //hi,me,lo values for bars 1..x
    double            hi[5],me[5],lo[5];

    //incline results for hi,me,lo
    double            inc_hi,inc_me,inc_lo;

    //amplitude (max,min difference of 1..x bars) calculation items            
    int               maxbar,minbar;
    double            maxval,minval,amplitude;

    //modeB,modeE,modeR;      mode qualities of Breakout, Explorer, Ranger
    int               modeB,modeE,modeR;

    //bs BER
    int               bs;
    double            oo,sl,tp;
   };

 status stat;
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OnInit()
   {
    timeframes[0]=1;timeframes[1]=5;timeframes[2]=15;timeframes[3]=30;timeframes[4]=60;
    return(INIT_SUCCEEDED);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {
  
   GtfIndex=1;
   GbI=3;
    int
    tf=timeframes[GtfIndex];
    status(tf,GbI,1,stat);

    if(CanDoTrade(GbarsInChart))
      {
       Gtkt=OrderSend(Symbol(),stat.bs,Glt,stat.oo,0,stat.sl,stat.tp);
      }

   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void status(int tf,int bI,int bF,status &s)
 //determines mode (0-B,1-R,2-E) and its quality based on hilome of GbI
   {
    double amptmp,accmax,accmin,avgmax,avgmin;
    int b,
    barsN=bI-bF+1,
    inclinesN=bI-1;
    string
    mode="N";

 //fill barV bF-bI with lo,hi,me
    for(b=bF;b<=bI;b++)
      {
       s.lo[b]=iLow(NULL,tf,b);
       s.hi[b]=iHigh(NULL,tf,b);
       s.me[b]=0.5*(s.lo[b]+s.hi[b]);
      }

 //add up the inclines from bx to bF
    s.lo[0]=0;s.me[0]=0;s.hi[0]=0;
    for(b=bF+1;b<=bI;b++)
      {
       s.lo[0]=s.lo[0]+incline(b,s.lo[b],bF,s.lo[bF]);
       s.hi[0]=s.hi[0]+incline(b,s.hi[b],bF,s.hi[bF]);
       s.me[0]=s.me[0]+incline(b,s.me[b],bF,s.me[bF]);
      }

 //calculate the average inclines for lo,hi,me
    s.inc_lo=s.lo[0]/inclinesN;
    s.inc_hi=s.hi[0]/inclinesN;
    s.inc_me=s.me[0]/inclinesN;

 //get maxmin data for 1..x bars and calculate amplitude
    maxmin(tf,bI,bF,s.maxbar,s.maxval,s.minbar,s.minval);
    s.amplitude=Dpts(s.minval,s.maxval);
    if(s.amplitude<30) amptmp=30;else amptmp=s.amplitude;
 /* there can be more to all this depending on which bars the max and min occur*/

 //determine mean maxmin
    accmax=0;accmin=0;
    for(b=bF;b<=bI;b++)
    {
       accmax=accmax+iHigh(NULL,tf,b);
       accmin=accmin+iLow(NULL,tf,b);
    }
    avgmax=accmax/barsN;
    avgmin=accmin/barsN;

 //display status
    display("amplitude","amplitude = "+DoubleToStr(s.amplitude),1,200,0,Red);
    display("incl_hi","incl_hi = "+DoubleToStr(s.inc_hi),1,200,20,Red);
    display("incl_me","incl_me = "+DoubleToStr(s.inc_me),1,200,30,Red);
    display("incl_lo","incl_lo = "+DoubleToStr(s.inc_lo),1,200,40,Red);
    display("mode","mode = "+mode,1,200,60,Green);
    display("avgmax","avgmax = "+DoubleToStr(avgmax),1,200,70,Blue);
    display("avgmin","avgmin = "+DoubleToStr(avgmin),1,200,80,Blue); 
  
 //determine mode
    if(fabs(s.inc_me)>GslopE && s.amplitude>GamplE)
      {
       mode="E";
       /*
       if(s.inc_me>0)
         {
          s.bs=0;
          s.oo=Ask;
          s.sl=s.minval;
          s.tp=Ask+(Ask-s.sl);
         }
       if(s.inc_me<0)
         {
          s.bs=1;
          s.oo=Bid;
          s.sl=s.maxval;
          s.tp=Bid-(s.sl-Bid);
         }
        
       return;*/
      }

    if(fabs(s.inc_me)<GslopR && s.amplitude>GamplR) 
    {
    mode="R";
   

   
    }
    if(fabs(s.inc_me)<GslopB && s.amplitude<GamplB) mode="B";
  }

 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double extrapolate(int bI,double bIval,double avgincl)
 //extrapolates point from bI to bar0 given bIval and avgincline
   {
    return avgincl*Point*(bI)+bIval;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
   {
    maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
    maxval=iHigh(NULL,tf,maxbar);
    minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
    minval=iLow(NULL,tf,minbar);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
   {
    return (pF-pI)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
   {
    int
    Dbar=bI-bF;
    return Dpts(vI,vF)/Dbar;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool CanDoTrade(int &barsInchart)
 //checks various conditions to see if trade is permitted
   {
    bool
    newbar=(barsInchart!=Bars);
    double
    spread=MarketInfo(NULL,MODE_SPREAD);
    int aords,pords,
    tords=OrdersForSymbol(aords,pords);

    barsInchart=Bars;
    return ((tords==0) && newbar && (spread<9));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of orders that have been placed for a particular symbol
   {
    aords=0;pords=0;
    for(int p=OrdersTotal()-1;p>=0;p--)
       if(OrderSelect(p,SELECT_BY_POS) && OrderSymbol()==Symbol())
         {
          if(OrderType()>1 && OrderType()<6)
             pords++;
          if(OrderType()==OP_BUY || OrderType()==OP_SELL)
             aords++;
         }
    return aords+pords;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void closepords()
 //clears pending orders
   {
    bool ordsel,orddel;
    for(int p=OrdersTotal()-1;p>=0;p--)
      {
       ordsel=OrderSelect(p,SELECT_BY_POS);
       if(OrderType()>1)
          orddel=OrderDelete(OrderTicket());
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void display(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
   {
    ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
    ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
    ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
    ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
    ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
   }

 /*
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void projector(int tf,int bI,int bF,int &bs,double &oo,double &sl,double &tp)
 //
   {
    double projV[3],inclacc[3],barV[3,3];
    int b,
    numb=bI-bF+1;
    ArrayInitialize(projV,0);
    ArrayResize(barV,numb+1);

 //fill barV bF-bI with lo,hi,me
    for(b=bF;b<=numb;b++)
      {
       barV[b,0]=iLow(NULL,tf,b);
       barV[b,2]=iHigh(NULL,tf,b);
       barV[b,1]=0.5*(barV[b,0]+barV[b,2]);
      }

 //add up the inclines from bx to bF  
    ArrayInitialize(inclacc,0);
    for(b=bF+1;b<=numb;b++)
      {
       inclacc[0]=inclacc[0]+incline(b,barV[b,0],bF,barV[bF,0]);
       inclacc[1]=inclacc[1]+incline(b,barV[b,1],bF,barV[bF,1]);
       inclacc[2]=inclacc[2]+incline(b,barV[b,2],bF,barV[bF,2]);
      }

 //calculate the avgincl for lo,hi,me and store in barV[0,x]
    for(int i=0;i<3;i++)
       barV[0,i]=inclacc[i]/(numb-1);

    for(int i=0;i<3;i++)
       projV[i]=extrapolate(1,barV[1,i],barV[0,i]);

    if(barV[0,1]>+Graexthresh)
      {
       //Comment("buy");
       bs=OP_BUYLIMIT;
       oo=projV[1]-Gslfactor*fabs(Dpts(projV[0],projV[1]))*Point;
       tp=projV[1]+Gtpfactor*fabs(Dpts(projV[2],projV[1]))*Point;
       sl=barV[2,1];
      }
    if(barV[0,1]<-Graexthresh)
      {
       Comment("sel");
       bs=OP_SELLLIMIT;
       oo=projV[1]+Gslfactor*fabs(Dpts(projV[2],projV[1]))*Point;
       tp=projV[1]-Gtpfactor*fabs(Dpts(projV[0],projV[1]))*Point;
       sl=barV[2,1];
       //*** figure out oo,sl,tp
       //*** use nul to launch explorer
      }
    if(barV[0,1]<+Graexthresh && barV[0,1]>-Graexthresh)
      {
       Comment("nul");
      }
   }
 */

         /*
       if(s.inc_me>0)
         {
          s.bs=1;
          s.oo=Bid;
          s.sl=s.maxval;
          s.tp=Bid-2*(s.sl-Bid);
         }
       if(s.inc_me<0)
         {
          s.bs=0;
          s.oo=Ask;
          s.sl=s.minval;
          s.tp=Ask+2*(Ask-s.sl);
         }
         */

 //+------------------------------------------------------------------+

*** pradiation
 improved to BER
 program trades primarily on bars using both modes of raex
 principle idea is to take a significant chunk of each move

 first try to optimize the xbars
 then see if combos of xbars working together lead to anything
**** initial code with display
 //+------------------------------------------------------------------+
 //|                                                   pradiation.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+
 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict

 /*
 program trades primarily on bars using both modes of raex
 principle idea is to take a significant chunk of each move
 */

 int OnInit() {return(INIT_SUCCEEDED);}
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {
    int timeframe=1;
    string pricemovestr,inclinestr;

    pricemovestr="barsize = "+DoubleToStr(apm(timeframe));
    display("barsize",pricemovestr,1,200,0,Red);
   
    inclinestr="incline = "+DoubleToStr(medianincline(timeframe,2,1));
    display("incline",inclinestr,1,200,20,Blue);

   }
 double medianincline(int timeframe,int barI,int barF)
 //calculates the incline of median values
 {
  double
  inclineval=incline(timeframe,barI,iMA(NULL,timeframe,1,0,0,4,barI),barF,iMA(NULL,timeframe,1,0,0,4,barF));
 
  Comment(iMA(NULL,timeframe,1,0,0,4,barI));
  return inclineval;
 }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double apm(int timeframe)
 //determines average price movement for a group of bars
   {
    double maxval,minval,
    acc=0;
    int maxbar,minbar,
    numBars=1;

    for(int i=1;i<=numBars;i++)
      {
       maxmin(timeframe,i,i,maxbar,maxval,minbar,minval);
       acc=NormalizeDouble(Dpts(minval,maxval),2);
      }
    return acc;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void maxmin(int timeframe,int barI,int barF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barvalues between barI and barF for a timeframe
   {
    maxbar=iHighest(NULL,timeframe,MODE_HIGH,barI,barF);
    maxval=iHigh(NULL,timeframe,maxbar);
    minbar=iLowest(NULL,timeframe,MODE_LOW,barI,barF);
    minval=iLow(NULL,timeframe,minbar);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
   {
    return (pF-pI)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double incline(int timeframe,int barI,double valI,int barF,double valF)
 //calculates slope between barI and barF for a timeframe
   {
    int
    Dbar=barI-barF+1;
    return Dpts(valI,valF)/Dbar;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void display(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
   {
    ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
    ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
    ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
    ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
    ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
   }

 //+------------------------------------------------------------------+
**** code1
 //+------------------------------------------------------------------+
 //|                                                   pradiation.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+
 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #define sp "  "

 /*
 program trades on bars in raex modes
 using 3ma concept to determine ntrxit through projection
 beware of sl when there are significant slopes
 don't do mostly sel on uptrend and buy on downtrend
 */

 int timeframes[5],
 Gtkt=0,
 Graexthresh=1,
 GbarsInChart=0,
 Gtfnum=3,
 Gmn=3;
 double mas[4,3],
 Gfract=0.5;
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OnInit()
   {
    timeframes[0]=1;timeframes[1]=5;timeframes[2]=15;timeframes[3]=30;timeframes[4]=60;
    ArrayInitialize(mas,0);
    return(INIT_SUCCEEDED);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {
    int
    tf=timeframes[Gtfnum];
    masfill(tf);

    //determiner(trender(tf),(int)pricemove(tf));
   
    double v[3];ArrayInitialize(v,0);
   
    v[1]=2;v[2]=0;
   
    double avgincl=avgincline(v),
    proj=extrapolate(2,0,2);
    Comment(avgincl,sp,proj);
   

 /*   if(CanDoTrade(GbarsInChart))
       opn(Gtkt);
    else
       alt(Gtkt);*/
   }
 double avgincline(double &prval[])
 //calculates average incline of consecutive points in y[]
 {
    int bar,
    barI=ArraySize(prval)-1;
    double
    acc=0;
    for(bar=barI;bar>1;bar--)
       acc=acc+incline(bar,prval[bar],1,prval[1]);
    return acc/(barI-1);
 }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double extrapolate(int barI,double barIval,double avgincl)
 //extrapolates point from barI to bar0 given barIval and avgincline
   {
    return avgincl*(barI)+barIval;
   }

 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void opn(int &tkt)
 //opens a trade via some ntr fn combo
   {
    int
    bs=-1;
    double
    sl=0,tp=0,oo=0,
    pad=60*Point,
    lt=0.1,
    raexthresh=Graexthresh,
    selthresh=Gfract*(mas[1,0]+mas[1,1]),
    buythresh=Gfract*(mas[1,1]+mas[1,2]);
    bool
    ramode=(fabs(mas[0,1])<raexthresh),
    exmode=(fabs(mas[0,1])>raexthresh);

    if(ramode)
      {
       if(Bid<buythresh)
         {
          bs=0;
          oo=Ask;
          sl=mas[1,0]-pad;
          tp=selthresh;
         }
       if(Bid>selthresh)
         {
          bs=1;
          oo=Bid;
          sl=mas[1,2]+pad;
          tp=buythresh;
         }
      }

    RefreshRates();
    tkt=OrderSend(Symbol(),bs,lt,oo,0,sl,tp);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void determiner(int trend,int prmov)
 //displays various items
   {
    color
    trendColor=Gray,
    prmovColor=Gray;
    int
    thrprmov=Gmn*20,
    thr1trend=10,
    thr2trend=20,
    thr3trend=30;

    if(prmov>thrprmov)
      {
       prmovColor=Green;

       if(trend<+thr1trend && trend>-thr1trend)
         {
          trendColor=Gray;
         }
       if(trend>+thr1trend)
         {
          trendColor=Blue;
         }
       if(trend<-thr1trend)
         {
          trendColor=Red;
         }
      }
    else
      {
       prmovColor=Gray;
      }

    display("trend","trend = "+DoubleToString(trend),1,200,0,trendColor);
    display("prmov","prmov = "+DoubleToString(prmov),1,200,20,prmovColor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double pricemove(int tf)
 //determines price movement over 3 bars rounded to integer
   {
    double maxval,minval;
    int maxbar,minbar;
    maxmin(tf,Gmn,1,maxbar,maxval,minbar,minval);
    return floor((maxval-minval)/Point);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int trender(int tf)
 //determines local trends in specific timeframes
   {
    double
    incl=mas[0,1];
    if(incl>30) return 30; if(incl<-30) return -30;
    if(incl>20) return 20; if(incl<-20) return -20;
    if(incl>10) return 10; if(incl<-10) return -10;
    return 0;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void masfill(int tf)
 //initializes mas[x,y] array x{b1,b2,b3}, y{lo,me,hi}, x[0,{lo,me,hi}] holds slopes btn b3,b1
   {
    for(int bar=1;bar<4;bar++)
      {
       mas[bar,0]=iMA(NULL,tf,3,0,MODE_LWMA,PRICE_LOW,bar);
       mas[bar,1]=iMA(NULL,tf,3,0,MODE_LWMA,PRICE_MEDIAN,bar);
       mas[bar,2]=iMA(NULL,tf,3,0,MODE_LWMA,PRICE_HIGH,bar);
      }
    for(int lmh=0;lmh<3;lmh++)
       mas[0,lmh]=incline(3,mas[3,lmh],1,mas[1,lmh]);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void maxmin(int tf,int barI,int barF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barvalues between barI and barF for a tf
   {
    maxbar=iHighest(NULL,tf,MODE_HIGH,barI,barF);
    maxval=iHigh(NULL,tf,maxbar);
    minbar=iLowest(NULL,tf,MODE_LOW,barI,barF);
    minval=iLow(NULL,tf,minbar);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool goodbehavior()
 //checks to see if prices are behaving well
   {
    bool
    ok=false;
    double
    err=10,
    loS=incline(Gmn,mas[2,0],1,mas[0,0]),
    meS=incline(Gmn,mas[2,1],1,mas[0,1]),
    hiS=incline(Gmn,mas[2,2],1,mas[0,2]);
    ok=(fabs(hiS-meS)<err) && (fabs(meS-loS)<err) && (fabs(hiS-loS)<err);
    return ok;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
   {
    return (pF-pI)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double incline(int barI,double valI,int barF,double valF)
 //calculates slope between barI and barF for a tf
   {
    int
    Dbar=barI-barF;
    return Dpts(valI,valF)/Dbar;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool CanDoTrade(int &barsInchart)
 //checks various conditions to see if trade is permitted
   {
    bool
    tradeless=(barsInchart!=Bars);
    double
    spread=MarketInfo(NULL,MODE_SPREAD);
    int
    aords,pords,
    tords=OrdersForSymbol(aords,pords);

    barsInchart=Bars;
    return ((tords==0) && tradeless && (spread<9));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of orders that have been placed for a particular symbol
   {
    for(int pos=OrdersTotal()-1; pos>=0; pos--)
      {
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUYSTOP || OrderType()==OP_SELLSTOP))
          pords++;
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUY || OrderType()==OP_SELL))
          aords++;
      }
    return aords+pords;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void display(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
   {
    ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
    ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
    ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
    ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
    ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
   }

 //+------------------------------------------------------------------+
**** code2
 replacing ma with avg slopes from 2 pts

**** code with projector
 //+------------------------------------------------------------------+
 //|                                                   pradiation.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+
 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #define sp "  "

 /*
 program trades on bars in raex modes
 using 3ma concept to determine ntrxit through projection
 beware of sl when there are significant slopes
 don't do mostly sel on uptrend and buy on downtrend
 */

 int timeframes[5],
 Gtkt=0,
 Graexthresh=10,
 GbarsInChart=0,
 GtimeframeIndex=0,
 GbI=3;
 double
 Glt=0.1,
 Gtpfactor=0.5,
 Gslfactor=0.5;
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OnInit()
   {
    timeframes[0]=1;timeframes[1]=5;timeframes[2]=15;timeframes[3]=30;timeframes[4]=60;
    return(INIT_SUCCEEDED);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {
    double oo,sl,tp;
    int
    tf=timeframes[GtimeframeIndex],
    bs=-1;

    projector(tf,3,1,bs,oo,sl,tp);

    if(CanDoTrade(GbarsInChart))
    {
       Gtkt=OrderSend(Symbol(),bs,Glt,oo,0,sl,tp);
    Comment(Gtkt,sp,bs,sp,oo,sp,sl,sp,tp);
    }

   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void projector(int tf,int bI,int bF,int &bs,double &oo,double &sl,double &tp)
 //
   {
    double projV[3],inclacc[3],barV[3,3];
    int b,
    numb=bI-bF+1;
    ArrayInitialize(projV,0);
    ArrayResize(barV,numb+1);

 //fill barV bF-bI with lo,hi,me
    for(b=bF;b<=numb;b++)
      {
       barV[b,0]=iLow(NULL,tf,b);
       barV[b,2]=iHigh(NULL,tf,b);
       barV[b,1]=0.5*(barV[b,0]+barV[b,2]);
      }

 //add up the inclines from bx to bF  
    ArrayInitialize(inclacc,0);
    for(b=bF+1;b<=numb;b++)
      {
       inclacc[0]=inclacc[0]+incline(b,barV[b,0],bF,barV[bF,0]);
       inclacc[1]=inclacc[1]+incline(b,barV[b,1],bF,barV[bF,1]);
       inclacc[2]=inclacc[2]+incline(b,barV[b,2],bF,barV[bF,2]);
      }

 //calculate the avgincl for lo,hi,me and store in barV[0,x]
    for(int i=0;i<3;i++)
       barV[0,i]=inclacc[i]/(numb-1);

    for(int i=0;i<3;i++)
       projV[i]=extrapolate(1,barV[1,i],barV[0,i]);

    if(barV[0,1]>+Graexthresh)
      {
       //Comment("buy");
       bs=OP_BUYLIMIT;
       oo=projV[1]-Gslfactor*fabs(Dpts(projV[0],projV[1]))*Point;
       tp=projV[1]+Gtpfactor*fabs(Dpts(projV[2],projV[1]))*Point;
       sl=barV[2,1];
      }
    if(barV[0,1]<-Graexthresh)
      {
       Comment("sel");
       bs=OP_SELLLIMIT;
       oo=projV[1]+Gslfactor*fabs(Dpts(projV[2],projV[1]))*Point;
       tp=projV[1]-Gtpfactor*fabs(Dpts(projV[0],projV[1]))*Point;
       sl=barV[2,1];
       //*** figure out oo,sl,tp
       //*** use nul to launch explorer
      }
    if(barV[0,1]<+Graexthresh && barV[0,1]>-Graexthresh)
      {
       Comment("nul");
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double extrapolate(int bI,double bIval,double avgincl)
 //extrapolates point from bI to bar0 given bIval and avgincline
   {
    return avgincl*Point*(bI)+bIval;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void opn(int &tkt)
 //opens a trade via some ntr fn combo
   {

   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void determiner(int trend,int prmov)
 //displays various items
   {
    color
    trendColor=Gray,
    prmovColor=Gray;
    int
    thrprmov=GbI*20,
    thr1trend=10,
    thr2trend=20,
    thr3trend=30;

    if(prmov>thrprmov)
      {
       prmovColor=Green;

       if(trend<+thr1trend && trend>-thr1trend)
         {
          trendColor=Gray;
         }
       if(trend>+thr1trend)
         {
          trendColor=Blue;
         }
       if(trend<-thr1trend)
         {
          trendColor=Red;
         }
      }
    else
      {
       prmovColor=Gray;
      }

    display("trend","trend = "+DoubleToString(trend),1,200,0,trendColor);
    display("prmov","prmov = "+DoubleToString(prmov),1,200,20,prmovColor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double pricemove(int tf)
 //determines price movement over 3 bars rounded to integer
   {
    double maxval,minval;
    int maxbar,minbar;
    maxmin(tf,GbI,1,maxbar,maxval,minbar,minval);
    return floor((maxval-minval)/Point);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void maxmin(int tf,int bI,int bF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barV between bI and bF for a tf
   {
    maxbar=iHighest(NULL,tf,MODE_HIGH,bI,bF);
    maxval=iHigh(NULL,tf,maxbar);
    minbar=iLowest(NULL,tf,MODE_LOW,bI,bF);
    minval=iLow(NULL,tf,minbar);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
   {
    return (pF-pI)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double incline(int bI,double vI,int bF,double vF)
 //calculates slope between bI and bF for a tf
   {
    int
    Dbar=bI-bF;
    return Dpts(vI,vF)/Dbar;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool CanDoTrade(int &barsInchart)
 //checks various conditions to see if trade is permitted
   {
    bool
    tradeless=(barsInchart!=Bars);
    double
    spread=MarketInfo(NULL,MODE_SPREAD);
    int
    aords,pords,
    tords=OrdersForSymbol(aords,pords);

    barsInchart=Bars;
    return ((tords==0) && tradeless && (spread<9));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of orders that have been placed for a particular symbol
   {
    for(int pos=OrdersTotal()-1; pos>=0; pos--)
      {
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUYSTOP || OrderType()==OP_SELLSTOP))
          pords++;
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUY || OrderType()==OP_SELL))
          aords++;
      }
    return aords+pords;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void display(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
   {
    ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
    ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
    ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
    ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
    ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
   }

 //+------------------------------------------------------------------

*** TODO 
 sline cycling
 check conceptually strong idea in xonesr v2
 bollinger bands on 1h in rng and xpl modes - envelopes possible too ... mechanism for baroc?
**** quickqatcher
 random entries biased by trend with rr of 1:2 or 1:3
**** baroc
 open and close near top or bot of bars may give very good opportunities in either direction and are possibly an excellent way to implement the rng approach when a strong trend is not present. characteristic of bar needs to be determined near close time or just after. the idea here will be to trade each bar usually.
**** atr breakout
 use atr low points to wait for breakouts


*** CUF
 bool n(double v3,double v2,double v1)
 //determines n
   {
    return (v3<v2 && v2>v1);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool u(double v3,double v2,double v1)
 //determines u
   {
    return (v3>v2 && v2<v1);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double fivonacci(int timeframe)
 //suggests trend from fivonacci inclines
   {
    color colors[5];
    double inclStrength,wis,incl[5];ArrayInitialize(incl,0);
    int barF,barI[5];

    barF=1;barI[0]=5;barI[1]=10;barI[2]=15;barI[3]=25;barI[4]=40;
    colors[0]=Red;colors[1]=Orange;colors[2]=Brown;colors[3]=Green;colors[4]=Blue;

    inclStrength=0;
    wis=0;
    for(int i=0;i<5;i++)
      {
       incl[i]=incline(timeframe,barI[i],barF);
       wis+=incl[i]*barI[i];
       drawOCtline(IntegerToString(barI[i]),barI[i],barF,colors[i]);
      }
    return wis/95;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void placebuysel(int bs,int &tk)
 //places buysel order
   {
    double
    lt=0.1,
    minsl=50*Point,
    padding=9*Point,
    sltpfactor=Gfac;

    double oo,sl,tp,hiVal,loVal,v[2];
    int hiBar,loBar;

    maxmin(Gtimeframe,GbarI,1,hiBar,hiVal,loBar,loVal);

    RefreshRates();
    switch(bs)
      {
       case  0:
          oo=Ask;
          v[0]=loVal-padding;
          v[1]=oo-minsl;
          arrmaxmin(v,hiBar,loBar);
          sl=v[loBar];
          tp=oo+sltpfactor*Dpts(sl,oo)*Point;
          tk=OrderSend(Symbol(),bs,lt,oo,0,sl,tp);
          break;
       case  1:
          oo=Bid;
          v[0]=hiVal+padding;
          v[1]=oo+minsl;
          arrmaxmin(v,hiBar,loBar);
          sl=v[hiBar];
          tp=oo-sltpfactor*Dpts(oo,sl)*Point;
          tk=OrderSend(Symbol(),bs,lt,oo,0,sl,tp);
          break;
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double incline(int timeframe,int barI,int barF)
 //calculates slope between barI and barF for a timeframe
   {
    return Dpts(iOpen(NULL,timeframe,barI),iClose(NULL,timeframe,barF))/((barI-barF)+1);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
   {
    return (pF-pI)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void arrmaxmin(double &v[],int &max,int &min)
 //returns largest and smallest of a group of numbers
   {
    max=ArrayMaximum(v);
    min=ArrayMinimum(v);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void maxmin(int timeframe,int barI,int barF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barvalues between barI and barF for a timeframe
   {
    maxbar=iHighest(NULL,timeframe,MODE_HIGH,barI,barF);
    maxval=iHigh(NULL,timeframe,maxbar);
    minbar=iLowest(NULL,timeframe,MODE_LOW,barI,barF);
    minval=iLow(NULL,timeframe,minbar);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int modrand(int divisor)
 //generates random number and mods it with divisor
   {
    return (int)fmod(rand(),divisor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OrderDetails(int tk,int &bs,double &oo,double &oc,double &sl,double &tp)
 //gets open order details into variables
   {
    bool zz=OrderSelect(tk,SELECT_BY_TICKET);

    bs=OrderType();
    oo=OrderOpenPrice();
    oc=OrderClosePrice();
    tp=OrderTakeProfit();
    sl=OrderStopLoss();
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void drawOCtline(string name,int barI,int barF,color acolor)
 //draws a line between two points (barI,priceI) and (barF,priceF)
   {
    datetime
    timeI=iTime(NULL,Gtimeframe,barI),
    timeF=iTime(NULL,Gtimeframe,barF);
    double
    pricI=iOpen(NULL,Gtimeframe,barI),
    pricF=iClose(NULL,Gtimeframe,barF);
    bool
    zz=ObjectDelete(name);
    zz=ObjectCreate(name,OBJ_TREND,0,timeI,pricI,timeF,pricF);
    zz=ObjectSet(name,OBJPROP_RAY,false);
    zz=ObjectSet(name,OBJPROP_COLOR,acolor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void display(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
   {
    ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
    ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
    ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
    ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
    ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool CanDoTrade(int &barsInchart)
 //checks various conditions to see if trade is permitted
   {
    bool
    tradeless=(barsInchart!=Bars);
    double
    spread=MarketInfo(NULL,MODE_SPREAD);
    int
    aords,pords,
    tords=OrdersForSymbol(aords,pords);

    barsInchart=Bars;
    return ((tords==0) && tradeless && (spread<9));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of orders that have been placed for a particular symbol
   {
    for(int pos=OrdersTotal()-1; pos>=0; pos--)
      {
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUYSTOP || OrderType()==OP_SELLSTOP))
          pords++;
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUY || OrderType()==OP_SELL))
          aords++;
      }
    return aords+pords;
   }
 //+------------------------------------------------------------------+
*** fivonacci
 initial attempt result in $1300 loss with nearly 700 trades
**** code1
 //+------------------------------------------------------------------+
 //|                                                    fivonacci.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+
 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #define sp "  "


 bool zz;
 double
 lt=0.1;
 int
 GbarsInchart=0,
 Gtkt=0,
 Gtimeframe=5;
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 struct data
   {
    int               tkt;
    double            incline;
    double            threshold;
    double            sltp;
   };

 data val[5];

 int OnInit() {return(INIT_SUCCEEDED);}
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {
    int aords,pords,
    totalOrders=OrdersForSymbol(aords,pords);

    if(totalOrders==0) zerotkts();
    initvalues();
    dotrades();
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void dotrades()
 //handles all trading
   {
    for(int i=0;i<5;i++)
      {
       if(val[i].tkt==0)
         {
          if(val[i].incline>val[i].threshold)
             val[i].tkt=OrderSend(NULL,0,lt,Ask,0,Ask-val[i].sltp,Ask+val[i].sltp);
          if(val[i].incline<-val[i].threshold)
             val[i].tkt=OrderSend(NULL,1,lt,Bid,0,Bid+val[i].sltp,Bid-val[i].sltp);
         }
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void initvalues()
 //initializes the fivonacci values
   {
    int barF,barI[5];

    barF=1;barI[0]=5;barI[1]=10;barI[2]=15;barI[3]=25;barI[4]=40;

    for(int i=0;i<5;i++)
      {
       val[i].incline=incline(5,barI[i],barF);
       val[i].threshold=0;
       val[i].sltp=barI[i]*10*Point;
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void zerotkts()
 //sets tkt values to zero when there are no orders active
   {
    for(int i=0;i<5;i++)
       val[i].tkt=0;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int fivonacci(int timeframe,int ratio)
 //enters on contrarian fivonacci
   {
    double th=0.25,incl[5];ArrayInitialize(incl,0);
    int barF=1,barI[5];
    barF=1;barI[0]=5;barI[1]=10;barI[2]=15;barI[3]=25;barI[4]=40;

    for(int i=0;i<5;i++)
       incl[i]=incline(timeframe,barI[i],barF);

    switch(ratio)
      {
       case  0:
          if(incl[4]>+th && incl[3]>+th && incl[2]>+th && incl[1]>+th && incl[0]>+th) return +1;
          if(incl[4]<-th && incl[3]<-th && incl[2]<-th && incl[1]<-th && incl[0]<-th) return -1;
          break;
       case  1:
          if(incl[4]>+th && incl[3]>+th && incl[2]>+th && incl[1]>+th && incl[0]<+th) return +1;
          if(incl[4]<-th && incl[3]<-th && incl[2]<-th && incl[1]<-th && incl[0]>-th) return -1;
          break;
       case  2:
          if(incl[4]>+th && incl[3]>+th && incl[2]>+th && incl[1]<+th && incl[0]<+th) return +1;
          if(incl[4]<-th && incl[3]<-th && incl[2]<-th && incl[1]<-th && incl[0]<-th) return -1;
          break;
       case  3:
          if(incl[4]>+th && incl[3]>+th && incl[2]<-th && incl[1]<-th && incl[0]<-th) return +1;
          if(incl[4]<-th && incl[3]<-th && incl[2]>+th && incl[1]>+th && incl[0]>+th) return -1;
          break;
       case  4:
          if(incl[4]>+th && incl[3]<-th && incl[2]<-th && incl[1]<-th && incl[0]<-th) return +1;
          if(incl[4]<-th && incl[3]>+th && incl[2]>+th && incl[1]>+th && incl[0]>+th) return -1;
          break;
      }
    return 0;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int macross(int timeframe,int barI)
 //ntr from price crossings of ma
   {
    double
    maVal=iMA(NULL,timeframe,barI,0,MODE_SMA,PRICE_OPEN,0),
    prLow=iLow(NULL,timeframe,1),
    prClo=iClose(NULL,timeframe,1),
    prHig=iHigh(NULL,timeframe,1);

    if(prLow<maVal && prClo>maVal) return +1;
    if(prHig>maVal && prClo<maVal) return -1;
    return 0;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void placeorder(int bs,int &tk)
 //places buysel order
   {
    double
    sl,tp,oo,
    slpts=500*Point,
    tppts=1*slpts;

    switch(bs)
      {
       case  0:
          oo=Ask;
          sl=oo-slpts;
          tp=oo+tppts;
          break;
       case  1:
          oo=Bid;
          sl=oo+slpts;
          tp=oo-tppts;
          break;
       default:
          oo=0;sl=0;tp=0;
          break;
      }
    RefreshRates();
    tk=OrderSend(Symbol(),bs,lt,oo,0,sl,tp);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double incline(int timeframe,int barI,int barF)
 //calculates slope between barI and barF for a timeframe
   {
    return Dpts(iOpen(NULL,timeframe,barI),iClose(NULL,timeframe,barF))/((barI-barF)+1);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
   {
    return (pF-pI)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void arrmaxmin(double &v[],int &max,int &min)
 //returns largest and smallest of a group of numbers
   {
    max=ArrayMaximum(v);
    min=ArrayMinimum(v);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void maxmin(int timeframe,int barI,int barF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barvalues between barI and barF for a timeframe
   {
    maxbar=iHighest(NULL,timeframe,MODE_HIGH,barI,barF);
    maxval=iHigh(NULL,timeframe,maxbar);
    minbar=iLowest(NULL,timeframe,MODE_LOW,barI,barF);
    minval=iLow(NULL,timeframe,minbar);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int modrand(int divisor)
 //generates random number and mods it with divisor
   {
    return (int)fmod(rand(),divisor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OrderDetails(int tk,int &bs,double &oo,double &oc,double &sl,double &tp)
 //gets open order details into variables
   {
    zz=OrderSelect(tk,SELECT_BY_TICKET);

    bs=OrderType();
    oo=OrderOpenPrice();
    oc=OrderClosePrice();
    tp=OrderTakeProfit();
    sl=OrderStopLoss();
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void drawOCtline(string name,int barI,int barF,color acolor)
 //draws a line between two points (barI,priceI) and (barF,priceF)
   {
    datetime
    timeI=iTime(NULL,Gtimeframe,barI),
    timeF=iTime(NULL,Gtimeframe,barF);
    double
    pricI=iOpen(NULL,Gtimeframe,barI),
    pricF=iClose(NULL,Gtimeframe,barF);

    zz=ObjectDelete(name);
    zz=ObjectCreate(name,OBJ_TREND,0,timeI,pricI,timeF,pricF);
    zz=ObjectSet(name,OBJPROP_RAY,false);
    zz=ObjectSet(name,OBJPROP_COLOR,acolor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void display(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
   {
    ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
    ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
    ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
    ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
    ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool CanDoTrade(int &barsInchart)
 //checks various conditions to see if trade is permitted
   {
    bool
    tradeless=(barsInchart!=Bars);
    double
    spread=MarketInfo(NULL,MODE_SPREAD);
    int
    aords,pords,
    tords=OrdersForSymbol(aords,pords);

    barsInchart=Bars;
    return ((tords==0) && tradeless && (spread<9));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of orders that have been placed for a particular symbol
   {
    for(int pos=OrdersTotal()-1; pos>=0; pos--)
      {
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUYSTOP || OrderType()==OP_SELLSTOP))
          pords++;
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUY || OrderType()==OP_SELL))
          aords++;
      }
    return aords+pords;
   }
 //+------------------------------------------------------------------+

**** code ma version
 //+------------------------------------------------------------------+
 //|                                                  fivonacciMA.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+
 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #define sp "  "


 //extern int limesc;

 bool zz;
 double
 lt=0.1;
 int
 mas=1,
 Gtimeframe=5;
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 struct data
   {
    int               tkt;
    int               bs;
    double            oo;
    double            oc;
    double            sl;
    double            tp;
    double            Dprma;
   };

 data val[5];

 int OnInit() {return(INIT_SUCCEEDED);}
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {
    doStatus(Gtimeframe);

    for(int i=0;i<mas;i++)
      {
       if(val[i].tkt==0)
         {
          if(val[i].Dprma>0) OpenTrade(i,0);
          if(val[i].Dprma<0) OpenTrade(i,1);
         }
       else
         {
          if(closeMet(i))
             ClosTrade(i);
         }
      }
   }
 bool closeMet(int i)
 //close condition met
 {  
    double limesc=20;
    return (val[i].bs==0 && val[i].Dprma<-limesc) || (val[i].bs==1 && val[i].Dprma>+limesc);
 }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void doStatus(int timeframe)
 //initializes the fivonacci values
   {
    int barI[5];

    barI[0]=05;barI[1]=10;barI[2]=15;barI[3]=25;barI[4]=40;

    for(int i=0;i<mas;i++)
      {
       val[i].Dprma=Dpts(iMA(NULL,timeframe,barI[i],0,MODE_SMA,PRICE_MEDIAN,0),Bid);
       if(val[i].tkt!=0)
         {
          bool ok=OrderSelect(val[i].tkt,SELECT_BY_TICKET);
          val[i].bs=OrderType();
          val[i].oo=OrderOpenPrice();
          val[i].oc=OrderClosePrice();
          val[i].sl=OrderStopLoss();
          val[i].tp=OrderTakeProfit();
         }
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OpenTrade(int i,int bs)
 //puts through a trade
   {
    double sl,tp,sltp=555*Point;

    switch(bs)
      {
       case  0:
          sl=Ask-sltp;
          tp=Ask+sltp;
          val[i].tkt=OrderSend(NULL,0,lt,Ask,0,sl,tp);
          break;
       case  1:
          sl=Bid+sltp;
          tp=Bid-sltp;
          val[i].tkt=OrderSend(NULL,1,lt,Bid,0,sl,tp);
          break;
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void ClosTrade(int i)
 //closes an open trade
   {
    bool oc=OrderClose(val[i].tkt,lt,val[i].oc,0,clrNONE);
    val[i].tkt=0;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
   {
    return (pF-pI)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void maxmin(int timeframe,int barI,int barF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barvalues between barI and barF for a timeframe
   {
    maxbar=iHighest(NULL,timeframe,MODE_HIGH,barI,barF);
    maxval=iHigh(NULL,timeframe,maxbar);
    minbar=iLowest(NULL,timeframe,MODE_LOW,barI,barF);
    minval=iLow(NULL,timeframe,minbar);
   }
 //+------------------------------------------------------------------+

**** code
 //+------------------------------------------------------------------+
 //|                                                    fivonacci.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+
 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #define sp "  "


 bool zz;
 double
 lt=0.1;
 int
 GbarsInchart=0,
 Gtkt=0,
 Gtimeframe=5;
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 struct data
   {
    int               tkt;
    double            incline;
    double            threshold;
    double            sltp;
   };

 data val[5];

 int OnInit() {return(INIT_SUCCEEDED);}
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {

   /*int barI[5],barF=1;
   double
   i0=NormalizeDouble(incline(5,05,barF),2),
   i1=NormalizeDouble(incline(5,10,barF),2),
   i2=NormalizeDouble(incline(5,15,barF),2),
   i3=NormalizeDouble(incline(5,25,barF),2),
   i4=NormalizeDouble(incline(5,40,barF),2);
  
   Comment(i0,sp,i1,sp,i2,sp,i3,sp,i4);
  
   drawOCtline("05",05,barF,Red);
   drawOCtline("10",10,barF,Orange);
   drawOCtline("15",15,barF,Brown);
   drawOCtline("25",25,barF,Green);
   drawOCtline("40",40,barF,Blue);
   */
    int aords,pords,
    totalOrders=OrdersForSymbol(aords,pords);

    if(totalOrders==0) zerotkts();
    initvalues();
    dotrades();
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void dotrades()
 //handles all trading
   {
    for(int i=0;i<5;i++)
      {
       if(val[i].tkt==0)
         {
          if(val[i].incline>val[i].threshold)
             val[i].tkt=OrderSend(NULL,0,lt,Ask,0,Ask-val[i].sltp,Ask+val[i].sltp);
          if(val[i].incline<-val[i].threshold)
             val[i].tkt=OrderSend(NULL,1,lt,Bid,0,Bid+val[i].sltp,Bid-val[i].sltp);
         }
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void initvalues()
 //initializes the fivonacci values
   {
    int barF,barI[5];

    barF=1;barI[0]=5;barI[1]=10;barI[2]=15;barI[3]=25;barI[4]=40;

    for(int i=0;i<5;i++)
      {
       val[i].incline=incline(5,barI[i],barF);
       val[i].threshold=0;
       val[i].sltp=barI[i]*75*Point;
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void zerotkts()
 //sets tkt values to zero when there are no orders active
   {
    for(int i=0;i<5;i++)
       val[i].tkt=0;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int fivonacci(int timeframe,int ratio)
 //enters on contrarian fivonacci
   {
    double th=0.25,incl[5];ArrayInitialize(incl,0);
    int barF=1,barI[5];
    barF=1;barI[0]=5;barI[1]=10;barI[2]=15;barI[3]=25;barI[4]=40;

    for(int i=0;i<5;i++)
       incl[i]=incline(timeframe,barI[i],barF);

    switch(ratio)
      {
       case  0:
          if(incl[4]>+th && incl[3]>+th && incl[2]>+th && incl[1]>+th && incl[0]>+th) return +1;
          if(incl[4]<-th && incl[3]<-th && incl[2]<-th && incl[1]<-th && incl[0]<-th) return -1;
          break;
       case  1:
          if(incl[4]>+th && incl[3]>+th && incl[2]>+th && incl[1]>+th && incl[0]<+th) return +1;
          if(incl[4]<-th && incl[3]<-th && incl[2]<-th && incl[1]<-th && incl[0]>-th) return -1;
          break;
       case  2:
          if(incl[4]>+th && incl[3]>+th && incl[2]>+th && incl[1]<+th && incl[0]<+th) return +1;
          if(incl[4]<-th && incl[3]<-th && incl[2]<-th && incl[1]<-th && incl[0]<-th) return -1;
          break;
       case  3:
          if(incl[4]>+th && incl[3]>+th && incl[2]<-th && incl[1]<-th && incl[0]<-th) return +1;
          if(incl[4]<-th && incl[3]<-th && incl[2]>+th && incl[1]>+th && incl[0]>+th) return -1;
          break;
       case  4:
          if(incl[4]>+th && incl[3]<-th && incl[2]<-th && incl[1]<-th && incl[0]<-th) return +1;
          if(incl[4]<-th && incl[3]>+th && incl[2]>+th && incl[1]>+th && incl[0]>+th) return -1;
          break;
      }
    return 0;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int macross(int timeframe,int barI)
 //ntr from price crossings of ma
   {
    double
    maVal=iMA(NULL,timeframe,barI,0,MODE_SMA,PRICE_OPEN,0),
    prLow=iLow(NULL,timeframe,1),
    prClo=iClose(NULL,timeframe,1),
    prHig=iHigh(NULL,timeframe,1);

    if(prLow<maVal && prClo>maVal) return +1;
    if(prHig>maVal && prClo<maVal) return -1;
    return 0;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void placeorder(int bs,int &tk)
 //places buysel order
   {
    double
    sl,tp,oo,
    slpts=500*Point,
    tppts=1*slpts;

    switch(bs)
      {
       case  0:
          oo=Ask;
          sl=oo-slpts;
          tp=oo+tppts;
          break;
       case  1:
          oo=Bid;
          sl=oo+slpts;
          tp=oo-tppts;
          break;
       default:
          oo=0;sl=0;tp=0;
          break;
      }
    RefreshRates();
    tk=OrderSend(Symbol(),bs,lt,oo,0,sl,tp);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double incline(int timeframe,int barI,int barF)
 //calculates slope between barI and barF for a timeframe
   {
    return Dpts(iOpen(NULL,timeframe,barI),iClose(NULL,timeframe,barF))/((barI-barF)+1);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
   {
    return (pF-pI)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void arrmaxmin(double &v[],int &max,int &min)
 //returns largest and smallest of a group of numbers
   {
    max=ArrayMaximum(v);
    min=ArrayMinimum(v);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void maxmin(int timeframe,int barI,int barF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barvalues between barI and barF for a timeframe
   {
    maxbar=iHighest(NULL,timeframe,MODE_HIGH,barI,barF);
    maxval=iHigh(NULL,timeframe,maxbar);
    minbar=iLowest(NULL,timeframe,MODE_LOW,barI,barF);
    minval=iLow(NULL,timeframe,minbar);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int modrand(int divisor)
 //generates random number and mods it with divisor
   {
    return (int)fmod(rand(),divisor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OrderDetails(int tk,int &bs,double &oo,double &oc,double &sl,double &tp)
 //gets open order details into variables
   {
    zz=OrderSelect(tk,SELECT_BY_TICKET);

    bs=OrderType();
    oo=OrderOpenPrice();
    oc=OrderClosePrice();
    tp=OrderTakeProfit();
    sl=OrderStopLoss();
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void drawOCtline(string name,int barI,int barF,color acolor)
 //draws a line between two points (barI,priceI) and (barF,priceF)
   {
    datetime
    timeI=iTime(NULL,Gtimeframe,barI),
    timeF=iTime(NULL,Gtimeframe,barF);
    double
    pricI=iOpen(NULL,Gtimeframe,barI),
    pricF=iClose(NULL,Gtimeframe,barF);

    zz=ObjectDelete(name);
    zz=ObjectCreate(name,OBJ_TREND,0,timeI,pricI,timeF,pricF);
    zz=ObjectSet(name,OBJPROP_RAY,false);
    zz=ObjectSet(name,OBJPROP_COLOR,acolor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void display(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
   {
    ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
    ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
    ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
    ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
    ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool CanDoTrade(int &barsInchart)
 //checks various conditions to see if trade is permitted
   {
    bool
    tradeless=(barsInchart!=Bars);
    double
    spread=MarketInfo(NULL,MODE_SPREAD);
    int
    aords,pords,
    tords=OrdersForSymbol(aords,pords);

    barsInchart=Bars;
    return ((tords==0) && tradeless && (spread<9));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of orders that have been placed for a particular symbol
   {
    for(int pos=OrdersTotal()-1; pos>=0; pos--)
      {
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUYSTOP || OrderType()==OP_SELLSTOP))
          pords++;
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUY || OrderType()==OP_SELL))
          aords++;
      }
    return aords+pords;
   }
 //+------------------------------------------------------------------+

*** pradapter
 can mc be defined simply as ratio of up-down movements with volatility thrown in?
 if so, then strategies can be developed on that basis - rather than slope?

 adjusts to mc and does a whole bunch more that we don't know about yet
 - like weighted indicators that continually adjust depending on results
 build components and test

 bsicators
 - return +1,0,-1 values for bs incorporating xr mode appropriate for each
 - these can be accumulated at will with weights to determine action anytime

**** version that ran
 //+------------------------------------------------------------------+
 //|                                                    pradapter.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+
 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #define sp "  "

 double Gfac;
 int GbarI;

 int
 GbarsInchart=0,
 Gtkt=0,
 Gtimeframe=5;

 int OnInit() {return(INIT_SUCCEEDED);}
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {
    Gfac=0.5;GbarI=15;
    if(CanDoTrade(GbarsInchart))
       opn(Gtkt);
    else
       alt(Gtkt);

   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void opn(int &tk)
 //opens a trade via some ntr fn combo
   {
    double
    bstrend=macross(Gtimeframe,GbarI)+fivonacci(Gtimeframe);

    if(bstrend>+1)
       placeorder(0,tk);
    if(bstrend<-1)
       placeorder(1,tk);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void alt(int tk)
 //alters a trade by moving sl,tp or by closing it via some xit fn combo
   {
 /*   bool zz,xit;
    double oo,oc,sl,tp,lt;
    int bs;

    OrderDetails(tk,bs,oo,oc,sl,tp);
    lt=0.1;
    xit=(bs==0 && II(Gtimeframe,GbarI)==-1) || (bs==1 && II(Gtimeframe,GbarI)==+1) ;

    if(xit)
       zz=OrderClose(tk,lt,oc,0);
 else
       trailer(tk,bs,oo,oc,sl,tp);*/
   }


 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int macross(int timeframe,int barI)
 //ntr from price crossings of ma
   {
    double
    maVal=iMA(NULL,timeframe,barI,0,MODE_SMA,PRICE_OPEN,0),
    prLow=iLow(NULL,timeframe,1),
    prClo=iClose(NULL,timeframe,1),
    prHig=iHigh(NULL,timeframe,1);

    if(prLow<maVal && prClo>maVal) return +1;
    if(prHig>maVal && prClo<maVal) return -1;
    return 0;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int fivonacci(int timeframe)
 //suggests trend from fivonacci inclines
   {
    color colors[5];
    double inclStrength,wis,incl[5];ArrayInitialize(incl,0);
    int barF,barI[5];

    barF=1;barI[0]=5;barI[1]=10;barI[2]=15;barI[3]=25;barI[4]=40;
    colors[0]=Red;colors[1]=Orange;colors[2]=Brown;colors[3]=Green;colors[4]=Blue;

    wis=0;
    for(int i=0;i<5;i++)
      {
       incl[i]=incline(timeframe,barI[i],barF);
       wis+=incl[i]*barI[i];
       drawOCtline(IntegerToString(barI[i]),barI[i],barF,colors[i]);
      }
    inclStrength=wis/95;

    if(inclStrength>+1) return +1;
    if(inclStrength<-1) return -1;
    return 0;
   }
  
  
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void placeorder(int bs,int &tk)
 //places buysel order
   {
    double
    sl,tp,oo,
    slpts=480*Point,
    tppts=Gfac*slpts,
    lt=0.1;

    switch(bs)
      {
       case  0:
          oo=Ask;
          sl=oo-slpts;
          tp=oo+tppts;
          break;
       case  1:
          oo=Bid;
          sl=oo+slpts;
          tp=oo-tppts;
          break;
       default:
          oo=0;sl=0;tp=0;
          break;
      }
    RefreshRates();
    tk=OrderSend(Symbol(),bs,lt,oo,0,sl,tp);
   }
 /*
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double incline(int timeframe,int barI,int barF)
 //calculates slope between barI and barF for a timeframe
   {
    return Dpts(iOpen(NULL,timeframe,barI),iClose(NULL,timeframe,barF))/((barI-barF)+1);
   }

 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double incline(int timeframe,int barI,int barF)
 //calculates slope between barI and barF for a timeframe
   {
    int
    Dbar=barI-barF+1;
    double
    midI=(iHigh(NULL,timeframe,barI)+iLow(NULL,timeframe,barI))/2,
    midF=(iHigh(NULL,timeframe,barF)+iLow(NULL,timeframe,barF))/2;
    return Dpts(midI,midF)/Dbar;
   }
 */
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double incline(int timeframe,int barI,int barF)
 //calculates slope between barI and barF for a timeframe
   {
    int
    Dbar=barI-barF+1;
    double
    openI=iOpen(NULL,timeframe,barI),
    closeF=iClose(NULL,timeframe,barF);
    return Dpts(openI,closeF)/Dbar;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
   {
    return (pF-pI)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void arrmaxmin(double &v[],int &max,int &min)
 //returns largest and smallest of a group of numbers
   {
    max=ArrayMaximum(v);
    min=ArrayMinimum(v);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void maxmin(int timeframe,int barI,int barF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barvalues between barI and barF for a timeframe
   {
    maxbar=iHighest(NULL,timeframe,MODE_HIGH,barI,barF);
    maxval=iHigh(NULL,timeframe,maxbar);
    minbar=iLowest(NULL,timeframe,MODE_LOW,barI,barF);
    minval=iLow(NULL,timeframe,minbar);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int modrand(int divisor)
 //generates random number and mods it with divisor
   {
    return (int)fmod(rand(),divisor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OrderDetails(int tk,int &bs,double &oo,double &oc,double &sl,double &tp)
 //gets open order details into variables
   {
    bool zz=OrderSelect(tk,SELECT_BY_TICKET);

    bs=OrderType();
    oo=OrderOpenPrice();
    oc=OrderClosePrice();
    tp=OrderTakeProfit();
    sl=OrderStopLoss();
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void drawOCtline(string name,int barI,int barF,color acolor)
 //draws a line between two points (barI,priceI) and (barF,priceF)
   {
    datetime
    timeI=iTime(NULL,Gtimeframe,barI),
    timeF=iTime(NULL,Gtimeframe,barF);
    double
    pricI=iOpen(NULL,Gtimeframe,barI),
    pricF=iClose(NULL,Gtimeframe,barF);
    bool
    zz=ObjectDelete(name);
    zz=ObjectCreate(name,OBJ_TREND,0,timeI,pricI,timeF,pricF);
    zz=ObjectSet(name,OBJPROP_RAY,false);
    zz=ObjectSet(name,OBJPROP_COLOR,acolor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void display(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
   {
    ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
    ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
    ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
    ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
    ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool CanDoTrade(int &barsInchart)
 //checks various conditions to see if trade is permitted
   {
    bool
    tradeless=(barsInchart!=Bars);
    double
    spread=MarketInfo(NULL,MODE_SPREAD);
    int
    aords,pords,
    tords=OrdersForSymbol(aords,pords);

    barsInchart=Bars;
    return ((tords==0) && tradeless && (spread<9));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of orders that have been placed for a particular symbol
   {
    for(int pos=OrdersTotal()-1; pos>=0; pos--)
      {
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUYSTOP || OrderType()==OP_SELLSTOP))
          pords++;
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUY || OrderType()==OP_SELL))
          aords++;
      }
    return aords+pords;
   }
 //+------------------------------------------------------------------+
**** nu
 - optimized nu on 2016 is far lower than in 2015 suggests much more frequent zigzagging
 - unoptimized with Gfac=1,GbarI=15 both years showed profit confirming above
***** code
 //+------------------------------------------------------------------+
 //|                                                    nu.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+
 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict

 /*
 this is pradapter version since original nu functioned very poorly
 */

 int      tkt,tifr=30;
 double   lots=0.1;
 bool     zz;


 int OnInit() {return(INIT_SUCCEEDED);}
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {
    int
    aords=0,pords=0,ords=ordersforsymbol(aords,pords);

    if(ords==0)
      {
       opn(tkt);
      }
    /*else
      {
       alt(tkt);
      }*/
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void opn(int &tk)
 //opens a trade
   {
    int bs=-1,lev=0;
    double op,sl,tp;
   
    nu(tifr,bs,op,sl,tp);

    if(bs!=-1) tk=OrderSend(Symbol(),bs,lots,op,lev,sl,tp);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void alt(int tk)
 //alters the trade
   {
    zz=OrderSelect(tk,SELECT_BY_TICKET);
    int bs=OrderType();
    double
    oop=OrderOpenPrice(),
    ocp=OrderClosePrice(),
    tp=OrderTakeProfit(),
    sl=OrderStopLoss();
    /*bool xit=();

    if(xit)
       zz=OrderClose(tk,lots,ocp,0);*/
   }
 void sltp(string &nu,double &op,double &sl,double &tp)
 //determines order details from nu value
 {
   
 }
 void nu(int timeframe,int &bs,double &op,double &sl,double &tp)
 //detects n or u pattern in the past 5 bars
 {
    double barHIs[6],barLOs[6],tpfac=1.0*Point;
    ArrayInitialize(barHIs,0);ArrayInitialize(barLOs,0);
   
    for(int i=1;i<=5;i++)
       barHIs[i]=iHigh(NULL,timeframe,i);
    if(ArrayMaximum(barHIs,5,1)==3)
    {
       bs=1;
       op=Bid;
       sl=barHIs[3];
       tp=op-Dpts(sl,op)*tpfac;
    }

    for(int i=1;i<=5;i++)
       barLOs[i]=iLow(NULL,timeframe,i);
    if(ArrayMinimum(barLOs,5,1)==3)
    {
       bs=0;
       op=Ask;
       sl=barLOs[3];
       tp=op+Dpts(op,sl)*tpfac;
    }
 }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void srlevels()
 //marks sr for tifr
   {

   }
 double Dpts(double p2,double p1)
 //difference between two prices p2-p1 in points
   {
    return (p2-p1)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double max(int nbars,int timeframe)
 //finds the max price over the past n bars
   {
    return iHigh(NULL,timeframe,iHighest(NULL,timeframe,MODE_HIGH,nbars,0));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double min(int nbars,int timeframe)
 //finds the min price over the past n bars
   {
    return iLow(NULL,timeframe,iLowest(NULL,timeframe,MODE_LOW,nbars,0));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void drawhline(string label,double Vue,color acolor)
 //draws hline of particular color
   {
    ObjectDelete(label);
    ObjectCreate(label,OBJ_HLINE,0,Time[0],Vue);
    ObjectSet(label,OBJPROP_COLOR,acolor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double modrand(int divisor)
 //generates random number and mods it with divisor
   {
    return fmod(rand(),divisor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int ordersforsymbol(int &aords,int &pords)
 //calculates number of orders that have been placed for a particular symbol
   {
    for(int pos=OrdersTotal()-1; pos>=0; pos--)
      {
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUYSTOP || OrderType()==OP_SELLSTOP))
          pords++;
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUY || OrderType()==OP_SELL))
          aords++;
      }
    return aords+pords;
   }
 //+------------------------------------------------------------------+

***** opt 150102-150328
 |  85 | 2465.50 |   39 | 5.07 |  63.22 | 436.00 | 3.40% | Gfac=4   | GbarI=45 |
 |  93 | 1832.90 |   19 | 8.54 |  96.47 | 436.00 | 3.96% | Gfac=4   | GbarI=50 |
 |  67 | 1697.40 |   21 | 5.16 |  80.83 | 436.00 | 3.96% | Gfac=4.5 | GbarI=35 |
 |  57 | 1695.90 |   22 | 5.15 |  77.09 | 436.00 | 3.96% | Gfac=4.5 | GbarI=30 |
 |  48 | 1693.80 |   23 | 5.64 |  73.64 | 436.00 | 3.96% | Gfac=4.5 | GbarI=25 |
 |  27 | 1442.90 |  104 | 1.95 |  13.87 | 468.40 | 4.42% | Gfac=4   | GbarI=15 |
 |  24 | 1388.20 |  130 | 1.70 |  10.68 | 526.90 | 5.04% | Gfac=2.5 | GbarI=15 |
 |  66 | 1371.60 |   39 | 2.83 |  35.17 | 512.60 | 4.82% | Gfac=4   | GbarI=35 |
 |  23 | 1368.70 |  218 | 1.53 |   6.28 | 388.70 | 3.59% | Gfac=2   | GbarI=15 |
 |  68 | 1365.10 |   39 | 2.89 |  35.00 | 571.10 | 5.43% | Gfac=5   | GbarI=35 |
 |  44 | 1352.80 |   69 | 2.19 |  19.61 | 547.10 | 5.23% | Gfac=2.5 | GbarI=25 |
 |  75 | 1334.50 |   45 | 2.44 |  29.66 | 456.90 | 3.90% | Gfac=3.5 | GbarI=40 |
 |  47 | 1327.80 |   50 | 2.58 |  26.56 | 530.10 | 4.99% | Gfac=4   | GbarI=25 |
 |  56 | 1319.00 |   50 | 2.54 |  26.38 | 544.50 | 5.12% | Gfac=4   | GbarI=30 |
 |  34 | 1310.60 |   89 | 1.98 |  14.73 | 499.70 | 4.77% | Gfac=2.5 | GbarI=20 |
 |  40 | 1251.10 |   54 | 2.52 |  23.17 | 570.90 | 5.39% | Gfac=5.5 | GbarI=20 |
 | 102 | 1243.30 |   42 | 2.31 |  29.60 | 476.50 | 4.51% | Gfac=3.5 | GbarI=55 |
 |  77 | 1216.10 |    3 | 0.00 | 405.37 | 586.80 | 5.04% | Gfac=4.5 | GbarI=40 |
 |  92 | 1196.60 |   52 | 2.06 |  23.01 | 436.00 | 3.77% | Gfac=3.5 | GbarI=50 |
 |  15 | 1190.40 |   94 | 1.82 |  12.66 | 454.20 | 4.33% | Gfac=3   | GbarI=10 |
 |  99 | 1188.10 |   86 | 1.73 |  13.82 | 379.30 | 3.62% | Gfac=2   | GbarI=55 |
 |  37 | 1185.90 |   60 | 2.32 |  19.77 | 539.00 | 5.07% | Gfac=4   | GbarI=20 |
 |  76 | 1152.00 |   49 | 1.94 |  23.51 | 568.80 | 5.09% | Gfac=4   | GbarI=40 |
 |  84 | 1137.40 |   57 | 2.00 |  19.95 | 436.00 | 3.79% | Gfac=3.5 | GbarI=45 |
 | 100 | 1134.70 |   66 | 1.82 |  17.19 | 539.00 | 5.10% | Gfac=2.5 | GbarI=55 |
 |   4 | 1104.90 |  285 | 1.38 |   3.88 | 578.40 | 5.55% | Gfac=2.5 | GbarI=5  |
 |  17 | 1055.90 |  109 | 1.66 |   9.69 | 460.90 | 4.36% | Gfac=4   | GbarI=10 |
 |  90 | 1053.70 |   67 | 1.75 |  15.73 | 532.90 | 5.07% | Gfac=2.5 | GbarI=50 |
 |  58 | 1053.10 |   56 | 2.06 |  18.81 | 596.20 | 5.67% | Gfac=5   | GbarI=30 |
 |  79 | 1031.80 |   31 | 2.60 |  33.28 | 456.90 | 4.05% | Gfac=5.5 | GbarI=40 |
 |  14 | 1030.00 |  134 | 1.55 |   7.69 | 522.20 | 5.01% | Gfac=2.5 | GbarI=10 |
 |  38 | 1012.00 |   16 | 3.34 |  63.25 | 642.90 | 5.56% | Gfac=4.5 | GbarI=20 |
 |  18 | 1004.90 |   69 | 1.90 |  14.56 | 642.90 | 5.57% | Gfac=4.5 | GbarI=10 |
 |  28 |  990.00 |   16 | 3.30 |  61.88 | 642.90 | 5.57% | Gfac=4.5 | GbarI=15 |
 |  49 |  988.60 |   57 | 1.96 |  17.34 | 722.80 | 6.87% | Gfac=5   | GbarI=25 |
 |  82 |  984.80 |   76 | 1.62 |  12.96 | 518.20 | 4.94% | Gfac=2.5 | GbarI=45 |
 |  81 |  968.20 |   55 | 1.77 |  17.60 | 441.10 | 4.12% | Gfac=2   | GbarI=45 |
 |   9 |  968.10 |   93 | 1.74 |  10.41 | 450.20 | 3.98% | Gfac=5   | GbarI=5  |
 |  65 |  951.80 |   52 | 1.93 |  18.30 | 480.00 | 4.56% | Gfac=3.5 | GbarI=35 |
 |  89 |  951.20 |   76 | 1.65 |  12.52 | 431.90 | 3.84% | Gfac=2   | GbarI=50 |
 |  63 |  948.10 |   47 | 2.00 |  20.17 | 538.10 | 5.14% | Gfac=2.5 | GbarI=35 |
 |  29 |  946.20 |   59 | 1.83 |  16.04 | 526.50 | 4.63% | Gfac=5   | GbarI=15 |
 |  72 |  938.50 |   58 | 1.75 |  16.18 | 423.00 | 3.97% | Gfac=2   | GbarI=40 |
 |  91 |  936.40 |   65 | 1.65 |  14.41 | 612.50 | 5.66% | Gfac=3   | GbarI=50 |
 |  53 |  925.30 |   57 | 1.88 |  16.23 | 547.70 | 5.23% | Gfac=2.5 | GbarI=30 |
 |  64 |  910.40 |   45 | 1.93 |  20.23 | 501.10 | 4.75% | Gfac=3   | GbarI=35 |
 |  95 |  902.00 |   35 | 2.26 |  25.77 | 456.90 | 4.06% | Gfac=5   | GbarI=50 |
 |  16 |  881.80 |   86 | 1.62 |  10.25 | 542.70 | 5.13% | Gfac=3.5 | GbarI=10 |
 | 103 |  877.50 |   47 | 1.80 |  18.67 | 654.70 | 5.71% | Gfac=4   | GbarI=55 |
 |  87 |  870.30 |   37 | 2.17 |  23.52 | 456.90 | 4.07% | Gfac=5   | GbarI=45 |
 |  54 |  863.50 |   54 | 1.83 |  15.99 | 538.00 | 5.10% | Gfac=3   | GbarI=30 |
 |  45 |  838.10 |   55 | 1.80 |  15.24 | 537.40 | 5.09% | Gfac=3   | GbarI=25 |
 | 101 |  825.00 |   39 | 1.71 |  21.15 | 621.60 | 5.72% | Gfac=3   | GbarI=55 |
 |  62 |  819.00 |  100 | 1.50 |   8.19 | 491.80 | 4.73% | Gfac=2   | GbarI=35 |
 |  33 |  810.20 |  125 | 1.43 |   6.48 | 420.60 | 3.79% | Gfac=2   | GbarI=20 |
 |  94 |  778.10 |   23 | 2.09 |  33.83 | 642.90 | 5.68% | Gfac=4.5 | GbarI=50 |
 |  25 |  747.00 |   70 | 1.67 |  10.67 | 453.80 | 4.31% | Gfac=3   | GbarI=15 |
 |   7 |  734.50 |  155 | 1.38 |   4.74 | 522.40 | 4.67% | Gfac=4   | GbarI=5  |
 |  43 |  710.20 |  108 | 1.42 |   6.58 | 458.50 | 4.41% | Gfac=2   | GbarI=25 |
 |  52 |  688.50 |  115 | 1.39 |   5.99 | 466.50 | 4.49% | Gfac=2   | GbarI=30 |
 |  74 |  684.00 |   43 | 1.54 |  15.91 | 546.50 | 5.13% | Gfac=3   | GbarI=40 |
 |   1 |  673.80 | 2411 | 1.08 |   0.28 | 262.40 | 2.53% | Gfac=0.5 | GbarI=5  |
 |  46 |  672.10 |   45 | 1.75 |  14.94 | 500.00 | 4.75% | Gfac=3.5 | GbarI=25 |
 |  73 |  671.50 |   65 | 1.44 |  10.33 | 576.30 | 5.50% | Gfac=2.5 | GbarI=40 |
 |  78 |  663.50 |   44 | 1.77 |  15.08 | 456.90 | 4.15% | Gfac=5   | GbarI=40 |
 |  86 |  659.30 |   37 | 1.68 |  17.82 | 735.40 | 6.77% | Gfac=4.5 | GbarI=45 |
 |  36 |  659.30 |   63 | 1.58 |  10.47 | 508.90 | 4.83% | Gfac=3.5 | GbarI=20 |
 |  50 |  659.00 |   32 | 2.29 |  20.59 | 586.80 | 5.44% | Gfac=5.5 | GbarI=25 |
 |  55 |  658.80 |   45 | 1.72 |  14.64 | 514.40 | 4.88% | Gfac=3.5 | GbarI=30 |
 |  26 |  621.00 |  110 | 1.35 |   5.65 | 448.50 | 4.17% | Gfac=3.5 | GbarI=15 |
 |   8 |  611.10 |  118 | 1.40 |   5.18 | 642.90 | 5.76% | Gfac=4.5 | GbarI=5  |
 |  69 |  600.70 |   26 | 2.08 |  23.10 | 586.80 | 5.32% | Gfac=5.5 | GbarI=35 |
 |  35 |  595.80 |   41 | 1.59 |  14.53 | 533.30 | 5.01% | Gfac=3   | GbarI=20 |
 |  19 |  580.60 |   40 | 1.79 |  14.51 | 642.90 | 5.78% | Gfac=5   | GbarI=10 |
 |  59 |  578.10 |   34 | 1.95 |  17.00 | 586.80 | 5.51% | Gfac=5.5 | GbarI=30 |
 |   5 |  564.90 |  186 | 1.25 |   3.04 | 676.50 | 6.05% | Gfac=3   | GbarI=5  |
 |  71 |  559.10 |  130 | 1.24 |   4.30 | 565.50 | 5.48% | Gfac=1.5 | GbarI=40 |
 |  32 |  535.30 |  252 | 1.17 |   2.12 | 818.00 | 7.93% | Gfac=1.5 | GbarI=20 |
 | 106 |  531.80 |   24 | 1.80 |  22.16 | 654.70 | 5.92% | Gfac=5.5 | GbarI=55 |
 | 105 |  531.00 |   38 | 1.59 |  13.97 | 554.30 | 5.34% | Gfac=5   | GbarI=55 |
 |  30 |  530.10 |   78 | 1.39 |   6.80 | 549.70 | 5.32% | Gfac=5.5 | GbarI=15 |
 |   3 |  493.00 |  404 | 1.13 |   1.22 | 466.80 | 4.52% | Gfac=2   | GbarI=5  |
 |  83 |  486.50 |   38 | 1.38 |  12.80 | 737.70 | 6.92% | Gfac=3   | GbarI=45 |
 |  22 |  453.60 |  312 | 1.13 |   1.45 | 776.40 | 7.50% | Gfac=1.5 | GbarI=15 |
 |  96 |  432.30 |   39 | 1.48 |  11.08 | 642.90 | 5.88% | Gfac=5.5 | GbarI=50 |
 |  10 |  395.50 |  191 | 1.16 |   2.07 | 613.20 | 5.65% | Gfac=5.5 | GbarI=5  |
 |  31 |  394.10 |  286 | 1.12 |   1.38 | 634.80 | 6.19% | Gfac=1   | GbarI=20 |
 |  21 |  355.40 |  364 | 1.10 |   0.98 | 569.70 | 5.58% | Gfac=1   | GbarI=15 |
 |  12 |  337.50 |  382 | 1.08 |   0.88 | 689.30 | 6.68% | Gfac=1.5 | GbarI=10 |
 |   6 |  330.20 |  170 | 1.15 |   1.94 | 652.10 | 5.97% | Gfac=3.5 | GbarI=5  |
 |  61 |  329.00 |  135 | 1.13 |   2.44 | 854.90 | 8.24% | Gfac=1.5 | GbarI=35 |
 |  13 |  312.30 |  240 | 1.11 |   1.30 | 601.40 | 5.80% | Gfac=2   | GbarI=10 |
 |  39 |  305.10 |   56 | 1.28 |   5.45 | 716.70 | 6.82% | Gfac=5   | GbarI=20 |
 |  88 |  257.20 |   44 | 1.26 |   5.85 | 700.70 | 6.77% | Gfac=5.5 | GbarI=45 |
 |  80 |  250.50 |  160 | 1.09 |   1.57 | 734.80 | 7.19% | Gfac=1   | GbarI=45 |
 |  42 |  242.00 |  194 | 1.08 |   1.25 | 934.40 | 9.02% | Gfac=1.5 | GbarI=25 |
 |   2 |  240.00 | 1196 | 1.03 |   0.20 | 852.60 | 8.13% | Gfac=1   | GbarI=5  |
 | 104 |  203.20 |   54 | 1.17 |   3.76 | 644.40 | 6.22% | Gfac=4.5 | GbarI=55 |
 |  51 |  197.60 |  183 | 1.07 |   1.08 | 913.20 | 8.80% | Gfac=1.5 | GbarI=30 |
 |  98 |  155.90 |   88 | 1.07 |   1.77 | 649.30 | 6.29% | Gfac=1.5 | GbarI=55 |
 |  41 |  153.30 |  221 | 1.05 |   0.69 | 756.50 | 7.42% | Gfac=1   | GbarI=25 |
 |  60 |  148.50 |  173 | 1.05 |   0.86 | 937.90 | 9.19% | Gfac=1   | GbarI=35 |
 |  11 |  124.10 | 1490 | 1.02 |   0.08 | 426.90 | 4.12% | Gfac=0.5 | GbarI=10 |
 |  70 |  105.30 |  368 | 1.03 |   0.29 | 626.10 | 6.09% | Gfac=0.5 | GbarI=40 |
 |  20 |   65.10 |  971 | 1.01 |   0.07 | 562.50 | 5.41% | Gfac=0.5 | GbarI=15 |
 |  97 |   40.60 |  110 | 1.02 |   0.37 | 739.60 | 7.25% | Gfac=1   | GbarI=55 |

***** opt 160102-160328
 | 11 | 429.10 |  46 | 1.67 |  9.33 | 389.80 | 3.65% | Gfac=5.5 | GbarI=20 |
 | 27 | 420.30 |  38 | 1.63 | 11.06 | 264.50 | 2.63% | Gfac=5.5 | GbarI=45 |
 | 19 | 414.00 |  42 | 1.63 |  9.86 | 269.90 | 2.56% | Gfac=5.5 | GbarI=30 |
 | 15 | 408.40 |  46 | 1.62 |  8.88 | 389.80 | 3.66% | Gfac=5.5 | GbarI=25 |
 | 30 | 407.40 |  40 | 1.59 | 10.18 | 267.60 | 2.67% | Gfac=5.5 | GbarI=50 |
 | 12 | 404.10 | 141 | 1.27 |  2.87 | 204.60 | 1.95% | Gfac=1.5 | GbarI=25 |
 |  7 | 399.50 |  49 | 1.61 |  8.15 | 389.80 | 3.66% | Gfac=5.5 | GbarI=15 |
 | 24 | 385.70 |  40 | 1.56 |  9.64 | 273.40 | 2.62% | Gfac=5.5 | GbarI=40 |
 | 21 | 382.30 |  41 | 1.56 |  9.32 | 278.70 | 2.65% | Gfac=5.5 | GbarI=35 |
 |  8 | 358.80 | 170 | 1.22 |  2.11 | 230.20 | 2.28% | Gfac=1.5 | GbarI=20 |
 | 10 | 327.80 |  59 | 1.43 |  5.56 | 247.40 | 2.42% | Gfac=3   | GbarI=20 |
 |  6 | 304.10 |  74 | 1.33 |  4.11 | 418.30 | 4.07% | Gfac=3.5 | GbarI=15 |
 | 32 | 290.00 |  58 | 1.33 |  5.00 | 299.30 | 2.98% | Gfac=1.5 | GbarI=55 |
 | 16 | 280.30 | 113 | 1.21 |  2.48 | 264.80 | 2.59% | Gfac=1.5 | GbarI=30 |
 |  9 | 268.70 | 130 | 1.20 |  2.07 | 257.90 | 2.56% | Gfac=2   | GbarI=20 |
 |  3 | 211.60 |  64 | 1.27 |  3.31 | 468.00 | 4.42% | Gfac=5.5 | GbarI=10 |
 | 14 | 210.80 |  62 | 1.25 |  3.40 | 277.50 | 2.68% | Gfac=3   | GbarI=25 |
 | 29 | 179.40 |  67 | 1.18 |  2.68 | 432.20 | 4.29% | Gfac=2   | GbarI=50 |
 |  5 | 164.20 | 202 | 1.09 |  0.81 | 388.70 | 3.74% | Gfac=1.5 | GbarI=15 |
 | 26 | 155.60 |  70 | 1.15 |  2.22 | 433.90 | 4.30% | Gfac=2   | GbarI=45 |
 | 20 | 154.80 |  75 | 1.14 |  2.06 | 287.50 | 2.86% | Gfac=1.5 | GbarI=35 |
 | 25 | 142.60 |  72 | 1.13 |  1.98 | 289.80 | 2.89% | Gfac=1.5 | GbarI=45 |
 |  2 | 141.70 | 252 | 1.07 |  0.56 | 301.70 | 2.92% | Gfac=1.5 | GbarI=10 |
 | 33 | 141.00 |  47 | 1.17 |  3.00 | 459.10 | 4.57% | Gfac=2   | GbarI=55 |
 | 22 | 139.00 |  72 | 1.13 |  1.93 | 287.90 | 2.87% | Gfac=1.5 | GbarI=40 |
 | 28 | 108.10 |  70 | 1.10 |  1.54 | 294.80 | 2.94% | Gfac=1.5 | GbarI=50 |
 | 13 | 105.70 | 105 | 1.09 |  1.01 | 324.20 | 3.21% | Gfac=2   | GbarI=25 |
 |  4 | 103.60 | 350 | 1.04 |  0.30 | 374.50 | 3.58% | Gfac=1   | GbarI=15 |
 | 18 |  79.90 |  42 | 1.14 |  1.90 | 310.10 | 3.00% | Gfac=3   | GbarI=30 |
 |  1 |  73.40 |  99 | 1.07 |  0.74 | 600.30 | 5.63% | Gfac=5.5 | GbarI=5  |
 | 23 |  43.20 |  73 | 1.04 |  0.59 | 427.90 | 4.24% | Gfac=2   | GbarI=40 |
 | 31 |  38.10 | 104 | 1.03 |  0.37 | 393.10 | 3.90% | Gfac=1   | GbarI=55 |
 | 17 |  33.20 |  87 | 1.03 |  0.38 | 316.00 | 3.13% | Gfac=2   | GbarI=30 | 
***** opt 160102-160328 with Dhilo and nu with trend
 |  8 | 145.00 |  40 | 1.15 | 3.63 | 306.10 | 3.00% | Ginclmin=1   | GbarI=25 |
 |  7 | 145.00 |  40 | 1.15 | 3.63 | 306.10 | 3.00% | Ginclmin=0.5 | GbarI=25 |
 |  6 | 145.00 |  40 | 1.15 | 3.63 | 306.10 | 3.00% | Ginclmin=0   | GbarI=25 |
 | 43 | 126.60 |  32 | 1.13 | 3.96 | 377.50 | 3.66% | Ginclmin=5.5 | GbarI=40 |
 | 10 | 114.80 |  41 | 1.11 | 2.80 | 306.10 | 3.01% | Ginclmin=2   | GbarI=25 |
 |  9 | 114.80 |  41 | 1.11 | 2.80 | 306.10 | 3.01% | Ginclmin=1.5 | GbarI=25 |
 | 14 | 112.10 |  39 | 1.11 | 2.87 | 311.10 | 3.06% | Ginclmin=4   | GbarI=25 |
 | 27 | 110.70 |  38 | 1.11 | 2.91 | 312.00 | 3.07% | Ginclmin=1   | GbarI=35 |
 | 26 | 110.70 |  38 | 1.11 | 2.91 | 312.00 | 3.07% | Ginclmin=0.5 | GbarI=35 |
 | 11 | 109.80 |  41 | 1.11 | 2.68 | 311.10 | 3.06% | Ginclmin=2.5 | GbarI=25 |
 | 28 | 106.40 |  38 | 1.10 | 2.80 | 312.00 | 3.07% | Ginclmin=1.5 | GbarI=35 |
 | 30 |  95.80 |  37 | 1.09 | 2.59 | 312.00 | 3.07% | Ginclmin=2.5 | GbarI=35 |
 | 29 |  95.80 |  37 | 1.09 | 2.59 | 312.00 | 3.07% | Ginclmin=2   | GbarI=35 |
 | 25 |  81.80 |  38 | 1.08 | 2.15 | 312.00 | 3.08% | Ginclmin=0   | GbarI=35 |
 | 20 |  79.30 |  37 | 1.08 | 2.14 | 309.20 | 3.05% | Ginclmin=1   | GbarI=30 |
 | 19 |  79.30 |  37 | 1.08 | 2.14 | 309.20 | 3.05% | Ginclmin=0.5 | GbarI=30 |
 | 18 |  79.30 |  37 | 1.08 | 2.14 | 309.20 | 3.05% | Ginclmin=0   | GbarI=30 |
 | 40 |  77.20 |  38 | 1.07 | 2.03 | 338.10 | 3.32% | Ginclmin=3.5 | GbarI=40 |
 |  5 |  73.30 | 303 | 1.03 | 0.24 | 310.40 | 3.04% | Ginclmin=5.5 | GbarI=5  |
 | 42 |  69.40 |  36 | 1.07 | 1.93 | 382.00 | 3.72% | Ginclmin=5   | GbarI=40 |
 | 34 |  58.60 |  38 | 1.05 | 1.54 | 317.90 | 3.13% | Ginclmin=4.5 | GbarI=35 |
 | 16 |  57.90 |  36 | 1.06 | 1.61 | 398.20 | 3.90% | Ginclmin=5   | GbarI=25 |
 | 17 |  55.00 |  36 | 1.06 | 1.53 | 398.20 | 3.90% | Ginclmin=5.5 | GbarI=25 |
 | 38 |  54.10 |  37 | 1.05 | 1.46 | 332.20 | 3.28% | Ginclmin=1.5 | GbarI=40 |
 | 21 |  54.10 |  39 | 1.05 | 1.39 | 309.20 | 3.05% | Ginclmin=1.5 | GbarI=30 |
 |  4 |  41.30 | 308 | 1.02 | 0.13 | 292.20 | 2.86% | Ginclmin=5   | GbarI=5  |
 | 13 |  40.40 |  40 | 1.04 | 1.01 | 317.90 | 3.15% | Ginclmin=3.5 | GbarI=25 |
 | 37 |  29.10 |  37 | 1.03 | 0.79 | 332.20 | 3.29% | Ginclmin=1   | GbarI=40 |
 | 36 |  29.10 |  37 | 1.03 | 0.79 | 332.20 | 3.29% | Ginclmin=0.5 | GbarI=40 |
 | 35 |  29.10 |  37 | 1.03 | 0.79 | 332.20 | 3.29% | Ginclmin=0   | GbarI=40 |
 | 15 |  25.00 |  37 | 1.02 | 0.68 | 398.20 | 3.91% | Ginclmin=4.5 | GbarI=25 |
 | 12 |  21.00 |  41 | 1.02 | 0.51 | 317.90 | 3.15% | Ginclmin=3   | GbarI=25 |
 | 32 |  13.30 |  37 | 1.01 | 0.36 | 312.00 | 3.08% | Ginclmin=3.5 | GbarI=35 |
 | 31 |  13.30 |  37 | 1.01 | 0.36 | 312.00 | 3.08% | Ginclmin=3   | GbarI=35 |
 | 24 |   8.60 |  38 | 1.01 | 0.23 | 315.10 | 3.11% | Ginclmin=3.5 | GbarI=30 |
 |  1 |   7.50 | 322 | 1.00 | 0.02 | 290.90 | 2.85% | Ginclmin=2.5 | GbarI=5  |
 | 33 |   7.40 |  37 | 1.01 | 0.20 | 317.90 | 3.14% | Ginclmin=4   | GbarI=35 |
 |  3 |   6.80 | 314 | 1.00 | 0.02 | 272.10 | 2.67% | Ginclmin=4   | GbarI=5  |
 |  2 |   5.60 | 320 | 1.00 | 0.02 | 301.60 | 2.96% | Ginclmin=3.5 | GbarI=5  |
 | 39 |   2.80 |  38 | 1.00 | 0.07 | 332.20 | 3.28% | Ginclmin=2   | GbarI=40 |
 | 23 |   2.80 |  40 | 1.00 | 0.07 | 309.20 | 3.05% | Ginclmin=2.5 | GbarI=30 |
 | 22 |   2.80 |  40 | 1.00 | 0.07 | 309.20 | 3.05% | Ginclmin=2   | GbarI=30 |
 | 41 |   0.10 |  38 | 1.00 | 0.00 | 393.10 | 3.85% | Ginclmin=4.5 | GbarI=40 |

***** opt 160102-160328 with Dhilo and nu against trend
 | 118 | 826.20 |  31 | 2.10 | 26.65 | 310.90 | 2.91% | Ginclmin=4.5 | GbarI=55 |
 | 117 | 826.20 |  31 | 2.10 | 26.65 | 310.90 | 2.91% | Ginclmin=4   | GbarI=55 |
 | 116 | 826.20 |  31 | 2.10 | 26.65 | 310.90 | 2.91% | Ginclmin=3.5 | GbarI=55 |
 | 115 | 826.20 |  31 | 2.10 | 26.65 | 310.90 | 2.91% | Ginclmin=3   | GbarI=55 |
 | 120 | 731.20 |  31 | 1.91 | 23.59 | 310.90 | 2.94% | Ginclmin=5.5 | GbarI=55 |
 | 119 | 731.20 |  31 | 1.91 | 23.59 | 310.90 | 2.94% | Ginclmin=5   | GbarI=55 |
 | 114 | 726.10 |  30 | 1.96 | 24.20 | 390.50 | 3.65% | Ginclmin=2.5 | GbarI=55 |
 | 113 | 726.10 |  30 | 1.96 | 24.20 | 390.50 | 3.65% | Ginclmin=2   | GbarI=55 |
 | 112 | 726.10 |  30 | 1.96 | 24.20 | 390.50 | 3.65% | Ginclmin=1.5 | GbarI=55 |
 | 111 | 726.10 |  30 | 1.96 | 24.20 | 390.50 | 3.65% | Ginclmin=1   | GbarI=55 |
 | 110 | 726.10 |  30 | 1.96 | 24.20 | 390.50 | 3.65% | Ginclmin=0.5 | GbarI=55 |
 | 109 | 726.10 |  30 | 1.96 | 24.20 | 390.50 | 3.65% | Ginclmin=0   | GbarI=55 |
 | 103 | 630.00 |  33 | 1.70 | 19.09 | 309.50 | 2.89% | Ginclmin=3   | GbarI=50 |
 | 102 | 630.00 |  33 | 1.70 | 19.09 | 309.50 | 2.89% | Ginclmin=2.5 | GbarI=50 |
 |  23 | 626.20 |  66 | 1.53 |  9.49 | 298.50 | 2.81% | Ginclmin=5   | GbarI=15 |
 |   2 | 610.30 | 100 | 1.42 |  6.10 | 288.20 | 2.76% | Ginclmin=0.5 | GbarI=10 |
 |   1 | 610.30 | 100 | 1.42 |  6.10 | 288.20 | 2.76% | Ginclmin=0   | GbarI=10 |
 |  11 | 608.90 | 100 | 1.42 |  6.09 | 288.20 | 2.76% | Ginclmin=5   | GbarI=10 |
 |  10 | 608.90 | 100 | 1.42 |  6.09 | 288.20 | 2.76% | Ginclmin=4.5 | GbarI=10 |
 |   6 | 605.60 | 100 | 1.41 |  6.06 | 288.20 | 2.76% | Ginclmin=2.5 | GbarI=10 |
 |   5 | 605.60 | 100 | 1.41 |  6.06 | 288.20 | 2.76% | Ginclmin=2   | GbarI=10 |
 |   4 | 605.60 | 100 | 1.41 |  6.06 | 288.20 | 2.76% | Ginclmin=1.5 | GbarI=10 |
 |   3 | 605.60 | 100 | 1.41 |  6.06 | 288.20 | 2.76% | Ginclmin=1   | GbarI=10 |
 |  69 | 603.60 |  48 | 1.54 | 12.57 | 300.60 | 2.84% | Ginclmin=4   | GbarI=35 |
 |  68 | 603.60 |  48 | 1.54 | 12.57 | 300.60 | 2.84% | Ginclmin=3.5 | GbarI=35 |
 |  67 | 603.60 |  48 | 1.54 | 12.57 | 300.60 | 2.84% | Ginclmin=3   | GbarI=35 |
 |  66 | 603.60 |  48 | 1.54 | 12.57 | 300.60 | 2.84% | Ginclmin=2.5 | GbarI=35 |
 |  65 | 603.60 |  48 | 1.54 | 12.57 | 300.60 | 2.84% | Ginclmin=2   | GbarI=35 |
 |   9 | 595.40 | 101 | 1.40 |  5.90 | 288.20 | 2.77% | Ginclmin=4   | GbarI=10 |
 |   8 | 595.40 | 101 | 1.40 |  5.90 | 288.20 | 2.77% | Ginclmin=3.5 | GbarI=10 |
 |   7 | 595.40 | 101 | 1.40 |  5.90 | 288.20 | 2.77% | Ginclmin=3   | GbarI=10 |
 |  12 | 581.10 | 100 | 1.39 |  5.81 | 288.20 | 2.77% | Ginclmin=5.5 | GbarI=10 |
 |  24 | 560.00 |  66 | 1.46 |  8.48 | 298.50 | 2.83% | Ginclmin=5.5 | GbarI=15 |
 |  75 | 557.40 |  47 | 1.49 | 11.86 | 384.00 | 3.60% | Ginclmin=1   | GbarI=40 |
 |  74 | 557.40 |  47 | 1.49 | 11.86 | 384.00 | 3.60% | Ginclmin=0.5 | GbarI=40 |
 |  73 | 557.40 |  47 | 1.49 | 11.86 | 384.00 | 3.60% | Ginclmin=0   | GbarI=40 |
 | 108 | 535.00 |  33 | 1.56 | 16.21 | 309.50 | 2.92% | Ginclmin=5.5 | GbarI=50 |
 | 107 | 535.00 |  33 | 1.56 | 16.21 | 309.50 | 2.92% | Ginclmin=5   | GbarI=50 |
 | 106 | 535.00 |  33 | 1.56 | 16.21 | 309.50 | 2.92% | Ginclmin=4.5 | GbarI=50 |
 | 105 | 535.00 |  33 | 1.56 | 16.21 | 309.50 | 2.92% | Ginclmin=4   | GbarI=50 |
 | 104 | 535.00 |  33 | 1.56 | 16.21 | 309.50 | 2.92% | Ginclmin=3.5 | GbarI=50 |
 | 101 | 529.90 |  32 | 1.59 | 16.56 | 389.10 | 3.64% | Ginclmin=2   | GbarI=50 |
 | 100 | 529.90 |  32 | 1.59 | 16.56 | 389.10 | 3.64% | Ginclmin=1.5 | GbarI=50 |
 |  99 | 529.90 |  32 | 1.59 | 16.56 | 389.10 | 3.64% | Ginclmin=1   | GbarI=50 |
 |  98 | 529.90 |  32 | 1.59 | 16.56 | 389.10 | 3.64% | Ginclmin=0.5 | GbarI=50 |
 |  97 | 529.90 |  32 | 1.59 | 16.56 | 389.10 | 3.64% | Ginclmin=0   | GbarI=50 |
 |  22 | 518.00 |  65 | 1.43 |  7.97 | 298.50 | 2.81% | Ginclmin=4.5 | GbarI=15 |
 |  21 | 518.00 |  65 | 1.43 |  7.97 | 298.50 | 2.81% | Ginclmin=4   | GbarI=15 |
 |  80 | 505.10 |  48 | 1.42 | 10.52 | 304.40 | 2.89% | Ginclmin=3.5 | GbarI=40 |
 |  71 | 501.00 |  48 | 1.42 | 10.44 | 300.60 | 2.87% | Ginclmin=5   | GbarI=35 |
 |  70 | 501.00 |  48 | 1.42 | 10.44 | 300.60 | 2.87% | Ginclmin=4.5 | GbarI=35 |
 |  18 | 485.20 |  65 | 1.39 |  7.46 | 298.50 | 2.82% | Ginclmin=2.5 | GbarI=15 |
 |  17 | 485.20 |  65 | 1.39 |  7.46 | 298.50 | 2.82% | Ginclmin=2   | GbarI=15 |
 |  16 | 485.20 |  65 | 1.39 |  7.46 | 298.50 | 2.82% | Ginclmin=1.5 | GbarI=15 |
 |  15 | 485.20 |  65 | 1.39 |  7.46 | 298.50 | 2.82% | Ginclmin=1   | GbarI=15 |
 |  42 | 482.40 |  50 | 1.42 |  9.65 | 325.70 | 3.12% | Ginclmin=2.5 | GbarI=25 |
 |  41 | 482.40 |  50 | 1.42 |  9.65 | 325.70 | 3.12% | Ginclmin=2   | GbarI=25 |
 |  40 | 482.40 |  50 | 1.42 |  9.65 | 325.70 | 3.12% | Ginclmin=1.5 | GbarI=25 |
 |  39 | 482.40 |  50 | 1.42 |  9.65 | 325.70 | 3.12% | Ginclmin=1   | GbarI=25 |
 |  38 | 482.40 |  50 | 1.42 |  9.65 | 325.70 | 3.12% | Ginclmin=0.5 | GbarI=25 |
 |  37 | 482.40 |  50 | 1.42 |  9.65 | 325.70 | 3.12% | Ginclmin=0   | GbarI=25 |
 |  26 | 469.10 |  58 | 1.39 |  8.09 | 282.40 | 2.70% | Ginclmin=0.5 | GbarI=20 |
 |  25 | 469.10 |  58 | 1.39 |  8.09 | 282.40 | 2.70% | Ginclmin=0   | GbarI=20 |
 |  64 | 455.40 |  47 | 1.40 |  9.69 | 380.20 | 3.61% | Ginclmin=1.5 | GbarI=35 |
 |  63 | 455.40 |  47 | 1.40 |  9.69 | 380.20 | 3.61% | Ginclmin=1   | GbarI=35 |
 |  62 | 455.40 |  47 | 1.40 |  9.69 | 380.20 | 3.61% | Ginclmin=0.5 | GbarI=35 |
 |  61 | 455.40 |  47 | 1.40 |  9.69 | 380.20 | 3.61% | Ginclmin=0   | GbarI=35 |
 |  78 | 454.80 |  47 | 1.38 |  9.68 | 384.00 | 3.63% | Ginclmin=2.5 | GbarI=40 |
 |  77 | 454.80 |  47 | 1.38 |  9.68 | 384.00 | 3.63% | Ginclmin=2   | GbarI=40 |
 |  76 | 454.80 |  47 | 1.38 |  9.68 | 384.00 | 3.63% | Ginclmin=1.5 | GbarI=40 |
 |  20 | 451.80 |  65 | 1.36 |  6.95 | 298.50 | 2.83% | Ginclmin=3.5 | GbarI=15 |
 |  48 | 427.90 |  50 | 1.36 |  8.56 | 325.70 | 3.14% | Ginclmin=5.5 | GbarI=25 |
 |  47 | 427.90 |  50 | 1.36 |  8.56 | 325.70 | 3.14% | Ginclmin=5   | GbarI=25 |
 |  19 | 419.00 |  65 | 1.33 |  6.45 | 298.50 | 2.84% | Ginclmin=3   | GbarI=15 |
 |  84 | 410.10 |  48 | 1.32 |  8.54 | 304.40 | 3.02% | Ginclmin=5.5 | GbarI=40 |
 |  83 | 410.10 |  48 | 1.32 |  8.54 | 304.40 | 3.02% | Ginclmin=5   | GbarI=40 |
 |  82 | 410.10 |  48 | 1.32 |  8.54 | 304.40 | 3.02% | Ginclmin=4.5 | GbarI=40 |
 |  81 | 410.10 |  48 | 1.32 |  8.54 | 304.40 | 3.02% | Ginclmin=4   | GbarI=40 |
 |  72 | 406.00 |  48 | 1.33 |  8.46 | 300.60 | 2.90% | Ginclmin=5.5 | GbarI=35 |
 |  79 | 405.00 |  47 | 1.33 |  8.62 | 384.00 | 3.65% | Ginclmin=3   | GbarI=40 |
 |  30 | 402.90 |  58 | 1.32 |  6.95 | 282.40 | 2.71% | Ginclmin=2.5 | GbarI=20 |
 |  29 | 402.90 |  58 | 1.32 |  6.95 | 282.40 | 2.71% | Ginclmin=2   | GbarI=20 |
 |  28 | 402.90 |  58 | 1.32 |  6.95 | 282.40 | 2.71% | Ginclmin=1.5 | GbarI=20 |
 |  27 | 402.90 |  58 | 1.32 |  6.95 | 282.40 | 2.71% | Ginclmin=1   | GbarI=20 |
 |  14 | 399.10 |  65 | 1.31 |  6.14 | 298.50 | 2.85% | Ginclmin=0.5 | GbarI=15 |
 |  13 | 399.10 |  65 | 1.31 |  6.14 | 298.50 | 2.85% | Ginclmin=0   | GbarI=15 |
 |  46 | 379.80 |  50 | 1.32 |  7.60 | 325.70 | 3.15% | Ginclmin=4.5 | GbarI=25 |
 |  45 | 379.80 |  50 | 1.32 |  7.60 | 325.70 | 3.15% | Ginclmin=4   | GbarI=25 |
 |  44 | 379.80 |  50 | 1.32 |  7.60 | 325.70 | 3.15% | Ginclmin=3.5 | GbarI=25 |
 |  43 | 379.80 |  50 | 1.32 |  7.60 | 325.70 | 3.15% | Ginclmin=3   | GbarI=25 |
 |  36 | 354.70 |  58 | 1.28 |  6.12 | 282.40 | 2.73% | Ginclmin=5.5 | GbarI=20 |
 |  35 | 354.70 |  58 | 1.28 |  6.12 | 282.40 | 2.73% | Ginclmin=5   | GbarI=20 |
 |  34 | 354.70 |  58 | 1.28 |  6.12 | 282.40 | 2.73% | Ginclmin=4.5 | GbarI=20 |
 |  33 | 354.70 |  58 | 1.28 |  6.12 | 282.40 | 2.73% | Ginclmin=4   | GbarI=20 |
 |  32 | 354.70 |  58 | 1.28 |  6.12 | 282.40 | 2.73% | Ginclmin=3.5 | GbarI=20 |
 |  31 | 354.70 |  58 | 1.28 |  6.12 | 282.40 | 2.73% | Ginclmin=3   | GbarI=20 |
 |  54 | 351.40 |  51 | 1.29 |  6.89 | 372.50 | 3.58% | Ginclmin=2.5 | GbarI=30 |
 |  53 | 351.40 |  51 | 1.29 |  6.89 | 372.50 | 3.58% | Ginclmin=2   | GbarI=30 |
 |  52 | 351.40 |  51 | 1.29 |  6.89 | 372.50 | 3.58% | Ginclmin=1.5 | GbarI=30 |
 |  51 | 351.40 |  51 | 1.29 |  6.89 | 372.50 | 3.58% | Ginclmin=1   | GbarI=30 |
 |  50 | 351.40 |  51 | 1.29 |  6.89 | 372.50 | 3.58% | Ginclmin=0.5 | GbarI=30 |
 |  49 | 351.40 |  51 | 1.29 |  6.89 | 372.50 | 3.58% | Ginclmin=0   | GbarI=30 |
 |  60 | 313.00 |  51 | 1.25 |  6.14 | 372.50 | 3.60% | Ginclmin=5.5 | GbarI=30 |
 |  59 | 296.90 |  51 | 1.24 |  5.82 | 372.50 | 3.60% | Ginclmin=5   | GbarI=30 |
 |  58 | 296.90 |  51 | 1.24 |  5.82 | 372.50 | 3.60% | Ginclmin=4.5 | GbarI=30 |
 |  57 | 296.90 |  51 | 1.24 |  5.82 | 372.50 | 3.60% | Ginclmin=4   | GbarI=30 |
 |  56 | 296.90 |  51 | 1.24 |  5.82 | 372.50 | 3.60% | Ginclmin=3.5 | GbarI=30 |
 |  55 | 296.90 |  51 | 1.24 |  5.82 | 372.50 | 3.60% | Ginclmin=3   | GbarI=30 |
 |  89 | 236.20 |  42 | 1.19 |  5.62 | 384.90 | 3.71% | Ginclmin=2   | GbarI=45 |
 |  88 | 236.20 |  42 | 1.19 |  5.62 | 384.90 | 3.71% | Ginclmin=1.5 | GbarI=45 |
 |  87 | 236.20 |  42 | 1.19 |  5.62 | 384.90 | 3.71% | Ginclmin=1   | GbarI=45 |
 |  86 | 236.20 |  42 | 1.19 |  5.62 | 384.90 | 3.71% | Ginclmin=0.5 | GbarI=45 |
 |  85 | 236.20 |  42 | 1.19 |  5.62 | 384.90 | 3.71% | Ginclmin=0   | GbarI=45 |
 |  94 | 191.50 |  43 | 1.15 |  4.45 | 353.10 | 3.52% | Ginclmin=4.5 | GbarI=45 |
 |  93 | 191.50 |  43 | 1.15 |  4.45 | 353.10 | 3.52% | Ginclmin=4   | GbarI=45 |
 |  92 | 186.40 |  42 | 1.15 |  4.44 | 384.90 | 3.73% | Ginclmin=3.5 | GbarI=45 |
 |  91 | 186.40 |  42 | 1.15 |  4.44 | 384.90 | 3.73% | Ginclmin=3   | GbarI=45 |
 |  90 | 186.40 |  42 | 1.15 |  4.44 | 384.90 | 3.73% | Ginclmin=2.5 | GbarI=45 |
 |  96 | 133.10 |  45 | 1.10 |  2.96 | 305.30 | 3.02% | Ginclmin=5.5 | GbarI=45 |
 |  95 |  47.90 |  45 | 1.03 |  1.06 | 353.10 | 3.52% | Ginclmin=5   | GbarI=45 |

***** opt 150102-150328 with Dhilo and nu with trend
 | 257 | 1961.50 |  15 |  5.06 | 130.77 | 426.70 | 3.68% | Gfac=3   | Ginclmin=3.5 | GbarI=20 |
 | 254 | 1961.50 |  15 |  5.06 | 130.77 | 426.70 | 3.68% | Gfac=3   | Ginclmin=0   | GbarI=20 |
 | 253 | 1961.50 |  15 |  5.06 | 130.77 | 426.70 | 3.68% | Gfac=3   | Ginclmin=5.5 | GbarI=20 |
 | 250 | 1961.50 |  15 |  5.06 | 130.77 | 426.70 | 3.68% | Gfac=3   | Ginclmin=5   | GbarI=20 |
 | 248 | 1961.50 |  15 |  5.06 | 130.77 | 426.70 | 3.68% | Gfac=3   | Ginclmin=2   | GbarI=20 |
 | 237 | 1961.50 |  15 |  5.06 | 130.77 | 426.70 | 3.68% | Gfac=3   | Ginclmin=4.5 | GbarI=20 |
 | 223 | 1961.50 |  15 |  5.06 | 130.77 | 426.70 | 3.68% | Gfac=3   | Ginclmin=1.5 | GbarI=20 |
 | 213 | 1961.50 |  15 |  5.06 | 130.77 | 426.70 | 3.68% | Gfac=3   | Ginclmin=2.5 | GbarI=20 |
 | 209 | 1961.50 |  15 |  5.06 | 130.77 | 426.70 | 3.68% | Gfac=3   | Ginclmin=1   | GbarI=20 |
 | 203 | 1961.50 |  15 |  5.06 | 130.77 | 426.70 | 3.68% | Gfac=3   | Ginclmin=3   | GbarI=20 |
 | 199 | 1961.50 |  15 |  5.06 | 130.77 | 426.70 | 3.68% | Gfac=3   | Ginclmin=0.5 | GbarI=20 |
 |  14 | 1961.50 |  15 |  5.06 | 130.77 | 426.70 | 3.68% | Gfac=3   | Ginclmin=4   | GbarI=20 |
 | 249 | 1917.60 |   8 | 26.64 | 239.70 | 435.90 | 3.97% | Gfac=3   | Ginclmin=1   | GbarI=50 |
 | 227 | 1917.60 |   8 | 26.64 | 239.70 | 435.90 | 3.97% | Gfac=3   | Ginclmin=0.5 | GbarI=50 |
 | 243 | 1856.60 |   6 | 20.58 | 309.43 | 435.90 | 3.92% | Gfac=3.5 | Ginclmin=1   | GbarI=55 |
 | 211 | 1856.60 |   6 | 20.58 | 309.43 | 435.90 | 3.92% | Gfac=3.5 | Ginclmin=1.5 | GbarI=55 |
 | 128 | 1856.60 |   6 | 20.58 | 309.43 | 435.90 | 3.92% | Gfac=3.5 | Ginclmin=4.5 | GbarI=55 |
 |  94 | 1856.60 |   6 | 20.58 | 309.43 | 435.90 | 3.92% | Gfac=3.5 | Ginclmin=3.5 | GbarI=55 |
 | 222 | 1842.30 |   7 | 25.63 | 263.19 | 435.90 | 3.97% | Gfac=3   | Ginclmin=4.5 | GbarI=50 |
 | 184 | 1842.30 |   7 | 25.63 | 263.19 | 435.90 | 3.97% | Gfac=3   | Ginclmin=4   | GbarI=50 |
 | 183 | 1842.30 |   7 | 25.63 | 263.19 | 435.90 | 3.97% | Gfac=3   | Ginclmin=5.5 | GbarI=50 |
 | 143 | 1842.30 |   7 | 25.63 | 263.19 | 435.90 | 3.97% | Gfac=3   | Ginclmin=2.5 | GbarI=50 |
 |  99 | 1842.30 |   7 | 25.63 | 263.19 | 435.90 | 3.97% | Gfac=3   | Ginclmin=5   | GbarI=50 |
 |  85 | 1798.10 |   7 | 19.81 | 256.87 | 435.90 | 3.98% | Gfac=3   | Ginclmin=5   | GbarI=30 |
 | 231 | 1793.60 |   7 | 26.16 | 256.23 | 435.90 | 3.97% | Gfac=3   | Ginclmin=2.5 | GbarI=45 |
 | 212 | 1793.60 |   7 | 26.16 | 256.23 | 435.90 | 3.97% | Gfac=3   | Ginclmin=4.5 | GbarI=45 |
 | 192 | 1793.60 |   7 | 26.16 | 256.23 | 435.90 | 3.97% | Gfac=3   | Ginclmin=5   | GbarI=45 |
 | 145 | 1793.60 |   7 | 26.16 | 256.23 | 435.90 | 3.97% | Gfac=3   | Ginclmin=3   | GbarI=45 |
 | 104 | 1793.60 |   7 | 26.16 | 256.23 | 435.90 | 3.97% | Gfac=3   | Ginclmin=4   | GbarI=45 |
 | 193 | 1785.80 |  51 |  2.72 |  35.02 | 498.70 | 4.20% | Gfac=5.5 | Ginclmin=1.5 | GbarI=5  |
 | 162 | 1785.80 |  51 |  2.72 |  35.02 | 498.70 | 4.20% | Gfac=5.5 | Ginclmin=0   | GbarI=5  |
 | 244 | 1726.60 |   7 | 13.97 | 246.66 | 435.90 | 3.98% | Gfac=3   | Ginclmin=4   | GbarI=40 |
 | 226 | 1707.20 |  11 |  5.42 | 155.20 | 435.90 | 4.05% | Gfac=5.5 | Ginclmin=4.5 | GbarI=50 |
 | 216 | 1707.20 |  11 |  5.42 | 155.20 | 435.90 | 4.05% | Gfac=5.5 | Ginclmin=5.5 | GbarI=50 |
 | 207 | 1707.20 |  11 |  5.42 | 155.20 | 435.90 | 4.05% | Gfac=5.5 | Ginclmin=3.5 | GbarI=50 |
 | 178 | 1707.20 |  11 |  5.42 | 155.20 | 435.90 | 4.05% | Gfac=5.5 | Ginclmin=4   | GbarI=50 |
 | 114 | 1699.10 |  53 |  2.55 |  32.06 | 498.70 | 4.23% | Gfac=5.5 | Ginclmin=5.5 | GbarI=5  |
 | 181 | 1677.30 |  18 |  3.87 |  93.18 | 426.70 | 3.61% | Gfac=3   | Ginclmin=2.5 | GbarI=15 |
 | 173 | 1677.30 |  18 |  3.87 |  93.18 | 426.70 | 3.61% | Gfac=3   | Ginclmin=1.5 | GbarI=15 |
 |  44 | 1677.30 |  18 |  3.87 |  93.18 | 426.70 | 3.61% | Gfac=3   | Ginclmin=0   | GbarI=15 |
 |  43 | 1677.30 |  18 |  3.87 |  93.18 | 426.70 | 3.61% | Gfac=3   | Ginclmin=0.5 | GbarI=15 |
 | 182 | 1664.80 |  56 |  2.46 |  29.73 | 498.70 | 4.24% | Gfac=5.5 | Ginclmin=4   | GbarI=5  |
 | 210 | 1656.20 |  56 |  2.44 |  29.58 | 498.70 | 4.24% | Gfac=5.5 | Ginclmin=3.5 | GbarI=5  |
 | 242 | 1638.90 |   5 | 29.02 | 327.78 | 435.90 | 3.92% | Gfac=5.5 | Ginclmin=5.5 | GbarI=15 |
 | 228 | 1638.90 |   5 | 29.02 | 327.78 | 435.90 | 3.92% | Gfac=5.5 | Ginclmin=4   | GbarI=15 |
 | 191 | 1638.90 |   5 | 29.02 | 327.78 | 435.90 | 3.92% | Gfac=5.5 | Ginclmin=1.5 | GbarI=15 |
 | 186 | 1638.90 |   5 | 29.02 | 327.78 | 435.90 | 3.92% | Gfac=5.5 | Ginclmin=3.5 | GbarI=15 |
 | 146 | 1638.90 |   5 | 29.02 | 327.78 | 435.90 | 3.92% | Gfac=5.5 | Ginclmin=0   | GbarI=15 |
 | 198 | 1621.80 |   5 | 28.72 | 324.36 | 435.90 | 3.92% | Gfac=5.5 | Ginclmin=5.5 | GbarI=10 |
 | 189 | 1621.80 |   5 | 28.72 | 324.36 | 435.90 | 3.92% | Gfac=5.5 | Ginclmin=0   | GbarI=10 |
 | 150 | 1621.80 |   5 | 28.72 | 324.36 | 435.90 | 3.92% | Gfac=5.5 | Ginclmin=4   | GbarI=10 |
 |  96 | 1621.80 |   5 | 28.72 | 324.36 | 435.90 | 3.92% | Gfac=5.5 | Ginclmin=3.5 | GbarI=10 |
 |  17 | 1621.80 |   5 | 28.72 | 324.36 | 435.90 | 3.92% | Gfac=5.5 | Ginclmin=1.5 | GbarI=10 |
 | 190 | 1599.70 |  11 |  5.33 | 145.43 | 435.90 | 4.05% | Gfac=5.5 | Ginclmin=1.5 | GbarI=50 |
 | 109 | 1599.70 |  11 |  5.33 | 145.43 | 435.90 | 4.05% | Gfac=5.5 | Ginclmin=0   | GbarI=50 |
 | 261 | 1576.30 |  21 |  3.30 |  75.06 | 426.70 | 3.64% | Gfac=3   | Ginclmin=3.5 | GbarI=15 |
 | 260 | 1576.10 |   5 | 27.94 | 315.22 | 435.90 | 3.94% | Gfac=5.5 | Ginclmin=1   | GbarI=20 |
 | 141 | 1576.10 |   5 | 27.94 | 315.22 | 435.90 | 3.94% | Gfac=5.5 | Ginclmin=1.5 | GbarI=20 |
 | 135 | 1576.10 |   5 | 27.94 | 315.22 | 435.90 | 3.94% | Gfac=5.5 | Ginclmin=3.5 | GbarI=20 |
 | 111 | 1576.10 |   5 | 27.94 | 315.22 | 435.90 | 3.94% | Gfac=5.5 | Ginclmin=4   | GbarI=20 |
 | 224 | 1575.20 |  21 |  3.30 |  75.01 | 426.70 | 3.64% | Gfac=3   | Ginclmin=4.5 | GbarI=15 |
 |  65 | 1575.20 |  21 |  3.30 |  75.01 | 426.70 | 3.64% | Gfac=3   | Ginclmin=5   | GbarI=15 |
 |  13 | 1575.20 |  21 |  3.30 |  75.01 | 426.70 | 3.64% | Gfac=3   | Ginclmin=4   | GbarI=15 |
 | 158 | 1553.80 |  94 |  1.96 |  16.53 | 498.70 | 4.21% | Gfac=3   | Ginclmin=4.5 | GbarI=5  |
 | 172 | 1541.40 |  21 |  3.52 |  73.40 | 456.20 | 3.90% | Gfac=3   | Ginclmin=5   | GbarI=10 |
 | 133 | 1541.40 |  21 |  3.52 |  73.40 | 456.20 | 3.90% | Gfac=3   | Ginclmin=5.5 | GbarI=10 |
 | 206 | 1535.40 |  21 |  3.51 |  73.11 | 456.20 | 3.90% | Gfac=3   | Ginclmin=2.5 | GbarI=10 |
 | 148 | 1535.40 |  21 |  3.51 |  73.11 | 456.20 | 3.90% | Gfac=3   | Ginclmin=4.5 | GbarI=10 |
 | 132 | 1535.40 |  21 |  3.51 |  73.11 | 456.20 | 3.90% | Gfac=3   | Ginclmin=3   | GbarI=10 |
 | 107 | 1535.40 |  21 |  3.51 |  73.11 | 456.20 | 3.90% | Gfac=3   | Ginclmin=4   | GbarI=10 |
 | 217 | 1530.10 |  68 |  2.31 |  22.50 | 498.70 | 4.18% | Gfac=3.5 | Ginclmin=5.5 | GbarI=5  |
 |   6 | 1529.80 |  46 |  2.41 |  33.26 | 426.70 | 3.66% | Gfac=1.5 | Ginclmin=3.5 | GbarI=15 |
 | 255 | 1518.30 |   5 | 12.84 | 303.66 | 435.90 | 3.96% | Gfac=3   | Ginclmin=1.5 | GbarI=55 |
 | 251 | 1518.30 |   5 | 12.84 | 303.66 | 435.90 | 3.96% | Gfac=3   | Ginclmin=1   | GbarI=55 |
 | 236 | 1518.30 |   5 | 12.84 | 303.66 | 435.90 | 3.96% | Gfac=3   | Ginclmin=5.5 | GbarI=55 |
 | 230 | 1518.30 |   5 | 12.84 | 303.66 | 435.90 | 3.96% | Gfac=3   | Ginclmin=0.5 | GbarI=55 |
 | 218 | 1518.30 |   5 | 12.84 | 303.66 | 435.90 | 3.96% | Gfac=3   | Ginclmin=3   | GbarI=55 |
 | 197 | 1518.30 |   5 | 12.84 | 303.66 | 435.90 | 3.96% | Gfac=3   | Ginclmin=0   | GbarI=55 |
 | 188 | 1518.30 |   5 | 12.84 | 303.66 | 435.90 | 3.96% | Gfac=3   | Ginclmin=2.5 | GbarI=55 |
 | 171 | 1518.30 |   5 | 12.84 | 303.66 | 435.90 | 3.96% | Gfac=3   | Ginclmin=4.5 | GbarI=55 |
 | 120 | 1518.30 |   5 | 12.84 | 303.66 | 435.90 | 3.96% | Gfac=3   | Ginclmin=4   | GbarI=55 |
 |  51 | 1518.30 |   5 | 12.84 | 303.66 | 435.90 | 3.96% | Gfac=3   | Ginclmin=5   | GbarI=55 |
 |  77 | 1517.60 |  43 |  2.44 |  35.29 | 426.70 | 3.66% | Gfac=1.5 | Ginclmin=1   | GbarI=15 |
 |  35 | 1517.60 |  43 |  2.44 |  35.29 | 426.70 | 3.66% | Gfac=1.5 | Ginclmin=1.5 | GbarI=15 |
 | 204 | 1509.20 |   4 | 12.77 | 377.30 | 435.90 | 3.96% | Gfac=5.5 | Ginclmin=5.5 | GbarI=55 |
 | 175 | 1509.20 |   4 | 12.77 | 377.30 | 435.90 | 3.96% | Gfac=5.5 | Ginclmin=1.5 | GbarI=55 |
 |  68 | 1509.20 |   4 | 12.77 | 377.30 | 435.90 | 3.96% | Gfac=5.5 | Ginclmin=0   | GbarI=55 |
 | 259 | 1503.20 |  12 |  5.68 | 125.27 | 435.90 | 3.98% | Gfac=3   | Ginclmin=0.5 | GbarI=25 |
 | 256 | 1503.20 |  12 |  5.68 | 125.27 | 435.90 | 3.98% | Gfac=3   | Ginclmin=1.5 | GbarI=25 |
 | 187 | 1502.70 |  22 |  3.34 |  68.30 | 456.20 | 3.91% | Gfac=3   | Ginclmin=0   | GbarI=10 |
 | 214 | 1500.70 |   5 | 12.71 | 300.14 | 435.90 | 3.97% | Gfac=4.5 | Ginclmin=0   | GbarI=50 |
 |  79 | 1500.70 |   5 | 12.71 | 300.14 | 435.90 | 3.97% | Gfac=4.5 | Ginclmin=2   | GbarI=50 |
 |  25 | 1500.70 |   5 | 12.71 | 300.14 | 435.90 | 3.97% | Gfac=4.5 | Ginclmin=0.5 | GbarI=50 |
 |   8 | 1500.70 |   5 | 12.71 | 300.14 | 435.90 | 3.97% | Gfac=4.5 | Ginclmin=5.5 | GbarI=50 |
 | 121 | 1495.80 |   5 | 12.67 | 299.16 | 435.90 | 3.97% | Gfac=4.5 | Ginclmin=0   | GbarI=45 |
 | 100 | 1495.80 |   5 | 12.67 | 299.16 | 435.90 | 3.97% | Gfac=4.5 | Ginclmin=5.5 | GbarI=45 |
 |  73 | 1495.80 |   5 | 12.67 | 299.16 | 435.90 | 3.97% | Gfac=4.5 | Ginclmin=0.5 | GbarI=45 |
 |  29 | 1495.80 |   5 | 12.67 | 299.16 | 435.90 | 3.97% | Gfac=4.5 | Ginclmin=2   | GbarI=45 |
 | 232 | 1494.80 |  95 |  1.92 |  15.73 | 498.70 | 4.23% | Gfac=3   | Ginclmin=4   | GbarI=5  |
 | 247 | 1490.40 |  10 |  5.38 | 149.04 | 435.90 | 3.97% | Gfac=3   | Ginclmin=2   | GbarI=45 |
 | 241 | 1477.30 |  76 |  2.13 |  19.44 | 498.70 | 4.20% | Gfac=3.5 | Ginclmin=3.5 | GbarI=5  |
 |  64 | 1465.70 |  11 |  4.17 | 133.25 | 435.90 | 4.08% | Gfac=4.5 | Ginclmin=0   | GbarI=55 |
 | 258 | 1463.50 |  11 |  4.15 | 133.05 | 435.90 | 4.08% | Gfac=4.5 | Ginclmin=3.5 | GbarI=55 |
 | 176 | 1463.50 |  11 |  4.15 | 133.05 | 435.90 | 4.08% | Gfac=4.5 | Ginclmin=4   | GbarI=55 |
 | 125 | 1463.50 |  11 |  4.15 | 133.05 | 435.90 | 4.08% | Gfac=4.5 | Ginclmin=4.5 | GbarI=55 |
 | 108 | 1463.50 |  11 |  4.15 | 133.05 | 435.90 | 4.08% | Gfac=4.5 | Ginclmin=0.5 | GbarI=55 |
 |  48 | 1458.00 |  21 |  3.39 |  69.43 | 492.90 | 4.23% | Gfac=2   | Ginclmin=1.5 | GbarI=15 |
 | 167 | 1455.60 |  23 |  2.92 |  63.29 | 500.40 | 4.29% | Gfac=3   | Ginclmin=3   | GbarI=15 |
 | 240 | 1416.90 | 100 |  1.81 |  14.17 | 498.70 | 4.25% | Gfac=3   | Ginclmin=0.5 | GbarI=5  |
 | 205 | 1412.50 |  97 |  1.84 |  14.56 | 498.70 | 4.26% | Gfac=3   | Ginclmin=1.5 | GbarI=5  |
 | 160 | 1411.40 |  26 |  2.75 |  54.28 | 448.10 | 4.14% | Gfac=2.5 | Ginclmin=2   | GbarI=15 |
 | 201 | 1409.00 |  13 |  3.42 | 108.38 | 435.90 | 4.05% | Gfac=5.5 | Ginclmin=0   | GbarI=45 |
 | 122 | 1409.00 |  13 |  3.42 | 108.38 | 435.90 | 4.05% | Gfac=5.5 | Ginclmin=3.5 | GbarI=45 |
 |  93 | 1409.00 |  13 |  3.42 | 108.38 | 435.90 | 4.05% | Gfac=5.5 | Ginclmin=1.5 | GbarI=45 |
 |  24 | 1409.00 |  13 |  3.42 | 108.38 | 435.90 | 4.05% | Gfac=5.5 | Ginclmin=4   | GbarI=45 |
 |  71 | 1407.60 |  26 |  2.74 |  54.14 | 448.10 | 4.14% | Gfac=2.5 | Ginclmin=2.5 | GbarI=15 |
 |  89 | 1392.40 |  11 |  7.49 | 126.58 | 435.90 | 3.96% | Gfac=1.5 | Ginclmin=1.5 | GbarI=55 |
 |  59 | 1392.40 |  11 |  7.49 | 126.58 | 435.90 | 3.96% | Gfac=1.5 | Ginclmin=1   | GbarI=55 |
 | 139 | 1385.20 |   5 | 14.47 | 277.04 | 676.20 | 5.74% | Gfac=5   | Ginclmin=1   | GbarI=20 |
 |  45 | 1385.20 |   5 | 14.47 | 277.04 | 676.20 | 5.74% | Gfac=5   | Ginclmin=0.5 | GbarI=20 |
 | 238 | 1372.30 |  11 |  4.34 | 124.75 | 435.90 | 3.97% | Gfac=3   | Ginclmin=1   | GbarI=45 |
 | 123 | 1372.30 |  11 |  4.34 | 124.75 | 435.90 | 3.97% | Gfac=3   | Ginclmin=0   | GbarI=45 |
 |  78 | 1372.30 |  11 |  4.34 | 124.75 | 435.90 | 3.97% | Gfac=3   | Ginclmin=0.5 | GbarI=45 |
 | 180 | 1360.70 |  11 |  7.34 | 123.70 | 435.90 | 3.97% | Gfac=1.5 | Ginclmin=1.5 | GbarI=50 |
 | 169 | 1349.00 |  11 |  7.32 | 122.64 | 435.90 | 3.98% | Gfac=1.5 | Ginclmin=3.5 | GbarI=45 |
 |  26 | 1349.00 |  11 |  7.32 | 122.64 | 435.90 | 3.98% | Gfac=1.5 | Ginclmin=1   | GbarI=45 |
 |  69 | 1346.70 |   5 | 13.79 | 269.34 | 678.70 | 5.78% | Gfac=5   | Ginclmin=2   | GbarI=25 |
 | 168 | 1328.80 |  11 |  6.68 | 120.80 | 435.90 | 3.98% | Gfac=1.5 | Ginclmin=4.5 | GbarI=45 |
 | 101 | 1317.90 |  45 |  2.21 |  29.29 | 498.70 | 4.33% | Gfac=5   | Ginclmin=4.5 | GbarI=5  |
 | 136 | 1317.90 |  13 |  3.21 | 101.38 | 435.90 | 4.05% | Gfac=5.5 | Ginclmin=5.5 | GbarI=45 |
 | 137 | 1313.70 |  11 |  6.75 | 119.43 | 435.90 | 3.96% | Gfac=1.5 | Ginclmin=5.5 | GbarI=55 |
 |  20 | 1313.70 |  11 |  6.75 | 119.43 | 435.90 | 3.96% | Gfac=1.5 | Ginclmin=4.5 | GbarI=55 |
 | 142 | 1283.90 |   9 |  4.11 | 142.66 | 426.70 | 3.74% | Gfac=3.5 | Ginclmin=3.5 | GbarI=45 |
 |  63 | 1283.90 |   9 |  4.11 | 142.66 | 426.70 | 3.74% | Gfac=3.5 | Ginclmin=4.5 | GbarI=45 |
 | 127 | 1282.90 |   8 |  4.46 | 160.36 | 426.70 | 3.74% | Gfac=4.5 | Ginclmin=0   | GbarI=40 |
 |  23 | 1282.90 |   8 |  4.46 | 160.36 | 426.70 | 3.74% | Gfac=4.5 | Ginclmin=2   | GbarI=40 |
 |  81 | 1278.10 |  11 |  5.23 | 116.19 | 426.70 | 3.74% | Gfac=2   | Ginclmin=1   | GbarI=35 |
 |  70 | 1275.90 |  11 |  5.23 | 115.99 | 426.70 | 3.74% | Gfac=2   | Ginclmin=5.5 | GbarI=40 |
 |  90 | 1270.80 |  36 |  2.20 |  35.30 | 615.00 | 5.62% | Gfac=1.5 | Ginclmin=1   | GbarI=20 |
 | 144 | 1265.10 |  17 |  2.79 |  74.42 | 422.10 | 3.71% | Gfac=4.5 | Ginclmin=5   | GbarI=30 |
 | 102 | 1265.10 |  17 |  2.79 |  74.42 | 422.10 | 3.71% | Gfac=4.5 | Ginclmin=5.5 | GbarI=30 |
 |   9 | 1265.10 |  17 |  2.79 |  74.42 | 422.10 | 3.71% | Gfac=4.5 | Ginclmin=4.5 | GbarI=30 |
 |  11 | 1260.10 |  17 |  2.79 |  74.12 | 435.90 | 4.12% | Gfac=5.5 | Ginclmin=3.5 | GbarI=25 |
 | 113 | 1247.80 |   6 |  5.97 | 207.97 | 440.60 | 4.05% | Gfac=5   | Ginclmin=2   | GbarI=55 |
 |  84 | 1247.80 |   6 |  5.97 | 207.97 | 440.60 | 4.05% | Gfac=5   | Ginclmin=3   | GbarI=55 |
 |  38 | 1247.80 |   6 |  5.97 | 207.97 | 440.60 | 4.05% | Gfac=5   | Ginclmin=1.5 | GbarI=55 |
 | 245 | 1230.40 |  63 |  1.86 |  19.53 | 714.90 | 6.49% | Gfac=1.5 | Ginclmin=0   | GbarI=10 |
 | 246 | 1224.10 |   8 |  4.50 | 153.01 | 426.70 | 3.76% | Gfac=3.5 | Ginclmin=5.5 | GbarI=50 |
 | 239 | 1224.10 |   8 |  4.50 | 153.01 | 426.70 | 3.76% | Gfac=3.5 | Ginclmin=4   | GbarI=50 |
 | 233 | 1224.10 |   8 |  4.50 | 153.01 | 426.70 | 3.76% | Gfac=3.5 | Ginclmin=1   | GbarI=50 |
 |  52 | 1224.10 |   8 |  4.50 | 153.01 | 426.70 | 3.76% | Gfac=3.5 | Ginclmin=3.5 | GbarI=50 |
 |  30 | 1224.10 |   8 |  4.50 | 153.01 | 426.70 | 3.76% | Gfac=3.5 | Ginclmin=4.5 | GbarI=50 |
 | 166 | 1219.10 |  62 |  1.86 |  19.66 | 682.70 | 6.20% | Gfac=1.5 | Ginclmin=3.5 | GbarI=10 |
 | 151 | 1211.50 |  10 |  4.12 | 121.15 | 426.70 | 3.76% | Gfac=2   | Ginclmin=4.5 | GbarI=45 |
 | 252 | 1181.80 |  14 |  3.06 |  84.41 | 676.20 | 5.84% | Gfac=3.5 | Ginclmin=1   | GbarI=20 |
 | 235 | 1181.80 |  14 |  3.06 |  84.41 | 676.20 | 5.84% | Gfac=3.5 | Ginclmin=3.5 | GbarI=20 |
 | 229 | 1181.80 |  14 |  3.06 |  84.41 | 676.20 | 5.84% | Gfac=3.5 | Ginclmin=4.5 | GbarI=20 |
 | 147 | 1181.80 |  14 |  3.06 |  84.41 | 676.20 | 5.84% | Gfac=3.5 | Ginclmin=4   | GbarI=20 |
 | 159 | 1175.30 |   7 |  5.17 | 167.90 | 599.00 | 5.15% | Gfac=5   | Ginclmin=0.5 | GbarI=15 |
 |  88 | 1175.30 |   7 |  5.17 | 167.90 | 599.00 | 5.15% | Gfac=5   | Ginclmin=3   | GbarI=15 |
 |  33 | 1174.80 |  52 |  1.80 |  22.59 | 408.20 | 3.61% | Gfac=1   | Ginclmin=0.5 | GbarI=25 |
 | 156 | 1159.10 |  15 |  2.49 |  77.27 | 503.80 | 4.52% | Gfac=5   | Ginclmin=2   | GbarI=10 |
 | 140 | 1159.10 |  15 |  2.49 |  77.27 | 503.80 | 4.52% | Gfac=5   | Ginclmin=0.5 | GbarI=10 |
 | 134 | 1159.10 |  15 |  2.49 |  77.27 | 503.80 | 4.52% | Gfac=5   | Ginclmin=1   | GbarI=10 |
 |  91 | 1159.10 |  15 |  2.49 |  77.27 | 503.80 | 4.52% | Gfac=5   | Ginclmin=1.5 | GbarI=10 |
 |  62 | 1159.10 |  15 |  2.49 |  77.27 | 503.80 | 4.52% | Gfac=5   | Ginclmin=3.5 | GbarI=10 |
 | 106 | 1133.50 |  23 |  2.39 |  49.28 | 426.70 | 3.79% | Gfac=2.5 | Ginclmin=5   | GbarI=20 |
 |   4 | 1130.50 |  15 |  2.49 |  75.37 | 426.70 | 3.79% | Gfac=2.5 | Ginclmin=2.5 | GbarI=45 |
 |  56 | 1119.80 |  17 |  2.80 |  65.87 | 503.80 | 4.56% | Gfac=3.5 | Ginclmin=1   | GbarI=15 |
 | 129 | 1099.70 |  21 |  2.76 |  52.37 | 503.80 | 4.60% | Gfac=3.5 | Ginclmin=3.5 | GbarI=10 |
 |  28 | 1087.00 |  21 |  2.47 |  51.76 | 728.40 | 6.57% | Gfac=2   | Ginclmin=3.5 | GbarI=20 |
 |  49 | 1083.90 |   7 |  3.38 | 154.84 | 531.00 | 4.69% | Gfac=4   | Ginclmin=3.5 | GbarI=50 |
 | 161 | 1055.70 |   5 |  8.86 | 211.14 | 841.20 | 7.25% | Gfac=5   | Ginclmin=2   | GbarI=30 |
 | 131 | 1055.70 |   5 |  8.86 | 211.14 | 841.20 | 7.25% | Gfac=5   | Ginclmin=5.5 | GbarI=30 |
 | 118 | 1055.70 |   5 |  8.86 | 211.14 | 841.20 | 7.25% | Gfac=5   | Ginclmin=3.5 | GbarI=30 |
 |  66 | 1055.70 |   5 |  8.86 | 211.14 | 841.20 | 7.25% | Gfac=5   | Ginclmin=1.5 | GbarI=30 |
 |  50 | 1055.70 |   5 |  8.86 | 211.14 | 841.20 | 7.25% | Gfac=5   | Ginclmin=3   | GbarI=30 |
 | 215 | 1041.90 |   9 |  3.79 | 115.77 | 676.20 | 5.92% | Gfac=4.5 | Ginclmin=3.5 | GbarI=20 |
 | 170 | 1041.90 |   9 |  3.79 | 115.77 | 676.20 | 5.92% | Gfac=4.5 | Ginclmin=0   | GbarI=20 |
 | 126 | 1041.90 |   9 |  3.79 | 115.77 | 676.20 | 5.92% | Gfac=4.5 | Ginclmin=0.5 | GbarI=20 |
 |  54 | 1026.60 |   7 |  3.81 | 146.66 | 678.70 | 5.94% | Gfac=4   | Ginclmin=4.5 | GbarI=45 |
 | 154 | 1023.00 |  11 |  2.69 |  93.00 | 426.70 | 3.82% | Gfac=2.5 | Ginclmin=2.5 | GbarI=50 |
 |  19 | 1022.70 |  26 |  2.16 |  39.33 | 756.00 | 7.07% | Gfac=2.5 | Ginclmin=5   | GbarI=10 |
 |  98 | 1018.40 |  20 |  2.41 |  50.92 | 503.80 | 4.56% | Gfac=3.5 | Ginclmin=3.5 | GbarI=15 |
 | 179 | 1018.30 |  74 |  1.70 |  13.76 | 531.40 | 4.64% | Gfac=4.5 | Ginclmin=0   | GbarI=5  |
 | 124 | 1018.30 |  74 |  1.70 |  13.76 | 531.40 | 4.64% | Gfac=4.5 | Ginclmin=0.5 | GbarI=5  |
 | 196 | 1017.30 |  20 |  2.41 |  50.87 | 503.80 | 4.56% | Gfac=3.5 | Ginclmin=4.5 | GbarI=15 |
 |  21 |  993.30 |   7 |  3.79 | 141.90 | 678.70 | 5.96% | Gfac=4   | Ginclmin=4.5 | GbarI=40 |
 |  18 |  993.30 |   7 |  3.79 | 141.90 | 678.70 | 5.96% | Gfac=4   | Ginclmin=3.5 | GbarI=40 |
 | 194 |  992.60 |  55 |  1.81 |  18.05 | 569.30 | 4.98% | Gfac=4.5 | Ginclmin=5.5 | GbarI=5  |
 | 163 |  992.60 |  55 |  1.81 |  18.05 | 569.30 | 4.98% | Gfac=4.5 | Ginclmin=5   | GbarI=5  |
 |  75 |  992.10 |   7 |  3.79 | 141.73 | 678.70 | 5.96% | Gfac=4   | Ginclmin=4.5 | GbarI=35 |
 |  32 |  977.90 |  33 |  1.88 |  29.63 | 474.80 | 4.48% | Gfac=1   | Ginclmin=3.5 | GbarI=35 |
 | 200 |  975.70 |  12 |  3.00 |  81.31 | 503.80 | 4.56% | Gfac=4.5 | Ginclmin=1   | GbarI=10 |
 | 195 |  975.70 |  12 |  3.00 |  81.31 | 503.80 | 4.56% | Gfac=4.5 | Ginclmin=0   | GbarI=10 |
 | 119 |  975.70 |  12 |  3.00 |  81.31 | 503.80 | 4.56% | Gfac=4.5 | Ginclmin=4.5 | GbarI=10 |
 | 116 |  975.70 |  12 |  3.00 |  81.31 | 503.80 | 4.56% | Gfac=4.5 | Ginclmin=5.5 | GbarI=10 |
 |  72 |  971.50 |  28 |  1.89 |  34.70 | 469.10 | 4.45% | Gfac=1   | Ginclmin=2.5 | GbarI=45 |
 | 208 |  961.90 |  12 |  2.73 |  80.16 | 503.80 | 4.55% | Gfac=4.5 | Ginclmin=1.5 | GbarI=15 |
 | 153 |  961.90 |  12 |  2.73 |  80.16 | 503.80 | 4.55% | Gfac=4.5 | Ginclmin=2   | GbarI=15 |
 |  47 |  961.90 |  12 |  2.73 |  80.16 | 503.80 | 4.55% | Gfac=4.5 | Ginclmin=5.5 | GbarI=15 |
 |  10 |  961.90 |  12 |  2.73 |  80.16 | 503.80 | 4.55% | Gfac=4.5 | Ginclmin=0   | GbarI=15 |
 | 157 |  956.70 |  62 |  1.76 |  15.43 | 549.90 | 4.81% | Gfac=4.5 | Ginclmin=4.5 | GbarI=5  |
 | 155 |  951.30 |  13 |  2.92 |  73.18 | 468.10 | 4.56% | Gfac=5.5 | Ginclmin=1.5 | GbarI=25 |
 | 149 |  933.80 |   7 |  3.82 | 133.40 | 832.90 | 7.26% | Gfac=5   | Ginclmin=0.5 | GbarI=50 |
 | 115 |  933.80 |   7 |  3.82 | 133.40 | 832.90 | 7.26% | Gfac=5   | Ginclmin=2   | GbarI=50 |
 |  22 |  933.80 |   7 |  3.82 | 133.40 | 832.90 | 7.26% | Gfac=5   | Ginclmin=3.5 | GbarI=50 |
 | 112 |  930.00 |  12 |  2.59 |  77.50 | 502.50 | 4.90% | Gfac=5.5 | Ginclmin=4   | GbarI=30 |
 | 130 |  928.30 |   7 |  3.80 | 132.61 | 832.90 | 7.26% | Gfac=5   | Ginclmin=3.5 | GbarI=45 |
 | 110 |  928.30 |   7 |  3.80 | 132.61 | 832.90 | 7.26% | Gfac=5   | Ginclmin=1   | GbarI=45 |
 |  42 |  928.30 |   7 |  3.80 | 132.61 | 832.90 | 7.26% | Gfac=5   | Ginclmin=1.5 | GbarI=45 |
 |  41 |  928.30 |   7 |  3.80 | 132.61 | 832.90 | 7.26% | Gfac=5   | Ginclmin=4.5 | GbarI=45 |
 | 174 |  921.10 |  16 |  2.19 |  57.57 | 468.50 | 4.42% | Gfac=2   | Ginclmin=4   | GbarI=55 |
 | 117 |  921.00 |  16 |  2.19 |  57.56 | 468.60 | 4.42% | Gfac=2   | Ginclmin=3.5 | GbarI=55 |
 |  86 |  917.90 |  13 |  2.54 |  70.61 | 499.40 | 4.87% | Gfac=5.5 | Ginclmin=2.5 | GbarI=35 |
 |  87 |  904.70 |  21 |  2.11 |  43.08 | 865.90 | 7.85% | Gfac=2   | Ginclmin=1.5 | GbarI=30 |
 |  60 |  904.70 |  21 |  2.11 |  43.08 | 865.90 | 7.85% | Gfac=2   | Ginclmin=4.5 | GbarI=30 |
 |  55 |  904.70 |  21 |  2.11 |  43.08 | 865.90 | 7.85% | Gfac=2   | Ginclmin=0.5 | GbarI=30 |
 |  39 |  904.70 |  21 |  2.11 |  43.08 | 865.90 | 7.85% | Gfac=2   | Ginclmin=2.5 | GbarI=30 |
 |  58 |  899.30 |  16 |  2.13 |  56.21 | 463.80 | 4.39% | Gfac=2   | Ginclmin=3.5 | GbarI=50 |
 |   7 |  899.30 |  16 |  2.13 |  56.21 | 463.80 | 4.39% | Gfac=2   | Ginclmin=4   | GbarI=50 |
 |   2 |  899.30 |  16 |  2.13 |  56.21 | 463.80 | 4.39% | Gfac=2   | Ginclmin=5.5 | GbarI=50 |
 |  16 |  896.70 |  13 |  2.45 |  68.98 | 520.60 | 5.07% | Gfac=5.5 | Ginclmin=2.5 | GbarI=40 |
 | 225 |  889.80 |  18 |  1.94 |  49.43 | 776.40 | 7.18% | Gfac=2.5 | Ginclmin=0   | GbarI=30 |
 | 105 |  876.30 |   7 |  3.64 | 125.19 | 832.90 | 7.29% | Gfac=5   | Ginclmin=4.5 | GbarI=40 |
 |  61 |  876.30 |   7 |  3.64 | 125.19 | 832.90 | 7.29% | Gfac=5   | Ginclmin=2   | GbarI=40 |
 |  80 |  869.40 |  10 |  2.73 |  86.94 | 734.60 | 6.67% | Gfac=3.5 | Ginclmin=3.5 | GbarI=40 |
 | 177 |  868.60 |  10 |  2.73 |  86.86 | 734.30 | 6.67% | Gfac=3.5 | Ginclmin=3.5 | GbarI=30 |
 |  37 |  868.60 |  10 |  2.73 |  86.86 | 734.30 | 6.67% | Gfac=3.5 | Ginclmin=2   | GbarI=30 |
 |   5 |  868.30 |  10 |  2.73 |  86.83 | 734.60 | 6.67% | Gfac=3.5 | Ginclmin=4.5 | GbarI=35 |
 |  67 |  858.70 |  17 |  2.02 |  50.51 | 530.90 | 5.01% | Gfac=2   | Ginclmin=2.5 | GbarI=55 |
 |   1 |  858.70 |  17 |  2.02 |  50.51 | 530.90 | 5.01% | Gfac=2   | Ginclmin=1.5 | GbarI=55 |
 | 220 |  845.90 | 132 |  1.36 |   6.41 | 360.70 | 3.27% | Gfac=2   | Ginclmin=0   | GbarI=5  |
 | 164 |  838.10 |  17 |  1.98 |  49.30 | 525.00 | 4.97% | Gfac=2   | Ginclmin=1.5 | GbarI=50 |
 |   3 |  838.10 |  17 |  1.98 |  49.30 | 525.00 | 4.97% | Gfac=2   | Ginclmin=1   | GbarI=50 |
 |  76 |  797.30 |  33 |  1.64 |  24.16 | 512.00 | 4.91% | Gfac=1   | Ginclmin=3.5 | GbarI=40 |
 |  36 |  797.30 |  33 |  1.64 |  24.16 | 512.00 | 4.91% | Gfac=1   | Ginclmin=0   | GbarI=40 |
 | 202 |  789.60 |   9 |  2.63 |  87.73 | 841.20 | 7.42% | Gfac=4.5 | Ginclmin=3.5 | GbarI=35 |
 |  83 |  789.60 |   9 |  2.63 |  87.73 | 841.20 | 7.42% | Gfac=4.5 | Ginclmin=0.5 | GbarI=35 |
 |  53 |  789.60 |   9 |  2.63 |  87.73 | 841.20 | 7.42% | Gfac=4.5 | Ginclmin=3   | GbarI=35 |
 | 165 |  786.00 | 200 |  1.27 |   3.93 | 437.70 | 4.17% | Gfac=1.5 | Ginclmin=0   | GbarI=5  |
 | 103 |  777.80 | 200 |  1.27 |   3.89 | 445.90 | 4.25% | Gfac=1.5 | Ginclmin=0.5 | GbarI=5  |
 | 221 |  776.20 | 198 |  1.27 |   3.92 | 444.90 | 4.24% | Gfac=1.5 | Ginclmin=1   | GbarI=5  |
 | 185 |  775.10 |  20 |  1.73 |  38.76 | 763.80 | 7.05% | Gfac=2.5 | Ginclmin=0   | GbarI=25 |
 |  97 |  775.10 |  20 |  1.73 |  38.76 | 763.80 | 7.05% | Gfac=2.5 | Ginclmin=5   | GbarI=25 |
 |  40 |  755.30 |  12 |  2.13 |  62.94 | 832.90 | 7.37% | Gfac=4   | Ginclmin=3   | GbarI=30 |
 | 263 |  706.00 |   8 |  2.76 |  88.25 | 844.70 | 7.50% | Gfac=4   | Ginclmin=0   | GbarI=55 |
 | 262 |  614.20 |  87 |  1.25 |   7.06 | 515.20 | 4.68% | Gfac=1   | Ginclmin=4   | GbarI=15 |
 |  82 |  604.40 |  24 |  1.56 |  25.18 | 466.00 | 4.43% | Gfac=1   | Ginclmin=0   | GbarI=55 |
 |  31 |  604.40 |  24 |  1.56 |  25.18 | 466.00 | 4.43% | Gfac=1   | Ginclmin=2   | GbarI=55 |
 |  12 |  604.40 |  24 |  1.56 |  25.18 | 466.00 | 4.43% | Gfac=1   | Ginclmin=0.5 | GbarI=55 |
 |  15 |  562.10 |  25 |  1.45 |  22.48 | 877.30 | 7.79% | Gfac=4   | Ginclmin=3.5 | GbarI=10 |
 |  57 |  528.40 |  94 |  1.20 |   5.62 | 518.10 | 4.74% | Gfac=1   | Ginclmin=2.5 | GbarI=15 |
 | 138 |  512.20 | 143 |  1.16 |   3.58 | 750.30 | 7.13% | Gfac=1   | Ginclmin=0.5 | GbarI=10 |
 | 152 |  511.30 |  94 |  1.20 |   5.44 | 498.80 | 4.72% | Gfac=1   | Ginclmin=3.5 | GbarI=15 |
 |  27 |  505.80 |  62 |  1.28 |   8.16 | 543.00 | 5.27% | Gfac=1   | Ginclmin=3.5 | GbarI=20 |
 |  46 |  500.70 |  93 |  1.19 |   5.38 | 518.10 | 4.75% | Gfac=1   | Ginclmin=0.5 | GbarI=15 |
 |  74 |  484.70 |  63 |  1.27 |   7.69 | 543.00 | 5.27% | Gfac=1   | Ginclmin=0.5 | GbarI=20 |
 |  92 |  410.70 | 142 |  1.13 |   2.89 | 750.30 | 7.16% | Gfac=1   | Ginclmin=2.5 | GbarI=10 |
 | 219 |  224.00 |  72 |  1.11 |   3.11 | 676.10 | 6.62% | Gfac=0.5 | Ginclmin=5.5 | GbarI=55 |
 | 234 |  155.20 |  76 |  1.07 |   2.04 | 710.50 | 6.94% | Gfac=0.5 | Ginclmin=2.5 | GbarI=55 |
 |  95 |   55.70 |  77 |  1.02 |   0.72 | 703.60 | 6.88% | Gfac=0.5 | Ginclmin=0   | GbarI=55 |
 |  34 |   35.60 |  83 |  1.01 |   0.43 | 887.40 | 8.59% | Gfac=0.5 | Ginclmin=4   | GbarI=50 |

***** opt 150102-150328 with Dhilo and nu against trend
 | 33 | 343.90 | 130 | 1.11 | 2.65 | 602.50 | 5.81% | Gfac=1 | Ginclmin=1.5 | GbarI=10 |
 | 32 | 343.90 | 130 | 1.11 | 2.65 | 602.50 | 5.81% | Gfac=1 | Ginclmin=2.5 | GbarI=10 |
 | 24 | 343.90 | 130 | 1.11 | 2.65 | 602.50 | 5.81% | Gfac=1 | Ginclmin=0.5 | GbarI=10 |
 | 15 | 343.90 | 130 | 1.11 | 2.65 | 602.50 | 5.81% | Gfac=1 | Ginclmin=1   | GbarI=10 |
 | 31 | 322.50 | 130 | 1.10 | 2.48 | 602.50 | 5.82% | Gfac=1 | Ginclmin=3.5 | GbarI=10 |
 | 30 | 322.50 | 130 | 1.10 | 2.48 | 602.50 | 5.82% | Gfac=1 | Ginclmin=4   | GbarI=10 |
 | 20 | 322.50 | 130 | 1.10 | 2.48 | 602.50 | 5.82% | Gfac=1 | Ginclmin=4.5 | GbarI=10 |
 |  2 | 322.50 | 130 | 1.10 | 2.48 | 602.50 | 5.82% | Gfac=1 | Ginclmin=3   | GbarI=10 |
 |  8 | 295.00 | 130 | 1.09 | 2.27 | 602.50 | 5.83% | Gfac=1 | Ginclmin=0   | GbarI=10 |
 | 26 | 292.30 | 131 | 1.09 | 2.23 | 602.50 | 5.84% | Gfac=1 | Ginclmin=5   | GbarI=10 |
 |  9 | 292.30 | 131 | 1.09 | 2.23 | 602.50 | 5.84% | Gfac=1 | Ginclmin=5.5 | GbarI=10 |
 | 29 | 208.80 | 381 | 1.04 | 0.55 | 463.10 | 4.55% | Gfac=1 | Ginclmin=2.5 | GbarI=5  |
 |  3 | 205.90 | 374 | 1.04 | 0.55 | 454.40 | 4.44% | Gfac=1 | Ginclmin=0   | GbarI=5  |
 | 17 | 197.80 | 382 | 1.04 | 0.52 | 446.60 | 4.44% | Gfac=1 | Ginclmin=4.5 | GbarI=5  |
 | 14 | 186.80 | 376 | 1.04 | 0.50 | 454.40 | 4.46% | Gfac=1 | Ginclmin=0.5 | GbarI=5  |
 |  5 | 185.50 | 382 | 1.04 | 0.49 | 463.10 | 4.55% | Gfac=1 | Ginclmin=3   | GbarI=5  |
 | 18 | 181.30 | 383 | 1.04 | 0.47 | 463.10 | 4.55% | Gfac=1 | Ginclmin=4   | GbarI=5  |
 |  6 | 181.30 | 383 | 1.04 | 0.47 | 463.10 | 4.55% | Gfac=1 | Ginclmin=3.5 | GbarI=5  |
 | 10 | 168.40 | 379 | 1.03 | 0.44 | 463.10 | 4.54% | Gfac=1 | Ginclmin=1.5 | GbarI=5  |
 | 12 | 159.00 | 383 | 1.03 | 0.42 | 459.10 | 4.52% | Gfac=1 | Ginclmin=5   | GbarI=5  |
 | 13 | 156.30 | 377 | 1.03 | 0.41 | 454.40 | 4.46% | Gfac=1 | Ginclmin=1   | GbarI=5  |
 | 22 | 125.50 | 384 | 1.02 | 0.33 | 459.10 | 4.53% | Gfac=1 | Ginclmin=5.5 | GbarI=5  |
 | 19 | 110.70 | 118 | 1.04 | 0.94 | 450.90 | 4.33% | Gfac=2 | Ginclmin=5   | GbarI=5  |
 | 11 | 110.70 | 118 | 1.04 | 0.94 | 450.90 | 4.33% | Gfac=2 | Ginclmin=4.5 | GbarI=5  |
 |  1 | 110.70 | 118 | 1.04 | 0.94 | 450.90 | 4.33% | Gfac=2 | Ginclmin=5.5 | GbarI=5  |
 |  4 |  83.30 |  63 | 1.04 | 1.32 | 743.80 | 6.97% | Gfac=3 | Ginclmin=4   | GbarI=5  |
 | 25 |  70.80 | 120 | 1.03 | 0.59 | 450.90 | 4.35% | Gfac=2 | Ginclmin=4   | GbarI=5  |
 | 28 |  36.80 |  60 | 1.02 | 0.61 | 667.80 | 6.33% | Gfac=1 | Ginclmin=3   | GbarI=20 |
 | 23 |  36.80 |  60 | 1.02 | 0.61 | 667.80 | 6.33% | Gfac=1 | Ginclmin=1   | GbarI=20 |
 | 21 |  36.80 |  60 | 1.02 | 0.61 | 667.80 | 6.33% | Gfac=1 | Ginclmin=0.5 | GbarI=20 |
 | 16 |  36.80 |  60 | 1.02 | 0.61 | 667.80 | 6.33% | Gfac=1 | Ginclmin=2.5 | GbarI=20 |
 |  7 |  36.80 |  60 | 1.02 | 0.61 | 667.80 | 6.33% | Gfac=1 | Ginclmin=0   | GbarI=20 |
 | 27 |  36.60 | 119 | 1.01 | 0.31 | 517.60 | 4.98% | Gfac=2 | Ginclmin=2   | GbarI=5  |
**** macross with fivonacci
 Gfac=4;GbarI=15;
 the surprise was fivonacci going to 2 giving 2300 profit instead of just 1924 before.
 however, we think that great ntr won't matter until we get better xit because a Gfac of 4 requires a lot of chance to be hit.
 also we think conditions are too difficult to ntr and we have very few trades 
***** code
 //+------------------------------------------------------------------+
 //|                                                    pradapter.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+
 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #define sp "  "

 extern double Gfac;
 extern int GbarI;

 int
 GbarsInchart=0,
 Gtkt=0,
 Gtimeframe=5;

 int OnInit() {return(INIT_SUCCEEDED);}
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {
 //Gfac=4;GbarI=15;

    if(CanDoTrade(GbarsInchart))
       opn(Gtkt);
    else
       alt(Gtkt);

   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void opn(int &tk)
 //opens a trade via some ntr fn combo
   {
    double 
    bstrend=macross(Gtimeframe,GbarI),
    fivonacci=fivonacci(Gtimeframe);

    if(bstrend>0 && fivonacci>+2)
       placebuysel(0,tk);
    if(bstrend<0 && fivonacci<-2)
       placebuysel(1,tk);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void alt(int tk)
 //alters a trade by moving sl,tp or by closing it via some xit fn combo
   {
 /*   bool zz,xit;
    double oo,oc,sl,tp,lt;
    int bs;

    OrderDetails(tk,bs,oo,oc,sl,tp);
    lt=0.1;
    xit=(bs==0 && II(Gtimeframe,GbarI)==-1) || (bs==1 && II(Gtimeframe,GbarI)==+1) ;

    if(xit)
       zz=OrderClose(tk,lt,oc,0);
 else
       trailer(tk,bs,oo,oc,sl,tp);*/
   }
 //
 //
 //
 //
 //
 //+------------------------------------------------------------------+
 //|     NTRXIT                                                       |
 //+------------------------------------------------------------------+
 //

 int macross(int timeframe,int barI)
 //ntr from price crossings of ma
   {
    double
    maVal=iMA(NULL,timeframe,barI,0,MODE_SMA,PRICE_OPEN,0),
    prLow=iLow(NULL,timeframe,1),
    prClo=iClose(NULL,timeframe,1),
    prHig=iHigh(NULL,timeframe,1);

    bool buy,sel;

    buy=(prLow<maVal && prClo>maVal);
    sel=(prHig>maVal && prClo<maVal);

    if(buy) return +1;
    if(sel) return -1;
    return 0;
   }
 //
 //
 //
 //+------------------------------------------------------------------+
 //|        VARIOUS FUNCTIONS                                         |
 //+------------------------------------------------------------------+
 //

 double fivonacci(int timeframe)
 //suggests trend from fivonacci inclines
   {
    color colors[5];
    double inclStrength,wis,incl[5];ArrayInitialize(incl,0);
    int barF,barI[5];

    barF=1;barI[0]=5;barI[1]=10;barI[2]=15;barI[3]=25;barI[4]=40;
    colors[0]=Red;colors[1]=Orange;colors[2]=Brown;colors[3]=Green;colors[4]=Blue;

    inclStrength=0;
    wis=0;
    for(int i=0;i<5;i++)
      {
       incl[i]=incline(timeframe,barI[i],barF);
       wis+=incl[i]*barI[i];
       drawOCtline(IntegerToString(barI[i]),barI[i],barF,colors[i]);
      }
    return wis/95;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void placebuysel(int bs,int &tk)
 //places buysel order
   {
    double
    lt=0.1,
    minsl=50*Point,
    padding=9*Point,
    sltpfactor=Gfac;

    double oo,sl,tp,hiVal,loVal,v[2];
    int hiBar,loBar;

    maxmin(Gtimeframe,GbarI,1,hiBar,hiVal,loBar,loVal);

    RefreshRates();
    switch(bs)
      {
       case  0:
          oo=Ask;
          v[0]=loVal-padding;
          v[1]=oo-minsl;
          arrmaxmin(v,hiBar,loBar);
          sl=v[loBar];
          tp=oo+sltpfactor*Dpts(sl,oo)*Point;
          tk=OrderSend(Symbol(),bs,lt,oo,0,sl,tp);
          break;
       case  1:
          oo=Bid;
          v[0]=hiVal+padding;
          v[1]=oo+minsl;
          arrmaxmin(v,hiBar,loBar);
          sl=v[hiBar];
          tp=oo-sltpfactor*Dpts(oo,sl)*Point;
          tk=OrderSend(Symbol(),bs,lt,oo,0,sl,tp);
          break;
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double incline(int timeframe,int barI,int barF)
 //calculates slope between barI and barF for a timeframe
   {
    return Dpts(iOpen(NULL,timeframe,barI),iClose(NULL,timeframe,barF))/((barI-barF)+1);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
   {
    return (pF-pI)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void arrmaxmin(double &v[],int &max,int &min)
 //returns largest and smallest of a group of numbers
   {
    max=ArrayMaximum(v);
    min=ArrayMinimum(v);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void maxmin(int timeframe,int barI,int barF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barvalues between barI and barF for a timeframe
   {
    maxbar=iHighest(NULL,timeframe,MODE_HIGH,barI,barF);
    maxval=iHigh(NULL,timeframe,maxbar);
    minbar=iLowest(NULL,timeframe,MODE_LOW,barI,barF);
    minval=iLow(NULL,timeframe,minbar);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int modrand(int divisor)
 //generates random number and mods it with divisor
   {
    return (int)fmod(rand(),divisor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OrderDetails(int tk,int &bs,double &oo,double &oc,double &sl,double &tp)
 //gets open order details into variables
   {
    bool zz=OrderSelect(tk,SELECT_BY_TICKET);

    bs=OrderType();
    oo=OrderOpenPrice();
    oc=OrderClosePrice();
    tp=OrderTakeProfit();
    sl=OrderStopLoss();
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void drawOCtline(string name,int barI,int barF,color acolor)
 //draws a line between two points (barI,priceI) and (barF,priceF)
   {
    datetime
    timeI=iTime(NULL,Gtimeframe,barI),
    timeF=iTime(NULL,Gtimeframe,barF);
    double
    pricI=iOpen(NULL,Gtimeframe,barI),
    pricF=iClose(NULL,Gtimeframe,barF);
    bool
    zz=ObjectDelete(name);
    zz=ObjectCreate(name,OBJ_TREND,0,timeI,pricI,timeF,pricF);
    zz=ObjectSet(name,OBJPROP_RAY,false);
    zz=ObjectSet(name,OBJPROP_COLOR,acolor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void display(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
   {
    ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
    ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
    ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
    ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
    ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool CanDoTrade(int &barsInchart)
 //checks various conditions to see if trade is permitted
   {
    bool
    tradeless=(barsInchart!=Bars);
    double
    spread=MarketInfo(NULL,MODE_SPREAD);
    int
    aords,pords,
    tords=OrdersForSymbol(aords,pords);

    barsInchart=Bars;
    return ((tords==0) && tradeless && (spread<9));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of orders that have been placed for a particular symbol
   {
    for(int pos=OrdersTotal()-1; pos>=0; pos--)
      {
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUYSTOP || OrderType()==OP_SELLSTOP))
          pords++;
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUY || OrderType()==OP_SELL))
          aords++;
      }
    return aords+pords;
   }
 //+------------------------------------------------------------------+
**** fivonacci for ntrxit
 150102-150328
 | 17 | 1035.40 | 263 | 1.33 | 3.94 | 486.40 | 4.69% | ntrfivo=1 | xitfivo=3 |
 | 13 |  873.80 | 291 | 1.28 | 3.00 | 280.20 | 2.73% | ntrfivo=2 | xitfivo=2 |
 | 12 |  680.60 | 262 | 1.20 | 2.60 | 375.00 | 3.71% | ntrfivo=1 | xitfivo=2 |
 | 14 |  678.90 | 260 | 1.25 | 2.61 | 338.80 | 3.35% | ntrfivo=3 | xitfivo=2 |
 | 18 |  568.70 | 233 | 1.22 | 2.44 | 334.90 | 3.13% | ntrfivo=2 | xitfivo=3 |
 | 15 |  548.70 | 260 | 1.23 | 2.11 | 368.30 | 3.59% | ntrfivo=4 | xitfivo=2 |
 |  7 |  505.10 | 370 | 1.12 | 1.37 | 605.90 | 5.98% | ntrfivo=1 | xitfivo=1 |
 | 22 |  497.00 | 276 | 1.14 | 1.80 | 570.90 | 5.53% | ntrfivo=1 | xitfivo=4 |
 |  6 |  492.30 | 363 | 1.10 | 1.36 | 536.80 | 5.32% | ntrfivo=0 | xitfivo=1 |
 |  8 |  482.60 | 296 | 1.16 | 1.63 | 300.80 | 2.97% | ntrfivo=2 | xitfivo=1 |
 |  2 |  463.70 | 402 | 1.13 | 1.15 | 496.30 | 4.89% | ntrfivo=1 | xitfivo=0 |
 |  1 |  461.50 | 539 | 1.08 | 0.86 | 455.50 | 4.44% | ntrfivo=0 | xitfivo=0 |

 160102-1603285
 | 10 | 651.10 | 132 | 1.68 | 4.93 | 219.80 | 2.17% | ntrfivo=3 | xitfivo=4 |
 |  6 | 583.20 | 172 | 1.39 | 3.39 | 259.80 | 2.46% | ntrfivo=2 | xitfivo=2 |
 |  7 | 458.90 | 144 | 1.39 | 3.19 | 217.50 | 2.11% | ntrfivo=3 | xitfivo=2 |
 |  5 | 407.70 | 137 | 1.29 | 2.98 | 227.10 | 2.19% | ntrfivo=1 | xitfivo=2 |
 |  2 | 156.90 | 205 | 1.14 | 0.77 | 178.80 | 1.76% | ntrfivo=3 | xitfivo=0 |
 |  9 | 143.40 | 162 | 1.09 | 0.89 | 417.90 | 4.14% | ntrfivo=3 | xitfivo=3 |
 |  4 | 141.60 | 158 | 1.08 | 0.90 | 401.60 | 3.87% | ntrfivo=0 | xitfivo=2 |
 |  8 | 109.90 | 149 | 1.11 | 0.74 | 384.60 | 3.80% | ntrfivo=4 | xitfivo=2 |
 |  1 |  58.10 | 210 | 1.04 | 0.28 | 343.20 | 3.32% | ntrfivo=2 | xitfivo=0 |
 |  3 |  15.60 | 169 | 1.01 | 0.09 | 304.90 | 3.02% | ntrfivo=3 | xitfivo=1 | 

 160102-160328
 | 33 | 693.90 |  94 | 1.59 | 7.38 | 205.50 | 1.93% | ntrfivo=1 | xitfivo=3 | Gth=0.9 |
 | 35 | 692.70 |  95 | 1.62 | 7.29 | 210.30 | 1.98% | ntrfivo=1 | xitfivo=3 | Gth=0.8 |
 | 29 | 608.30 | 104 | 1.48 | 5.85 | 207.80 | 1.98% | ntrfivo=1 | xitfivo=3 | Gth=0.6 |
 | 24 | 551.60 |  99 | 1.46 | 5.57 | 210.30 | 2.01% | ntrfivo=1 | xitfivo=3 | Gth=0.7 |
 | 14 | 522.90 |  94 | 1.54 | 5.56 | 238.40 | 2.26% | ntrfivo=3 | xitfivo=3 | Gth=0.8 |
 |  4 | 502.00 | 109 | 1.36 | 4.61 | 334.90 | 3.23% | ntrfivo=0 | xitfivo=3 | Gth=0.8 |
 | 15 | 450.10 | 103 | 1.51 | 4.37 | 190.30 | 1.86% | ntrfivo=3 | xitfivo=4 | Gth=0.4 | 

 pass33 produced 1600+ 150102-160328 and 694 160102-160328
 making the ><+-th consistent had deterimental effect 655 being highest

 results were good only for EURUSD which is rather strange, imho.
 fivonacci code:
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int fivonacci(int timeframe,int ratio)
 //enters on contrarian fivonacci
   {
    double th=Gth,incl[5];ArrayInitialize(incl,0);
    int barF=1,barI[5];
    barF=1;barI[0]=5;barI[1]=10;barI[2]=15;barI[3]=25;barI[4]=40;

    for(int i=0;i<5;i++)
       incl[i]=incline(timeframe,barI[i],barF);

    switch(ratio)
      {
       case  0:
          if(incl[4]>+th && incl[3]>+th && incl[2]>+th && incl[1]>+th && incl[0]>+th) return +1;
          if(incl[4]<-th && incl[3]<-th && incl[2]<-th && incl[1]<-th && incl[0]<-th) return -1;
          break;
       case  1:
          if(incl[4]>+th && incl[3]>+th && incl[2]>+th && incl[1]>+th && incl[0]<+th) return +1;
          if(incl[4]<-th && incl[3]<-th && incl[2]<-th && incl[1]<-th && incl[0]>-th) return -1;
          break;
       case  2:
          if(incl[4]>+th && incl[3]>+th && incl[2]>+th && incl[1]<+th && incl[0]<+th) return +1;
          if(incl[4]<-th && incl[3]<-th && incl[2]<-th && incl[1]<-th && incl[0]<-th) return -1;
          break;
       case  3:
          if(incl[4]>+th && incl[3]>+th && incl[2]<-th && incl[1]<-th && incl[0]<-th) return +1;
          if(incl[4]<-th && incl[3]<-th && incl[2]>+th && incl[1]>+th && incl[0]>+th) return -1;
          break;
       case  4:
          if(incl[4]>+th && incl[3]<-th && incl[2]<-th && incl[1]<-th && incl[0]<-th) return +1;
          if(incl[4]<-th && incl[3]>+th && incl[2]>+th && incl[1]>+th && incl[0]>+th) return -1;
          break;
      }
    return 0;
   }
  

***** code
 //+------------------------------------------------------------------+
 //|                                                    pradapter.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+
 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #define sp "  "


 extern int ntrfivo;
 extern int xitfivo;

 double
 lt=0.1;
 int
 GbarsInchart=0,
 Gtkt=0,
 Gtimeframe=5;

 int OnInit() {return(INIT_SUCCEEDED);}
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {

    if(CanDoTrade(GbarsInchart))
       opn(Gtkt);
    else
       alt(Gtkt);

   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void opn(int &tk)
 //opens a trade via some ntr fn combo
   {
    double
    bstrend=fivonacci(Gtimeframe,ntrfivo);

    if(bstrend>0)
       placeorder(0,tk);
    if(bstrend<0)
       placeorder(1,tk);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void alt(int tk)
 //alters a trade by moving sl,tp or by closing it via some xit fn combo
   {
    bool zz,xit;
    double oo,oc,sl,tp;
    int bs;

    OrderDetails(tk,bs,oo,oc,sl,tp);
    xit=(bs==0 && fivonacci(Gtimeframe,xitfivo)==-1) || (bs==1 && fivonacci(Gtimeframe,xitfivo)==+1);

    if(xit)
       zz=OrderClose(tk,lt,oc,0);
 /*else
       trailer(tk,bs,oo,oc,sl,tp);*/
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int fivonacci(int timeframe,int ratio)
 //enters on contrarian fivonacci
   {
    double incl[5];ArrayInitialize(incl,0);
    int barF=1,barI[5];
    barF=1;barI[0]=5;barI[1]=10;barI[2]=15;barI[3]=25;barI[4]=40;

    for(int i=0;i<5;i++)
       incl[i]=incline(timeframe,barI[i],barF);

    switch(ratio)
      {
       case  0:
          if(incl[4]>0 && incl[3]>0 && incl[2]>0 && incl[1]>0 && incl[0]>0) return +1;
          if(incl[4]<0 && incl[3]<0 && incl[2]<0 && incl[1]<0 && incl[0]<0) return -1;
          break;
       case  1:
          if(incl[4]>0 && incl[3]>0 && incl[2]>0 && incl[1]>0 && incl[0]<0) return +1;
          if(incl[4]<0 && incl[3]<0 && incl[2]<0 && incl[1]<0 && incl[0]>0) return -1;
          break;
       case  2:
          if(incl[4]>0 && incl[3]>0 && incl[2]>0 && incl[1]<0 && incl[0]<0) return +1;
          if(incl[4]<0 && incl[3]<0 && incl[2]<0 && incl[1]>0 && incl[0]>0) return -1;
          break;
       case  3:
          if(incl[4]>0 && incl[3]>0 && incl[2]<0 && incl[1]<0 && incl[0]<0) return +1;
          if(incl[4]<0 && incl[3]<0 && incl[2]>0 && incl[1]>0 && incl[0]>0) return -1;
          break;
       case  4:
          if(incl[4]>0 && incl[3]<0 && incl[2]<0 && incl[1]<0 && incl[0]<0) return +1;
          if(incl[4]<0 && incl[3]>0 && incl[2]>0 && incl[1]>0 && incl[0]>0) return -1;
          break;
      }
    return 0;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int macross(int timeframe,int barI)
 //ntr from price crossings of ma
   {
    double
    maVal=iMA(NULL,timeframe,barI,0,MODE_SMA,PRICE_OPEN,0),
    prLow=iLow(NULL,timeframe,1),
    prClo=iClose(NULL,timeframe,1),
    prHig=iHigh(NULL,timeframe,1);

    if(prLow<maVal && prClo>maVal) return +1;
    if(prHig>maVal && prClo<maVal) return -1;
    return 0;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void placeorder(int bs,int &tk)
 //places buysel order
   {
    double
    sl,tp,oo,
    slpts=500*Point,
    tppts=1*slpts;

    switch(bs)
      {
       case  0:
          oo=Ask;
          sl=oo-slpts;
          tp=oo+tppts;
          break;
       case  1:
          oo=Bid;
          sl=oo+slpts;
          tp=oo-tppts;
          break;
       default:
          oo=0;sl=0;tp=0;
          break;
      }
    RefreshRates();
    tk=OrderSend(Symbol(),bs,lt,oo,0,sl,tp);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double incline(int timeframe,int barI,int barF)
 //calculates slope between barI and barF for a timeframe
   {
    return Dpts(iOpen(NULL,timeframe,barI),iClose(NULL,timeframe,barF))/((barI-barF)+1);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
   {
    return (pF-pI)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void arrmaxmin(double &v[],int &max,int &min)
 //returns largest and smallest of a group of numbers
   {
    max=ArrayMaximum(v);
    min=ArrayMinimum(v);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void maxmin(int timeframe,int barI,int barF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barvalues between barI and barF for a timeframe
   {
    maxbar=iHighest(NULL,timeframe,MODE_HIGH,barI,barF);
    maxval=iHigh(NULL,timeframe,maxbar);
    minbar=iLowest(NULL,timeframe,MODE_LOW,barI,barF);
    minval=iLow(NULL,timeframe,minbar);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int modrand(int divisor)
 //generates random number and mods it with divisor
   {
    return (int)fmod(rand(),divisor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OrderDetails(int tk,int &bs,double &oo,double &oc,double &sl,double &tp)
 //gets open order details into variables
   {
    bool zz=OrderSelect(tk,SELECT_BY_TICKET);

    bs=OrderType();
    oo=OrderOpenPrice();
    oc=OrderClosePrice();
    tp=OrderTakeProfit();
    sl=OrderStopLoss();
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void drawOCtline(string name,int barI,int barF,color acolor)
 //draws a line between two points (barI,priceI) and (barF,priceF)
   {
    datetime
    timeI=iTime(NULL,Gtimeframe,barI),
    timeF=iTime(NULL,Gtimeframe,barF);
    double
    pricI=iOpen(NULL,Gtimeframe,barI),
    pricF=iClose(NULL,Gtimeframe,barF);
    bool
    zz=ObjectDelete(name);
    zz=ObjectCreate(name,OBJ_TREND,0,timeI,pricI,timeF,pricF);
    zz=ObjectSet(name,OBJPROP_RAY,false);
    zz=ObjectSet(name,OBJPROP_COLOR,acolor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void display(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
   {
    ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
    ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
    ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
    ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
    ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool CanDoTrade(int &barsInchart)
 //checks various conditions to see if trade is permitted
   {
    bool
    tradeless=(barsInchart!=Bars);
    double
    spread=MarketInfo(NULL,MODE_SPREAD);
    int
    aords,pords,
    tords=OrdersForSymbol(aords,pords);

    barsInchart=Bars;
    return ((tords==0) && tradeless && (spread<9));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of orders that have been placed for a particular symbol
   {
    for(int pos=OrdersTotal()-1; pos>=0; pos--)
      {
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUYSTOP || OrderType()==OP_SELLSTOP))
          pords++;
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUY || OrderType()==OP_SELL))
          aords++;
      }
    return aords+pords;
   }
 //+------------------------------------------------------------------+
**** xit
 monitoring mii,mai,nu
 1. on initially placed sltp based on maxmin
 2. on first modification sltp when gain > first mod sl
 3. on x% pullback when gain > y*first mod sl?
 4. on minslope of mai

**** version1
 Gtimeframe=1;Glookback=80;Gntrslope=1;Gxitslope=6; -> 3030 150102-151228
 however, these settings produced losses 2012-2013 and only a small gain 2014(?)
 optimizing 2014's biggest loss period, produced over 1100 but with only 9 trades.
 2012 equity was very choppy.

 what all this suggests is that years and therefore smaller time units have characteristics. certain settings seem to work well in certain markets.

 we should make it a project to not to excessively large sltp because these result in essentially random activity even when there are longterm defined trends.

 let's try to optimize in smaller chunks and see if we can identify useful patterns that we can utilize.


 //+------------------------------------------------------------------+
 //|                                                    pradapter.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+
 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #define sp "  "


 extern int     Glookback;
 extern double  Gntrslope;
 extern double  Gxitslope;

 int Gtkt,Gtimeframe;

 int OnInit() {return(INIT_SUCCEEDED);}
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {
    int aords,pords,tords;

    Gtimeframe=1;Glookback=80;Gntrslope=1;Gxitslope=6;

    aords=0;
    pords=0;
    tords=OrdersForSymbol(aords,pords);

    if(tords==0)
       opn(Gtkt);
    else
       alt(Gtkt);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void opn(int &tk)
 //opens a trade
   {
    double lt,oo,sl,tp;
    int bs;
   
    bs=ntrOnInclineValue();
    bsParameters(bs,lt,oo,sl,tp);
    RefreshRates();
    tk=OrderSend(Symbol(),bs,lt,oo,0,sl,tp);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void alt(int tk)
 //alters a trade
   {
    bool zz,xit;
    double v[],oo,oc,sl,tp,lt;
    int bs;

    OrderDetails(tk,bs,oo,oc,sl,tp);
    lt=0.1;
    xit=xitOnInclineValue(bs);

 //zz=OrderModify(tk,oo,sl,tp,0,clrNONE);

    if(xit)
       zz=OrderClose(tk,lt,oc,0);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int ntrOnInclineValue()
 //ntr based on abs incline being greater than Gntrslope
   {
    double inclineV;
   
    inclineV=incline(Gtimeframe,Glookback,1);

    if(inclineV>+Gntrslope)
       return OP_BUY;
    if(inclineV<-Gntrslope)
       return OP_SELL;
    return -1;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool xitOnInclineValue(int bs)
 //determines xit on abs incline being greater than Gxitslope
   {
    double inclineV;
   
    inclineV=incline(Gtimeframe,Glookback,1);
    return ((bs==0 && inclineV<-Gxitslope) || (bs==1 && inclineV>+Gxitslope));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void bsParameters(int bs,double &lt,double &oo,double &sl,double &tp)
 //calculates appropriate lt,oo,sl,tp values depending on bs
   {
    double rrfactor,hi,lo;
   
    rrfactor=5;
    lt=0.1;
   
    hiloValues(Gtimeframe,Glookback,1,hi,lo);

    switch(bs)
      {
       case  0:
          oo=Ask;
          sl=lo;
          tp=oo+rrfactor*Dpts(sl,oo)*Point;
          break;
       case  1:
          oo=Bid;
          sl=hi;
          tp=oo-rrfactor*Dpts(oo,sl)*Point;
          break;
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double incline(int timeframe,int barI,int barF)
 //calculates slope between barI and barF for a timeframe
   {
    int Dbars;
   
    Dbars=(barI-barF)+1;
    return Dpts(iOpen(NULL,timeframe,barI),iClose(NULL,timeframe,barF))/Dbars;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void hiloValues(int timeframe,int barI,int barF,double &hi,double &lo)
 //determines hilo values between barI and barF for a timeframe
   {
    int maxbar,minbar;
    double ptpad,maxval,minval;

    maxmin(timeframe,Glookback,0,maxbar,maxval,minbar,minval);
    ptpad=9*Point;
    hi=maxval+ptpad;
    lo=minval-ptpad;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
   {
    return (pF-pI)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void maxmin(int timeframe,int barI,int barF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barvalues between barI and barF for a timeframe
   {
    maxbar=iHighest(NULL,timeframe,MODE_HIGH,barI,barF);
    maxval=iHigh(NULL,timeframe,maxbar);
    minbar=iLowest(NULL,timeframe,MODE_LOW,barI,barF);
    minval=iLow(NULL,timeframe,minbar);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int modrand(int divisor)
 //generates random number and mods it with divisor
   {
    return (int)fmod(rand(),divisor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OrderDetails(int tk,int &bs,double &oo,double &oc,double &sl,double &tp)
 //gets open order details into variables
   {
    bool zz=OrderSelect(tk,SELECT_BY_TICKET);
    bs=OrderType();
    oo=OrderOpenPrice();
    oc=OrderClosePrice();
    tp=OrderTakeProfit();
    sl=OrderStopLoss();
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void display(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
   {
    ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
    ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
    ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
    ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
    ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of orders that have been placed for a particular symbol
   {
    for(int pos=OrdersTotal()-1; pos>=0; pos--)
      {
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUYSTOP || OrderType()==OP_SELLSTOP))
          pords++;
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUY || OrderType()==OP_SELL))
          aords++;
      }
    return aords+pords;
   }
 //+------------------------------------------------------------------+

**** version2
 rrfactor optimization included too

 Gtimeframe=1;Glookback=100;Gntrslope=2.5;Gxitslope=6.5;rrfactor=8
 -> $3628 150102-151228 and $500 2012,2014 $900 2015
 this is interesting because it suggests that 2015 is a very different year from the others at least as far as its own optimization goes.

 optimizations for
 2012
 443	2296.70	583	1.31	3.94	420.50	4.06%	0.00000000	Glookback=140 	Gntrslope=2 	Gxitslope=1.5 	rrfactor=6	
 463	2238.90	577	1.26	3.88	422.40	3.70%	0.00000000	Glookback=170 	Gntrslope=1 	Gxitslope=1.5 	rrfactor=7	

 2013
 299	2388.90	56	2.21	42.66	674.20	5.17%	0.00000000	Glookback=200 	Gntrslope=1 	Gxitslope=6.5 	rrfactor=3	
 116	2103.30	54	2.15	38.95	643.40	5.13%	0.00000000	Glookback=200 	Gntrslope=1 	Gxitslope=7 	rrfactor=3	
 220	1910.10	75	1.99	25.47	668.20	5.32%	0.00000000	Glookback=200 	Gntrslope=1 	Gxitslope=5.5 	rrfactor=3	
 302	1765.00	14	7.86	126.07	252.70	2.25%	0.00000000	Glookback=170 	Gntrslope=6.5 	Gxitslope=5.5 	rrfactor=3	

 2014
 427	1434.50	18	3.29	79.69	717.30	6.00%	0.00000000	Glookback=190 	Gntrslope=1 	Gxitslope=6 	rrfactor=7	
 458	1255.20	9	3.68	139.47	442.10	3.84%	0.00000000	Glookback=190 	Gntrslope=5.5 	Gxitslope=6 	rrfactor=9	

 //+------------------------------------------------------------------+
 //|                                                    pradapter.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+
 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #define sp "  "


 extern int     Glookback;
 extern double  Gntrslope;
 extern double  Gxitslope;
 extern double  rrfactor;

 int Gtkt,Gtimeframe;

 int OnInit() {return(INIT_SUCCEEDED);}
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {

 Gtimeframe=1;/*Glookback=80;Gntrslope=1;Gxitslope=6;

    if(CanDoTrade())
       opn(Gtkt);
    else
       alt(Gtkt);*/

    drawOCtline("125",125,1,Blue);
    drawOCtline("25",25,1,Green);
    drawOCtline("5",5,1,Red);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void opn(int &tk)
 //opens a trade via some ntr fn combo
   {
    double lt,oo,sl,tp;
    int bs;

    bs=ntrOnInclineValue();
    bsParameters(bs,lt,oo,sl,tp);
    RefreshRates();
    tk=OrderSend(Symbol(),bs,lt,oo,0,sl,tp);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void alt(int tk)
 //alters a trade by moving sl,tp or by closing it via some xit fn combo
   {
    bool zz,xit;
    double oo,oc,sl,tp,lt;
    int bs;

    OrderDetails(tk,bs,oo,oc,sl,tp);
    lt=0.1;
    xit=xitOnInclineValue(bs);

    if(xit)
       zz=OrderClose(tk,lt,oc,0);
    else
       trailer(tk,bs,oo,oc,sl,tp);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void trailer(int tk,int bs,double oo,double oc,double sl,double tp)
 //moves sltp according to price movements
   {
    bool zz;
    double sl1,tp1,ptsmoved,movestep;

    sl1=sl;Comment(oc,sp,tp);
    tp1=tp;
    movestep=100;
    ptsmoved=fabs(Dpts(oo,oc));

    switch(bs)
      {
       case  0:
          sl=oc-movestep*Point;
          if(sl<sl1) sl=sl1;
          break;
       case  1:
          sl=oc+movestep*Point;
          if(sl>sl1) sl=sl1;
          break;
      }

    zz=OrderModify(tk,oo,sl,tp,0,clrNONE);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int ntrOnInclineValue()
 //ntr based on abs incline being greater than Gntrslope
   {
    double inclineV;

    inclineV=incline(Gtimeframe,Glookback,1);

    if(inclineV>+Gntrslope)
       return OP_BUY;
    if(inclineV<-Gntrslope)
       return OP_SELL;
    return -1;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool xitOnInclineValue(int bs)
 //determines xit on abs incline being greater than Gxitslope
   {
    double inclineV;

    inclineV=incline(Gtimeframe,Glookback,1);
    return ((bs==0 && inclineV<-Gxitslope) || (bs==1 && inclineV>+Gxitslope));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void bsParameters(int bs,double &lt,double &oo,double &sl,double &tp)
 //calculates appropriate lt,oo,sl,tp values depending on bs
   {
    double hi,lo;

    rrfactor=6;
    lt=0.1;

    hiloValues(Gtimeframe,Glookback,1,hi,lo);

    switch(bs)
      {
       case  0:
          oo=Ask;
          sl=lo;
          tp=oo+rrfactor*Dpts(sl,oo)*Point;
          break;
       case  1:
          oo=Bid;
          sl=hi;
          tp=oo-rrfactor*Dpts(oo,sl)*Point;
          break;
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double incline(int timeframe,int barI,int barF)
 //calculates slope between barI and barF for a timeframe
   {
    int Dbars;

    Dbars=(barI-barF)+1;
    return Dpts(iOpen(NULL,timeframe,barI),iClose(NULL,timeframe,barF))/Dbars;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void hiloValues(int timeframe,int barI,int barF,double &hi,double &lo)
 //determines hilo values between barI and barF for a timeframe
   {
    int maxbar,minbar;
    double ptpad,maxval,minval;

    maxmin(timeframe,Glookback,0,maxbar,maxval,minbar,minval);
    ptpad=9*Point;
    hi=maxval+ptpad;
    lo=minval-ptpad;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
   {
    return (pF-pI)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void maxmin(int timeframe,int barI,int barF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barvalues between barI and barF for a timeframe
   {
    maxbar=iHighest(NULL,timeframe,MODE_HIGH,barI,barF);
    maxval=iHigh(NULL,timeframe,maxbar);
    minbar=iLowest(NULL,timeframe,MODE_LOW,barI,barF);
    minval=iLow(NULL,timeframe,minbar);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int modrand(int divisor)
 //generates random number and mods it with divisor
   {
    return (int)fmod(rand(),divisor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OrderDetails(int tk,int &bs,double &oo,double &oc,double &sl,double &tp)
 //gets open order details into variables
   {
    bool zz=OrderSelect(tk,SELECT_BY_TICKET);
    bs=OrderType();
    oo=OrderOpenPrice();
    oc=OrderClosePrice();
    tp=OrderTakeProfit();
    sl=OrderStopLoss();
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void drawOCtline(string name,int barI,int barF,color acolor)
 //draws a line between two points (barI,priceI) and (barF,priceF)
   {
    bool zz;
    datetime timeI,timeF;
    double pricI,pricF;

    timeI=iTime(NULL,Gtimeframe,barI);
    timeF=iTime(NULL,Gtimeframe,barF);
    pricI=iOpen(NULL,Gtimeframe,barI);
    pricF=iClose(NULL,Gtimeframe,barF);

    zz=ObjectDelete(name);
    zz=ObjectCreate(name,OBJ_TREND,0,timeI,pricI,timeF,pricF);
    zz=ObjectSet(name,OBJPROP_RAY,false);
    zz=ObjectSet(name,OBJPROP_COLOR,acolor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void display(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
   {
    ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
    ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
    ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
    ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
    ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool CanDoTrade()
 //checks various conditions to see if trade is permitted
   {
    double spread;
    int aords,pords,tords;

    aords=0;
    pords=0;
    tords=OrdersForSymbol(aords,pords);
    spread=MarketInfo(NULL,MODE_SPREAD);

    return ((tords==0) && (spread<9));

   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of orders that have been placed for a particular symbol
   {
    for(int pos=OrdersTotal()-1; pos>=0; pos--)
      {
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUYSTOP || OrderType()==OP_SELLSTOP))
          pords++;
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUY || OrderType()==OP_SELL))
          aords++;
      }
    return aords+pords;
   }
 //+------------------------------------------------------------------+

**** version3
 improved coding

 //+------------------------------------------------------------------+
 //|                                                    pradapter.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+
 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #define sp "  "


 double rrfactor;
 double Gntrth,Gxitth;
 int Gtkt,Gtimeframe,Glb;

 int OnInit() {return(INIT_SUCCEEDED);}
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {

 Gtimeframe=1;Glb=100;Gntrth=2.5;Gxitth=6.5;rrfactor=8;

    if(CanDoTrade())
       opn(Gtkt);
    else
       alt(Gtkt);

    drawOCtline("125",125,1,Blue);
    drawOCtline("25",25,1,Green);
    drawOCtline("5",5,1,Red);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void opn(int &tk)
 //opens a trade via some ntr fn combo
   {
    double lt,oo,sl,tp;
    int bs;

    bs=ntrOnInclineValue(Gtimeframe,Glb,Gntrth);
    bsParameters(Gtimeframe,Glb,bs,lt,oo,sl,tp);
    RefreshRates();
    tk=OrderSend(Symbol(),bs,lt,oo,0,sl,tp);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void alt(int tk)
 //alters a trade by moving sl,tp or by closing it via some xit fn combo
   {
    bool zz,xit;
    double oo,oc,sl,tp,lt;
    int bs;

    OrderDetails(tk,bs,oo,oc,sl,tp);
    lt=0.1;
    xit=xitOnInclineValue(Gtimeframe,bs,Glb,Gxitth);

    if(xit)
       zz=OrderClose(tk,lt,oc,0);
    /*else
       trailer(tk,bs,oo,oc,sl,tp);*/
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void trailer(int tk,int bs,double oo,double oc,double sl,double tp)
 //moves sltp according to price movements
   {
    bool zz;
    double sl1,tp1,ptsmoved,movestep;

    sl1=sl;Comment(oc,sp,tp);
    tp1=tp;
    movestep=100;
    ptsmoved=fabs(Dpts(oo,oc));

    switch(bs)
      {
       case  0:
          sl=oc-movestep*Point;
          if(sl<sl1) sl=sl1;
          break;
       case  1:
          sl=oc+movestep*Point;
          if(sl>sl1) sl=sl1;
          break;
      }

    zz=OrderModify(tk,oo,sl,tp,0,clrNONE);
   }
 int ntrInclineInteraction(int timeframe,int lb1,double th1,int lb2,double th2,int lb3,double th3)
 //determines entry from relation of inclines of various lookbacks
 {
    double in1,in2,in3;
    int bar1;
   
    bar1=1;
    in1=incline(timeframe,lb1,bar1);
    in2=incline(timeframe,lb2,bar1);
    in3=incline(timeframe,lb3,bar1);
   
   
    if((in3>+th3) && (in2>+th2) && (in1<-th1)) return 0;
    if((in3<-th3) && (in2<-th2) && (in1>+th1)) return 1;
    return -1;
 }
 bool xitInclineInteraction(int bs,int timeframe,int lb1,double th1,int lb2,double th2,int lb3,double th3)
 //
 {
    double in1,in2,in3;
    int bar1;
   
    bar1=1;
    in1=incline(timeframe,lb1,bar1);
    in2=incline(timeframe,lb2,bar1);
    in3=incline(timeframe,lb3,bar1);
   
   
    if((bs==0) && (in2<+th2) && (in1<+th1)) return true;
    if((bs==1) && (in2>-th2) && (in1>-th1)) return true;
    return false;
 }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int ntrOnInclineValue(int timeframe,int lb,double th)
 //ntr based on abs incline being greater than Gntrslope
   {
    double inclineV;

    inclineV=incline(timeframe,lb,1);

    if(inclineV>+th)
       return OP_BUY;
    if(inclineV<-th)
       return OP_SELL;
    return -1;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool xitOnInclineValue(int timeframe,int bs,int lb,double th)
 //determines xit on abs incline being greater than Gxitslope
   {
    double inclineV;

    inclineV=incline(timeframe,lb,1);
    return ((bs==0 && inclineV<-th) || (bs==1 && inclineV>+th));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void bsParameters(int timeframe,int lb,int bs,double &lt,double &oo,double &sl,double &tp)
 //calculates appropriate lt,oo,sl,tp values depending on bs
   {
    double hi,lo;

    lt=0.1;

    hiloValues(timeframe,lb,1,hi,lo);

    switch(bs)
      {
       case  0:
          oo=Ask;
          sl=lo;
          tp=oo+rrfactor*Dpts(sl,oo)*Point;
          break;
       case  1:
          oo=Bid;
          sl=hi;
          tp=oo-rrfactor*Dpts(oo,sl)*Point;
          break;
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double incline(int timeframe,int barI,int barF)
 //calculates slope between barI and barF for a timeframe
   {
    int Dbars;

    Dbars=(barI-barF)+1;
    return Dpts(iOpen(NULL,timeframe,barI),iClose(NULL,timeframe,barF))/Dbars;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void hiloValues(int timeframe,int barI,int barF,double &hi,double &lo)
 //determines hilo values between barI and barF for a timeframe
   {
    int maxbar,minbar;
    double ptpad,maxval,minval;

    maxmin(timeframe,Glb,0,maxbar,maxval,minbar,minval);
    ptpad=9*Point;
    hi=maxval+ptpad;
    lo=minval-ptpad;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
   {
    return (pF-pI)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void maxmin(int timeframe,int barI,int barF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barvalues between barI and barF for a timeframe
   {
    maxbar=iHighest(NULL,timeframe,MODE_HIGH,barI,barF);
    maxval=iHigh(NULL,timeframe,maxbar);
    minbar=iLowest(NULL,timeframe,MODE_LOW,barI,barF);
    minval=iLow(NULL,timeframe,minbar);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int modrand(int divisor)
 //generates random number and mods it with divisor
   {
    return (int)fmod(rand(),divisor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OrderDetails(int tk,int &bs,double &oo,double &oc,double &sl,double &tp)
 //gets open order details into variables
   {
    bool zz=OrderSelect(tk,SELECT_BY_TICKET);
    bs=OrderType();
    oo=OrderOpenPrice();
    oc=OrderClosePrice();
    tp=OrderTakeProfit();
    sl=OrderStopLoss();
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void drawOCtline(string name,int barI,int barF,color acolor)
 //draws a line between two points (barI,priceI) and (barF,priceF)
   {
    bool zz;
    datetime timeI,timeF;
    double pricI,pricF;

    timeI=iTime(NULL,Gtimeframe,barI);
    timeF=iTime(NULL,Gtimeframe,barF);
    pricI=iOpen(NULL,Gtimeframe,barI);
    pricF=iClose(NULL,Gtimeframe,barF);

    zz=ObjectDelete(name);
    zz=ObjectCreate(name,OBJ_TREND,0,timeI,pricI,timeF,pricF);
    zz=ObjectSet(name,OBJPROP_RAY,false);
    zz=ObjectSet(name,OBJPROP_COLOR,acolor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void display(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
   {
    ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
    ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
    ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
    ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
    ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool CanDoTrade()
 //checks various conditions to see if trade is permitted
   {
    double spread;
    int aords,pords,tords;

    aords=0;
    pords=0;
    tords=OrdersForSymbol(aords,pords);
    spread=MarketInfo(NULL,MODE_SPREAD);

    return ((tords==0) && (spread<9));

   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of orders that have been placed for a particular symbol
   {
    for(int pos=OrdersTotal()-1; pos>=0; pos--)
      {
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUYSTOP || OrderType()==OP_SELLSTOP))
          pords++;
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUY || OrderType()==OP_SELL))
          aords++;
      }
    return aords+pords;
   }
 //+------------------------------------------------------------------+

**** version4
 split with mqh and intro of InclineInteraction
 //+------------------------------------------------------------------+
 //|                                                    pradapter.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+
 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #define sp "  "

 #include "std.mqh"
 #include "ntrxit.mqh"

 extern double rrfactor,Gntrgate1,Gntrgate2,Gntrgate3,Gxitgate1,Gxitgate2,Gxitgate3;

 double Gntrgate[4],Gxitgate[4];
 int Gtkt,Gtimeframe,GbarI[4];

 int OnInit() {return(INIT_SUCCEEDED);}
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {
    Gtimeframe=1;
    GbarI[1]=5;GbarI[2]=25;GbarI[3]=125;
    Gntrgate[1]=Gntrgate1;Gntrgate[2]=Gntrgate2;Gntrgate[3]=Gntrgate3;
    Gxitgate[1]=Gxitgate1;Gxitgate[2]=Gxitgate2;Gxitgate[3]=Gxitgate3;


   /* if(CanDoTrade())
       opn(Gtkt);
    else
       alt(Gtkt);*/

    drawOCtline("125",125,1,Blue);
    drawOCtline("25",25,1,Green);
    drawOCtline("5",5,1,Red);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void opn(int &tk)
 //opens a trade via some ntr fn combo
   {
    double lt,oo,sl,tp;
    int bs;

    bs=ntrInclineInteraction(Gtimeframe,GbarI,Gntrgate);
    bsParameters(Gtimeframe,GbarI[2],1,bs,lt,oo,sl,tp);
    RefreshRates();
    tk=OrderSend(Symbol(),bs,lt,oo,0,sl,tp);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void alt(int tk)
 //alters a trade by moving sl,tp or by closing it via some xit fn combo
   {
    bool zz,xit;
    double oo,oc,sl,tp,lt;
    int bs;

    OrderDetails(tk,bs,oo,oc,sl,tp);
    lt=0.1;
    xit=xitInclineInteraction(Gtimeframe,bs,GbarI,Gxitgate);

    if(xit)
       zz=OrderClose(tk,lt,oc,0);
 /*else
       trailer(tk,bs,oo,oc,sl,tp);*/
   }

 //+------------------------------------------------------------------+

 //+------------------------------------------------------------------+
 //|                                                          std.mqh |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+
 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property strict

 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void bsParameters(int timeframe,int barI,int barF,int bs,double &lt,double &oo,double &sl,double &tp)
 //calculates appropriate lt,oo,sl,tp values depending on bs
   {
    double hi,lo;
   
    lt=0.1;

    hiloValues(timeframe,barI,barF,hi,lo);

    switch(bs)
      {
       case  0:
          oo=Ask;
          sl=lo;
          tp=oo+rrfactor*Dpts(sl,oo)*Point;
          break;
       case  1:
          oo=Bid;
          sl=hi;
          tp=oo-rrfactor*Dpts(oo,sl)*Point;
          break;
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double incline(int timeframe,int barI,int barF)
 //calculates slope between barI and barF for a timeframe
   {
    int Dbars;

    Dbars=(barI-barF)+1;
    return Dpts(iOpen(NULL,timeframe,barI),iClose(NULL,timeframe,barF))/Dbars;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void hiloValues(int timeframe,int barI,int barF,double &hi,double &lo)
 //determines hilo values between barI and barF for a timeframe
   {
    int maxbar,minbar;
    double ptpad,maxval,minval;

    maxmin(timeframe,barI,barF,maxbar,maxval,minbar,minval);
    ptpad=9*Point;
    hi=maxval+ptpad;
    lo=minval-ptpad;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
   {
    return (pF-pI)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void maxmin(int timeframe,int barI,int barF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barvalues between barI and barF for a timeframe
   {
    maxbar=iHighest(NULL,timeframe,MODE_HIGH,barI,barF);
    maxval=iHigh(NULL,timeframe,maxbar);
    minbar=iLowest(NULL,timeframe,MODE_LOW,barI,barF);
    minval=iLow(NULL,timeframe,minbar);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int modrand(int divisor)
 //generates random number and mods it with divisor
   {
    return (int)fmod(rand(),divisor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OrderDetails(int tk,int &bs,double &oo,double &oc,double &sl,double &tp)
 //gets open order details into variables
   {
    bool zz=OrderSelect(tk,SELECT_BY_TICKET);
    bs=OrderType();
    oo=OrderOpenPrice();
    oc=OrderClosePrice();
    tp=OrderTakeProfit();
    sl=OrderStopLoss();
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void drawOCtline(string name,int barI,int barF,color acolor)
 //draws a line between two points (barI,priceI) and (barF,priceF)
   {
    bool zz;
    datetime timeI,timeF;
    double pricI,pricF;

    timeI=iTime(NULL,Gtimeframe,barI);
    timeF=iTime(NULL,Gtimeframe,barF);
    pricI=iOpen(NULL,Gtimeframe,barI);
    pricF=iClose(NULL,Gtimeframe,barF);

    zz=ObjectDelete(name);
    zz=ObjectCreate(name,OBJ_TREND,0,timeI,pricI,timeF,pricF);
    zz=ObjectSet(name,OBJPROP_RAY,false);
    zz=ObjectSet(name,OBJPROP_COLOR,acolor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void display(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
   {
    ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
    ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
    ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
    ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
    ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool CanDoTrade()
 //checks various conditions to see if trade is permitted
   {
    double spread;
    int aords,pords,tords;

    aords=0;
    pords=0;
    tords=OrdersForSymbol(aords,pords);
    spread=MarketInfo(NULL,MODE_SPREAD);

    return ((tords==0) && (spread<9));

   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of orders that have been placed for a particular symbol
   {
    for(int pos=OrdersTotal()-1; pos>=0; pos--)
      {
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUYSTOP || OrderType()==OP_SELLSTOP))
          pords++;
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUY || OrderType()==OP_SELL))
          aords++;
      }
    return aords+pords;
   }

 //+------------------------------------------------------------------+
 //|                                                       ntrxit.mqh |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+
 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property strict

 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int ntrInclineInteraction(int timeframe,int &barI[],double &gate[])
 //determines entry from relation of inclines of various lookbacks
   {
    double incline[4];ArrayInitialize(incline,0);
    int barF;

    barF=1;
    for(int i=1;i<4;i++)
       incline[i]=incline(timeframe,barI[i],barF);

    if((incline[3]>+gate[3]) && (incline[2]>+gate[2]) && (incline[1]<-gate[1])) return 0;
    if((incline[3]<-gate[3]) && (incline[2]<-gate[2]) && (incline[1]>+gate[1])) return 1;
    return -1;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool xitInclineInteraction(int timeframe,int bs,int &barI[],double &gate[])
 //
   {
    double incline[4];ArrayInitialize(incline,0);
    int barF;

    barF=1;
    for(int i=1;i<4;i++)
       incline[i]=incline(timeframe,barI[i],barF);


    if((bs==0) && (incline[2]<+gate[3])) return true;
    if((bs==1) && (incline[2]>-gate[3])) return true;
    return false;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int ntrOnInclineValue(int timeframe,int barI,int barF,double gate)
 //ntr based on abs incline being greater gatean Gntrslope
   {
    double inclineV;

    inclineV=incline(timeframe,barI,barF);

    if(inclineV>+gate)
       return OP_BUY;
    if(inclineV<-gate)
       return OP_SELL;
    return -1;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool xitOnInclineValue(int timeframe,int bs,int barI,int barF,double gate)
 //determines xit on abs incline being greater gatean Gxitslope
   {
    double inclineV;

    inclineV=incline(timeframe,barI,barF);
    return ((bs==0 && inclineV<-gate) || (bs==1 && inclineV>+gate));
   }
 //+------------------------------------------------------------------+

**** vindicator
 tries to use tickvity, but not doing too well yet
 //+------------------------------------------------------------------+
 //|                                                    pradapter.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+
 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #define sp "  "


 double GprvPri=0,Gacc=0;

 int
 GbarsInchart=0,
 GbarF=1,
 Gtkt=0,

 Gtimeframe=5;

 int OnInit() {return(INIT_SUCCEEDED);}
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {
  
    vindicator(GprvPri,Gacc);

    /*if(CanDoTrade(GbarsInchart))
       opn(Gtkt);
    else
       alt(Gtkt);*/
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void opn(int &tk)
 //opens a trade via some ntr fn combo
   {
    int vind=0;
    if(vind==+1)
       placebuysel(OP_BUY,tk);
    if(vind==-1)
       placebuysel(OP_SELL,tk);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void alt(int tk)
 //alters a trade by moving sl,tp or by closing it via some xit fn combo
   {

    bool zz,xit=false;
    double oo,oc,sl,tp,lt;
    int bs;

    OrderDetails(tk,bs,oo,oc,sl,tp);
    lt=0.1;

    if(xit)
       zz=OrderClose(tk,lt,oc,0);
    else
       trailer(tk,bs,oo,oc,sl,tp);
   }
 //
 //
 //
 //
 //
 //+------------------------------------------------------------------+
 //|     NTRXIT                                                       |
 //+------------------------------------------------------------------+
 //
 void vindicator(double &prvPri,double &acc)
 //checks atickvity
 {
    double Dprvprs,prsPri=Bid;
   
    if(prvPri==0) prvPri=prsPri;
    Dprvprs=Dpts(prvPri,prsPri);
   
    acc+=Dprvprs;
   
    Comment(prvPri,sp,prsPri,sp,Dprvprs,sp,acc);
   
    prvPri=prsPri;
 }
 int nu(int timeframe)
 //ntr on nu when incline sufficiently steep
   {
    double mid[4];ArrayInitialize(mid,0);
    bool n,u;

    for(int i=0;i<4;i++)
       mid[i]=(High[i]+Low[i])/2;

    u=u(mid[3],mid[2],mid[1]);
    n=n(mid[3],mid[2],mid[1]);

    if(u) return +1;
    if(n) return -1;
    return 0;
   }
 //
 //
 //
 //+------------------------------------------------------------------+
 //|        Commonly Used Functions                                   |
 //+------------------------------------------------------------------+
 //
 void trailer(int tk,int bs,double oo,double oc,double sl,double tp)
 //manages sltp dynamics
   {
    double
    Doooc=Dpts(oo,oc);
    Comment(Doooc);
    switch(bs)
      {
       case  0:
          if(Doooc>+50) sl=oo+40*Point;
          break;
       case  1:
          if(Doooc<-50) sl=oo-40*Point;
          break;
      }
    bool zz=OrderModify(tk,oc,sl,tp,0,clrNONE);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void placebuysel(int bs,int &tk)
 //places buysel order with sltp
   {
    double oo,sl,tp,
    pad=55*Point,
    lt=0.1;

    RefreshRates();
    switch(bs)
      {
       case  0:
          oo=Ask;
          sl=oo-pad;
          tp=oo+5*pad;
          break;
       case  1:
          oo=Bid;
          sl=oo+pad;
          tp=oo-5*pad;
          break;
       default:
          return;
      }
    tk=OrderSend(Symbol(),bs,lt,oo,0,sl,tp);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool n(double v3,double v2,double v1)
 //determines n
   {
    return (v3<v2 && v2>v1);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool u(double v3,double v2,double v1)
 //determines u
   {
    return (v3>v2 && v2<v1);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double incline(int timeframe,int barI,int barF)
 //calculates slope between barI and barF for a timeframe
   {
    return Dpts(iOpen(NULL,timeframe,barI),iClose(NULL,timeframe,barF))/((barI-barF)+1);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double pI,double pF)
 //difference between two prices pF-pI in points
   {
    return (pF-pI)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void arrmaxmin(double &v[],int &max,int &min)
 //returns largest and smallest of a group of numbers
   {
    max=ArrayMaximum(v);
    min=ArrayMinimum(v);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void maxmin(int timeframe,int barI,int barF,int &maxbar,double &maxval,int &minbar,double &minval)
 //calculates maxmin barnumbers and barvalues between barI and barF for a timeframe
   {
    maxbar=iHighest(NULL,timeframe,MODE_HIGH,barI,barF);
    maxval=iHigh(NULL,timeframe,maxbar);
    minbar=iLowest(NULL,timeframe,MODE_LOW,barI,barF);
    minval=iLow(NULL,timeframe,minbar);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int modrand(int divisor)
 //generates random number and mods it with divisor
   {
    return (int)fmod(rand(),divisor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OrderDetails(int tk,int &bs,double &oo,double &oc,double &sl,double &tp)
 //gets open order details into variables
   {
    bool zz=OrderSelect(tk,SELECT_BY_TICKET);

    bs=OrderType();
    oo=OrderOpenPrice();
    oc=OrderClosePrice();
    tp=OrderTakeProfit();
    sl=OrderStopLoss();
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void drawOCtline(string name,int barI,int barF,color acolor)
 //draws a line between two points (barI,priceI) and (barF,priceF)
   {
    datetime
    timeI=iTime(NULL,Gtimeframe,barI),
    timeF=iTime(NULL,Gtimeframe,barF);
    double
    pricI=iOpen(NULL,Gtimeframe,barI),
    pricF=iClose(NULL,Gtimeframe,barF);
    bool
    zz=ObjectDelete(name);
    zz=ObjectCreate(name,OBJ_TREND,0,timeI,pricI,timeF,pricF);
    zz=ObjectSet(name,OBJPROP_RAY,false);
    zz=ObjectSet(name,OBJPROP_COLOR,acolor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void display(string objlabel,string objtext,int refcorner,int xcoord,int ycoord,int objcolor)
 //displays items on screen according to specifications
   {
    ObjectCreate(objlabel,OBJ_LABEL,0,0,0);// Creating obj.
    ObjectSet(objlabel,OBJPROP_CORNER,refcorner);    // Reference corner
    ObjectSet(objlabel,OBJPROP_XDISTANCE,xcoord);// X coordinate
    ObjectSet(objlabel,OBJPROP_YDISTANCE,ycoord);// Y coordinate
    ObjectSetText(objlabel,objtext,10,"Courier",objcolor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 bool CanDoTrade(int &barsInchart)
 //checks various conditions to see if trade is permitted
   {
    bool
    tradeless=(barsInchart!=Bars);
    double
    spread=MarketInfo(NULL,MODE_SPREAD);
    int
    aords,pords,
    tords=OrdersForSymbol(aords,pords);

    barsInchart=Bars;
    return ((tords==0) && tradeless && (spread<9));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OrdersForSymbol(int &aords,int &pords)
 //calculates number of orders that have been placed for a particular symbol
   {
    for(int pos=OrdersTotal()-1; pos>=0; pos--)
      {
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUYSTOP || OrderType()==OP_SELLSTOP))
          pords++;
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUY || OrderType()==OP_SELL))
          aords++;
      }
    return aords+pords;
   }
 //+------------------------------------------------------------------+

*** viamc
 uses array logic to determine ntralt

*** indcombo
**** v1 gets 22134 for apr9 then goes downhill
 //+------------------------------------------------------------------+
 //|                                                    indcombo.mq4 |
 //|                                           Copyright 2015, prader |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+
 #property copyright "Copyright 2015, prader"
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict


 /*
 combination of indicators working in coordination
 */


 //common variables with set values
 extern double   LOTSIZ=1.0;
 extern int      TIMFRA=PERIOD_M30; 

 int tkt=0, MXORDS=1, MXBARS=0, LEV=0, MN=666, SLTP=6000;

 bool os, oc, oB, oS;


 /*
 double   mahpos[60],mahslo[60],mahacc[60],mampos[60],mamslo[60],mamacc[60],malpos[60],malslo[60],malacc[60],
          osmpos[60],osmslo[60],osmacc[60],rsipos[60],rsislo[60],rsiacc[60],
          loch[4,60];
 */

 //int fh=FileOpen("ttt.txt",FILE_READ | FILE_WRITE | FILE_TXT);
 //FileSeek(fh,0,SEEK_END);FileWrite(fh,maslo/Point);
 //FileClose(fh);

 int Oninit() {return(INIT_SUCCEEDED);}
 void OnDeinit(const int reason) {}


 void OnTick()
 {
    bool  canntr = (MXBARS!=iBars(NULL,TIMFRA) && OrdersforSymbol()!=MXORDS),
          canalt = (OrdersforSymbol()==MXORDS);
         
    if (canntr) //minimum conditions for entering are present
     {
       ind("ntr");
       MXBARS=iBars(NULL,TIMFRA);
     }
    if (canalt) //modification of trade is possible
     {
       ind("alt");
       MXBARS=iBars(NULL,TIMFRA);
     }   
 }


 void ind(string choice)
 //indicators to determine ntralt
 {
    if (choice=="ntr")
     {   
       bool  nB = (mas("n",6)=="B" && rvi("n")=="B"),
             nS = (mas("n",6)=="S" && rvi("n")=="S");

       if (nB)
          tkt=OrderSend(Symbol(),0,LOTSIZ,Ask,0,Ask-SLTP*Point,Ask+SLTP*Point,NULL,MN,0,Blue);
       if (nS)
          tkt=OrderSend(Symbol(),1,LOTSIZ,Bid,0,Bid+SLTP*Point,Bid-SLTP*Point,NULL,MN,0,Red);
     }
   
    if (choice=="alt")
     {
       os = OrderSelect(tkt,SELECT_BY_TICKET);
       oB = (OrderType()==0);
       oS = (OrderType()==1);      
      
       bool  xB = (rvi("n")=="S"),
             xS = (rvi("n")=="B");

       if ((oB && xB) || (oS && xS)) oc = OrderClose(tkt,LOTSIZ,OrderClosePrice(),0,Orange);
       //if (xB || xS) oc = OrderClose(tkt,LOTSIZ,OrderClosePrice(),0,Orange);
     }
 }



 ///////////////////////////////////////////

 string mas(string nx, int p)
 //indication from moving average slope
 {
    double   ma1 = iMA(NULL,TIMFRA,p,0,3,6,1),
             ma2 = iMA(NULL,TIMFRA,p,0,3,6,2),
             ma3 = iMA(NULL,TIMFRA,p,0,3,6,3);
    if (nx=="n")
     {
       if (ma1>ma2 && ma2>ma3) return "B";
       if (ma1<ma2 && ma2<ma3) return "S";
     }
    
    if(nx=="x")
     {
      
     }
    return "";
 }


 string rvi(string nx)
 //indication from rvi
 {
    double   grn = iRVI(NULL,TIMFRA,6,MODE_MAIN,0),
             red = iRVI(NULL,TIMFRA,6,MODE_SIGNAL,0);
            
    if(nx=="n")
      {
       if (grn>red && grn>0 && red>0) return "B";
       if (grn<red && grn<0 && red<0) return "S";    
      }
    if(nx=="x")
      {
       if ((oB && grn<red) || 
           (oS && grn>red)
          )  
           return "X";
      }
    return "";
   
 }


 string osma()
 //indication from osma
 {
    double   os1 = iOsMA(NULL,TIMFRA,12,24,6,6,1),
             os2 = iOsMA(NULL,TIMFRA,12,24,6,6,2),
             os3 = iOsMA(NULL,TIMFRA,12,24,6,6,3);
            
    if (os3<0 && os1>0) return "B";
    if (os3>0 && os1<0) return "S";
    return "";
   
 }


 string cci()
 //indication for xit from cci
 {
    double   xB = (iCCI(NULL,TIMFRA,12,6,2)>100 && iCCI(NULL,TIMFRA,12,6,0)<100),
             xS = (iCCI(NULL,TIMFRA,12,6,2)<-100 && iCCI(NULL,TIMFRA,12,6,0)>-100);
            
    if ((oB && xB) || (oS && xS)) return "X";
    else return "";
 }


 string rsi()
 //indication for xit from rsi
 {
    double   LB = 80.0,
             LS = 100-LB;         
    bool     xB = (iRSI(NULL,TIMFRA,12,6,3)>LB && iRSI(NULL,TIMFRA,12,6,0)<LB),
             xS = (iRSI(NULL,TIMFRA,12,6,3)<LS && iRSI(NULL,TIMFRA,12,6,0)>LS);
   
    if ((oB && xB) || (oS && xS)) return "X";
    else return "";
 }



 bool prolos(int pro, int los)
 //determine whether profit or loss amount has been exceeded with pro> and los<
 {
    if (OrderProfit()>pro || OrderProfit()<los) return true; 
    else return false;
 }


 int OrdersforSymbol()
 //calculates number of orders that have been placed for a particular symbol
 {
    int count=0,pos;
    for(pos = OrdersTotal()-1; pos >= 0 ; pos--) 
       if (OrderSelect(pos, SELECT_BY_POS) && OrderSymbol()==Symbol())
          count++;
    return(count);
 }

**** v2 with maslope0 at 18 gets 18503
 //+------------------------------------------------------------------+
 //|                                                    indcombo.mq4 |
 //|                                           Copyright 2015, prader |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+
 #property copyright "Copyright 2015, prader"
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict


 /*
 combination of indicators working in coordination
 */


 //common variables with set values
 extern double   LOTSIZ=1.0;
 extern int      TIMFRA=PERIOD_M30; 

 int tkt=0, MXORDS=1, MXBARS=0, LEV=0, MN=666, SLTP=6000;

 bool os, oc, oB, oS;
 double h=0,l=0,c=0;

 /*
 double   mahpos[60],mahslo[60],mahacc[60],mampos[60],mamslo[60],mamacc[60],malpos[60],malslo[60],malacc[60],
          osmpos[60],osmslo[60],osmacc[60],rsipos[60],rsislo[60],rsiacc[60],
          loch[4,60];
 */

 //int fh=FileOpen("ttt.txt",FILE_READ | FILE_WRITE | FILE_TXT);
 //FileSeek(fh,0,SEEK_END);FileWrite(fh,maslo/Point);
 //FileClose(fh);

 int Oninit() {return(INIT_SUCCEEDED);}
 void OnDeinit(const int reason) {}


 void OnTick()
 {
    bool  canntr = (MXBARS!=iBars(NULL,TIMFRA) && OrdersforSymbol()!=MXORDS),
          canalt = (OrdersforSymbol()==MXORDS);
         
    if (canntr) //minimum conditions for entering are present
     {
       ind("ntr");
       MXBARS=iBars(NULL,TIMFRA);
     }
    if (canalt) //modification of trade is possible
     {
       ind("alt");
       MXBARS=iBars(NULL,TIMFRA);
     }   
 }


 void ind(string choice)
 //indicators to determine ntralt
 {
    if (choice=="ntr")
     {
       int zero=18;
       bool  nB = (!maslope0(zero) && osma()=="B"),
             nS = (!maslope0(zero) && osma()=="S");

       if (nB)
          tkt=OrderSend(Symbol(),0,LOTSIZ,Ask,0,Ask-SLTP*Point,Ask+SLTP*Point,NULL,MN,0,Blue);
       if (nS)
          tkt=OrderSend(Symbol(),1,LOTSIZ,Bid,0,Bid+SLTP*Point,Bid-SLTP*Point,NULL,MN,0,Red);
     }
   
    if (choice=="alt")
     {
       os = OrderSelect(tkt,SELECT_BY_TICKET);
       oB = (OrderType()==0);
       oS = (OrderType()==1);      
      
       bool  xB = (osma()=="S"),
             xS = (osma()=="B");

       if ((oB && xB) || (oS && xS)) oc = OrderClose(tkt,LOTSIZ,OrderClosePrice(),0,Orange);
       //if (xB || xS) oc = OrderClose(tkt,LOTSIZ,OrderClosePrice(),0,Orange);
     }
 }



 ///////////////////////////////////////////

 bool maslope0(int points)
 //moving average slope is close to 0
 {
    int candles=6, maperiod=6;
   
    for(int i=1;i<=candles;i++)
      {
       c = iMA(NULL,TIMFRA,maperiod,0,3,6,i);
       if (c>h) h=c;
       if (c<l) l=c;
      }
    if ((h-c)<points*Point) return true;
    else return false;
 }

 string mas(string nx, int p)
 //indication from moving average slope
 {
    double   ma1 = iMA(NULL,TIMFRA,p,0,3,6,1),
             ma2 = iMA(NULL,TIMFRA,p,0,3,6,2),
             ma3 = iMA(NULL,TIMFRA,p,0,3,6,3);

    if (nx=="n")
     {
       if (ma1>ma2 && ma2>ma3) return "B";
       if (ma1<ma2 && ma2<ma3) return "S";
     }    
    if(nx=="x")
     {
       double epsilon = 18*Point;
       bool zero = ((ma1-ma2)<epsilon);
       if (zero) return "X";
     }
    return "";
 }


 string rvi(string nx)
 //indication from rvi
 {
    double   grn = iRVI(NULL,TIMFRA,6,MODE_MAIN,0),
             red = iRVI(NULL,TIMFRA,6,MODE_SIGNAL,0);
            
    if(nx=="n")
      {
       if (grn>red && grn>0 && red>0) return "B";
       if (grn<red && grn<0 && red<0) return "S";    
      }
    if(nx=="x")
      {
       if ((oB && grn<red) || 
           (oS && grn>red)
          )  
           return "X";
      }
    return "";
   
 }


 string osma()
 //indication from osma
 {
    double   os1 = iOsMA(NULL,TIMFRA,12,26,9,6,1),
             os2 = iOsMA(NULL,TIMFRA,12,26,9,6,2),
             os3 = iOsMA(NULL,TIMFRA,12,26,9,6,3),
             os4 = iOsMA(NULL,TIMFRA,12,26,9,6,4),
             os5 = iOsMA(NULL,TIMFRA,12,26,9,6,5);

    if (os5>os4 && os4>os3 && os3<os2 && os2<os1) return "B";
    if (os5<os4 && os4<os3 && os3>os2 && os2>os1) return "S";
    return "";
   
 }


 string cci()
 //indication for xit from cci
 {
    double   xB = (iCCI(NULL,TIMFRA,12,6,2)>100 && iCCI(NULL,TIMFRA,12,6,0)<100),
             xS = (iCCI(NULL,TIMFRA,12,6,2)<-100 && iCCI(NULL,TIMFRA,12,6,0)>-100);
            
    if ((oB && xB) || (oS && xS)) return "X";
    else return "";
 }


 string rsi()
 //indication for xit from rsi
 {
    double   LB = 80.0,
             LS = 100-LB;         
    bool     xB = (iRSI(NULL,TIMFRA,12,6,3)>LB && iRSI(NULL,TIMFRA,12,6,0)<LB),
             xS = (iRSI(NULL,TIMFRA,12,6,3)<LS && iRSI(NULL,TIMFRA,12,6,0)>LS);
   
    if ((oB && xB) || (oS && xS)) return "X";
    else return "";
 }



 bool prolos(int pro, int los)
 //determine whether profit or loss amount has been exceeded with pro> and los<
 {
    if (OrderProfit()>pro || OrderProfit()<los) return true; 
    else return false;
 }


 int OrdersforSymbol()
 //calculates number of orders that have been placed for a particular symbol
 {
    int count=0,pos;
    for(pos = OrdersTotal()-1; pos >= 0 ; pos--) 
       if (OrderSelect(pos, SELECT_BY_POS) && OrderSymbol()==Symbol())
          count++;
    return(count);
 }
*** tickbouncer
 look at priceaction code
 figure out how it works
 try to simplify repetitious parts of code
*** xonerate
 use xr zones for entry between local sr keeping tight sl
 setup zone with maxmin for nbars
 trade from the edges 
 - increases chances of local impetus
 - decreases sl
 - decreases number of trades
 - rentry utilizes bounsr
 - xentry utilizes penesr

 rules
 - if zone sufficient
   - if slope significant
     - rentry from slopposite edge of zone
     - xentry when zone is cleared 
   - else
     - rentry from slopposite edge of zone

 vary parameters according to volatility?
**** xonerate code
 //+------------------------------------------------------------------+
 //|                                                     xonerate.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+
 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict

 /*

 */

 int      Rtkt,Xtkt,tifr=1;
 double   lots=0.1;
 bool     zz;

 int OnInit() {return(INIT_SUCCEEDED);}
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {
    int aords=0,pords=0,ords=ordersforsymbol(aords,pords);;
    double hi=0,lo=0;

   

 if(ords==0)
      {
       Rtkt=0;Xtkt=0;
       xoner(hi,lo);
       popn(Rtkt,Xtkt,hi,lo);
      }
    else
      {
       if(Rtkt!=0) alt(Rtkt);
       if(Xtkt!=0) alt(Xtkt);
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void popn(int &Rtk,int &Xtk,double hi,double lo)
 //opens pending orders
   {
    int bs=-1,lev=0;
    double sl=10*Point,tp=10*Point,op=0;
    bool
    buy,
    sel;

    if(buy) bs=0;
    if(sel) bs=1;

    switch(bs)
      {
       case  0:
          op=Ask;
          sl=Ask-sl;
          tp=Ask+tp;
          break;
       case  1:
          op=Bid;
          sl=Bid+sl;
          tp=Bid-tp;
          break;
      }

    tk=OrderSend(Symbol(),bs,lots,op,lev,sl,tp);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void alt(int tk)
 //alters the trade
   {
    zz=OrderSelect(tk,SELECT_BY_TICKET);
    int bs=OrderType();
    double
    oop=OrderOpenPrice(),
    ocp=OrderClosePrice(),
    tp=OrderTakeProfit(),
    sl=OrderStopLoss();
 /*   bool xit=();

    if(xit)
       zz=OrderClose(tk,lots,ocp,0);
   }*/
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void xoner(double &hi,double &lo)
 //establishs the zone
   {
    int nbars=20;
    nu(nbars,tifr,hi,lo);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double p2,double p1)
 //difference between two prices p2-p1 in points
   {
    return (p2-p1)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void nu(int bars,int timeframe,double &hi,double &lo)
 //finds n peak
   {
    int chk,barsORG=bars;
    bool nfound=false,ufound=false;
    double b00,br2,br1,bl2,bl1;

    while(!nfound)
      {
       chk=iHighest(NULL,timeframe,MODE_HIGH,bars,0);
       b00=iHigh(NULL,timeframe,chk);
       br2=iHigh(NULL,timeframe,chk+2);
       br1=iHigh(NULL,timeframe,chk+1);
       bl2=iHigh(NULL,timeframe,chk-2);
       bl1=iHigh(NULL,timeframe,chk-1);

       if(b00>=br2 && b00>=br1 && b00>=bl2 && b00>=bl1)
         {
          hi=b00;
          bars=barsORG;
          nfound=true;
         }
       else bars=bars+5;
      }
    while(!ufound)
      {
       chk=iLowest(NULL,timeframe,MODE_LOW,bars,0);
       b00=iLow(NULL,timeframe,chk);
       br2=iLow(NULL,timeframe,chk+2);
       br1=iLow(NULL,timeframe,chk+1);
       bl2=iLow(NULL,timeframe,chk-2);
       bl1=iLow(NULL,timeframe,chk-1);

       if(b00<=br2 && b00<=br1 && b00<=bl2 && b00<=bl1)
         {
          lo=b00;
          bars=barsORG;
          ufound=true;
         }
       else bars=bars+5;
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double max(int nbars,int timeframe)
 //finds the max price over the past n bars
   {
    return iHigh(NULL,timeframe,iHighest(NULL,timeframe,MODE_HIGH,nbars,0));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double min(int nbars,int timeframe)
 //finds the min price over the past n bars
   {
    return iLow(NULL,timeframe,iLowest(NULL,timeframe,MODE_LOW,nbars,0));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void drawhline(string label,double Vue,color acolor)
 //draws hline of particular color
   {
    ObjectDelete(label);
    ObjectCreate(label,OBJ_HLINE,0,Time[0],Vue);
    ObjectSet(label,OBJPROP_COLOR,acolor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double modrand(int divisor)
 //generates random number and mods it with divisor
   {
    return fmod(rand(),divisor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int ordersforsymbol(int &aords,int &pords)
 //calculates number of orders that have been placed for a particular symbol
   {
    for(int pos=OrdersTotal()-1; pos>=0; pos--)
      {
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUYSTOP || OrderType()==OP_SELLSTOP))
          pords++;
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUY || OrderType()==OP_SELL))
          aords++;
      }
    return aords+pords;
   }
 //+------------------------------------------------------------------+

**** xonerator code
 //+------------------------------------------------------------------+
 //|                                                     xonerator.mq4|
 //|                                           Copyright 2015, prader |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+


 /*
 a variation of xoner which sets zone up only with hi and lo
 0901-0902
 gets $120 minhilo=30
 gets $200 minhilo=60
 gets $299 minhilo=70
 but significant losses 0902-0903
 */

 #property copyright "Copyright 2015, prader"
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #define sp " "


 ///////////////////////////////////////////////
 int lots=1.0,tifr=1,
 Btkt,Stkt;
 ///////////////////////////////////////////////

 int OnInit() {srand(GetTickCount());return(INIT_SUCCEEDED);}
 void OnDeinit(const int reason){}
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {
    int aords,pords,maxminspan=5;
    double
    minhilo=70,
    hi=max(maxminspan,tifr),lo=min(maxminspan,tifr),Dhilo=Dpts(hi,lo),
    spr=ceil(fabs(Bid-Ask)/Point)+1;

    drawhline("hi",hi,Aqua);drawhline("lo",lo,Tomato);

    ordersforsymbol(aords,pords);

    if(aords==0 && pords==0 && Dhilo<minhilo) placepending(Btkt,Stkt,hi,lo,Dhilo);
    if((aords==1 && pords==1) || (aords==0 && pords==1)) deletpending(Btkt,Stkt);
    if(aords==1 && pords==0) manage();
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double trailer(int bs,double &sl,double oop)
 //sets trailing stop based on whether trailerV is sufficient
   {
    double 
    sl1=sl,sl2=sl,trail=15,
    lockin=15.0,lockinfactor=1.3,gain=lockin*lockinfactor;

    if(bs==0)
      {
       double bidoop=Dpts(Bid,oop);
       bool brkevn=(bidoop>lockin);
       if(bidoop>gain) sl1=oop+lockin*Point;
       if(Dpts(Bid,sl)>trail && brkevn) sl2=Bid-trail*Point;
       if(sl2>sl1) sl=sl2; else sl=sl1;
      }
    if(bs==1)
      {
       double oopbid=Dpts(oop,Bid);
       bool brkevn=(oopbid>lockin);
       if(Dpts(oop,Bid)>gain) sl1=oop-lockin*Point;
       if(Dpts(sl,Ask)>trail && brkevn) sl2=Ask+trail*Point;
       if(sl2<sl1) sl=sl2; else sl=sl1;
      }
    return sl;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void placepending(int &Btk,int &Stk,double hi,double lo,double Dhilo)
 //moves pending orders close to hilo
   {
    double
    m=1*Point,
    Bop=hi+3*m,Bsl=lo-9*m,Btp=Bop+5*Dhilo*Point,
    Sop=lo-3*m,Ssl=hi+9*m,Stp=Sop-5*Dhilo*Point;
    Btk=OrderSend(Symbol(),OP_BUYSTOP,lots,Bop,0,Bsl,Btp);
    Stk=OrderSend(Symbol(),OP_SELLSTOP,lots,Sop,0,Ssl,Stp);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void deletpending(int Btk,int Stk)
 //deletes pending order leaving only active one
   {
    bool o;
    int Bty,Sty;
    o=OrderSelect(Btk,SELECT_BY_TICKET);Bty=OrderType();
    o=OrderSelect(Stk,SELECT_BY_TICKET);Sty=OrderType();
    if(Bty==OP_BUY) o=OrderDelete(Stk);
    if(Sty==OP_SELL) o=OrderDelete(Btk);

   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void manage()
 //manages aord through trailing stop
   {
    bool om,os=OrderSelect(0,SELECT_BY_POS,MODE_TRADES);
    int ot=OrderType(),tk=OrderTicket();
    double op=OrderOpenPrice(),sl=OrderStopLoss(),tp=OrderTakeProfit();
    trailer(ot,sl,op);

    om=OrderModify(tk,op,sl,tp,0,clrNONE);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double p2,double p1)
 //difference between two prices p2-p1 in points
   {
    return (p2-p1)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double max(int nbars,int timeframe)
 //finds the max price over the past n bars
   {
    return iHigh(NULL,timeframe,iHighest(NULL,timeframe,MODE_HIGH,nbars,0));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double min(int nbars,int timeframe)
 //finds the min price over the past n bars
   {
    return iLow(NULL,timeframe,iLowest(NULL,timeframe,MODE_LOW,nbars,0));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void drawhline(string label,double Vue,color acolor)
 //draws hline of particular color
   {
    ObjectDelete(label);
    ObjectCreate(label,OBJ_HLINE,0,Time[0],Vue);
    ObjectSet(label,OBJPROP_COLOR,acolor);
   }
 double modrand(int divisor)
 //generates random number and mods it with divisor
 {
    return fmod(rand(),divisor);
 }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void ordersforsymbol(int &aords,int &pords)
 //calculates number of orders that have been placed for a particular symbol
   {
    for(int pos=OrdersTotal()-1; pos>=0; pos--)
      {
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUYSTOP || OrderType()==OP_SELLSTOP))
          pords++;
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUY || OrderType()==OP_SELL))
          aords++;
      }
   }
 //+------------------------------------------------------------------+

**** xoner code
 //+------------------------------------------------------------------+
 //|                                                         xoner.mq4|
 //|                                           Copyright 2015, prader |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+


 /*

 */

 #property copyright "Copyright 2015, prader"
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #define sp " "


 ///////////////////////////////////////////////
 int tifr=1,tktV;
 double lots=1.0;
 double BopV,BslV,BtpV,SopV,SslV,StpV;
 bool set=false;
 ///////////////////////////////////////////////

 int OnInit() {return(INIT_SUCCEEDED);}
 void OnDeinit(const int reason){}
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {
    int maxminspan=777;
    double
    lockin=15.0,lockinfactor=1.34,trail=11.0,hilofraction=0.13,
    hi=max(maxminspan,tifr),lo=min(maxminspan,tifr),Dhilo=Dpts(hi,lo),
    zonesize=hilofraction*Dhilo*Point,ih=hi-zonesize,ol=lo+zonesize;

    string zone=udzone(hi,ih,lo,ol);
    bool inzone=(zone!="N"),noord=(OrdersforSymbol()==0),roomy=(Dhilo>11);

    sethlines(hi,ih,lo,ol);

    if(inzone && !set && noord && roomy)
      {
       setop(hi,ih,lo,ol,Dhilo,zone,BopV,BslV,BtpV,SopV,SslV,StpV);
       set=true;
      }
    if(set && noord)
      {//waiting for ntrs to be triggered so an order is placed
       tktV=opn(BopV,BslV,BtpV,SopV,SslV,StpV);
      }
    if(!noord)
      {//working with an order
       alt(tktV,lockin,lockinfactor,trail);
       set=false;
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void setop(double hi,double ih,double lo,double ol,double Dhilo,string zone,
            double &Bop,double &Bsl,double &Btp,double &Sop,double &Ssl,double &Stp)
 //sets up opening prices
   {
    double g=Dhilo*Point,m=2*Point;
    if(zone=="U")
      {
       Bop=NormalizeDouble(hi+m,Digits);Bsl=ih;Btp=hi+g;
       Sop=NormalizeDouble(ih-m,Digits);Ssl=hi+m;Stp=ol;
      }
    if(zone=="D")
      {
       Bop=NormalizeDouble(ol+m,Digits);Bsl=lo-m;Btp=ih;
       Sop=NormalizeDouble(lo-m,Digits);Ssl=ol;Stp=lo-g;
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int opn(double Bop,double Bsl,double Btp,double Sop,double Ssl,double Stp)
 //opens order
   {
    if(Bid>Bop)
       return OrderSend(Symbol(),0,lots,Ask,0,Bsl,Btp,"",0,0);
    if(Bid<Sop)
      {
       return OrderSend(Symbol(),1,lots,Bid,0,Ssl,Stp,"",0,0);
      }
    return -1;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void alt(int tkt,double lockin,double lockinfactor,double trail)
 //manages the open trade
   {
    bool os=OrderSelect(tkt,SELECT_BY_TICKET);
    int bs=OrderType();
    double
    sl=OrderStopLoss(),
    tp=OrderTakeProfit(),
    oop=OrderOpenPrice();

    sl=trailer(bs,sl,lockin,lockinfactor,trail,oop);
    bool om=OrderModify(tkt,oop,sl,tp,0,clrNONE);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double trailer(int bs,double sl,double lockin,double lockinfactor,double trail,double oop)
 //sets trailing stop based on whether trailerV is sufficient
   {

    double sl1=sl,sl2=sl,gain=lockinfactor*lockin;

    if(bs==0)
      {
       double bidoop=Dpts(Bid,oop);
       bool brkevn=(bidoop>lockin);
       if(bidoop>gain) sl1=oop+lockin*Point;
       if(Dpts(Bid,sl)>trail && brkevn) sl2=Bid-trail*Point;
       if(sl2>sl1) sl=sl2; else sl=sl1;
      }

    if(bs==1)
      {
       double oopbid=Dpts(oop,Bid);
       bool brkevn=(oopbid>lockin);
       if(Dpts(oop,Bid)>gain) sl1=oop-lockin*Point;
       if(Dpts(sl,Ask)>trail && brkevn) sl2=Ask+trail*Point;
       if(sl2<sl1) sl=sl2; else sl=sl1;
      }

    return sl;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void delpending()
 //deletes pending orders
   {
    int ot[2],tk[2],total=OrdersforSymbol();
    bool o;
    ArrayInitialize(ot,-1);
    ArrayInitialize(tk,-1);
    for(int i=0;i<total;i++)
      {
       o=OrderSelect(i,SELECT_BY_POS,MODE_TRADES);
       ot[i]=OrderType();
       tk[i]=OrderTicket();
      }
    if(ot[0]>1 && ot[1]<2)
       o=OrderDelete(tk[0]);
    if(ot[1]>1 && ot[0]<2)
       o=OrderDelete(tk[1]);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 string udzone(double hi,double ih,double lo,double ol)
 //identifies which zone price is in
   {
    if(Bid<hi && Bid>ih)
       return "U";
    if(Bid>lo && Bid<ol)
       return "D";
    return "N";
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double hlfcalc(double factor,double hiV,double loV)
 //calculates the hilo fraction as a price Vue
   {
    return factor*(hiV-loV)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double p2,double p1)
 //difference between two prices p2-p1 in points
   {
    return (p2-p1)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double max(int nbars,int timeframe)
 //finds the max price over the past n bars
   {
    return iHigh(NULL,timeframe,iHighest(NULL,timeframe,MODE_HIGH,nbars,0));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double min(int nbars,int timeframe)
 //finds the min price over the past n bars
   {
    return iLow(NULL,timeframe,iLowest(NULL,timeframe,MODE_LOW,nbars,0));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void sethlines(double hi,double ih,double lo,double ol)
 //sets the two hline Vues given hi,lo in aqua
   {
    drawhline("hi",hi,Aqua);
    drawhline("ol",ih,Tomato);
    drawhline("lo",lo,Tomato);
    drawhline("ih",ol,Aqua);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void drawhline(string label,double Vue,color acolor)
 //draws hline of particular color
   {
    ObjectDelete(label);
    ObjectCreate(label,OBJ_HLINE,0,Time[0],Vue);
    ObjectSet(label,OBJPROP_COLOR,acolor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OrdersforSymbol()
 //calculates number of orders that have been placed for a particular symbol
   {
    int count=0,pos;
    for(pos=OrdersTotal()-1; pos>=0; pos--)
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol())
          count++;
    return(count);
   }
 //+------------------------------------------------------------------+

**** xonerwatch code
 //+------------------------------------------------------------------+
 //|                                                         xoner.mq4|
 //|                                           Copyright 2015, prader |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+


 /*

 */

 #property copyright "Copyright 2015, prader"
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #define sp " "


 ///////////////////////////////////////////////
 int tifr=1,tktV;
 double lots=1.0;
 double BopV,BslV,BtpV,SopV,SslV,StpV;
 bool set=false;
 ///////////////////////////////////////////////

 int OnInit() {return(INIT_SUCCEEDED);}
 void OnDeinit(const int reason){}
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {
    int maxminspan=7;
    double
    trail=15,hilofraction=.13,
    hi=max(maxminspan,1),lo=min(maxminspan,1);
    //zonesize=hilofraction*Dhilo*Point,ih=hi-zonesize,ol=lo+zonesize;

    //string zone=udzone(hi,ih,lo,ol);
    //bool inzone=(zone!="N"),noord=(OrdersforSymbol()==0),roomy=(Dhilo>11);

    //sethlines(hi,ih,lo,ol);
   
    drawhline("hi",hi,Blue);
    drawhline("lo",lo,Red);
   
      
 /*
    if(inzone && !set && noord && roomy)
      {
       setop(hi,ih,lo,ol,Dhilo,zone,BopV,BslV,BtpV,SopV,SslV,StpV);
       set=true;
      }
    if(set && noord)
      {//waiting for ntrs to be triggered so an order is placed
       tktV=opn(BopV,BslV,BtpV,SopV,SslV,StpV);
      }
    if(!noord)
      {//working with an order
       alt(tktV,trail);
       set=false;
      }
      */
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void setop(double hi,double ih,double lo,double ol,double Dhilo,string zone,
            double &Bop,double &Bsl,double &Btp,double &Sop,double &Ssl,double &Stp)
 //sets up opening prices
   {
    double g=Dhilo*Point,m=2*Point;
    if(zone=="U")
      {
       Bop=NormalizeDouble(hi+m,Digits);Bsl=ih;Btp=hi+g;
       Sop=NormalizeDouble(ih-m,Digits);Ssl=hi+m;Stp=ol;
      }
    if(zone=="D")
      {
       Bop=NormalizeDouble(ol+m,Digits);Bsl=lo-m;Btp=ih;
       Sop=NormalizeDouble(lo-m,Digits);Ssl=ol;Stp=lo-g;
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int opn(double Bop,double Bsl,double Btp,double Sop,double Ssl,double Stp)
 //opens order
   {
    if(Bid>Bop)
       return OrderSend(Symbol(),0,1.0,Ask,0,Bsl,Btp,"",0,0);
    if(Bid<Sop)
      {
       return OrderSend(Symbol(),1,1.0,Bid,0,Ssl,Stp,"",0,0);
      }
    return -1;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void alt(int tkt,double trail)
 //manages the open trade
   {
    bool os=OrderSelect(tkt,SELECT_BY_TICKET);
    int bs=OrderType();
    double
    sl=OrderStopLoss(),
    tp=OrderTakeProfit(),
    oop=OrderOpenPrice();

    sl=trailer(bs,sl,trail,oop);
    bool om=OrderModify(tkt,oop,sl,tp,0,clrNONE);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double trailer(int bs,double sl,double trail,double oop)
 //sets trailing stop based on whether trailerV is sufficient
   {

    double sl1=sl,sl2=sl,gain=15,adv=10;

    if(bs==0)
      {
       double bidoop=Dpts(Bid,oop);
       bool brkevn=(bidoop>adv);
       if(bidoop>gain) sl1=oop+adv*Point;
       if(Dpts(Bid,sl)>trail && brkevn) sl2=Bid-trail*Point;
       if(sl2>sl1) sl=sl2; else sl=sl1;
      }

    if(bs==1)
      {
       double oopbid=Dpts(oop,Bid);
       bool brkevn=(oopbid>adv);
       if(Dpts(oop,Bid)>gain) sl1=oop-adv*Point;
       if(Dpts(sl,Ask)>trail && brkevn) sl2=Ask+trail*Point;
       if(sl2<sl1) sl=sl2; else sl=sl1;
      }

    return sl;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void delpending()
 //deletes pending orders
   {
    int ot[2],tk[2],total=OrdersforSymbol();
    bool o;
    ArrayInitialize(ot,-1);
    ArrayInitialize(tk,-1);
    for(int i=0;i<total;i++)
      {
       o=OrderSelect(i,SELECT_BY_POS,MODE_TRADES);
       ot[i]=OrderType();
       tk[i]=OrderTicket();
      }
    if(ot[0]>1 && ot[1]<2)
       o=OrderDelete(tk[0]);
    if(ot[1]>1 && ot[0]<2)
       o=OrderDelete(tk[1]);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 string udzone(double hi,double ih,double lo,double ol)
 //identifies which zone price is in
   {
    if(Bid<hi && Bid>ih)
       return "U";
    if(Bid>lo && Bid<ol)
       return "D";
    return "N";
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double hlfcalc(double factor,double hiV,double loV)
 //calculates the hilo fraction as a price Vue
   {
    return factor*(hiV-loV)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double p2,double p1)
 //difference between two prices p2-p1 in points
   {
    return (p2-p1)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double max(int nbars,int timeframe)
 //finds the max price over the past n bars
   {
    return iHigh(NULL,timeframe,iHighest(NULL,timeframe,MODE_HIGH,nbars,0));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double min(int nbars,int timeframe)
 //finds the min price over the past n bars
   {
    return iLow(NULL,timeframe,iLowest(NULL,timeframe,MODE_LOW,nbars,0));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void sethlines(double hi,double ih,double lo,double ol)
 //sets the two hline Vues given hi,lo in aqua
   {
    drawhline("hi",hi,Aqua);
    drawhline("ol",ih,Tomato);
    drawhline("lo",lo,Tomato);
    drawhline("ih",ol,Aqua);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void drawhline(string label,double Vue,color acolor)
 //draws hline of particular color
   {
    ObjectDelete(label);
    ObjectCreate(label,OBJ_HLINE,0,Time[0],Vue);
    ObjectSet(label,OBJPROP_COLOR,acolor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int OrdersforSymbol()
 //calculates number of orders that have been placed for a particular symbol
   {
    int count=0,pos;
    for(pos=OrdersTotal()-1; pos>=0; pos--)
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol())
          count++;
    return(count);
   }
 //+------------------------------------------------------------------+

*** masloper
 ntr on zero, xit on zero || prolos

 TF=30, prolos=2400/1200, minslope=18, 150402-150502
 |   max |   min |   end |   md | nzer |  nmin | xzer |  xmin |   |
 | 13996 | 09879 | 13391 | 1119 |   18 | 600.0 |   18 | 600.0 |   |
 | 13021 | 09756 | 11811 | 1669 |   18 | 162.0 |   18 | 600.0 |   |
 | 14364 | 09388 | 13275 | 1947 |   18 | 108.0 |   18 | 600.0 |   |
 | 17963 | 14075 | 16871 | 1660 |   18 |  93.6 |   18 | 600.0 | * |
 | 17842 | 14075 | 16750 | 1660 |   18 |  90.0 |   18 | 600.0 |   |
 | 17817 | 11673 | 16135 | 2140 |   18 |  82.8 |   18 | 600.0 |   |


 we seem to be able to make money, but we need to reduce the losses. increasing the prolos to 240 and 360 created worse losses. a loss of 120 seems to be the best option even on 5M with slo12.

 changing slo0 from 2,1 to 2,0 bad and worse with minslope 12 instead of 18, possibly because you never know what the current candle is going to do.

 best results so far seem to be with
 double   LOTSIZ=1.0, minslope=18, POSSLO=minslope*Point, NEGSLO=-POSSLO;
 int      NMBARS=6, MABARS=6;
 using slomin=9 improved max, but still getting md.

 how to cut the losing streaks. possibly the xit should not be the same as ntr. if it is, we miss the point which is that we should be entering in the opposite direction. symmetry is counterproductive. so try to find different criteria for xit such as a faster version. some of the losing streaks are caused by price moving within the single candle so it is too fast for a slope mechanism to cause exit, so we need to find a solution to this - may be work in smaller tf.


 also see if incorporating tick volume helps to determine how to ntr and xit.


 go to smaller TF. 

 TF=05, prolos=2400/1200, minslope=12, 150402-150502
 |   max |   min |   end |   md | nzer | nmin | xzer | xmin |   |
 | 13169 | 09757 | 12235 | 1383 |    1 |   80 |    1 |   80 |   |
 | 13494 | 09878 | 12197 | 1746 |    1 |   12 |    1 |   80 |   |
 | 13616 | 09878 | 12440 | 1625 |    1 |   13 |    1 |   80 |   |
 | 13616 | 09878 | 12561 | 1504 |    1 |   14 |    1 |   80 |   |
 | 13616 | 09878 | 12682 | 1383 |    1 |   15 |    1 |   80 | * |
 | 13169 | 09757 | 12235 | 1383 |    1 |   18 |    1 |   80 |   |

 though these are fairly good, we are only doing 30 trades where as on M30 we had 40. we should be getting in on 240 trades and then optimizing the xits so that we make consistent profits.
**** code
 //+------------------------------------------------------------------+
 //|                                                     masloper.mq4 |
 //|                                           Copyright 2015, prader |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+
 #property copyright "Copyright 2015, prader"
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict

 /*consider reversals and/or small goals to deal with repeated losses*/

 /*
 masloper uses 6 period ma slopes to determine ntrxit when slope is 'zero' or greater than a minimum
 best results seem to be with ntr:18-93.6 xit:18-600 with prolos:120 on M30

 SLOZER: slope zero ie if slope is less than value then ntr
 SLOMIN: minimum slope ie if abs(slope) greater then ntr

 bs: buy 0 or sell 1 value of trade, so set to -1 when no trade

 MXORDS: max trades allowed, controls how many trades in progress
 MXBARS: max bars keeps track of recent number of bars, which if exceeded allows trade to take place
 LEV: leverage (irrelevant for our purposes, but a required parameter)
 MN: magic number (can be used to track trade identities)

 takpro: take profit (irrelevant because it is set so high)
 stolos: stop loss that is rr fraction of takpro

 mapos: moving average position
 maslo: moving average slope
 maacc: moving average acceleration
 each of the above has a high H, middle M, low L value that is calculated and stored by mafill function

 mar2-jun30 30710 with prolos 2400,-240
            31140 with prolos 3000,-240
            31693 with prolos 2400,-300

 -> add intelligent stoploss instead of prolos
 */


 double   LOTSIZ=0.1;
 int      TIMFRA=PERIOD_M30;
 double   ntrSLOZER=18, ntrSLOMIN=93.6, xitSLOZER=18, xitSLOMIN=600; //ntrxit versions

 int      bs=-1, tkt=0, MXORDS=1, MXBARS=0, LEV=0, MN=666;
 double   rr=0.9, takpro=6000, stolos=rr*takpro;
 double   maposH[7],masloH[7],maaccH[7],maposM[7],masloM[7],maaccM[7],maposL[7],masloL[7],maaccL[7];

 double plsl=-180*LOTSIZ, pltp=2400*LOTSIZ; //prolos functions takeprofit and stoploss
 
 //int fh=FileOpen("ttt.txt",FILE_READ | FILE_WRITE | FILE_TXT);
 //FileSeek(fh,0,SEEK_END);FileWrite(fh,maslo/Point);
 //FileClose(fh);

 int Oninit() {return(INIT_SUCCEEDED);}
 void OnDeinit(const int reason) {}


 void OnTick()
 {
    bool os;
    double op;
  
    if (MXBARS!=iBars(NULL,TIMFRA) && OrdersforSymbol()!=MXORDS) //ntr if new bar and not max orders reached
     { 
       int buse = masloper(ntrSLOZER,ntrSLOMIN);
       ntr(tkt,buse,stolos,takpro); //buy or sell depending on masloper value
       MXBARS=iBars(NULL,TIMFRA); //get most recent number of bars in chart
     }

    if (OrdersforSymbol()==MXORDS) //consider alt if max order reached
     {
       os = OrderSelect(tkt,SELECT_BY_TICKET); //select ticket so to get other values
       op = OrderOpenPrice();
       bs = OrderType(); //determine buy or sell to figure out xit
               
       if (bs==0)
        {
          if ((masloper(xitSLOZER,xitSLOMIN)==1) || prolos(pltp,plsl)) xit(tkt);
        }
       if (bs==1)
        {
          if ((masloper(xitSLOZER,xitSLOMIN)==0) || prolos(pltp,plsl)) xit(tkt);       
        }

       MXBARS=iBars(NULL,TIMFRA); //get most recent number of bars in chart
     }
    
 }


 /////////////////////////////////////////////////////////////


 int masloper(double zerslo, double minslo)
 //detects slope sign change or slope>minslope
 {
    mafill(maposM,masloM,maaccM,TIMFRA,6,0,3,4);
    if (slozer(masloM,zerslo)==0 || slomin(masloM,minslo)==0) return 0;
    if (slozer(masloM,zerslo)==1 || slomin(masloM,minslo)==1) return 1;
    return -1;
 }



 // various functions //

 double stoploss(int buyorsell)
 //sets stoploss at furthest value from entry based on number of candles
    {
       int numbars = 12;
       double   mx = iHigh(NULL,TIMFRA,numbars),
                mn = iLow(NULL,TIMFRA,numbars);
      
       if (buyorsell==0) return fabs(Bid-mn)/Point;
       else return fabs(Ask-mx)/Point;
    }

 bool prolos(double pro, double los)
 //determine whether profit or loss amount has been exceeded with pro> and los<
 {
    if (OrderProfit()>pro || OrderProfit()<los) return true; 
    else return false;
 }


 int OrdersforSymbol()
 //calculates number of orders that have been placed for a particular symbol
 {
    int count=0,pos;
    for(pos = OrdersTotal()-1; pos >= 0 ; pos--) 
       if (OrderSelect(pos, SELECT_BY_POS) && OrderSymbol()==Symbol())
          count++;
    return(count);
 }



 // slope functions //

 int slozer(double & slo[], double slo0)
 //checks for zero slope condition
 {
    double posslo=slo0*Point, negslo=-posslo;
    if (slo[2]<negslo && slo[1]>posslo) return 0;
    if (slo[2]>posslo && slo[1]<negslo) return 1;
    return -1;
 }

 int slomin(double & slo[], double minslo)
 //checks if slope is greater than some minimum
 {
    double posslo=minslo*Point, negslo=-posslo;
    if (slo[1]>posslo) return 0;
    if (slo[1]<negslo) return 1;
    return -1;
 }


 // trade functions //

 void ntr(int& tk, int ls, double sl, double tp)
 //determines whether to buy or sell
 //args: &ticket, ls (long,short decision), plsl and pltp 
 {
    switch(ls)
    {
       case 0: tk = OrderSend(Symbol(),OP_BUY,LOTSIZ,Ask,LEV,Ask-sl*Point,Ask+tp*Point,"magnum: ",MN,0,Blue); break;
       case 1: tk = OrderSend(Symbol(),OP_SELL,LOTSIZ,Bid,LEV,Bid+sl*Point,Bid-tp*Point,"magnum: ",MN,0,Red); break;
    }   
 }

 void xit(int tk)
 //closes specific trade
 //args: ticket, ls (whether dealing with buy || sell)
 {
    bool oc = OrderClose(tk,LOTSIZ,OrderClosePrice(),0,Orange);
 }



 // fill array functions //

 void mafill(double& mapos[], double& maslo[], double& maacc[],
             int timeframe,int period,int shift,int method,int applprice)
 //fills ma arrays for pos, slo, acc
 {
    for (int i=0;i<=period;i++)
    {
       mapos[i]=NormalizeDouble(iMA(NULL,timeframe,period,shift,method,applprice,i),Digits);
    }
    fillPSA(mapos,maslo,maacc);
 }


 void fillPSA(double & pos[], double& slo[], double& acc[])
 //given position, fills slope and acceleration arrays
 {
    int Psize=ArrayRange(pos,0)-1;
   
    for(int i=0;i<=Psize-1;i++)
       slo[i] = pos[i] - pos[i+1];

    for(int i=0;i<=Psize-2;i++)
       acc[i] = slo[i] - slo[i+1];     
 }

*** maSSs
 moving average supportive slope system
 - use supportive slopes of 3,45 to get in, but 45 cross to get out
 - 45 slope to do xr mode when bars are split by this ma
**** code
 //+------------------------------------------------------------------+
 //|                                                   zztemplate.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+
 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict

 /*

 */

 int      tkt,tifr=15;
 double   lots=0.1;
 bool     zz;

 int OnInit() {return(INIT_SUCCEEDED);}
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {
    int
    ords=ordersforsymbol(),
    barL=1,barR=0,
    Pfma=3,Psma=45;

    if(ords<1)
      {
       opn(tkt,ss(barL,barR,Pfma,Psma));
      }
    else
      {
       alt(tkt,Psma);
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void opn(int &tk,string ss)
 //opens a trade
   {
    int bs=-1,lev=0;
    double sl=700*Point,tp=1100*Point,op=0;
    bool
    buy=(ss=="ntrBUY"),
    sel=(ss=="ntrSEL");

    if(buy) bs=0;
    if(sel) bs=1;

    switch(bs)
      {
       case  0:
          op=Ask;
          sl=Ask-sl;
          tp=Ask+tp;
          break;
       case  1:
          op=Bid;
          sl=Bid+sl;
          tp=Bid-tp;
          break;
      }
    tk=OrderSend(Symbol(),bs,lots,op,lev,sl,tp);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void alt(int tk,int Psma)
 //alters the trade
   {
    zz=OrderSelect(tk,SELECT_BY_TICKET);
    int
    bs=OrderType();
    double
    oop=OrderOpenPrice(),
    ocp=OrderClosePrice(),
    tp=OrderTakeProfit(),
    sl=OrderStopLoss();
    bool xit=(pc(bs,Psma)=="xit");

    if(xit)
       zz=OrderClose(tk,lots,ocp,0);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 string pc(int bs,int Psma)
 //price crossing of sma
   {
    double
    margin=20*Point,
    sma=mavalue(tifr,Psma,0);

    if((bs==0 && (Bid<sma)) || (bs==1 && (Bid>sma))) return "xit";
    else return "WAIT";

   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 string ss(int barL,int barR,int Pfma,int Psma)
 //supportive slope shows fma,sma matching 
   {
    int
    nbars=barL-barR;
    double
    Mfmin=0,Msmin=0,
    Lfma=mavalue(tifr,Pfma,barL),
    Rfma=mavalue(tifr,Pfma,barR),
    Lsma=mavalue(tifr,Psma,barL),
    Rsma=mavalue(tifr,Psma,barR),
    Mfma=maslope(nbars,Lfma,Rfma),
    Msma=maslope(nbars,Lsma,Rsma);

    if(Rfma>Rsma)
      {
       if((Mfma>+Mfmin) && (Msma>+Msmin)) return "ntrBUY";
      }
    if(Rfma<Rsma)
      {
       if((Mfma<-Mfmin) && (Msma<-Msmin)) return "ntrSEL";
      }
    return "WAIT";
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double mavalue(int timeframe,int period,int barnumber)
 //returns the value for a ma
   {
    int
    shift=0,
    method=MODE_LWMA,
    applprice=PRICE_MEDIAN;

    return NormalizeDouble(iMA(NULL,timeframe,period,shift,method,applprice,barnumber),Digits);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double maslope(int nbars,double Lma,double Rma)
 //calculates the slope of ma between selected bars
   {
    return (Rma-Lma)/nbars/Point;
   }
 //+------------------------------------------------------------------+
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int ordersforsymbol()
 //calculates number of orders that have been placed for a particular symbol
   {
    int count=0,pos;
    for(pos=OrdersTotal()-1; pos>=0; pos--)
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol())
          count++;
    return(count);
   }
 //+------------------------------------------------------------------+

*** momrsi
 combo of momentum indicator with rsi
*** rsiac
 fedosov's implementation of rsi and ac gives better idea of what each indicator can be used for.

 15m rsiperiod=11,sltp=700 1127,133,-250,627 qtrs for 2015
 but the losing 3rd qtr was turned into a 400 by making sl=700 tp=1100
 going to 30m it became 642, but going to 60m lost
 however 30m produced 750,653,642,743 giving over the year 2790 with 255 trades
 (masloper did 2489 with 292 trades!)

 are there optimal sltp for various tifr and/or mc?

 *trailing stop:*
 - hi lockinfactor with no continuous trailer got bit better result than no trailer
 - lo lockinfactor and/or continuous trailer produced poor results due to commission
 - suggestion may be that we need an intelligent trailer?
 - however, an unintelligent one's benefits may be cancelled out by excessive trades
 - over 2015 eurusd 5x5 ts produced 1600 with 439 trades
 - the ts seems to hinder price getting to the stated tp
 - it may be good to randomize the implementation of ts

 also 2 oscillators are used - perhaps better with a trender and oscillator

 after running it for 3 days, it seems rsiac suffers from the same issue as masloper in that it gets in too late. what's worse is that due to the 700pt sl, it can lose much more severely. also, the program can come out of a good trade without hitting tp, but there is no way to come out of a bad one till you hit sl. so we've taken it off on all but eurusd and usdcad for now (160113).
**** code
 //+------------------------------------------------------------------+
 //|                                                        rsiac.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+
 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict

 /*
 a rewrite of alexander fedosov's rsi and ac EA https://www.mql5.com/en/articles/1747
 */

 //+------------------------------------------------------------------+
 //| Parameters                                              |
 //+------------------------------------------------------------------+
 int      tkt,tifr=30;
 double   lots=0.1;
 bool     zz;

 int OnInit() {return(INIT_SUCCEEDED);}
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {
    int
    ords=ordersforsymbol(),bs=-1,
    rsiV=depth_trend(),acV=speed_ac();

    if(ords<1)
      {
       opn(tkt,rsiV,acV);
      }
    else
      {
       alt(tkt,rsiV,acV);
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void opn(int &tk,int rsiV,int acV)
 //opens a trade
   {
    int bs=-1,lev=0;
    double sl=700*Point,tp=1100*Point,op=0;

    if(Buy(rsiV,acV)) bs=OP_BUY;
    if(Sel(rsiV,acV)) bs=OP_SELL;

    switch(bs)
      {
       case  0:
          op=Ask;
          sl=Ask-sl;
          tp=Ask+tp;
          break;
       case  1:
          op=Bid;
          sl=Bid+sl;
          tp=Bid-tp;
          break;
      }

    tk=OrderSend(Symbol(),bs,lots,op,lev,sl,tp);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void alt(int tk,int rsiV,int acV)
 //alters the trade
   {
    zz=OrderSelect(tk,SELECT_BY_TICKET);
    int bs=OrderType();
    double
    oop=OrderOpenPrice(),
    ocp=OrderClosePrice(),
    tp=OrderTakeProfit(),
    sl=OrderStopLoss();

    bool xit=((bs==0 && Buy_close(rsiV,acV)) || (bs==1 && Sel_close(rsiV,acV)));

    if(xit)
       zz=OrderClose(tk,lots,ocp,0);
    else
      {
       //trailer(bs,sl,oop);
       //zz=OrderModify(tk,oop,sl,tp,0,clrNONE);
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void trailer(int bs,double &sl,double oop)
 //sets trailing stop based on whether trailerV is sufficient
   {
    double
    sl1=sl,sl2=sl,trail=6000,
    lockin=50,lockinfactor=5,gain=lockin*lockinfactor;

    if(bs==0)
      {
       double bidoop=Dpts(Bid,oop);
       bool brkevn=(bidoop>lockin);
       if(bidoop>gain) sl1=oop+lockin*Point;
       if(Dpts(Bid,sl)>trail && brkevn) sl2=Bid-trail*Point;
       if(sl2>sl1) sl=sl2; else sl=sl1;
      }
    if(bs==1)
      {
       double oopbid=Dpts(oop,Bid);
       bool brkevn=(oopbid>lockin);
       if(Dpts(oop,Bid)>gain) sl1=oop-lockin*Point;
       if(Dpts(sl,Bid)>trail && brkevn) sl2=Bid+trail*Point;
       if(sl2<sl1) sl=sl2; else sl=sl1;
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double p2,double p1)
 //difference between two prices p2-p1 in points
   {
    return (p2-p1)/Point;
   }
 //+------------------------------------------------------------------+
 //| Function for determining the trend speed                         |
 //+------------------------------------------------------------------+
 int speed_ac()
   {
    int acV=0;
    double ac[5];
    ArrayResize(ac,5);

    for(int i=0; i<5; i++)
       ac[i]=iAC(Symbol(),tifr,i);

 //buy signals
    if(ac[0]>ac[1])                                                   acV=1;
    else if(ac[0]>ac[1] && ac[1]>ac[2])                               acV=2;
    else if(ac[0]>ac[1] && ac[1]>ac[2] && ac[2]>ac[3])                acV=3;
    else if(ac[0]>ac[1] && ac[1]>ac[2] && ac[2]>ac[3] && ac[3]>ac[4]) acV=4;
 //sell signals
    else if(ac[0]<ac[1])                                              acV=-1;
    else if(ac[0]<ac[1] && ac[1]<ac[2])                               acV=-2;
    else if(ac[0]<ac[1] && ac[1]<ac[2] && ac[2]<ac[3])                acV=-3;
    else if(ac[0]<ac[1] && ac[1]<ac[2] && ac[2]<ac[3] && ac[3]<ac[4]) acV=-4;
    return acV;
   }
 //+------------------------------------------------------------------+
 //| Function for determining the trend depth                         |
 //+------------------------------------------------------------------+
 int depth_trend()
   {
    int rsiV=0,period=11;
    double rsi=iRSI(Symbol(),tifr,period,PRICE_CLOSE,0);

 //buy signals
    if(rsi>90.0)      rsiV=4;
    else if(rsi>80.0) rsiV=3;
    else if(rsi>70.0) rsiV=2;
    else if(rsi>60.0) rsiV=1;
 //sel signals
    else if(rsi<10.0) rsiV=-4;
    else if(rsi<20.0) rsiV=-3;
    else if(rsi<30.0) rsiV=-2;
    else if(rsi<40.0) rsiV=-1;

    return rsiV;
   }
 //+------------------------------------------------------------------+
 //| Function for checking buy conditions                             |
 //+------------------------------------------------------------------+
 bool Buy(int rsiV,int acV)
   {
    bool res=false;
    if((rsiV==2 && acV>=1) || (rsiV==3 && acV==1))
       res=true;
    return (res);
   }
 //+------------------------------------------------------------------+
 //| Function for checking sell conditions                              |
 //+------------------------------------------------------------------+
 bool Sel(int rsiV,int acV)
   {
    bool res=false;
    if((rsiV==-2 && acV<=-1) || (rsiV==-3 && acV==-1))
       res=true;
    return (res);
   }
 //+------------------------------------------------------------------+
 //| Function for checking buy position closing conditions            |
 //+------------------------------------------------------------------+
 bool Buy_close(int rsiV,int acV)
   {
    bool res=false;
    if(rsiV>2 && acV<0)
       res=true;
    return (res);
   }
 //+------------------------------------------------------------------+
 //| Function for checking sell position closing conditions             |
 //+------------------------------------------------------------------+
 bool Sel_close(int rsiV,int acV)
   {
    bool res=false;
    if(rsiV<-2 && acV>0)
       res=true;
    return (res);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int ordersforsymbol()
 //calculates number of orders that have been placed for a particular symbol
   {
    int count=0,pos;
    for(pos=OrdersTotal()-1; pos>=0; pos--)
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol())
          count++;
    return(count);
   }
 //+------------------------------------------------------------------+

*** raex
**** code
 //+------------------------------------------------------------------+
 //|                                                         raex.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+
 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #define sp "  "

 /*

 */

 int      tkt;
 double   lots=0.1;
 bool     zz;

 int OnInit() {return(INIT_SUCCEEDED);}
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {
    int
    tifr=1,
    aords=0,pords=0,ords=ordersforsymbol(aords,pords);

    if(ords==0)
      {
       opn(tkt);
      }
 /*   else
      {
       alt(tkt);
      }*/
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void opn(int &tk)
 //opens a trade
   {
    int bs=-1,lev=0,timeframe=1,period=33,Lbar=5,Rbar=0;
    double op=0,sl=0,tp=0,ma=maslope(timeframe,period,Lbar,Rbar);

    bs=explorer(ma);

    if(bs!=-1) opsltp(bs,timeframe,period,op,sl,tp);

    tk=OrderSend(Symbol(),bs,lots,op,lev,sl,tp);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void alt(int tk)
 //alters the trade
   {
    zz=OrderSelect(tk,SELECT_BY_TICKET);
    int bs=OrderType();
    double
    oop=OrderOpenPrice(),
    ocp=OrderClosePrice(),
    tp=OrderTakeProfit(),
    sl=OrderStopLoss();
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int explorer(double slopema)
 //bs signal based on slope steepness
   {
    double slopemin=3;
    bool
    buy=(slopema>+slopemin),
    sel=(slopema<-slopemin);

    if(buy) return 0;
    if(sel) return 1;
    return -1;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void opsltp(int bs,int timeframe,int period,double &op,double &sl,double &tp)
 //calculates op,sl,tp
   {
    switch(bs)
      {
       case  0:
          op=Ask;
          sl=min(timeframe,period);
          tp=Ask+Dpts(op,sl)*Point;
          break;
       case  1:
          op=Bid;
          sl=max(timeframe,period);
          tp=Bid-Dpts(sl,op)*Point;
          break;
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double maslope(int timeframe,int period,int Lbar,int Rbar)
 //calculates the slope of ma between selected bars
   {
    int
    nbars=Lbar-Rbar;
    double
    Lma=mavalue(timeframe,period,Lbar),
    Rma=mavalue(timeframe,period,Rbar);

    return (Rma-Lma)/nbars/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double mavalue(int timeframe,int period,int barnumber)
 //returns the value for a ma
   {
    int
    shift=0,
    method=MODE_LWMA,
    applprice=PRICE_MEDIAN;

    return NormalizeDouble(iMA(NULL,timeframe,period,shift,method,applprice,barnumber),Digits);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double p2,double p1)
 //difference between two prices p2-p1 in points
   {
    return (p2-p1)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double max(int timeframe,int nbars)
 //finds the max price over the past n bars
   {
    return iHigh(NULL,timeframe,iHighest(NULL,timeframe,MODE_HIGH,nbars,0));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double min(int timeframe,int nbars)
 //finds the min price over the past n bars
   {
    return iLow(NULL,timeframe,iLowest(NULL,timeframe,MODE_LOW,nbars,0));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void drawhline(string label,double Vue,color acolor)
 //draws hline of particular color
   {
    ObjectDelete(label);
    ObjectCreate(label,OBJ_HLINE,0,Time[0],Vue);
    ObjectSet(label,OBJPROP_COLOR,acolor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double modrand(int divisor)
 //generates random number and mods it with divisor
   {
    return fmod(rand(),divisor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int ordersforsymbol(int &aords,int &pords)
 //calculates number of orders that have been placed for a particular symbol
   {
    for(int pos=OrdersTotal()-1; pos>=0; pos--)
      {
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUYSTOP || OrderType()==OP_SELLSTOP))
          pords++;
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUY || OrderType()==OP_SELL))
          aords++;
      }
    return aords+pords;
   }
 //+------------------------------------------------------------------+

*** ntrxit
 nu and macross code
 int nu(int timeframe)
 //ntr on nu when incline sufficiently steep
   {
    double mid[4];ArrayInitialize(mid,0);
    bool n,u;

    for(int i=0;i<4;i++)
       mid[i]=(High[i]+Low[i])/2;

    u=u(mid[3],mid[2],mid[1]);
    n=n(mid[3],mid[2],mid[1]);

    if(u) return +1;
    if(n) return -1;
    return 0;

   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int macross(int timeframe,int barI)
 //ntr from price crossings of ma
   {
    double
    maVal=iMA(NULL,timeframe,barI,0,MODE_SMA,PRICE_OPEN,0),
    prLow=iLow(NULL,timeframe,1),
    prClo=iClose(NULL,timeframe,1),
    prHig=iHigh(NULL,timeframe,1);

    bool buy,sel;

    buy=(prLow<maVal && prClo>maVal);
    sel=(prHig>maVal && prClo<maVal);

    if(buy) return +1;
    if(sel) return -1;
    return 0;
   }
*** nu
**** code
 //+------------------------------------------------------------------+
 //|                                                    nu.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+
 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict

 /*
 this is pradapter version since original nu functioned very poorly
 */

 int      tkt,tifr=30;
 double   lots=0.1;
 bool     zz;


 int OnInit() {return(INIT_SUCCEEDED);}
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {
    int
    aords=0,pords=0,ords=ordersforsymbol(aords,pords);

    if(ords==0)
      {
       opn(tkt);
      }
    /*else
      {
       alt(tkt);
      }*/
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void opn(int &tk)
 //opens a trade
   {
    int bs=-1,lev=0;
    double op,sl,tp;
   
    nu(tifr,bs,op,sl,tp);

    if(bs!=-1) tk=OrderSend(Symbol(),bs,lots,op,lev,sl,tp);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void alt(int tk)
 //alters the trade
   {
    zz=OrderSelect(tk,SELECT_BY_TICKET);
    int bs=OrderType();
    double
    oop=OrderOpenPrice(),
    ocp=OrderClosePrice(),
    tp=OrderTakeProfit(),
    sl=OrderStopLoss();
    /*bool xit=();

    if(xit)
       zz=OrderClose(tk,lots,ocp,0);*/
   }
 void sltp(string &nu,double &op,double &sl,double &tp)
 //determines order details from nu value
 {
   
 }
 void nu(int timeframe,int &bs,double &op,double &sl,double &tp)
 //detects n or u pattern in the past 5 bars
 {
    double barHIs[6],barLOs[6],tpfac=1.0*Point;
    ArrayInitialize(barHIs,0);ArrayInitialize(barLOs,0);
   
    for(int i=1;i<=5;i++)
       barHIs[i]=iHigh(NULL,timeframe,i);
    if(ArrayMaximum(barHIs,5,1)==3)
    {
       bs=1;
       op=Bid;
       sl=barHIs[3];
       tp=op-Dpts(sl,op)*tpfac;
    }

    for(int i=1;i<=5;i++)
       barLOs[i]=iLow(NULL,timeframe,i);
    if(ArrayMinimum(barLOs,5,1)==3)
    {
       bs=0;
       op=Ask;
       sl=barLOs[3];
       tp=op+Dpts(op,sl)*tpfac;
    }
 }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void srlevels()
 //marks sr for tifr
   {

   }
 double Dpts(double p2,double p1)
 //difference between two prices p2-p1 in points
   {
    return (p2-p1)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double max(int nbars,int timeframe)
 //finds the max price over the past n bars
   {
    return iHigh(NULL,timeframe,iHighest(NULL,timeframe,MODE_HIGH,nbars,0));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double min(int nbars,int timeframe)
 //finds the min price over the past n bars
   {
    return iLow(NULL,timeframe,iLowest(NULL,timeframe,MODE_LOW,nbars,0));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void drawhline(string label,double Vue,color acolor)
 //draws hline of particular color
   {
    ObjectDelete(label);
    ObjectCreate(label,OBJ_HLINE,0,Time[0],Vue);
    ObjectSet(label,OBJPROP_COLOR,acolor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double modrand(int divisor)
 //generates random number and mods it with divisor
   {
    return fmod(rand(),divisor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int ordersforsymbol(int &aords,int &pords)
 //calculates number of orders that have been placed for a particular symbol
   {
    for(int pos=OrdersTotal()-1; pos>=0; pos--)
      {
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUYSTOP || OrderType()==OP_SELLSTOP))
          pords++;
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUY || OrderType()==OP_SELL))
          aords++;
      }
    return aords+pords;
   }
 //+------------------------------------------------------------------+

*** ms
**** code
 //+------------------------------------------------------------------+
 //|                                                           ms.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+
 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict

 /*
 determines slopes on various tifr
 */

 #property copyright "Copyright 2015, prader"
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #define sp " "


 ///////////////////////////////////////////////
 int lots=1.0,tifr=1,
 Btkt,Stkt;
 ///////////////////////////////////////////////

 int OnInit() {srand(GetTickCount());return(INIT_SUCCEEDED);}
 void OnDeinit(const int reason){}
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {
    int
    aords,pords,ords=0,
    bs=-1,mingate=1,maxminspan=25;
    double
    hi=max(maxminspan,tifr),lo=min(maxminspan,tifr),Dhilo=Dpts(hi,lo),
    m01=slope(1),m05=slope(5),m15=slope(15),
    v01=10,v05=.5*v01,v15=.15*v01;
   
    if(m01<mingate && m05<mingate && m15<mingate) bs=2;
    if(m01<-v01 && m05<v05 && m15<v15) bs=1;
    if(m01>v01 && m05>v05 && m15>v15) bs=0;
   
    ords=ordersforsymbol(aords,pords);

    switch(bs)
      {
       case  0:
          Comment("BUY");
          break;
       case  1:
          Comment("SEL");
          break;
       case  2:
          Comment("MIN");
          if(ords==0) placepending(Btkt,Stkt,hi,lo,Dhilo);
          break;
       default:
          Comment("NUL");
          break;
      }
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double slope(int timeframe)
 //computes slope between midpoints of bar1 and bar0 for timeframe
   {
    double
    b0=(iHigh(NULL,timeframe,0)+iLow(NULL,timeframe,0))/2,
    b1=(iHigh(NULL,timeframe,1)+iLow(NULL,timeframe,1))/2,
    m=(b0-b1)/timeframe/Point;

    return m;
   }
 void placepending(int &Btk,int &Stk,double hi,double lo,double Dhilo)
 //moves pending orders close to hilo
   {
    double
    m=1*Point,sl=110*Point,
    Bop=hi+3*m,Bsl=hi-sl,Btp=Bop+5*Dhilo*Point,
    Sop=lo-3*m,Ssl=lo+sl,Stp=Sop-5*Dhilo*Point;
    Btk=OrderSend(Symbol(),OP_BUYSTOP,lots,Bop,0,Bsl,Btp);
    Stk=OrderSend(Symbol(),OP_SELLSTOP,lots,Sop,0,Ssl,Stp);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void deletpending(int Btk,int Stk)
 //deletes pending order leaving only active one
   {
    bool o;
    int Bty,Sty;
    o=OrderSelect(Btk,SELECT_BY_TICKET);Bty=OrderType();
    o=OrderSelect(Stk,SELECT_BY_TICKET);Sty=OrderType();
    if(Bty==OP_BUY) o=OrderDelete(Stk);
    if(Sty==OP_SELL) o=OrderDelete(Btk);

   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double p2,double p1)
 //difference between two prices p2-p1 in points
   {
    return (p2-p1)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double max(int nbars,int timeframe)
 //finds the max price over the past n bars
   {
    return iHigh(NULL,timeframe,iHighest(NULL,timeframe,MODE_HIGH,nbars,0));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double min(int nbars,int timeframe)
 //finds the min price over the past n bars
   {
    return iLow(NULL,timeframe,iLowest(NULL,timeframe,MODE_LOW,nbars,0));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void drawhline(string label,double Vue,color acolor)
 //draws hline of particular color
   {
    ObjectDelete(label);
    ObjectCreate(label,OBJ_HLINE,0,Time[0],Vue);
    ObjectSet(label,OBJPROP_COLOR,acolor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double modrand(int divisor)
 //generates random number and mods it with divisor
   {
    return fmod(rand(),divisor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void bs(int ot,double op,double sl,double tp)
 //buy or sell an order
   {
    bool os=OrderSend(Symbol(),ot,lots,op,0,sl,tp,"",0,0);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int ordersforsymbol(int &aords,int &pords)
 //calculates number of orders that have been placed for a particular symbol
   {
    for(int pos=OrdersTotal()-1; pos>=0; pos--)
      {
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUYSTOP || OrderType()==OP_SELLSTOP))
          pords++;
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUY || OrderType()==OP_SELL))
          aords++;
      }
    return aords+pords;
   }
 //+------------------------------------------------------------------+

*** hapist type going for only 50p
*** pradomizer
 a randomized trading program relying on rr to win (and may be some other things)
**** code
 //+------------------------------------------------------------------+
 //|                                                    pradapter.mq4 |
 //|                        Copyright 2015, MetaQuotes Software Corp. |
 //|                                             https://www.mql5.com |
 //+------------------------------------------------------------------+
 #property copyright "Copyright 2015, MetaQuotes Software Corp."
 #property link      "https://www.mql5.com"
 #property version   "1.00"
 #property strict
 #define sp " "

 /*

 */

 int      tkt,tifr=1;
 double   lots=0.1;
 bool     zz;

 int OnInit() {srand(GetTickCount());return(INIT_SUCCEEDED);}
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void OnTick()
   {
    int
    aords=0,pords=0,ords=ordersforsymbol(aords,pords);;
    mcdetector(5,tifr);

    if(ords<1)
      {
       opn(tkt);
      }
   /* else
      {
       alt(tkt);
      }*/
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void opn(int &tk)
 //opens a trade
   {
    int bs=-1,lev=0;
    double sl=10*Point,tp=10*Point,op=0;

    prandomer(bs,op,sl,tp);
   

    tk=OrderSend(Symbol(),bs,lots,op,lev,sl,tp);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void alt(int tk)
 //alters the trade
   {
    zz=OrderSelect(tk,SELECT_BY_TICKET);
    int bs=OrderType();
    double
    oop=OrderOpenPrice(),
    ocp=OrderClosePrice(),
    tp=OrderTakeProfit(),
    sl=OrderStopLoss();
   }
 void prandomer(int &bs,double &op,double &sl,double &tp)
 //gets randomized values for entry
 {
    bs=fmod(rand(),2);
   
    switch(bs)
      {
       case  0:
         op=Ask;
         sl=op-(fmod(rand(),50)+90)*Point;
         tp=op+(fmod(rand(),50)+90)*Point;
         break;
       case  1:
         op=Bid;
         sl=op+(fmod(rand(),1000)+50)*Point;
         tp=op-(fmod(rand(),1610)+50)*Point;        
         break;
       default:
         break;
      }
 }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void mcdetector(int bars,int timeframe)
 //determines market condition type based on price activity of last bars
   {
    double sum=0,dif=0,acc=0;
   
    dif=maxmin(bars,timeframe);
    for(int i=0;i<=bars;i++)
       acc+=iClose(NULL,timeframe,i)-iOpen(NULL,timeframe,i);
    sum=round(acc/Point);
    Comment(sum,sp,dif);
   
   }
 double maxmin(int bars,int timeframe)
 //calculates the difference btn maxmin taking order into account
 {
    int maxbar=iHighest(NULL,timeframe,MODE_HIGH,bars,0),minbar=iLowest(NULL,timeframe,MODE_LOW,bars,0);
    double diff=max(bars,timeframe)-min(bars,timeframe);

    if(maxbar>minbar) diff=-diff;   
    return round(diff/Point);
 }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double Dpts(double p2,double p1)
 //difference between two prices p2-p1 in points
   {
    return (p2-p1)/Point;
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double max(int nbars,int timeframe)
 //finds the max price over the past n bars
   {
    return iHigh(NULL,timeframe,iHighest(NULL,timeframe,MODE_HIGH,nbars,0));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double min(int nbars,int timeframe)
 //finds the min price over the past n bars
   {
    return iLow(NULL,timeframe,iLowest(NULL,timeframe,MODE_LOW,nbars,0));
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 void drawhline(string label,double Vue,color acolor)
 //draws hline of particular color
   {
    ObjectDelete(label);
    ObjectCreate(label,OBJ_HLINE,0,Time[0],Vue);
    ObjectSet(label,OBJPROP_COLOR,acolor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 double modrand(int divisor)
 //generates random number and mods it with divisor
   {
    return fmod(rand(),divisor);
   }
 //+------------------------------------------------------------------+
 //|                                                                  |
 //+------------------------------------------------------------------+
 int ordersforsymbol(int &aords,int &pords)
 //calculates number of orders that have been placed for a particular symbol
   {
    for(int pos=OrdersTotal()-1; pos>=0; pos--)
      {
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUYSTOP || OrderType()==OP_SELLSTOP))
          pords++;
       if(OrderSelect(pos,SELECT_BY_POS) && OrderSymbol()==Symbol() && 
          (OrderType()==OP_BUY || OrderType()==OP_SELL))
          aords++;
      }
    return aords+pords;
   }
 //+------------------------------------------------------------------+

** old ideas and systems
*** DoHaVo
  donchian, heiken ashi, volume
  suggestions should be prefaced with 'often' if not done so already
  rules should be prefaced with 'almost'
  watch volume for confirmation
  utilize M when possible
  make use of postion ratio and orderbook when possible

  READ (right entry and direction) rules
  00: never do market order - only entry orders limit or stop
  Tl: limit entry near step with sl on next step at least
  Ts: stop entry just beyond last LU
  Rl: limit entry near LUM with sl on otherside of LU
  Rs: stop entry near step with sl beyond LU
  Dl: identify and trade range if large enough in direction of larger trend

**** Ranging
  l at LUM going in same direction as major trend
  s further from LU if going in opposite direction to major trend
  Do:
  - near horizontal LU
  Ha:
  - long heads and sometimes tails
  - dojis
  Vo:
  - larger than usual signals beg/end of tren
**** Squeezing
  l at edges
  s outside edges
  Vo:
  - small range somewhere between UM or LM or on M
  Ha:
  - candles mixed in color
  - heads and tails present
  Vo:
  - low and consistent level
  - may be larger if many doji-like candles are there
**** Trending
  l catching formed steps
  s if not sure whether pullback will continue further
  Do: 
  - cling to LU or mostly away from M
  - LUM forms steps or at least further LU is flat
  - retracements can bounce off prior steps or M
  - rarely bounces off LU and then only for a bit
  Ha: 
  - no tails, short heads
  - color changes provide discounted entry points
  - look for possible sr on opposite direction color changes
  Vo:
  - larger than usual signals beg/end of trend
  - on a doji volume can get large
 - Xplorer
 Price clinging to angled UL lines
 Steps on both UL, but more so on line further from direction
 No tails on candles
 Volume hi|lo can signal beg|end of trend
 - Ranger
 Horizontal ULM lines forming sr
 Mismash of candles or small waves
 Volume generally low - so look for spikes
*** CHAnuELS
 Look for nu inside of channels or near sr (found by autochartist).
 1. Setup on 240 with ma:6(1da), 36(1wk), 216(1.5mo) to provide movement indication and to confirm interim nu opportunities. The ma choices make it unnecessary to examine different timeframes.
 2. Signals from autochartist (confluence in direction and pattern) as well as ma recommendations from tradingview should be sufficient first sift or continuation confirmations. However, there may be possibilities with other items so consider checking oanda forexlabs (eg heatmaps, currency volatility, candlestick patterns, oandabook etc) initially as confirmations. Going though each item in list to see if nu exist or are forming is probably awkward, so sifting is a sensible approach in all likelihood.
 3. Orders can be market or entry. Annotate the chart with note and show autochartist or tradingview if available and screenshot. Entry orders should have sltp on nearest whole number. Then mvtrade xxxxxxM or xxxxxxE. Sometimes xxxxxxA can be done (likely on a fullscreen) if more detailed analysis or commentary is desired. Set sltp at nu or whole and usually <1:2 simply because we may take advantage of spike.
*** grid500
 done on 4hr chart with sr at 500pts
 generally good turning points here though price may go nearly to halfway before reversing.
 worth trying to understand why halfway is significant.
*** rit
 ranging, indecisive, trending
 combines ideas from hapi variations and others
**** process
 *entry*
 - if not I
   - if R try to enter at defining levels
   - else T
     - identify 1m mai
     - identify 1m potential patterns like hathre, miimai etc
     - check aso and sr on longer timeframes
     - check sr coordination possibilities with 1m aso
     - enter on aso 1m amplitute zero or just past max

 *manage*
 - position sl/tp at appropriate sr
 - utilize concept of invalidation
 - move to breakeven when opportunity presents itself

 *exit*
 - apply concept of repositioning instead of staying in losing trades
 - near sr bounce expectations
 - on extended moves which are likely to bounsr
 - anytime to grab p if movement is dubious

**** brief
 market movement is the result of relative numbers of buyers and sellers. we have 2:1 advantage win/pass vs lose, so use the odds.

 there are three market situations Ranging Indecisive Trending. after identifying which situation is currently in force, we apply the haosfine methods appropriately.

 hasofine uses heiken ashi, aso, fibsr, news with the perfect number 6 as a point of interest. we work from 1m chart where there are usually 6+ good trades every 1h in tradable market. additionally, trader sentiment seems to oscillate in 6ha cycles with considerable consistency on the 1m chart.

 - enter only on pullbacks to a logical sr and/or on aso minmax amplitudes
 - do not enter on extremities unless there is very clear momentum
 - be agile

**** market
 *R* anging\\
 Prices are trading between two levels. The best opportunities are often present at the edges (bounsr or penesr), though it is possible to catch parts of the movement from inside if one maps out sr properly. Set out the range boundaries accurately and use them both inside and outside. Make use of subranges within the larger range too.

 *I* ndecisive\\
 It is unclear what the market is up to. Shapes here include dithers, wedges and pennants. This category also includes untradeable situations like high volatility or random fluctuations. Don't trade these. The technique is to put entries on either side of the action beyond established sr in order to catch a breakout.

 *T* rending\\
 Typical trend which can be traded using mima. There are two variations fast (mai >> mii where we should not try to trade the latter) and slow (mai > mii where we can try to trade the latter because it is essentially a slightly tilted range). Also, on the slow, it is better to enter at more distant pullbacks.

**** patterns
 on the 1m, these patterns tend to produce at least a 6p move. mima and pesr require some sort of a trending market, while hathre and bounsr can work anywhere.

***** momtum (strong movement 90%)
 *any after first 3 bars in mai, but avoid extremity entering* 
 momentum is building during first 3. after these, mai may be strong for sometime. the momentum or heiken ashi indicators may be good ones to catch this action.
***** miimai (mii pullback to mai 90%)
 *any of 1st 3ha of mii or on color change to mai* 
 a pullback from the mai forms a mii which subsequently reverses to join mai again. these pullbacks seem to last no more than 3ha especially in a trending market resulting in far fewer ha than mai. if there are more than 3ha then we should be cautious that a trend reversal may be taking place as mii becomes mai.
***** bounsr (bounce off sr 80%)
 *0th or 1st ha after sr bounce/wickening - catch at extremity* 
 particularly effective with large wicks. small number of pips can be picked up right away and sometimes the move can result in a major reversal. there will likely be a bounce unless the body of ha gets through in which case mai continues (unless there is weaving). the difficulty lies with getting in when the wick is at its maximum calling for good anticipation and quick reflexes.
***** double (twin tops and bottoms 90%)
 this is a fairly standard pattern that often leads to big moves. after two failed attempts to go in a certain direction, traders give up taking the path of least effort. tweezers are a compressed subset of these.

***** dither (catch volatility 80%)
 when prices are dithering place entry orders on either side. be ready to come out quickly though, since the breakout may be short-lived.
 
***** brkout (strong move beyond 80%)
 breakouts usually occur after some sort of congestion shape such as dither, wedges or pennants. they also can take place when price moves beyond a range's levels such as defining 0% or 100% fibs. so long as it is not a fake (unlikely on a 1m), large unidirection action can be expected.
***** wicken (long wick reversal 70%)
 a long wick often generates a move in the opposite direction. the move may be delayed by several candles and there may be more than one wick candle. it is important to realize that entry is made sometime after the wick candles close.
***** penesr (penetrate sr with candle bodies 70%)
 *1st candle after body penetrates sr - catch on bounce back to sr if possible*
 this seems to work better on 5m, but not so well on 1m. if candlebodies (rather than just the wick) continues through pivot then chances are good that there will be more movement in the same direction. this pattern works really well in trending situations, but not so when there are tight weaves or high volatility. on the 1m, it usually takes at least two penetrations separated by 3ha before the price really moves significantly because of the fluctuations within such a short time span. in a mai, there is likely better chance of success because of the momentum already in place.
***** weaves (narrow sideways wrap around sr 70%)
 these occur on sr and are essentially a compressed range. they disrupt the usual reflection or penetration of at an sr causing it to act like an attractor. only trade these carefully from the edges as with any range. they are very risky to trade from the middle. 
**** concepts
***** invalidation
 when a trade is sensibly stopped out, the original idea of entering at the chosen point is no longer valid. sr is valid until broken, but may still be influencial later on.
***** repositioning
 if a trade is invalidated, we have an opportunity to re-enter it from a better vantage point sometimes in the opposite direction.
***** agility
 the markets continuously change direction, so we must be ready to do the same. wanting prices go against our position, wishing it would be otherwise is a silly state.

 therefore, when prices move sufficiently against our chosen position (aka invalidation), exit and evalutate. we may re-enter in the same direction from a better vantage point or enter with the current movement (repositioning).

 also, when prices stall on an extremity while going with our position, it may be advantageous to exit, wait for a pullback and re-enter. to be sure not to miss out if there is continuation, place an entry order on the projected path.
***** opportunity
 there are at least 6 good trades every hour. however, there are likely several more trades yielding at least 6p within that hour too. these trades are acquirable if we understand the sr terrain.
***** phasing
 to be in phase with the market requires correct action at sr since there are often bounces at these levels (macro), as well as proper entry within a candle in the furthest quarter (micro). reactionary trading will always lose since entry is after the fact. the simplest way to go out of phase is often to go in the same direction as the extremity and use tight stops. aso is an excellent indicator for showing the alternating market sentiment that seems to cycle on 1m every 6ha and therefore assists one to stay in phase.
***** duration
 if trading with mai, one can stay in longer usually than if trading with mii. 
***** bodsor
 buy on dips sell on rallies is the most advantageous approach provided it is done properly. it is the primary principle of range trading and all market movements are range-like in essence since the retracement is omnipresent.
**** progress
 the goal is to make a certain amount $ over each of the three 6h periods (06-12, 12-18, 18-24) that we will trade in using increasing lotsizes. the amount made each day is calculated using the formula (* lotsize value/p).

 |-------+---------+--------+---------+------------|
 | stage | lotsize | margin | pips/pp | amount/day |
 |-------+---------+--------+---------+------------|
 | A     |       6 |    420 |       6 |      10.80 |
 |       |         |        |      36 |      64.80 |
 |       |         |        |     216 |     388.80 |
 |-------+---------+--------+---------+------------|
 | B     |      66 |   4620 |       6 |     118.80 |
 |       |         |        |      36 |     712.80 |
 |       |         |        |     216 |    4276.80 |
 |-------+---------+--------+---------+------------|
 | C     |     666 |  46620 |       6 |    1198.80 |
 |       |         |        |      36 |    7192.80 |
 |       |         |        |     216 |   43156.80 |
 |-------+---------+--------+---------+------------|
*** hapi variations
**** hapist (Heikin Ashi PIvotpoint STochastics)
 use the Thapist.cht template to setup on 15m charts.

 don't object to coming out of losing/winning positions early, because usually they can be entered more opportunely either in the same or opposite direction. at the same time, don't exit a position prematurely on a whim because things can reverse quickly as eurjpy just did 8:23am being down 6.5p and reversing to hit the stop after we'd changed direction.

 market order trade settings are 9p stop and 9p limit. adjust these to s/r.

 don't enter without checking the terrain carefully especially in choppy markets. also, consider what is happening with parallel pairs (eg eurusd and gbpusd often move together).

 correct entry means everything and is far more important than r/r.

***** Entry Hierarchy

 *HA* shows the trend and its strength. long wicks in same direction of the trend implies strength. double wicks suggest uncertainty.

 *ST* shows likihood of trend continuation and/or reversal. when green line crosses red, price action will reverse direction especially if it occurs in the top or bottom zones. while green and red are separate, the trend should continue. ignore the over bought/sold concept since it is meaningless. it should be read in conjunction with previous prior price action ie if there has been a lot of long, then it is likely that the shorts will be shorter. settings used are 9,5,3,ema,ema with seems to work especially well on 5m the %D period being 5 gives a good signal for entry when it changes slope and its 0 slope indicates that the trend will continue. aa, enter on %D inflections or crosses, but exit on %K inflections. pay particular attention to %D slope.

 *noSR* means not opposing s/r. movement can stall or bounce near s/r which can be formed from pivot points, fib as well as manual drawing from past and/or present price action. sometimes when s/r is broken, prices can reverse as though exhausted by the effort it took to get through, but they can also accelerate their progress in the same direction.


 +---------+----+----+------+------------------------------------+
 | Entry   | HA | ST | noSR | comment                            |
 +---------+----+----+------+------------------------------------+
 | alpha   | T  | T  | T    | all thrusters firing               |
 +---------+----+----+------+------------------------------------+
 | beta    | T  | F  | T    | ST sometimes misleads              |
 +---------+----+----+------+------------------------------------+
 | gamma   | F  | T  | T    | ST sometimes anticipates           |
 +---------+----+----+------+------------------------------------+
 | delta   | T  | T  | F    | be cautious when in vicinity of SR |
 +---------+----+----+------+------------------------------------+
 | epsilon | T  | F  | F    | be careful since 2 against one     |
 +---------+----+----+------+------------------------------------+

 *alpha* trade has good chance of going far because of HA and ST agreement while noSR. often these are the beginning of a significant move. we should be regularly scanning for these. these may be particularly strong when in the same direction as the larger trend.

 *beta* since ST has a tendency to not align with reality at times due to its lagging nature, trades where HA is showing a strong trend which is noSR, will likely produce a good move.

 *gamma* when HA is fluctuating or in disagreement with ST, it could reverse because of the latter's tendency to predict what direction price action may move. so long as we are noSR, and the HA candle bodies are short and/or have double wicks, there is a likelihood of a reversal.

 *delta* even though HA and ST agree, you can have stalling or bounces near SR, therefore, entry needs to be made cautiously. sometimes, SR will be broken, so the trade is still viable or a bounce can be taken advantage of.

 *epsilon* anytime we have two indicators opposing one (even HA), one should be very careful entering. usually, we should wait till a more favorable situation develops.

***** Notes
 a double scanning system is needed. one is to observe what is happening with various pairs for which outside input (eg news, speculation, trend, technical analysis) can be useful. the second is to monitor what prices are doing within a pair since entry/exit should be done on the basis of how the market is moving. catching the wave at the right candle and getting off at the optimal position makes pips.

 in scraping, it is not so much that you end up on the wrong side, as you've entered at the wrong point.

 sometimes dojis work our way and sometimes they don't. therefore, it is usually a good idea not to rush in until we are fairly certain what the next trend is going to be.

 when there are 2 wicks, the market is unsure, so we should stay out or just try to trade small ranges for only a few pips (possibly using cot).

 be very aware of s/r and the behavior near them. going in prematurely in their vicinty can result in undesirable bounces. it may be better to set an entry on the other side of s/r.

 it can be difficult when there is rapid movement within a single candlestick, so go to a smaller timeframe to get a better idea of what is happening.

 when ST and HA are not in agreement with each other, it is best to wait for clarity and make use of any s/r clues. there is no need to rush in as we did with eurusd, gbpusd and audusd (around 6pm 141110) when the HA was blue, but ST indicated a downward movement. remember we always want to be a few pips ahead asap.

 when up by 9p, advance the stoploss to just past breakeven. trail stops with 9p to stay consistent.

 the stochastic greenline indicates the most recent price action and can often be useful to detect changes.

 in choppy and/or slow markets, there is nothing wrong in grabbing a small number of pips repeatedly.

 sometimes the choice of direction will be correct, but the limit distance will not be hit.

 don't trade many pairs at once. if things go against you then it's difficult to keep track of.

 one should be clear about the intent of this approach. it is to get in optimally and get out after a reasonable profit. it is not to stay in for a long period of time because prices will necessarily keep going in one's favor.

 when there is a strong trend, don't go against it unless you aim only for small pips.

 let go of trades that aren't enthusiastic to make room in the quota.

 when prices go flat, always work from 1m.

 it is usually a good idea not to try to outguess or override the indicators.

 trading 1m can be tricky since it is sometimes quite fickle.
**** hapine5
 hapine5 uses heiken ashi, pivot, news and is pentagonized around the number 5.

 - market movement is the result of relative numbers of buyers and sellers
 - you always have a 2:1 advantage: win or not trade vs lose
 - watch all, trade only best (no more than 2 pairs at a time)
 - lose small, enter often, gain large: minimize loss, maximize win, be agile
 - there are usually only 5 good trades per hour per pair in a trending market

***** enter
 *trade only when market conditions define mat clearly and go in near established sr.*
 - mat5: go with trend preferably using pullbacks
 - mima: rejoin trend preferable when color changes to mat
 - bosr: go against immediate trend when sr encountered

***** manage
 *apply concept of invalidation to all trades.*
 - position stop/limit at sr whenever possible, but permit only 2.5p loss usually
 - when >2.5p profit, move stop to entry point
 - when >5p profit, move stop to 2.5p
 - when >10p profit, move stop to 5p
***** exit
 *apply concept of repositioning instead of staying in losing trades.*
 - near sr bounce expectations (re-entry possible if sr broken)
 - anytime to grab p if market is slow (build up to 5p if necessary)
 - anytime prices go against (don't have to wait for stop to be hit)

***** patterns
 the bosr and mima are particularly effective near sr regions like pivots. therefore, we should use the roadmap that 4hr pivots (especially bounces) offer, but be careful not to get into a pivot weave or mindless entries. always try to use ha to its advantage.

****** bosr (bounce off sr +90%)
 *0th or 1st ha after sr bounce/wickening - catch at extremity* 
 larger number of opposers waiting at sr in ambush resulting in sudden and sometimes significant move opposite to the immediate direction. small number of pips can be picked up right away and sometimes the move can result in a major reversal. there will likely be a bounce unless the body of ha gets through in which case mat continues (unless there is weaving).

****** mima (mit pullback to mat 85%)
 *any of 1st 5ha of mit on color change* 
 a pullback from the mat forms a mit which subsequently reverses to join mat again. these pullbacks seem to last no more than 5ha. if there are more than 5ha then we likely have a trend reversal as mit becomes mat. the pullback essentially runs out of atrenders and is likely to happen at sr.

****** mat5 (first 5ha in mat 80%)
 *any of first 5ha in mat - avoid extremity* 
 momentum is still building. after these, mat still may be strong, but one should enter more cautiously since there may be profit takers getting off board especially if substantial gains have been made, mima or even bosr opportunities arise.

***** concepts
****** invalidation
 when a trade is stopped out, the original idea of entering at the chosen point is no longer valid.
****** repositioning
 if a trade is invalidated, we have an opportunity to re-enter it from a better vantage point (often in the opposite direction).

****** opportunity
 there are likely no more than 5 good trades every hour under reasonable market conditions, so if we are trying for more, many will fail.
**** hapine4
***** preamble
 hapine4 uses heiken ashi, pivot, news with the number 4 as a point of interest. we work from 1m chart. the short timeframe not only permits closer monitoring, it can is subject to larger movements from the longer sessions. 

 - market movement is the result of relative numbers of buyers and sellers
 - we have 2:1 advantage win/pass vs lose, so use the odds
 - watch all, trade best
 - lose small, gain large: be agile
 - on 1m, there are usually 4+ good trades every 1h in tradable market

***** trade eme

 *enter:* all 4 conditions below must be met for trade to take place
 - *m* arket is tradable (not inactive or volatile)
 - *i* nclination for mai and mii have been established
 - *s* pread < .8
 - *o* pportunity is one of pesr | bosr | mima | hai4  
 *manage:* apply concept of invalidation to all trades.
 - position stop/limit at sr whenever possible, but permit only 2p loss usually
 - when >4p profit, move stop to breakeven
 - when >8p profit, move stop to 4p
 *exit:* apply concept of repositioning instead of staying in losing trades.
 - near sr bounce expectations (re-entry possible if sr broken)
 - anytime to grab p if movement is dubious (build up to 4p if necessary)

***** patterns
 on the 1m, these patterns tend to produce at least a 4p move. mima and pesr require some sort of a trending market, while hai4 and bosr can work anywhere.

****** mima (mii pullback to mai 90%)
 *any of 1st 4ha of mii or on color change to mai* 
 a pullback from the mai forms a mii which subsequently reverses to join mai again. these pullbacks seem to last no more than 4ha especially in a trending market resulting in far fewer ha than mai. if there are more than 4ha then we should be cautious that a trend reversal may be taking place as mii becomes mai.

****** hai4 (first 4ha in mai 90%)
 *any of first 4ha in mai - avoid extremity entering* 
 momentum is building during these 4ha. after these, mai still may be strong, but one should enter more cautiously since there may be profit takers getting off board especially if substantial gains.
****** bosr (bounce off sr 85%)
 *0th or 1st ha after sr bounce/wickening - catch at extremity* 
 particularly effective with large wicks. small number of pips can be picked up right away and sometimes the move can result in a major reversal. there will likely be a bounce unless the body of ha gets through in which case mai continues (unless there is weaving).
 
****** pesr (penetrate sr with candle body 80%)
 *1st candle after body penetrates sr - catch on bounce back to sr if possible*
 if candlebody (rather than just the wick) continues through pivot then chances are very good that there will be more movement in the same direction. this pattern works really well in trending situations, but not so when there are tight weaves or high volatility. on the 1m, it may take more than one penetration before the price really moves significantly because of the fluctuations within such a short time span. in a mai, there is likely better chance of success.
***** concepts
****** invalidation
 when a trade is stopped out, the original idea of entering at the chosen point is no longer valid. sr is valid until broken, but may still be influencial later on.
****** repositioning
 if a trade is invalidated, we have an opportunity to re-enter it from a better vantage point (often in the opposite direction).

****** opportunity
 there are at least 4 good trades every hour under tradable conditions. however, there are likely several more trades yielding at least 4p within that hour too. these trades are acquirable if we understand the sr terrain.

****** sr status
 sr can be repellers (bosr) or attractors (weaving).
****** phasing
 to be in phase with the market requires correct action at sr since there are often bounces at these levels (macro), as well as proper entry within a candle in the furthest quarter (micro). reactionary trading will always lose since entry is after the fact.
***** progress
 4p/h for total of 16p over each 4h pivot change time period (06-10, 10-14, 14-18, 18-22) resulting in 64p/d.

 | volume | margin | amount |
 |      4 |    280 |     25 |
 |     44 |   3080 |    280 |
 |    444 |  31080 |   2840 |
 |   4444 | 311080 |  28440 |

***** notes
 where is the range?
 what is mai?
 is sr attractor or repeller?
 cross-checking with other pairs often reveals insights.
 check news events.
*** simple trade the news strategy
 1. Have your client open and logged in a half hour before the announcement. This is to ensure that you have everything set and ready to go, just in case of any problems. As always, you can never be too prepared!

 2. Set your chart to 5-minute increments.

 3. Wait for the very first candlestick to close after the time of the announcement. The FOMC is at 2 P.M., so we wait until 2:05 P.M. If there is volatility, you will see the price bouncing and carving out a fairly large candlestick.

 4. Analyse the candlestick by asking the following questions:
 a. Is the candlestick prominent? If yes, proceed to b.
 b. Does the candlestick have a clear direction? If yes, proceed to c.
 c. Execute trade.

  In a majority of news price action movements that I've seen, A and B are easy criteria to fulfil and generally herald continued movement in that direction for at least a little while after the announcement. If the prominent candlestick is weak, then I am very wary of a potential reversal. The body of the candlestick must be at least 2/3rds of the entire stick. If 1/3rd of the candlestick is wick, there is strong counter pressure and I do not have confidence that price will continue that direction.
 [[http://www.forexfactory.com/news.php?do%3Dnews&id%3D513569][How to Generate Profits From Forex News Announcements]]
*** AWE (Appropriate Win Environment)
**** Principles
***** The market always returns
 The entire market can be viewed as a range because prices always return even at the macrolevel. The driving force for this behavior has to do with what happens at the microlevel where longs/shorts drive prices up/down.

 It is not necessary to look for fine structures within the charts. The only thing to remember is that the price will eventually return. This concept is reasonable because we do not have to take delivery in forex - we can just wait. Understand though, that we may be waiting a long time and experiencing considerable losses which, however, will dissolve when prices go in the gaining direction.

 While waiting pretty much guarantees the always win result, it is not the only way. By increasing orders in the winning direction, it is possible to overcome the deficiencies developing in the losing direction. Hence, we can close a losing trade and still win.

 It is important not to be in a hurry to exit a losing trade. See these as long-term investments just as we do with items in mutual funds sometimes.

 At the same time, get into what is thought to be a winning trade quickly since it is possible to limit losses for it.
***** The balancing act
 Stops are replaced with balancing long/short entry orders. Some of these may be triggered, but they do not necessarily have to be - in fact, we don't want them ot be! Instead, they serve as protection in case the market goes the 'wrong' way. Of course, there is no such thing as a 'wrong' way, because the prader does not really care.

**** Difficulties with conventional trading and the AWEnsers
***** Prediction with high probability
 In order to trade effectively we are told to make predictions which seem to have high probability of success. Various tools are available to supposedly increase this probabilty including fundamentals and the plethora of technical analysis indicators that assist in understanding price action.

 We can still use many of these to expedite a trade, but they are not necessary in theory. If we wait, we can get out of trades gracefully.

***** Entry/Exit determined by Risk/Reward
 If we are willing to wait and/or exit gracefully, there is no risk and only reward. Since prices always return, in theory, we can never lose.

***** If we are stopped out of the game, we can't win
 This is an on-going problem. Using stops to get out of a losing trade, creates the feeling and reality of loss. Yet, when prices go against a position, we are actually better positioned to collect even more pips. However, we are even advised to not trade after a series of losses.

 So, the first step might be to realize that when prices go against us, the situation is not so much an obstacle, but an opportunity. However, it may be difficult to appreciate this fact after prices universally go against with 100% consistency. Even thinking that if it can go 100% against, it can also go 100% for, may not help much unless we can utilize some mechanism of making it so.

 That mechanism is waiting in the long-term and adding trades which go with the retracement as well as against it, at the correct positions.

 If we are always in the game, we cannot lose.

***** Sufficient market volatility
 Without movement, nothing happens. However, sufficient volatility will enable enough movement so that the same mechanism can be applied so long as prices can overcome the pip spread.

**** Implementation of the Companions Of Trade
***** Companionship
 Every trade must be complemented with one of the opposite direction creating a hedged combination, known as a COT (Companion of Trade). A COT limits the total loss that can be experienced at any given time to the gap between the entry points for the trades (and of course the spread loss). The smaller the gap, the less effort it should take to exit the COT with profit, in theory.

 Gaining trades can be closed for profit, so long as losing trades are neutralized through addition of an appropriate entry in the same direction. Losing trades can be closed provided sufficient profit has been accumulated or we can simply wait for the market to return to the point where the particular trade shows profit.

 COTs can be generated as we wish forming clusters, though it is unlikely there is much benefit in letting it do so beyond say 6 in total. It is likely preferable to close trades that are in profit while adding compensatory entries at appropriate points.

 We should try to maintain an imbalance of open positions in the direction we think prices are going, but always have it compensated for with an entry trade.
***** Awareness
 Though we can theoretically never lose if we wait, pragmatically we should try to be reasonably efficient.

 If the price lies between the COT, then both positions are in a loss. However, when prices start moving in one direction or another, we can simply add to the COT with suitable gap and catch the profit produced by closing that particular combo and setup another.

 If the price zigzags, then it may be best to leave the COT alone till some reasonable trend develops. We can safely traverse the primary trend as well as retracements this way without concern of being stopped out for a loss.

***** Tools
 It is not necessary to predict beyond choosing a long or short position. The  COT handles money management automatically. It is necessary to be patient though of course.

 It is also advantageous to be able to traverse trends and retracements in an efficient fashion, so having some idea as to identifying these is useful. Candlestick patterns and visible support/resistance lines should be sufficient in determining roughly how prices will behave.

 Other technicals and fundamentals may be used to provide some idea of where things are going, but as we have experienced, these have often been misleading. Since even the most rudimentary and solid predictors such as support/resistance and candlesticks can be incorrect, they should be used only as guides working under the auspices of COT, through grace.

**** Techniques
***** GOG (Go Out Gracefully)
 Closing a trade in this environment requires some significant criterion largely because we make or lose money based on how it is done.

 The first point is to remember that, in theory, it is never necessary to come out until a trade makes a profit because prices always return. A loss is not really a loss until we exit.

 The second point is that it may be plausible to close a losing trade provided we have adequate compensation from elsewhere. For instance, say we went short at 100 and the price went up to 110. Instead of creating just a single COT, we create two: we go long to companion the short and a second long with an appropriately placed short to companion the second lower down where it will not be activated. Now as the price rises, we collect two pips for everyone lost. Hence, at 120 you achieve a breakeven point and anything beyond enables you to close all components of the trade with profit.

 The third point is to understand that closing a loss may sometimes be useful if we are concerned about the impact it might have on subsequent movements. For instance, if we have a short and a long where we think the long may dominate, we may wish to close the short, so that the long can increase in value without hinderance. Of course, if there is reason to think that the price may go down and then up, we should leave the short open and close it when it has moved sufficiently.

 In general, always look for optimal opportunities to close positions. Never close positions out of fear of loss.
***** CIC (Catch If Can)
 When the price goes beyond the COT gap, close the (un)profitable part and re-enter it higher than the price. The rationale is that the price will not trigger the entry order and will head in the opposite direction thus reducing the existing loss.

 This process is similar to placing a stop that provides sufficient play room.

 There are 2 costs:
 - incurring another spread
 - gap will increase

***** CAM (Chasing A Move)
 This technique has similarity to trailing stops and tends to not only lock-in pips gained, but also increases the chances of acquiring more. Consider a starting a COT with long at 100 and an inactive short at 80 and the price rises above the former to 150. It would not be sensible to leave the short at 80 because a falling price to 110 would eliminate 40 pips gained. Instead, if we move the short to 130 (maintaining the same 20 pip gap), the loss will only be 10 pips (20 pip gap minus 10 pip gain on the short). We could then exit the short and put a new companion at say 115, with the thought that prices will move up again.

 The difference between such a CAM and a trailing stop at 130 is that you lose 20 pips and are out of the trade.

***** GIP (Get In Phase)
 Though the trend may be your friend, we can become too dominated by it to the extent that we do not want to recognize a retracement or even a reversal. As a result, we hold on to the major trend hoping that retracements will fall into lin.
***** MIS (Minimal Is Simple)
 The cleanest expression of AWE is done with a single COT consisting of 1 long and 1 short.

***** WAG (Work a Gap)
 Catching retracements can be difficult since it is uncertain where they occur and how long they last. Hence, the way to deal with this dilemma is to simultaneously go with the retracement in the short-term and against it in the long-term.

 If we simply waited for the retracement to turn around and return, we get nothing. However, if we go with it and then come out, we gain the amount retraced.

 For instance, say we go short when the price is 100. The price drops to 70, so we gain 30 pips. Then it starts to retrace to 90. If we just wait, we'll have 'lost' 20, until the price returns to 70 and will still have the same 30 pip gain as we did before. Now consider if we had gone long at say 75 and come out at 85. We gain 10 pips. When the price goes back to 70, we have 10 pips more than we did before.

 This has implications in a couple of areas:
 - CIC widens the gap
 - how do we resolve this

 so the price will always be inside the gap or outside it. if the latter, we know what to do. if the former, we are losing both ways. this matter requires serious contemplation.

 the key has to be to create an imbalance. otherwise, we just keep widening the gap and get stuck in it.

**** To Be Thot
 - some sort of manual journaling system to keep track of COTs
 - creation of the AWE sentinal computer program
 - can we expect retracements at certain times?
 - staggered entries for retracements?
 - how do cycles fit in both temporally and pricewise?
 - increasing gap
 - losing trades are long-term winning trades
 - how to deal with spikes using multiple orders and limits
 - use high leverage because you really do not lose
*** scaprader
 so this is super scalping going for every movement within a constricted region usually identified by some fib lines.
 - long low, short high therefore jump in sooner rather than later
 - wait and collect pips wherever possible
 - if we can make 20pips that could be $200 with 100 volume
 - create border failsafes in case anything blows up

 how one builds up cots seems to affect one's pip collection.

 if one is in a clear trend, one should be very careful when going against it.

 being out of phase is likely an illusion that one turns into reality through a lot of work.

 trends are different in different timeframes.

 different fibs fit better in different timeframes.

 we should become more familiar with various shapes and even candlesticks perhaps, though these apparently work better in longer term trading.

 why can't scalping be like regular trading???

*** FEME (Find Enter Manage Evaluate)
**** Find
***** Leads
 Various sites provide leads that are worth examining:
 - [[https://plus.dailyfx.com/dailyfxsignals/fxsignals.do][trading signals]], [[https://plus.dailyfx.com/fxcentral/technicalAnalyzer.jsp][technical analyser]], [[https://plus.dailyfx.com/fxcmideas/intraday-story.do?storyName%3D/dailyfxplus/intraday-ssi/2014/10/31/SSI_2014-10-31_54654654.html][speculative sentiment index]], [[http://www.dailyfx.com/authors/bio/Ilya_Spivak][ilya]]
 - [[http://www.forexnews.com/blog/category/forex-news/trade-of-the-day/][forexnews trade of the day]] comes via email each day
 - [[http://www.actionforex.com/trading-signals/][actionforex trading signals]]

 Forex Reviews provides Timon's weekly projections by email. Dailyfx also gives a weekly analysis by email.

 Dailyfx provides news and analysis, but these should be carefully scrutinized because a lot of it amounts to gossip.
***** Chart Study
 We should be looking at each pair regularly to see what possibilities are developing and what opportunities already exist. Intercurrency analysis is also useful and be examined at a glance with [[http://www.fxstreet.com/technical-studies/currencies/heat-map/][heatmap]].
***** News Events
 These are best examined at [[http://www.forexfactory.com/][forexfactory]] and are linked into the actual charts [[http://www.forexfactory.com/market.php][here]]. We should keep a regular and continous observation on the latter in the one hour timeframe.
**** Enter
 Trend, technicals and fundamentals should determine how we enter a trade. It is also a good idea to keep track of various market openings, since volume is affected by these.
***** Trend Examination
 Trends, both local and global indicate whether to go long or short and for how long.
***** Technicals
 We should have systems in play for different types of trading. Long-term techniques will differ from short-term scalpings, for instance. Staples we should use though are
 - candlesticks
 - s/r
 - pivot points
 - fib
 - ichimoku?

 We can determine r/r using s/r.

 A fully developed strategy with is presented in [[file:tradingtexts/technique/The%20Day%20Trade%20Forex%20System%20%5BBortucene%20&%20Macy%5D.pdf][The Day Trade Forex System]] by Bortucene and Macy.

 Forex Target Trading provides their 'big boys' approach in [[https://www.youtube.com/watch?v%3D2x6acQ9B-Pc][How to find the Big Boys Targets]].

 Forex Reviews shows a tip for detecting trend changes early in [[https://www.youtube.com/watch?v%3DHXoE1uxObR8][Secret Tip To Detecting Trend Changes As Early As Possible in Forex]].

***** Fundamentals
 These need to back the global trend and provide some rationale for local trend when it is different from the former. For instance, price may move in a range or triangle as it is about to make the next big move or there may be a retracement.

 It is important to keep track of these because sometimes you may get significant moves different from the established trend and these may lead to reversals too.

 Fundamentals are probably best followed on [[http://www.forexfactory.com/][forexfactory]] though john kicklighter does regular and extensive analysis which should not be accepted blindly. Also, be wary of long-term predictions, since much can happen in between.
**** Manage
 A trade cluster can be composed of one or more trades on the same pair on the same theme. one may enter and exit the pair several times, go in for long time periods or scalp. Here are some mechanics to employ depending on what is happening with price action:
 - exit and follow (eaf) if price goes against entry by certain percent of stop
 - fickle as trend (fat) if it seems likely that we can make money on reversal
 - companion of trade (cot) if expecting resumption of original trend soon
 - more on way (mow) if trend seems to be increasing0 pace
 - less on way (low) if trend seems to be decreasing pace
**** Evaluate
 Examine each concluded trade cluster to see what could have been improved and why. We may see that much could have been predicted from past behavior of pairs.
*** DoHaVo
  donchian, heiken ashi, volume
  suggestions should be prefaced with 'often' if not done so already
  rules should be prefaced with 'almost'
  watch volume for confirmation
  utilize M when possible
  make use of postion ratio and orderbook when possible

  READ (right entry and direction) rules
  00: never do market order - only entry orders limit or stop
  Tl: limit entry near step with sl on next step at least
  Ts: stop entry just beyond last LU
  Rl: limit entry near LUM with sl on otherside of LU
  Rs: stop entry near step with sl beyond LU
  Dl: identify and trade range if large enough in direction of larger trend

**** Ranging
  l at LUM going in same direction as major trend
  s further from LU if going in opposite direction to major trend
  Do:
  - near horizontal LU
  Ha:
  - long heads and sometimes tails
  - dojis
  Vo:
  - larger than usual signals beg/end of tren
**** Squeezing
  l at edges
  s outside edges
  Vo:
  - small range somewhere between UM or LM or on M
  Ha:
  - candles mixed in color
  - heads and tails present
  Vo:
  - low and consistent level
  - may be larger if many doji-like candles are there
**** Trending
  l catching formed steps
  s if not sure whether pullback will continue further
  Do: 
  - cling to LU or mostly away from M
  - LUM forms steps or at least further LU is flat
  - retracements can bounce off prior steps or M
  - rarely bounces off LU and then only for a bit
  Ha: 
  - no tails, short heads
  - color changes provide discounted entry points
  - look for possible sr on opposite direction color changes
  Vo:
  - larger than usual signals beg/end of trend
  - on a doji volume can get large
 - Xplorer
 Price clinging to angled UL lines
 Steps on both UL, but more so on line further from direction
 No tails on candles
 Volume hi|lo can signal beg|end of trend
 - Ranger
 Horizontal ULM lines forming sr
 Mismash of candles or small waves
 Volume generally low - so look for spikes
*** CHAnuELS
 Look for nu inside of channels or near sr (found by autochartist).
 1. Setup on 240 with ma:6(1da), 36(1wk), 216(1.5mo) to provide movement indication and to confirm interim nu opportunities. The ma choices make it unnecessary to examine different timeframes.
 2. Signals from autochartist (confluence in direction and pattern) as well as ma recommendations from tradingview should be sufficient first sift or continuation confirmations. However, there may be possibilities with other items so consider checking oanda forexlabs (eg heatmaps, currency volatility, candlestick patterns, oandabook etc) initially as confirmations. Going though each item in list to see if nu exist or are forming is probably awkward, so sifting is a sensible approach in all likelihood.
 3. Orders can be market or entry. Annotate the chart with note and show autochartist or tradingview if available and screenshot. Entry orders should have sltp on nearest whole number. Then mvtrade xxxxxxM or xxxxxxE. Sometimes xxxxxxA can be done (likely on a fullscreen) if more detailed analysis or commentary is desired. Set sltp at nu or whole and usually <1:2 simply because we may take advantage of spike.
*** grid500
 done on 4hr chart with sr at 500pts
 generally good turning points here though price may go nearly to halfway before reversing.
 worth trying to understand why halfway is significant.
*** rit
 ranging, indecisive, trending
 combines ideas from hapi variations and others
**** process
 *entry*
 - if not I
   - if R try to enter at defining levels
   - else T
     - identify 1m mai
     - identify 1m potential patterns like hathre, miimai etc
     - check aso and sr on longer timeframes
     - check sr coordination possibilities with 1m aso
     - enter on aso 1m amplitute zero or just past max

 *manage*
 - position sl/tp at appropriate sr
 - utilize concept of invalidation
 - move to breakeven when opportunity presents itself

 *exit*
 - apply concept of repositioning instead of staying in losing trades
 - near sr bounce expectations
 - on extended moves which are likely to bounsr
 - anytime to grab p if movement is dubious

**** brief
 market movement is the result of relative numbers of buyers and sellers. we have 2:1 advantage win/pass vs lose, so use the odds.

 there are three market situations Ranging Indecisive Trending. after identifying which situation is currently in force, we apply the haosfine methods appropriately.

 hasofine uses heiken ashi, aso, fibsr, news with the perfect number 6 as a point of interest. we work from 1m chart where there are usually 6+ good trades every 1h in tradable market. additionally, trader sentiment seems to oscillate in 6ha cycles with considerable consistency on the 1m chart.

 - enter only on pullbacks to a logical sr and/or on aso minmax amplitudes
 - do not enter on extremities unless there is very clear momentum
 - be agile

**** market
 *R* anging\\
 Prices are trading between two levels. The best opportunities are often present at the edges (bounsr or penesr), though it is possible to catch parts of the movement from inside if one maps out sr properly. Set out the range boundaries accurately and use them both inside and outside. Make use of subranges within the larger range too.

 *I* ndecisive\\
 It is unclear what the market is up to. Shapes here include dithers, wedges and pennants. This category also includes untradeable situations like high volatility or random fluctuations. Don't trade these. The technique is to put entries on either side of the action beyond established sr in order to catch a breakout.

 *T* rending\\
 Typical trend which can be traded using mima. There are two variations fast (mai >> mii where we should not try to trade the latter) and slow (mai > mii where we can try to trade the latter because it is essentially a slightly tilted range). Also, on the slow, it is better to enter at more distant pullbacks.

**** patterns
 on the 1m, these patterns tend to produce at least a 6p move. mima and pesr require some sort of a trending market, while hathre and bounsr can work anywhere.

***** momtum (strong movement 90%)
 *any after first 3 bars in mai, but avoid extremity entering* 
 momentum is building during first 3. after these, mai may be strong for sometime. the momentum or heiken ashi indicators may be good ones to catch this action.
***** miimai (mii pullback to mai 90%)
 *any of 1st 3ha of mii or on color change to mai* 
 a pullback from the mai forms a mii which subsequently reverses to join mai again. these pullbacks seem to last no more than 3ha especially in a trending market resulting in far fewer ha than mai. if there are more than 3ha then we should be cautious that a trend reversal may be taking place as mii becomes mai.
***** bounsr (bounce off sr 80%)
 *0th or 1st ha after sr bounce/wickening - catch at extremity* 
 particularly effective with large wicks. small number of pips can be picked up right away and sometimes the move can result in a major reversal. there will likely be a bounce unless the body of ha gets through in which case mai continues (unless there is weaving). the difficulty lies with getting in when the wick is at its maximum calling for good anticipation and quick reflexes.
***** double (twin tops and bottoms 90%)
 this is a fairly standard pattern that often leads to big moves. after two failed attempts to go in a certain direction, traders give up taking the path of least effort. tweezers are a compressed subset of these.

***** dither (catch volatility 80%)
 when prices are dithering place entry orders on either side. be ready to come out quickly though, since the breakout may be short-lived.
 
***** brkout (strong move beyond 80%)
 breakouts usually occur after some sort of congestion shape such as dither, wedges or pennants. they also can take place when price moves beyond a range's levels such as defining 0% or 100% fibs. so long as it is not a fake (unlikely on a 1m), large unidirection action can be expected.
***** wicken (long wick reversal 70%)
 a long wick often generates a move in the opposite direction. the move may be delayed by several candles and there may be more than one wick candle. it is important to realize that entry is made sometime after the wick candles close.
***** penesr (penetrate sr with candle bodies 70%)
 *1st candle after body penetrates sr - catch on bounce back to sr if possible*
 this seems to work better on 5m, but not so well on 1m. if candlebodies (rather than just the wick) continues through pivot then chances are good that there will be more movement in the same direction. this pattern works really well in trending situations, but not so when there are tight weaves or high volatility. on the 1m, it usually takes at least two penetrations separated by 3ha before the price really moves significantly because of the fluctuations within such a short time span. in a mai, there is likely better chance of success because of the momentum already in place.
***** weaves (narrow sideways wrap around sr 70%)
 these occur on sr and are essentially a compressed range. they disrupt the usual reflection or penetration of at an sr causing it to act like an attractor. only trade these carefully from the edges as with any range. they are very risky to trade from the middle. 
**** concepts
***** invalidation
 when a trade is sensibly stopped out, the original idea of entering at the chosen point is no longer valid. sr is valid until broken, but may still be influencial later on.
***** repositioning
 if a trade is invalidated, we have an opportunity to re-enter it from a better vantage point sometimes in the opposite direction.
***** agility
 the markets continuously change direction, so we must be ready to do the same. wanting prices go against our position, wishing it would be otherwise is a silly state.

 therefore, when prices move sufficiently against our chosen position (aka invalidation), exit and evalutate. we may re-enter in the same direction from a better vantage point or enter with the current movement (repositioning).

 also, when prices stall on an extremity while going with our position, it may be advantageous to exit, wait for a pullback and re-enter. to be sure not to miss out if there is continuation, place an entry order on the projected path.
***** opportunity
 there are at least 6 good trades every hour. however, there are likely several more trades yielding at least 6p within that hour too. these trades are acquirable if we understand the sr terrain.
***** phasing
 to be in phase with the market requires correct action at sr since there are often bounces at these levels (macro), as well as proper entry within a candle in the furthest quarter (micro). reactionary trading will always lose since entry is after the fact. the simplest way to go out of phase is often to go in the same direction as the extremity and use tight stops. aso is an excellent indicator for showing the alternating market sentiment that seems to cycle on 1m every 6ha and therefore assists one to stay in phase.
***** duration
 if trading with mai, one can stay in longer usually than if trading with mii. 
***** bodsor
 buy on dips sell on rallies is the most advantageous approach provided it is done properly. it is the primary principle of range trading and all market movements are range-like in essence since the retracement is omnipresent.
**** progress
 the goal is to make a certain amount $ over each of the three 6h periods (06-12, 12-18, 18-24) that we will trade in using increasing lotsizes. the amount made each day is calculated using the formula (* lotsize value/p).

 |-------+---------+--------+---------+------------|
 | stage | lotsize | margin | pips/pp | amount/day |
 |-------+---------+--------+---------+------------|
 | A     |       6 |    420 |       6 |      10.80 |
 |       |         |        |      36 |      64.80 |
 |       |         |        |     216 |     388.80 |
 |-------+---------+--------+---------+------------|
 | B     |      66 |   4620 |       6 |     118.80 |
 |       |         |        |      36 |     712.80 |
 |       |         |        |     216 |    4276.80 |
 |-------+---------+--------+---------+------------|
 | C     |     666 |  46620 |       6 |    1198.80 |
 |       |         |        |      36 |    7192.80 |
 |       |         |        |     216 |   43156.80 |
 |-------+---------+--------+---------+------------|
*** hapi variations
**** hapist (Heikin Ashi PIvotpoint STochastics)
 use the Thapist.cht template to setup on 15m charts.

 don't object to coming out of losing/winning positions early, because usually they can be entered more opportunely either in the same or opposite direction. at the same time, don't exit a position prematurely on a whim because things can reverse quickly as eurjpy just did 8:23am being down 6.5p and reversing to hit the stop after we'd changed direction.

 market order trade settings are 9p stop and 9p limit. adjust these to s/r.

 don't enter without checking the terrain carefully especially in choppy markets. also, consider what is happening with parallel pairs (eg eurusd and gbpusd often move together).

 correct entry means everything and is far more important than r/r.

***** Entry Hierarchy

 *HA* shows the trend and its strength. long wicks in same direction of the trend implies strength. double wicks suggest uncertainty.

 *ST* shows likihood of trend continuation and/or reversal. when green line crosses red, price action will reverse direction especially if it occurs in the top or bottom zones. while green and red are separate, the trend should continue. ignore the over bought/sold concept since it is meaningless. it should be read in conjunction with previous prior price action ie if there has been a lot of long, then it is likely that the shorts will be shorter. settings used are 9,5,3,ema,ema with seems to work especially well on 5m the %D period being 5 gives a good signal for entry when it changes slope and its 0 slope indicates that the trend will continue. aa, enter on %D inflections or crosses, but exit on %K inflections. pay particular attention to %D slope.

 *noSR* means not opposing s/r. movement can stall or bounce near s/r which can be formed from pivot points, fib as well as manual drawing from past and/or present price action. sometimes when s/r is broken, prices can reverse as though exhausted by the effort it took to get through, but they can also accelerate their progress in the same direction.


 +---------+----+----+------+------------------------------------+
 | Entry   | HA | ST | noSR | comment                            |
 +---------+----+----+------+------------------------------------+
 | alpha   | T  | T  | T    | all thrusters firing               |
 +---------+----+----+------+------------------------------------+
 | beta    | T  | F  | T    | ST sometimes misleads              |
 +---------+----+----+------+------------------------------------+
 | gamma   | F  | T  | T    | ST sometimes anticipates           |
 +---------+----+----+------+------------------------------------+
 | delta   | T  | T  | F    | be cautious when in vicinity of SR |
 +---------+----+----+------+------------------------------------+
 | epsilon | T  | F  | F    | be careful since 2 against one     |
 +---------+----+----+------+------------------------------------+

 *alpha* trade has good chance of going far because of HA and ST agreement while noSR. often these are the beginning of a significant move. we should be regularly scanning for these. these may be particularly strong when in the same direction as the larger trend.

 *beta* since ST has a tendency to not align with reality at times due to its lagging nature, trades where HA is showing a strong trend which is noSR, will likely produce a good move.

 *gamma* when HA is fluctuating or in disagreement with ST, it could reverse because of the latter's tendency to predict what direction price action may move. so long as we are noSR, and the HA candle bodies are short and/or have double wicks, there is a likelihood of a reversal.

 *delta* even though HA and ST agree, you can have stalling or bounces near SR, therefore, entry needs to be made cautiously. sometimes, SR will be broken, so the trade is still viable or a bounce can be taken advantage of.

 *epsilon* anytime we have two indicators opposing one (even HA), one should be very careful entering. usually, we should wait till a more favorable situation develops.

***** Notes
 a double scanning system is needed. one is to observe what is happening with various pairs for which outside input (eg news, speculation, trend, technical analysis) can be useful. the second is to monitor what prices are doing within a pair since entry/exit should be done on the basis of how the market is moving. catching the wave at the right candle and getting off at the optimal position makes pips.

 in scraping, it is not so much that you end up on the wrong side, as you've entered at the wrong point.

 sometimes dojis work our way and sometimes they don't. therefore, it is usually a good idea not to rush in until we are fairly certain what the next trend is going to be.

 when there are 2 wicks, the market is unsure, so we should stay out or just try to trade small ranges for only a few pips (possibly using cot).

 be very aware of s/r and the behavior near them. going in prematurely in their vicinty can result in undesirable bounces. it may be better to set an entry on the other side of s/r.

 it can be difficult when there is rapid movement within a single candlestick, so go to a smaller timeframe to get a better idea of what is happening.

 when ST and HA are not in agreement with each other, it is best to wait for clarity and make use of any s/r clues. there is no need to rush in as we did with eurusd, gbpusd and audusd (around 6pm 141110) when the HA was blue, but ST indicated a downward movement. remember we always want to be a few pips ahead asap.

 when up by 9p, advance the stoploss to just past breakeven. trail stops with 9p to stay consistent.

 the stochastic greenline indicates the most recent price action and can often be useful to detect changes.

 in choppy and/or slow markets, there is nothing wrong in grabbing a small number of pips repeatedly.

 sometimes the choice of direction will be correct, but the limit distance will not be hit.

 don't trade many pairs at once. if things go against you then it's difficult to keep track of.

 one should be clear about the intent of this approach. it is to get in optimally and get out after a reasonable profit. it is not to stay in for a long period of time because prices will necessarily keep going in one's favor.

 when there is a strong trend, don't go against it unless you aim only for small pips.

 let go of trades that aren't enthusiastic to make room in the quota.

 when prices go flat, always work from 1m.

 it is usually a good idea not to try to outguess or override the indicators.

 trading 1m can be tricky since it is sometimes quite fickle.
**** hapine5
 hapine5 uses heiken ashi, pivot, news and is pentagonized around the number 5.

 - market movement is the result of relative numbers of buyers and sellers
 - you always have a 2:1 advantage: win or not trade vs lose
 - watch all, trade only best (no more than 2 pairs at a time)
 - lose small, enter often, gain large: minimize loss, maximize win, be agile
 - there are usually only 5 good trades per hour per pair in a trending market

***** enter
 *trade only when market conditions define mat clearly and go in near established sr.*
 - mat5: go with trend preferably using pullbacks
 - mima: rejoin trend preferable when color changes to mat
 - bosr: go against immediate trend when sr encountered

***** manage
 *apply concept of invalidation to all trades.*
 - position stop/limit at sr whenever possible, but permit only 2.5p loss usually
 - when >2.5p profit, move stop to entry point
 - when >5p profit, move stop to 2.5p
 - when >10p profit, move stop to 5p
***** exit
 *apply concept of repositioning instead of staying in losing trades.*
 - near sr bounce expectations (re-entry possible if sr broken)
 - anytime to grab p if market is slow (build up to 5p if necessary)
 - anytime prices go against (don't have to wait for stop to be hit)

***** patterns
 the bosr and mima are particularly effective near sr regions like pivots. therefore, we should use the roadmap that 4hr pivots (especially bounces) offer, but be careful not to get into a pivot weave or mindless entries. always try to use ha to its advantage.

****** bosr (bounce off sr +90%)
 *0th or 1st ha after sr bounce/wickening - catch at extremity* 
 larger number of opposers waiting at sr in ambush resulting in sudden and sometimes significant move opposite to the immediate direction. small number of pips can be picked up right away and sometimes the move can result in a major reversal. there will likely be a bounce unless the body of ha gets through in which case mat continues (unless there is weaving).

****** mima (mit pullback to mat 85%)
 *any of 1st 5ha of mit on color change* 
 a pullback from the mat forms a mit which subsequently reverses to join mat again. these pullbacks seem to last no more than 5ha. if there are more than 5ha then we likely have a trend reversal as mit becomes mat. the pullback essentially runs out of atrenders and is likely to happen at sr.

****** mat5 (first 5ha in mat 80%)
 *any of first 5ha in mat - avoid extremity* 
 momentum is still building. after these, mat still may be strong, but one should enter more cautiously since there may be profit takers getting off board especially if substantial gains have been made, mima or even bosr opportunities arise.

***** concepts
****** invalidation
 when a trade is stopped out, the original idea of entering at the chosen point is no longer valid.
****** repositioning
 if a trade is invalidated, we have an opportunity to re-enter it from a better vantage point (often in the opposite direction).

****** opportunity
 there are likely no more than 5 good trades every hour under reasonable market conditions, so if we are trying for more, many will fail.
**** hapine4
***** preamble
 hapine4 uses heiken ashi, pivot, news with the number 4 as a point of interest. we work from 1m chart. the short timeframe not only permits closer monitoring, it can is subject to larger movements from the longer sessions. 

 - market movement is the result of relative numbers of buyers and sellers
 - we have 2:1 advantage win/pass vs lose, so use the odds
 - watch all, trade best
 - lose small, gain large: be agile
 - on 1m, there are usually 4+ good trades every 1h in tradable market

***** trade eme

 *enter:* all 4 conditions below must be met for trade to take place
 - *m* arket is tradable (not inactive or volatile)
 - *i* nclination for mai and mii have been established
 - *s* pread < .8
 - *o* pportunity is one of pesr | bosr | mima | hai4  
 *manage:* apply concept of invalidation to all trades.
 - position stop/limit at sr whenever possible, but permit only 2p loss usually
 - when >4p profit, move stop to breakeven
 - when >8p profit, move stop to 4p
 *exit:* apply concept of repositioning instead of staying in losing trades.
 - near sr bounce expectations (re-entry possible if sr broken)
 - anytime to grab p if movement is dubious (build up to 4p if necessary)

***** patterns
 on the 1m, these patterns tend to produce at least a 4p move. mima and pesr require some sort of a trending market, while hai4 and bosr can work anywhere.

****** mima (mii pullback to mai 90%)
 *any of 1st 4ha of mii or on color change to mai* 
 a pullback from the mai forms a mii which subsequently reverses to join mai again. these pullbacks seem to last no more than 4ha especially in a trending market resulting in far fewer ha than mai. if there are more than 4ha then we should be cautious that a trend reversal may be taking place as mii becomes mai.

****** hai4 (first 4ha in mai 90%)
 *any of first 4ha in mai - avoid extremity entering* 
 momentum is building during these 4ha. after these, mai still may be strong, but one should enter more cautiously since there may be profit takers getting off board especially if substantial gains.
****** bosr (bounce off sr 85%)
 *0th or 1st ha after sr bounce/wickening - catch at extremity* 
 particularly effective with large wicks. small number of pips can be picked up right away and sometimes the move can result in a major reversal. there will likely be a bounce unless the body of ha gets through in which case mai continues (unless there is weaving).
 
****** pesr (penetrate sr with candle body 80%)
 *1st candle after body penetrates sr - catch on bounce back to sr if possible*
 if candlebody (rather than just the wick) continues through pivot then chances are very good that there will be more movement in the same direction. this pattern works really well in trending situations, but not so when there are tight weaves or high volatility. on the 1m, it may take more than one penetration before the price really moves significantly because of the fluctuations within such a short time span. in a mai, there is likely better chance of success.
***** concepts
****** invalidation
 when a trade is stopped out, the original idea of entering at the chosen point is no longer valid. sr is valid until broken, but may still be influencial later on.
****** repositioning
 if a trade is invalidated, we have an opportunity to re-enter it from a better vantage point (often in the opposite direction).

****** opportunity
 there are at least 4 good trades every hour under tradable conditions. however, there are likely several more trades yielding at least 4p within that hour too. these trades are acquirable if we understand the sr terrain.

****** sr status
 sr can be repellers (bosr) or attractors (weaving).
****** phasing
 to be in phase with the market requires correct action at sr since there are often bounces at these levels (macro), as well as proper entry within a candle in the furthest quarter (micro). reactionary trading will always lose since entry is after the fact.
***** progress
 4p/h for total of 16p over each 4h pivot change time period (06-10, 10-14, 14-18, 18-22) resulting in 64p/d.

 | volume | margin | amount |
 |      4 |    280 |     25 |
 |     44 |   3080 |    280 |
 |    444 |  31080 |   2840 |
 |   4444 | 311080 |  28440 |

***** notes
 where is the range?
 what is mai?
 is sr attractor or repeller?
 cross-checking with other pairs often reveals insights.
 check news events.
*** simple trade the news strategy
 1. Have your client open and logged in a half hour before the announcement. This is to ensure that you have everything set and ready to go, just in case of any problems. As always, you can never be too prepared!

 2. Set your chart to 5-minute increments.

 3. Wait for the very first candlestick to close after the time of the announcement. The FOMC is at 2 P.M., so we wait until 2:05 P.M. If there is volatility, you will see the price bouncing and carving out a fairly large candlestick.

 4. Analyse the candlestick by asking the following questions:
 a. Is the candlestick prominent? If yes, proceed to b.
 b. Does the candlestick have a clear direction? If yes, proceed to c.
 c. Execute trade.

  In a majority of news price action movements that I've seen, A and B are easy criteria to fulfil and generally herald continued movement in that direction for at least a little while after the announcement. If the prominent candlestick is weak, then I am very wary of a potential reversal. The body of the candlestick must be at least 2/3rds of the entire stick. If 1/3rd of the candlestick is wick, there is strong counter pressure and I do not have confidence that price will continue that direction.
 [[http://www.forexfactory.com/news.php?do%3Dnews&id%3D513569][How to Generate Profits From Forex News Announcements]]
*** AWE (Appropriate Win Environment)
**** Principles
***** The market always returns
 The entire market can be viewed as a range because prices always return even at the macrolevel. The driving force for this behavior has to do with what happens at the microlevel where longs/shorts drive prices up/down.

 It is not necessary to look for fine structures within the charts. The only thing to remember is that the price will eventually return. This concept is reasonable because we do not have to take delivery in forex - we can just wait. Understand though, that we may be waiting a long time and experiencing considerable losses which, however, will dissolve when prices go in the gaining direction.

 While waiting pretty much guarantees the always win result, it is not the only way. By increasing orders in the winning direction, it is possible to overcome the deficiencies developing in the losing direction. Hence, we can close a losing trade and still win.

 It is important not to be in a hurry to exit a losing trade. See these as long-term investments just as we do with items in mutual funds sometimes.

 At the same time, get into what is thought to be a winning trade quickly since it is possible to limit losses for it.
***** The balancing act
 Stops are replaced with balancing long/short entry orders. Some of these may be triggered, but they do not necessarily have to be - in fact, we don't want them ot be! Instead, they serve as protection in case the market goes the 'wrong' way. Of course, there is no such thing as a 'wrong' way, because the prader does not really care.

**** Difficulties with conventional trading and the AWEnsers
***** Prediction with high probability
 In order to trade effectively we are told to make predictions which seem to have high probability of success. Various tools are available to supposedly increase this probabilty including fundamentals and the plethora of technical analysis indicators that assist in understanding price action.

 We can still use many of these to expedite a trade, but they are not necessary in theory. If we wait, we can get out of trades gracefully.

***** Entry/Exit determined by Risk/Reward
 If we are willing to wait and/or exit gracefully, there is no risk and only reward. Since prices always return, in theory, we can never lose.

***** If we are stopped out of the game, we can't win
 This is an on-going problem. Using stops to get out of a losing trade, creates the feeling and reality of loss. Yet, when prices go against a position, we are actually better positioned to collect even more pips. However, we are even advised to not trade after a series of losses.

 So, the first step might be to realize that when prices go against us, the situation is not so much an obstacle, but an opportunity. However, it may be difficult to appreciate this fact after prices universally go against with 100% consistency. Even thinking that if it can go 100% against, it can also go 100% for, may not help much unless we can utilize some mechanism of making it so.

 That mechanism is waiting in the long-term and adding trades which go with the retracement as well as against it, at the correct positions.

 If we are always in the game, we cannot lose.

***** Sufficient market volatility
 Without movement, nothing happens. However, sufficient volatility will enable enough movement so that the same mechanism can be applied so long as prices can overcome the pip spread.

**** Implementation of the Companions Of Trade
***** Companionship
 Every trade must be complemented with one of the opposite direction creating a hedged combination, known as a COT (Companion of Trade). A COT limits the total loss that can be experienced at any given time to the gap between the entry points for the trades (and of course the spread loss). The smaller the gap, the less effort it should take to exit the COT with profit, in theory.

 Gaining trades can be closed for profit, so long as losing trades are neutralized through addition of an appropriate entry in the same direction. Losing trades can be closed provided sufficient profit has been accumulated or we can simply wait for the market to return to the point where the particular trade shows profit.

 COTs can be generated as we wish forming clusters, though it is unlikely there is much benefit in letting it do so beyond say 6 in total. It is likely preferable to close trades that are in profit while adding compensatory entries at appropriate points.

 We should try to maintain an imbalance of open positions in the direction we think prices are going, but always have it compensated for with an entry trade.
***** Awareness
 Though we can theoretically never lose if we wait, pragmatically we should try to be reasonably efficient.

 If the price lies between the COT, then both positions are in a loss. However, when prices start moving in one direction or another, we can simply add to the COT with suitable gap and catch the profit produced by closing that particular combo and setup another.

 If the price zigzags, then it may be best to leave the COT alone till some reasonable trend develops. We can safely traverse the primary trend as well as retracements this way without concern of being stopped out for a loss.

***** Tools
 It is not necessary to predict beyond choosing a long or short position. The  COT handles money management automatically. It is necessary to be patient though of course.

 It is also advantageous to be able to traverse trends and retracements in an efficient fashion, so having some idea as to identifying these is useful. Candlestick patterns and visible support/resistance lines should be sufficient in determining roughly how prices will behave.

 Other technicals and fundamentals may be used to provide some idea of where things are going, but as we have experienced, these have often been misleading. Since even the most rudimentary and solid predictors such as support/resistance and candlesticks can be incorrect, they should be used only as guides working under the auspices of COT, through grace.

**** Techniques
***** GOG (Go Out Gracefully)
 Closing a trade in this environment requires some significant criterion largely because we make or lose money based on how it is done.

 The first point is to remember that, in theory, it is never necessary to come out until a trade makes a profit because prices always return. A loss is not really a loss until we exit.

 The second point is that it may be plausible to close a losing trade provided we have adequate compensation from elsewhere. For instance, say we went short at 100 and the price went up to 110. Instead of creating just a single COT, we create two: we go long to companion the short and a second long with an appropriately placed short to companion the second lower down where it will not be activated. Now as the price rises, we collect two pips for everyone lost. Hence, at 120 you achieve a breakeven point and anything beyond enables you to close all components of the trade with profit.

 The third point is to understand that closing a loss may sometimes be useful if we are concerned about the impact it might have on subsequent movements. For instance, if we have a short and a long where we think the long may dominate, we may wish to close the short, so that the long can increase in value without hinderance. Of course, if there is reason to think that the price may go down and then up, we should leave the short open and close it when it has moved sufficiently.

 In general, always look for optimal opportunities to close positions. Never close positions out of fear of loss.
***** CIC (Catch If Can)
 When the price goes beyond the COT gap, close the (un)profitable part and re-enter it higher than the price. The rationale is that the price will not trigger the entry order and will head in the opposite direction thus reducing the existing loss.

 This process is similar to placing a stop that provides sufficient play room.

 There are 2 costs:
 - incurring another spread
 - gap will increase

***** CAM (Chasing A Move)
 This technique has similarity to trailing stops and tends to not only lock-in pips gained, but also increases the chances of acquiring more. Consider a starting a COT with long at 100 and an inactive short at 80 and the price rises above the former to 150. It would not be sensible to leave the short at 80 because a falling price to 110 would eliminate 40 pips gained. Instead, if we move the short to 130 (maintaining the same 20 pip gap), the loss will only be 10 pips (20 pip gap minus 10 pip gain on the short). We could then exit the short and put a new companion at say 115, with the thought that prices will move up again.

 The difference between such a CAM and a trailing stop at 130 is that you lose 20 pips and are out of the trade.

***** GIP (Get In Phase)
 Though the trend may be your friend, we can become too dominated by it to the extent that we do not want to recognize a retracement or even a reversal. As a result, we hold on to the major trend hoping that retracements will fall into lin.
***** MIS (Minimal Is Simple)
 The cleanest expression of AWE is done with a single COT consisting of 1 long and 1 short.

***** WAG (Work a Gap)
 Catching retracements can be difficult since it is uncertain where they occur and how long they last. Hence, the way to deal with this dilemma is to simultaneously go with the retracement in the short-term and against it in the long-term.

 If we simply waited for the retracement to turn around and return, we get nothing. However, if we go with it and then come out, we gain the amount retraced.

 For instance, say we go short when the price is 100. The price drops to 70, so we gain 30 pips. Then it starts to retrace to 90. If we just wait, we'll have 'lost' 20, until the price returns to 70 and will still have the same 30 pip gain as we did before. Now consider if we had gone long at say 75 and come out at 85. We gain 10 pips. When the price goes back to 70, we have 10 pips more than we did before.

 This has implications in a couple of areas:
 - CIC widens the gap
 - how do we resolve this

 so the price will always be inside the gap or outside it. if the latter, we know what to do. if the former, we are losing both ways. this matter requires serious contemplation.

 the key has to be to create an imbalance. otherwise, we just keep widening the gap and get stuck in it.

**** To Be Thot
 - some sort of manual journaling system to keep track of COTs
 - creation of the AWE sentinal computer program
 - can we expect retracements at certain times?
 - staggered entries for retracements?
 - how do cycles fit in both temporally and pricewise?
 - increasing gap
 - losing trades are long-term winning trades
 - how to deal with spikes using multiple orders and limits
 - use high leverage because you really do not lose
*** scaprader
 so this is super scalping going for every movement within a constricted region usually identified by some fib lines.
 - long low, short high therefore jump in sooner rather than later
 - wait and collect pips wherever possible
 - if we can make 20pips that could be $200 with 100 volume
 - create border failsafes in case anything blows up

 how one builds up cots seems to affect one's pip collection.

 if one is in a clear trend, one should be very careful when going against it.

 being out of phase is likely an illusion that one turns into reality through a lot of work.

 trends are different in different timeframes.

 different fibs fit better in different timeframes.

 we should become more familiar with various shapes and even candlesticks perhaps, though these apparently work better in longer term trading.

 why can't scalping be like regular trading???

*** FEME (Find Enter Manage Evaluate)
**** Find
***** Leads
 Various sites provide leads that are worth examining:
 - [[https://plus.dailyfx.com/dailyfxsignals/fxsignals.do][trading signals]], [[https://plus.dailyfx.com/fxcentral/technicalAnalyzer.jsp][technical analyser]], [[https://plus.dailyfx.com/fxcmideas/intraday-story.do?storyName%3D/dailyfxplus/intraday-ssi/2014/10/31/SSI_2014-10-31_54654654.html][speculative sentiment index]], [[http://www.dailyfx.com/authors/bio/Ilya_Spivak][ilya]]
 - [[http://www.forexnews.com/blog/category/forex-news/trade-of-the-day/][forexnews trade of the day]] comes via email each day
 - [[http://www.actionforex.com/trading-signals/][actionforex trading signals]]

 Forex Reviews provides Timon's weekly projections by email. Dailyfx also gives a weekly analysis by email.

 Dailyfx provides news and analysis, but these should be carefully scrutinized because a lot of it amounts to gossip.
***** Chart Study
 We should be looking at each pair regularly to see what possibilities are developing and what opportunities already exist. Intercurrency analysis is also useful and be examined at a glance with [[http://www.fxstreet.com/technical-studies/currencies/heat-map/][heatmap]].
***** News Events
 These are best examined at [[http://www.forexfactory.com/][forexfactory]] and are linked into the actual charts [[http://www.forexfactory.com/market.php][here]]. We should keep a regular and continous observation on the latter in the one hour timeframe.
**** Enter
 Trend, technicals and fundamentals should determine how we enter a trade. It is also a good idea to keep track of various market openings, since volume is affected by these.
***** Trend Examination
 Trends, both local and global indicate whether to go long or short and for how long.
***** Technicals
 We should have systems in play for different types of trading. Long-term techniques will differ from short-term scalpings, for instance. Staples we should use though are
 - candlesticks
 - s/r
 - pivot points
 - fib
 - ichimoku?

 We can determine r/r using s/r.

 A fully developed strategy with is presented in [[file:tradingtexts/technique/The%20Day%20Trade%20Forex%20System%20%5BBortucene%20&%20Macy%5D.pdf][The Day Trade Forex System]] by Bortucene and Macy.

 Forex Target Trading provides their 'big boys' approach in [[https://www.youtube.com/watch?v%3D2x6acQ9B-Pc][How to find the Big Boys Targets]].

 Forex Reviews shows a tip for detecting trend changes early in [[https://www.youtube.com/watch?v%3DHXoE1uxObR8][Secret Tip To Detecting Trend Changes As Early As Possible in Forex]].

***** Fundamentals
 These need to back the global trend and provide some rationale for local trend when it is different from the former. For instance, price may move in a range or triangle as it is about to make the next big move or there may be a retracement.

 It is important to keep track of these because sometimes you may get significant moves different from the established trend and these may lead to reversals too.

 Fundamentals are probably best followed on [[http://www.forexfactory.com/][forexfactory]] though john kicklighter does regular and extensive analysis which should not be accepted blindly. Also, be wary of long-term predictions, since much can happen in between.
**** Manage
 A trade cluster can be composed of one or more trades on the same pair on the same theme. one may enter and exit the pair several times, go in for long time periods or scalp. Here are some mechanics to employ depending on what is happening with price action:
 - exit and follow (eaf) if price goes against entry by certain percent of stop
 - fickle as trend (fat) if it seems likely that we can make money on reversal
 - companion of trade (cot) if expecting resumption of original trend soon
 - more on way (mow) if trend seems to be increasing0 pace
 - less on way (low) if trend seems to be decreasing pace
**** Evaluate
 Examine each concluded trade cluster to see what could have been improved and why. We may see that much could have been predicted from past behavior of pairs.
** old misc stuff
*** aforexisms
**** eqid
 equity increment decrement - this much seems certain
 getting out with minimal profit and maximal loss guarantees equity decrement
 getting out with maximal profit and minimal loss guarantees equity increment
**** bad and good trades
 jumping in at extremities has gone wrong 95% and putting down sl is difficult
 going in near sr anticipates miimai and placement of minimal sl

 rapid entries in direction of immediate trend facilitates being whipsawed
 careful entry through bodsor enables some gains near developing sr levels

 staying in raging losing trade simply loses
 getting out and repositioning has better chance of winning

 watching a trade serves little purpose
 a sensible trade requires no watching

**** attitude
 see each trade as your very first and give it the same care.

 every trade that goes against you provides a way to improve yourself.

 if you ever get the urge to influence the market with wishful thinking, it is a good idea to not trade till you overcome this disability.

 after a few bad trades we start looking for miracles, forgetting our principles and rules. understandably, doing so only reinforces the problems that created the bad trades in the first place.

 the reason random entries tend not to work in our favor has to do with the mindset of the entry. when we make a good entry, we have good cause to stay in it longer and get out fast when there is invalidation. with the poor entries, it is exactly the opposite. 

 there is no excuse for either poor entry or poor exit. don't try to be smart - just execute the system according to the rules that have been worked out. that is true brilliancy!
 
 never gloat after a trade.

 if you are always afraid of losing, you may never get around to winning. so losing trades should not influence future entries.

 it shouldn't be "why did the price move against me?", but "how come i'm not moving with the price?". obsession may be your most dangerous enemy!

 stops and limits should not be seen as a ends, but as the beginnings of a new opportunity.

 reacting to 'missing out', usually ends up in 'losing out'.

 staying in a trade against an obvious trend seeking reversal is likely the single biggest weakness, followed by grabbing small profits and staying in for large losses. both have proven to produce consistent results. 

 thinking about losing what you have will always be detrimental whether it's from a gain or otherwise. therefore, don't think about such tripe ... just limit losses.

 feeling incompetent due to how the market has moved is very different from feeling incompetent due to how you have behaved. both are very applicable to life in general.

 never regret losses, never celebrate wins

 the key idea in forex (and in life) is to spot a recognizable pattern and to accumulate gains. if the pattern doesn't produce expected results, then minimize losses and be ready to try again.

 never sit there just staring at the screen.

 past trade losses shouldn't ever affect present ones. cowardice and megalomania are not desirable qualities. 

 what's important isn't that you experienced the loss, but what you did to experience the loss. there are good losses and bad losses.

 don't scalp unless you really know - that's where we've lost most quickly and some non-scalp trades have started to look like scalped ones.

 don't trade just because the experts say you should - that's where we've lost the most money.

 your circumstances and abilities are quite different and so should be maximized. your approach should be tailored to you not someone else who is unable to sit and watch the screen for hours and hours and hours because they have something else to get on with.

 patience is a virtue, but you shouldn't get into trades which necessitate sitting around waiting coaxing the market for the suitable price that you need. use the patience to adapt to the situation.

 missing a trade because you didn't get the price you wanted it at just means you don't have to worry about altering your equity. possibly, as with any purchase, you should always try to get the right price.

 going over past chart sections to identify patterns is more beneficial than maintaining a voluminous journal about personal feely-weelys.
**** technique
 technical analysis can be awkward on low tf because the typical patterns count for less, suggesting a different form of analysis may make more sense, such as one based purely on price action.

 if you examine conditions properly and enter correctly, it's up to only price action from there.

 don't use longterm approach on 1m chart because the local inclination overrides the global.

 don't expect one trade to do everything for you.

 watch more, trade less. prading full time as a career doesn't mean that trades are continually placed. it is more important to study and prepare so that all trades are optimal.

 every pullback within the inclination should be considered a miimai until otherwise demonstrated.

 it may be difficult to enter correctly in the middle of a range.

 it is strange practice to increase the stop and decrease the limit.

 enter when price reaches where you want it to either on a pullback or a pushforward. never enter at market unless there is real momentum.

 the market isn't random, but your trades sometimes seem to be. so never get into a trade in a wrong way.

 things often come back, so it's often best to wait to get the price you want to set up a better rr ratio.

 when we are clear about the layout of the market field, then we could make intelligent trades.

**** adaptability
 one should not be bigotted. for instance, 141002 we came out of a short gbpusd trade that we caught brilliantly (much better than ilya), but exited because we were attached to a short eurgbp - if gbpusd went down because of gbp weakness, then eurgbp would go up for the same reason (or so we thought).

 markets behave differently at different times. adapt your behavior to the market. don't confuse small gain opportunities with large ones. 

 adapt to reality no matter what fundamentals/technicals make you think is supposed to happen.

 when coming out of a losing trade, do so soon with the intent of following and catching it at a better point (going the same way), or reverse your position on it.

 adaptability makes sense because when done correctly, you do go with the trend rather than fighting it. this is likely easier to do when there is greater movement in the market than when there isn't.

 adapting inappropriately can be even more disastrous. around 5:30am on 141015, we came to see that our efforts to recover had been fulfilled and we got out and then tried to go back into usdjpy. the price went our way, but we were not in it with 4 lots as we could have been. the price drop sharply (interesting because the 3 plunges were successively larger), but we were busy adapting to the ups and downs and messed up the progress we had made. then we got to 50960 (we waited for the limits to be hit) or so and proceeded to lose it back down to 50367. same reasons, cut profits short and let the losses run. we can't afford to be adaptable when the market is so volatile. this event and the usual lesson is really one to remember.

**** the stoploss
 a system that always wins has an infinite sl. any system that wants to win most of the time would have very large sl. however, that a good system does not make. if you get an ntr at point X and the price goes against you for 100p, then comes back and hits your tp which is at 100p,200p (or whatever), it makes no sense to think that it happened because of your excellent ntr. in fact, your trade was likely invalidated long ago and it was pure luck (or other circumstances) that enabled your win. the purpose of a sl should not be to create a win, but to invalidate a trade and therefore should always be placed at well-reasoned locations.

 there is also nothing magical or mythical about an sl. it is just another point on the chart and it's only purpose is to suggest when a trading concept has been invalidated.

 there seems to be something peculiar about the idea that an event 5hrs in the past actually had any effect on what's happening in the present. therefore, successes/failures with large sltp have more to do with these being large rather than with intelligent trading.
**** reactive vs predictive
 this is an important matter especially when working with computers which can watch and act quickly. we don't need to guess at where the price is going. we merely need to follow it. problems come when there are fast fluctuations, but otherwise what is happening is usually consistent. if we can bypass the former may be through reference to larger tifr, then we can simply go in the price direction most of the time.
*** broker seeking 
**** letter 171006
 i am in canada and am considering opening a forex account with a broker who provides a python api for trading forex. i would appreciate some answers either by email or phone.

 are we protected by IIROC?
 transfering money back and forth - what are the options and costs?
 will your desktop trading system run on linux?
 what is the spread for say EURUSD?

*** praducation items
**** kicklighter kollection
 plan out jpy crosses
 GBP crosses are providing range opportunities.

 some kicklighter quotes:
 market conditions override and overrule anything else
 low volatility -> increased risk effort
 when we use fundamentals as a volatility trigger it becomes a full-fledged strategy.

 fundamental outlook mon 9:30am in [[http://www.dailyfx.com/live_forex_trading_room?CMP%3DSFS-70160000000NbTmAAK][The DailyFX Live Trading Room]]

***** [[http://www.dailyfx.com/forex/fundamental/daily_briefing/session_briefing/daily_fundamentals/2014/08/01/Dollar-Close-to-Full-Blown-Run-on-Risk-Rate-Shift.html][Daily Fundamentals]] <2014-08-01 Fri>
****** Dollar Close to Full Blown Run on Risk, Rate Shift
****** Euro Traders Eye Volatility, Harden to Stimulus Concerns
****** Yen Crosses Dramatically Diverge from Equities
****** Australian Dollar Thursday’s Worst Performer as Data Drops
****** British Pound Traders Have Not Forgotten Rate Speculation
***** [[http://www.dailyfx.com/forex/video/live_events/2014/08/01/Strategy-Video-Can-NFPs-Reinforce-a-Change-in-Volatility-Market-Trend.html][Can NFPs Reinforce a Change in Volatility, Market Trend?]]
 - We have seen the first market-wide volatility event in 6 months - and only the fourth in 3 years
 - The S&P 500 dropped 2 percent, high-yield assets tumbled and volatility measures surged higher
 - Initiating a true change in market bearing requires conviction, and the NFPs can help feed it

 We have seen the first, serious market-wide run on speculative positioning in six months. A drop for global equities, high-yield assets tumble, dollar rally and volatility measure surge marks a critical next step towards a more systemic change in sentiment. We have been here before however. This is the fourth 'shock' to the system since the beginning of 2012. In the previous iterations, the jolt was substantial but short-lived. To tip such a mature trend - even one as steeped in skepticism and fundamental doubt as this one - the market needs to be forced. With an important NFPs and inflation figure due today, perhaps that is possible. We look at burgeoning opportunity and its trade potential in today's Strategy Video.

 stimulus lowers expectation of volatility.

 heavier risk aversion, higher the dollar.

 jpy crosses may move with risk. 
***** [[http://www.dailyfx.com/forex/video/daily_news_report/2014/08/01/Trading-Video-Why-Didnt-FX-Join-the-SP-500-and-VIX-Run.html][Why Didn’t FX Join the S&P 500 and VIX Run?]]
 - The S&P 500 and Dow cleared important support at the same time volatility jumped the most in six months
 - In the broad 'risk' move, however, the typically first-mover Yen crosses were stoic
 - We haven't made the critical shift from volatility to true risk aversion

 We have seen many temporary bouts of volatility over the past few years, but these have consistently fallen short of making the critical jump to true risk aversion. This past session, we were faced with the jolt that raises the market's anxiety; but the next step is the most important. The make-or-break decision on trend and momentum will be decided over the next 48 hours of active trading. With the July NFPs and US labor data - accompanied by the PCE inflation statistics - on tap, we have event risk that can keep the pressure on or hasten the rebound. Traders will be watching benchmark readings like the S&P 500 and VIX volatility index to assess the next move, but conviction requires a broader view. Whether or not USDJPY and the Yen crosses conform to the capital markets will be a key milestone in his assessment. We weigh the market's bearings and potential in today's Trading Video.

 volatility and volume are tightly linked.

 low volatility forces traders to risk.

 still hesitancy in movement.

 concern of fx not taking part yet - especially in jpy crosses. there isn't commitment to risk aversion.

 central banks add liquidity to market through stimulus, volatility goes down. 
***** [[http://www.dailyfx.com/forex/fundamental/daily_briefing/session_briefing/daily_fundamentals/2014-07-31-Dollar-Rallies-But-What-Was-the-Source-of-Strength.html][Daily Fundamentals]] <2014-07-31 Thu>
****** Dollar Rallies, But What Was the Source of Strength?
 This noncommittal view will leverage the emphasis on Friday’s combination of July NFPs and June PCE inflation – the primary indicators for the central bank’s dual mandate.
****** Euro Advances as Spanish GDP Outperforms, Yields Rise
 On the data side, Spain’s own 2Q GDP reading beat expectations with a 0.6 percent increase through the period and the Eurozone economic sentiment index ticked higher. From more fundamental concerns, a notable jump in Italian and Spanish yields is too early to be called a sovereign bond risk.
****** Yen Crosses the Best Performing ‘Risk’ Assets
 If a universal appetite for income / dividend / yield doesn’t arise, these pairs are at risk.
****** Canadian Dollar Traders Weigh in on GDP Data
 the Canadian dollar is down against most of its major counterparts (the exception is the Euro). The dovish turn from the Bank of Canada has put material pressure on this once prominent carry currency.
****** Swiss Franc: SNB Tells Us How Expensive its Policy Efforts Are
 The exposure to the Euro keeping EURCHF above 1.2000 is to be expected, but details can illuminate what further steps they could take.

***** [[http://www.dailyfx.com/forex/video/live_events/2014/07/30/Strategy-Video-Volatility-and-Rate-Forecasts-Shifting-After-FOMC-GDP-.html][Volatility and Rate Forecasts Shifting After FOMC, GDP]]
 - US 2Q GDP beat expectations with a 4.0 percent clip of growth that seemed to support USD more than SPX
 - While the FOMC Tapered and its statement was slowly pushing hawkishness, its impact was muted
 - Looking at the bigger picture, volatility and interest rate measures are starting to trend higher

 Most traders were caught up in the short-term market responses from today's US 2Q GDP reading and the FOMC rate decision. Yet, there may be something more substantial brewing in the deeper fundamental currents. While there were a number of sharp moves in the financial markets - particularly from the US Dollar - there are more substantial and lasting developments behind volatility readings (risk) and yields (interest rate expectations). If these trends continue, a more systemic change in market conditions is afoot. We focus on these underlying trends in today's Strategy Video.

***** [[http://www.dailyfx.com/forex/video/daily_news_report/2014-07-31-Trading-Video-Dollar-and-Risk-Bearings-After-Fed-Before-NFPs.html?CMP%3DSFS-70160000000NbTmAAK][Dollar and Risk Bearings After Fed, Before NFPs]]
 - Volatility followed in the wake of the US GDP update and FOMC rate decision
 - The impact was a surprise, with the dollar charged while higher order risk assets diverged
 - The dollar looks ahead to NFPs to feed yield forecasts while speculative appetite face an uncertain future

 A strong pace of recovery for the US and steady course for the Fed's Taper saw the US Dollar charged higher this past session. Technical breakouts, however, aren't as important as fundamentally-sourced trends. And so, the question is whether this is a greenback move that will develop into a lasting drive. That depends heavily on the expectations for the next heavy round of event risk - including Friday's labor data. In the meantime, dollar traders will also have to keep tabs on risk trends. Investor sentiment didn't present a uniform response to this past session's data, but a jump in FX volatility certainly helped the currency. What is truly interesting though is the more gradual shift in underlying conditions that may be ushering a new market phase. We discuss the changing backdrop from short-term to more systemic in today's Trading Video.

 lot of market activity, but no consistency. clear break by usd though. gbpusd moved lower and usdchf moved higher etc. backdrop of marketing is changing.

 FOMC not quite hawkish, but less than dovish which will likely result in rate hike.

 usd will keep rising - though thu may be a minor correction or consolidation before next phase of bullish move.

 fri: uur and pce.

 eurusd should maintain itself (though nzdusd may bounce).

 euraud coming to bottom of wedge.

 eurcad is breaking downward trend.

 eurgbp is in indecision because of both currencies.

 gbpusd going down, but it isn't a full retreat yet - stalling now.

 audusd pull back but not decisive because both moving in same direction.

 usdchf is still moving.

 usdjpy is weird because there is a break to the upside.

 all jpy crosses sensitive to risk but have lots of potential. however, risk aversion is likely to set in.

***** [[http://www.dailyfx.com/forex/fundamental/daily_briefing/session_briefing/daily_fundamentals/2014/07/30/Dollar-Positioned-for-a-Breakout-but-Will-GDP-and-the-Fed-Provide.html][Daily Fundamentals]] <2014-07-30 Wed>
****** Dollar Positioned for a Breakout but Will GDP and the Fed Provide?
 From economist to central banker to investor, the belief is that the lull through the opening period was temporary – weather related – and a strong rebound will be realized through the rest of the year.
****** Euro Faces its Own Volatility on Stocked Docket
 the ECB itself will no doubt monitor to gauge whether its recent policy easing is having the desired effects or whether more needs to be done.
****** British Pound Unimpressed by Surge in Mortgage Approvals
 neither the pound nor two-year UK bond yields would respond with material strength.
****** Yen Pairs to be Fully Preoccupied with Capital Market’s Activity Level
 If the upcoming wave of US (or other) data can stir speculative trends, expect the yen crosses to respond.
****** Australian Dollar: Is the RBA’s Next Move a Hike or Cut?
 Australian yields are starting to take a slow and begrudging turn higher
***** [[http://www.dailyfx.com/forex/video/live_events/2014/07/29/Strategy-Video-Volatility-Before-and-After-FOMC-US-GDP-Hit.html][Volatility Before and After FOMC, US GDP Hit]]
 - Following Monday's extreme inactivity from EURUSD, GBPUSD and USDJPY, this past session saw a jump
 - A jump from the dollar however runs into an immediate wall with major US event risk ahead
 - Could the combination of extremely low volatility levels and top event risk finally alter our course?

 Heading into major event risk, we typically see the markets enter tight trading ranges as participants await signal on volatility and direction. Yet, that wasn't the case this past session. The dollar marked notable bullish progress in most of its major pairings - including EURUSD, GBPUSD and USDJPY. Is this move a signal of the market's intentions for the greenback after the event risk? Does the event risk simply not matter? Is volatility so extreme that it will make its shift without a spark from the economic docket and headlines? We discuss the market's activity levels and the dollar's bearings ahead of the FOMC rate decision and US GDP release in today's Strategy Video.

 volatility may be just around the corner.

***** [[http://www.dailyfx.com/forex/video/daily_news_report/2014/07/30/Trading-Video-Dollar-at-Resistance-SP-500-at-Support-Ahead-of-GDP-and-FOMC.html][Dollar at Resistance, S&P 500 at Support Ahead of GDP and FOMC]]
 - Though there is a heavy round of global event risk today, 2Q US GDP and the FOMC decision are top billing
 - Given fundamental trends, GDP poses a greater volatility threat for 'risk', and the FOMC a USD catalyst
 - Beyond short-term volatility, investors want to know if this combo can permanently revive market activity

 Anxious for a revival of volatility and 'normal' trading conditions, traders anxiously await the impact of today's top event risk: the FOMC rate decision and 2Q US GDP release. These are just two updates in a loaded economic calendar, but they carry the most potential to turn underlying fundamental trends rather than just tease short-term volatility. Beyond tracking the health of the world's largest economy, the growth report presents a weighty update that can tip the scales on confidence between richly priced assets and disturbingly barren expectations for risk and volatility. Alternatively, the FOMC decision carries more potential for rate speculation - a heavier dollar consideration. We discuss this event risk and its possible impacts on the market in today's Trading Video.

 potential is favorable for usd.

 jpy crosses have good opp in risk aversion scenario.

 friday's ui and pce are opp to break usd resistance and may provide volatility.
 
***** [[http://www.dailyfx.com/forex/fundamental/daily_briefing/session_briefing/daily_fundamentals/2014/07/29/Dollar-Pairs-Extreme-Quiet-is-Unnerving-.html][Daily Fundamentals]] <2014-07-29 Tue>
****** Dollar Pair’s Extreme Quiet is Unnerving
 With the FX volatility index only slightly off its record low set earlier this month, we find the most liquid majors opened this new week with incredibly small trading ranges. This is combination of historically quiet markets meeting the regular anxiety that precedes the combination release of the FOMC rate decision and quarterly US GDP readings.
****** British Pound: IMF Says BoE May Need to Raise Rates Due to Housing Boom
 while the sector was not showing signs of bubbles, the central bank should be ready with additional mortgage curbs and even traditional rate hikes if these measures fail.
****** Euro Unchanged but Government Bond Demand Shows Leverage Still Rising
 Record or near –record low yields for Portugal, Spain and Italy may show confidence in ECB support; but that may still be confidence misplaced.
****** Yen Crosses Show Just How Focused Market is On Volatility Measures
 When the Bank of Japan (BoJ) backed off of its effort to ramp up its monetary support of weak inflation and struggling economy, one of the major drivers for the yen crosses lost traction.
****** Australian Dollar: Strong Demand for Indexed Bond May Signal Glimmer
 If the market starts to form a time frame for a rate hike sometime in 2015, the Aussie dollar is still significantly discounted, that it can rally even with such a distant view.
***** [[http://www.dailyfx.com/forex/video/live_events/2014/07/29/Strategy-Video-Is-the-Dollar-Still-a-Safe-Haven-Currency.html?CMP%3DSFS-70160000000NbTmAAK][Is the Dollar Still a Safe Haven Currency?]]
 - A common question posed to me asks whether the US Dollar is still considered a 'safe haven' currency
 - In the spectrum of 'Safe to Risky' or 'Funding to Carry', the Dollar is still a liquidity haven
 - Yet, when risk trends are not at the extremes of fear to greed, other themes tend to take over

 Over the past year, the Dollar has consolidated against a backdrop of a remarkably consistent S&P 500 advance. Is this a sign that the currency is shedding its safe haven status? Is it starting to turn into a carry appeal against counterparts like the Euro? Currencies, asset classes and market benchmarks do see their appeal wax and wane over time which alters their relationship to 'risk trends'. However, the Dollar's position as a safe haven is not likely changing - just as its appeal as a carry currency is meaningfully climbing. Rather, the change we are seeing more likely a drop in conviction behind risk trends (whether we are talking bullish or bearish). We look at the dollar, sentiment trends and their relationship in today's Strategy Video.

 low volatility  =  risk appetite\\
 high volatility =  risk aversion

 safe --> usd jpy     chf cad gbp    aud eur nzd <-- risk

 usd,jpy safe for different reasons.

***** [[http://www.dailyfx.com/forex/video/daily_news_report/2014/07/29/Trading-Video-Dollar-SP-500-Breakouts-and-Trends-on-Hold-Before-FOMC-GDP.html?CMP%3DSFS-70160000000NbTmAAK][Dollar, S&P 500 Breakouts and Trends on Hold Before FOMC, GDP]]
 - This week opened to consolidation with EURUSD carving out its second smallest range in the Euro's history
 - Heading into heavy event risk - US GDP and FOMC among the top billings - investors will be cautious
 - Trades that fall outside the dollar's influence or 'risk' designation are better opportunities

 Traders can see and hear heavy event risk just over the horizon. With the threat of event risk that can materially alter volatility levels or underlying trends, it comes as no surprise that markets are retrenching. Through Monday's session, the USDollar's march higher was capped, the S&P 500 pulled back before committing to an intermediate bearish reversal and EURUSD carved out the second smallest trading range since the Euro began trading. In an already sluggish market, the build up to such a high profile collection of event risk is palpable. Opportunities - short, medium and long-term - are likely to arise from the aftermath of the events. Yet, in the lead-in, there are still trade options. Finding those pairs without a 'risk' connection or dependency on US rate forecasts can still develop at their own pace. We discuss this calm before the storm in today's Trading Video.

 benchmarks to gauge situation with (till wed)
 - sp500 couldn't progress either way
 - usd unable to go up strongly
 - eurusd very quiet 17pips

 no one wants to take large position till wed even though investors are in riskon mode due to low volume.

 approach should be very frugal and judicious. plenty of eur and usd news on wed.

 gbp is riding on interest data.

 get away from event risk and usd: audnzd (u), eurcad (d), euraud (?), gbpcad (r)

 eurusd good for short-term scalping.

***** [[http://www.dailyfx.com/forex/video/daily_news_report/2014/07/26/Trading-Video-Risk-Trends-and-Rate-Expectations-Amid-FOMC-NFPs-GDP.html][Market Puts Hurricane Shutters on Dollar Trades]] <2014-07-26 Sat>
 - The USDollar has advanced this past week despite a tepid rate forecasts and stubborn risk appetite
 - A heavy economic calendar - FOMC, US GDP, NFPs - threatens to revive rate  speculation and maybe even risk
 - We look at all of the dollar-backed majors with a particular interest in EURUSD and GBPUSD

 Event risk and fundamental trends weren't very favorable to the US Dollar this past week, but that didn't prevent the currency from marking a convincing bullish turn through the period. The scene is set for a more productive trend to develop, but conviction and momentum require the market's backing - and that is where fundamentals and market conditions come into play. To charge a move, we have the US 2Q GDP release, FOMC rate decision and Friday NFPs amongst other data. Yet, to chart a course with momentum, we may also need underlying conditions to shift from aimless range to concerted trend. We focus on the US Dollar in today's Strategy Video.

 event risk centered on usd and majors with wed having very heavy fundamentals.

 better to wait even if you get in late, so that the fundamentals drive the pair properly.

 gbpusd is not a risk based pair and will run on what usd does.

 look at usdchf.

 audusd needs clear conviction and doesn't have connection to risk.

 nzdusd shouldn't be traded without conviction for usd.

 usdcad isn't risk based either.

 usdjpy is riskbased, so look at risktrends.

***** [[http://www.dailyfx.com/forex/video/daily_news_report/2014/07/26/Trading-Video-Risk-Trends-and-Rate-Expectations-Amid-FOMC-NFPs-GDP.html][Risk Trends and Rate Expectations Amid FOMC, NFPs, GDP]] <2014-07-26 Sat>
 - The coming week looks to be one dominated by rate speculation, but risk trends are coiled like a spring
 - US event risk including the Fed rate decision, July NFPs and 2Q US GDP look to dominate headline
 - Yet, event risk alone will not ensure strong trends from the likes of EURUSD, GBPUSD and USDJPY Market conditions change, and our strategy should reflect those changes.

 With the US docket alone carrying the quarterly GDP reading, nonfarm payrolls report and FOMC rate decision; it looks like we are set for a busy week. These and other major fundamental catalysts are certainly high profile and easily segue into one of the FX market's primary themes: interest rate expectations. However, a wary eye must be kept on the current for sentiment as a general trend is developing between bottoming volatility indexes, consolidating carry trades and diverging performance between risk-sensitive asset classes. As tides turn, key pairs mark progress and event risk approaches; we discuss how to prepare in the weekend Trading Video.

 vix is an indicator of activity, but ATR works just as well. low volatility encourages risk taking. pick up in volatility will result in pick up in volume and momentum. without these you will keep seeing false breakouts and no lasting trends.

 if we miss shift in sentiment, we miss some of the best fx opportunities in years.

 eurusd is in contrast should move lower in medium/low term. the factors which should keep it moving aren't there yet. no risk aversion yet in usd and eur monetary policy seems to have leveled out. can get in at 1.3425 rather than higher, but jk wants to wait for confirmation.

 gbpusd good possibility, but no fundamental driver has shown up yet. however, gbp has moved down for 8 consecutive days, but there isn't a lot of momentum.

 gdp and fomc due on wed, and ui and pce on fri.

 stimulus rises fear falls and more riskon.

 usdjpy played from a risk perspective.

 usdchf, audnzd long with much higher potential.

***** [[http://www.dailyfx.com/forex/fundamental/daily_briefing/session_briefing/daily_fundamentals/2014/07/25/British-Pound-Already-Down-7-Straight-Days-Faces-UK-2Q-GDP.html?CMP%3DSFS-70160000000NbTmAAK][Daily Fundamentals]] <2014-07-25 Fri>
****** Dollar Traders Look Ahead to NFPs, GDP and FOMC Decision
 Through the past session, much of the dollar’s gains were founded in counter-currency developments – rather than innate strength on the greenback’s part. Modest gains for USDJPY were the work of risk trends, AUDUSD corrected after its preceding rally, and NZDUSD collapsed after the RBNZ rate decision.
****** British Pound Already Down 7 Straight Days Faces UK 2Q GDP
 GBPUSD closed its seventh consecutive bearish session and closed below 1.7000.
 A reading that ‘beats’ will offer limited progress while a ‘miss’ could leverage losses.
****** Euro Ready for a Turn after Data Improves, Yields Fall, EURUSD Doji?
 EURUSD made significant bearish progress when it finally broke below 1.3700. Yet, the technical move didn’t rouse the bears’ commitment.
****** New Zealand Dollar Drops Alongside Yields and Hope of September Rate Hike
 The New Zealand dollar was hit hard by the RBNZ rate decision, and there was little-to-know rebound when the session was through.
****** Yen Crosses: Steady Inflation Further Lowers Chance of More BoJ QQE
 For the trader, taking out the need to fight inflation means that the BoJ has little room to claim mandate and build up its QQE program – the program that drove the Yen crosses 30-45 percent higher last year.
***** [[http://www.dailyfx.com/forex/video/live_events/2014/07/25/Strategy-Video-GBPUSD-Pound-Strategy-for-UK-2Q-GDP-Report.html?CMP%3DSFS-70160000000NbTmAAK][GBPUSD, Pound Strategy for UK 2Q GDP Report]]
 - The UK 2Q GDP figures are due for release at 8:30 GMT Friday
 - This data set is a high-level potential market mover as an important spark for rate expectations
 - We perform a scenario analysis on the data's outcome and impact with a mind to preferred pound setups

 Fundamental analysis requires first recognizing what is important to the market. Interest rate expectations are key to British Pound's rally, and 2Q GDP is a capable catalyst to alter that outlook. For this event risk to be market-moving, it needs to significantly alter expectations - upgrade the timing and pace of rate forecasts or otherwise substantially undermine them. Which scenario would generate the biggest market impact? What Sterling-based pairs are more appealing under the different scenarios? We discuss that in today's Strategy Video.

 gbpcad,gbpaud are in range and may continue if gdp expectations don't fall.

 gbpusd dependent on interest rate expectations and may be a good one to look at.

***** [[http://www.dailyfx.com/forex/video/daily_news_report/2014/07/25/Trading-Video-Extreme-EURUSD-Quiet-After-Key-Break-Unnerving.html?CMP%3DSFS-70160000000NbTmAAK][Extreme EURUSD Quiet After Key Break Unnerving]]
 - Immediately after its break below 1.3500, EURUSD has reverted to extreme levels of inactivity
 - The S&P 500's slow melt up a distinct contrast to our Risk-Reward Indicator
 - A NZDUSD tumble is costly and GBPUSD's rally may soon adopt the same designation

 The unsettling calm that we have grown used to in 2014 has once again settled over the market. However, there are is enough turmoil below the surface that traders are not willing to set their trading on cruise control. From benchmarks like the S&P 500, the slow advance looks like bait on a hook as other sentiment measures struggle and the Risk-Reward Indicator extends its tumble. Meanwhile, rate speculation is evolving. The volatility from the New Zealand and Australian dollar is still throbbing, the ECB stimulus push now finds the Euro dangerously quiet after a critical break, the USDollar is facing serious event risk next week, and the British Pound faces an immediate threat to its pristine rate forecast in the form of the UK 2Q GDP release due today. We discuss all of this in today's Trading Video.

 usdjpy,gbpjpy impending opportunity if risk aversion sets in.
 eurjpy is good even if riskoff because of eur weakness.

 eurusd has short-term opportunities, but no longtrends yet, but may be next week.

 nzdusd may be heading down due to nzd weakness, but only short-term right now.

 long audnzd because both are comparable and nzd is weak.

 gbpusd may be going for a drop - seven consecutive losses.

***** [[http://www.dailyfx.com/forex/fundamental/daily_briefing/session_briefing/daily_fundamentals/2014/07/24/Dollar-Fails-to-Leverage-Key-EURUSD-Break.html?CMP%3DSFS-70160000000NbTmAAK][Daily Fundamentals]] <2014-07-24 Thu>
****** Dollar Fails to Leverage Key EURUSD Break
 Market conditions where participation and volatility are drained is a great equalizer for fundamental and technical developments. The key to seeing the dollar and broader financial markets return to trend – bullish or bearish – is seeing the masses return and reestablish a level of commitment. Can the combo of NFPs, FOMC decision and 2Q US GDP net week do it?
****** British Pound Retreats after BoE Minutes, Carney Comments
    The data on the UK docket this past session were encouraging. The home loans filed with the BBA for June unexpectedly increased and the CBI’s retail sales survey for the current month posted an unexpected acceleration in growth. Yet, neither of these carries much weight for what is truly capturing sterling traders’ attention: interest rate speculation.
****** New Zealand Tumbles…After a Rate Hike
 This affront to efficient market theory reflects the heavy impact that speculation can have. Traders had already priced in the hike for this particular meeting.
****** Australian Dollar Extends Gains Following Rising Inflation Pressures
 While this data is still far removed from the fist RBA rate hike, the market was not pricing in a positive yield curve.
****** Euro Traders Look to July PMI Figures to Benchmark Growth Forecast
 There are three major fundamental loose ends for the Euro, but the market is not actively trying to unravel them.

***** [[http://www.dailyfx.com/forex/video/live_events/2014/07/23/Strategy-Video-Are-EURUSD-SP-500-Leading-the-Market.html?CMP%3DSFS-70160000000NbTmAAK][Are EURUSD, S&P 500 Leading the Market?]]
 - There are strong technical and fundamental relationships in the market that can be exploited
 - A strong relation in single-currency crosses or asset classes that sees a deviation presents opportunity
 - We take a closer look at EURUSD, EURJPY, GBPUSD and S&P 500 as leading signals for their counterparts

 The S&P 500 has broken to fresh record highs, but other equity benchmarks have yet to follow. EURUSD has toppled 1.3500 support while other dollar-based majors are showing less drive. EURJPY has produced a high profile turn while other yen crosses are still hemmed into congestion. Are these stand out moves leading indicators of broader shifts for their respective currency/market/theme? Or, perhaps they are drives destined to be hammered back into line with the market. We look at a number of these divergence trade opportunities through technical, fundamental and market condition analysis in today's Strategy Video.

 sometimes a particular cross leads the other crosses.

 respect market conditions.

***** [[http://www.dailyfx.com/forex/video/daily_news_report/2014/07/24/Trading-Videp-Markets-Diverge-Dollar-and-Risk-Struggle-NZD-Drops-on-Rate-Hike.html?CMP%3DSFS-70160000000NbTmAAK][Markets Diverge, Dollar and Risk Struggle, NZD Drops on Rate Hike]]
 - The S&P 500 hit a record high without risk soaring, and GBPUSD's technical break hasn't throttled the USD
 - This past session's top market movers where the Pound, Aussie and Kiwi - all on rate speculation
 - Ahead, the focus turns to the Euro and back to the underlying themes that have seen tentative breaks

 Recently, some of the financial market's high-profile benchmarks - S&P 500, EURUSD, VIX - have taken steps towards substantial trend change. Yet, even where these early moves are still standing; conviction is still lacking through momentum and conformity from their most liquid peers remains notably absent. Complacency is difficult to shake as the market's default characteristic trait; but the longer these divergences last, the closer we are to the inevitable tide change. In the meantime, interest rate expectations were stirred behind the Pound, Australian and New Zealand dollars - with some surprising reactions. Moving forward we will see speculative appetite and monetary policy forecasts will once again share the spotlight. We discuss these themes and their trade implications in today's Trading Video.

 not getting momentum even though technicals look decisive.

 audcad, audnzd, euraud all potential ranges in some way.

 too much eur exposure to go after too many crosses.

 nzd crosses are possibilities because perfection was priced in.

 risk aversion will result in drop for usdjpy, but that is some distance away.
***** [[http://www.dailyfx.com/forex/fundamental/daily_briefing/session_briefing/daily_fundamentals/2014/07/23/British-Pound-Out-of-Room-and-Facing-Trial-by-Event-Risk.html?CMP%3DSFS-70160000000NbTmAAK][Daily Fundamentals]] <2014-07-23 Wed>
****** Dollar Performance Not as Robust as EURUSD Insinuates
 the gravity of next week’s FOMC decision, NFPs and 2Q GDP may keep the dollar anchored.
****** Euro Tumbles As European Equities Rally
 Next to the Swiss Franc, the Euro was the worst performer amongst the majors this past session. That said, its stumble began before the heavy-hitting news and data started to cross the wires. (might be why jk is long on usdchf)
****** British Pound Out of Room and Facing Trial by Event Risk
 GBPUSD is facing an impending breakout – a break of necessity.
****** New Zealand Dollar Coils before Heavily-Anticipated RBNZ Hike
 In fact, the currency has gained little to no ground against many of its counterparts since the first hike. So what happens if they decide to hold?
****** Australian Dollar Advances as Core Inflation Heats Up
 Given the currency’s sluggish performance these past few years and the fact that its rate is still the second highest among the majors as is, it is particularly sensitive to speculation of hikes.
***** [[http://www.dailyfx.com/forex/video/live_events/2014/07/22/07-22-2014-Strategy-Video-EURUSD-EURJPY-and-EURAUD-Break-but-Can-They-All-Run.html?CMP%3DSFS-70160000000NbTmAAK][EURUSD, EURJPY and EURAUD Break but Can They All Run?]]
 - EURUSD has broken below 1.3500, EURJPY is in retreat from 137.50 and EURAUD revived bears below 1.4350
 - All three look to continue a general Euro-bear theme that has fundamental backing
 - Yet, the fundamental themes that would carry the currency are not yet self-generating

 On occasion, a number of appealing trade setups based on a single currency present themselves at the same time. Given my technical and fundamental views, that is the situation I find the Euro in now. I already have a EURJPY short on, but I have maintained plans to trade EURUSD and EURAUD given certain conditions. This past session, all three made meaningful moves lower; but there is an issue. Taking all three would be leveraging up on a short Euro trade. To do that, I would need to be very confident in the currency's slide. And yet, market conditions and fundamentals give me reason to pause. In today's Strategy Video, I run an analysis on the Euro with a mind to strategy and risk-reward.

 should look at eurjpy, eurgbp, euraud due to the eur fundamentals. would they maintain the decline? monetary policy: banking sector likely to have most bearish influence on euro.

 going all three may be viable based soley on euro's declines even though doing 3 may be a risk.

***** [[Has%20the%20EURUSD%20Drop%20Below%201.3500%20Broken%20the%20FX%20Dam?][Has the EURUSD Drop Below 1.3500 Broken the FX Dam?]]
 - EURUSD breaks 1.3500 but Dollar shows limited initiative, Euro's catalysts medium-term considerations
 - The focus shifts from 'risk trends' to interest rate considerations
 - Event risk looks to spur rate speculation for the Pound, Aussie and Kiwi dollars

 Volatility readings have eased and the impending risk of collapse of the capital markets seems to have cooled. That said, the fundamental drive hasn't simply been turned off. Speculative appetites are always lingering along the fringes of the seemingly calm financial shore; but there is something else to actively track for market moving through this week: rate expectations. This past session's US CPI didn't clarify the dollar's bearing - especially with the NFPs, 2Q US GDP and FOMC decision all due next week. Meanwhile, the upcoming session offers plenty of UK event risk to speculate on BoE hikes, Aussie inflation data and an RBNZ rate decision expected to result in yet another hike. What opportunities does all of this present? That is the topic of today's Trading Video.

 medium term bearish view on eurusd.

 usdchf seems to be good to go long on as he has because chf is doing even worse than eur.

 market conditions not conducive to trends. usd unable to break the descending trend line and is still neutral so we really aren't getting a good asymetric situation. next week should be interesting though with many fundamental news being revealed.

 rbnz rate decision is expecting .25% rate hike may lead to bearish and if no hike may be even more bearish.

***** [[http://www.dailyfx.com/forex/fundamental/daily_briefing/session_briefing/daily_fundamentals/2014/07/22/Dollar-Can-US-CPI-Break-Greenbacks-Technical-Boundaries.html?CMP%3DSFS-70160000000NbTmAAK][Daily Fundamentals]] <2014-07-22 Tue>
****** Dollar: Can US CPI Break Greenback’s Technical Boundaries?
 The Dow Jones FXCM Dollar Index (ticker = USDollar) was nudged higher this past session, but the move clearly lacked the belief we would expect from a commitment from bulls. A substantial deviation may be needed though with the Fed, NFPs and GDP next week.
****** Euro Markets Cooling and Periphery Bonds Rising is Unusual
 Yen crosses have more readily followed equities into their retreat. Japanese currency finds a bid well before that extreme as the market looks to first unwind risky positions.
****** British Pound at Mercy of Yields as Event Risk Approaches
 The sterling has experienced a very strong run on the basis of a hawkish rate forecast – realizing a hike before its major counterparts and seeing a pace that keeps that premium thereafter. How much premium should this view afford the currency?
****** Australian Dollar: What Happens if CPI Stokes Rate Forecasts?
 When a key fundamental characteristic is fully underappreciated as carry interest is for the Aussie, there is tremendous potential. But, something substantial is needed to rouse bulls from recent years of cuts and a preoccupation with the connection between Australia and China.
****** New Zealand Dollar Stabilizes as Market Sets Hawkish View for RBNZ
 Last week, the Kiwi dollar suffered a hefty stumble when the country’s 2Q CPI reading printed a weaker-than-expected 1.6 percent annual pace. NZDUSD, meanwhile, is 160 pips off last week’s highs.
***** [[http://www.dailyfx.com/forex/video/live_events/2014/07/21/Strategy-Video-Skewed-Potential-for-EURUSD-GBPUSD-and-NZDUSD.html?CMP%3DSFS-70160000000NbTmAAK][Skewed Potential for EURUSD, GBPUSD and NZDUSD]]
 - We use a number of the concepts we've discussed in previous videos to focus on EURUSD, GBPUSD and NZDUSD
 - Market conditions, probability vs potential and top fundamental themes project significant potential
 - Potential is not a trade until it is triggered and sustained by an active market

 Combining a number of the concepts from previous strategy videos, we look more closely at EURUSD, GBPUSD and NZDUSD. There are underlying trends, technical levels and impending event risk; but these factors alone will not likely direct us to rewarding trade setups. We must look at the underlying trends and technical milestones against the context of market conditions. Impending event risk leverages market response only when it generates a 'surprise' and sustains that movement only when it is a major fundamental theme. Between major fundamental themes, broad analysis and potential vs probability; we use this Strategy Video to identify considerable asymetrical trade opportunities that simply await the correct promp...perhaps upcoming event risk.

 eurusd likely to be range till volatility picks up. fundamental catalysts are interest rate expectations which have improved for eur which lowered the yield while usd is moving differently. if risk aversion and volatility kick in then we will have a drop - it is a matter of time and bulls may avoid the scene.

 gbpusd dependent on interest rate expectations. gbp high interest difficult to maintain. usd will likely be an anchor, but gbp will be difficult to raise, so we will likely have a drop.

 nzdusd is much the same because nzd will disappoint more easily than otherwise. therefore we have a good asymmetrical opportunity.

***** [[http://www.dailyfx.com/forex/video/daily_news_report/2014/07/22/Trading-Video-Watching-Volatility-for-Risk-Cues-and-US-CPI-for-Dollar-Moves.html?CMP%3DSFS-70160000000NbTmAAK][Watching Volatility for Risk Cues and US CPI for Dollar Moves]]
 - Volatility measures cooled this past week, but there seems tentatively to be an underlying current shift
 - Should sentiment shift - beyond trade opportunities - it should also necessitate a trading approach change
 - Top event risk for the next 24 hours is the US CPI as the market continues to discount the Fed's pace

 The rebound in risk trends after last week's swoon has proven more restrained and uneven than previous bouts of uncertainty. In other words, market participants seem increasingly unsure of the 'next leg higher'. Doubt does not guarantee a turn in sentiment is imminent, but it is a significant enough warning sign and the potential fall out from such a development substantial enough that it is critical to keep track of and have trade setups at the ready. In today's Trading Video, we pick up the risk assessment in the new trading week and evaluate the upcoming session's top event risk - US CPI - for trade potential.

 there will be movement, but we don't know quite when. therefore, it is better to wait or take measured steps.

 eurjpy has potential and if there is a drop it is because of sentiment downdraft.

 usdjpy, gbpjpy, nzdjpy are also possibilities.

 if cpi picks up it will cause pressure on interest rate expectations. market is undervaluing fed's expectations. if fed's become correct, there will be a big usd rally.

 bigger the surprise bigger the impact because repositioning necessary.

 usdjpy has heavy implications for risk. high stimulus reduces volatility and low volatility drives investors towards risk.

 eurusd prefered candidate for downtrend. monday's candle took out rebound likelihood and fundamentals likely to pull down eur.

 gbpusd will test bounds of interest rate expectations.

***** [[http://www.dailyfx.com/forex/video/live_events/2014/07/21/Fundamental-Forecast-Volatility-Turns-Over-as-Event-Risk-Shapes-Rates.html][Volatility Turning Over as Events Shape Rates]] <2014-07-21 Mon>
 - Another surge in volatility this past week reflects a possible trend change in activity levels
 - Yen crosses and EURUSD are very risk sensitive, while the dollar and S&P 500 will prove stubborn
 - Meanwhile, data will stir rate forecasts for the Dollar, Pound, Aussie and Kiwi dollars

 Chief Strategist John Kicklighter discusses the top Forex fundamental themes for the coming week of trading. These sessions are held live every Monday at 16:30 GMT. Was last week's volatility jump just another short-lived blip on the radar or is the frequency of these spells showing a bigger change at work? Risk trends and speculative appetites are a key catalyst that is increasingly exacting its influence over the capital markets and majors. A strategy for both status quo and heavy risk swells is necessary. Meanwhile, the docket is littered with events that promise to sustain and amplify interest rate forecasts - for better or worse. Events like the US and Aussie CPI, BoE Minutes, UK GDP and RBNZ rate decision are top teir this week.

 vix low except for equities. leading and lagging indicators. measures of activity are hitting baseline.

 reversals are often preceded by consolidation.

 too low/high for vix is going to struggle to stay down/up.

 volatility and risk are ongoing themes.

 when vix is low, equity indices high - look for fx trades:
 - jpy crosses: usdjpy parallels jpy225 seek low yield but big movement riskon
 - usd crosses: rising at a different rate

 since there is a big buildup it is easier to hurt it than keep it going.

 eurusd is a very risky pair due to eur weakness. usd is safehaven when we need liquidity.

 gbp expected to see a rate hike at end of this year.

 not going to get rate hike from feds because of drop of unemployment, but because inflation will pickup.

 other major fundamentals:
 - gbp expectations figured in already
 - aud cpi audusd bearish, but nzdusd bullish

 biggest moves in currencies when there is deviation from expectations.

 he is long on audnzd. 
***** [[http://www.dailyfx.com/forex/video/daily_news_report/2014/07/19/Trading-Video-Volatility-is-Turning-Yen-Crosses-and-Equities-Ready.html?CMP%3DSFS-70160000000NbTmAAK][Volatility is Turning, Yen Crosses and Equities Ready]]
 - A change in market conditions is likely stirring more deeply than just surface volatility on headlines
 - Each short-term trigger that we meet reminds investors of extreme market positioning
 - The S&P 500 will be one of the key signals, but before it gives Yen crosses will lead the way

 Is there a deeper well of change behind the markets than just this past week's headline-derived swell in volatility? We have seen short-lived panics quickly squashed by opportunistic traders many times over the past months and years, with conditions ultimately returning to complacency and an increasingly stretched reach for return. Yet, rather than focus on the ripple, the underlying current is starting to turn. The pull of a 'return to norm' is exposing investors' leverage to risk and finding different benchmarks for sentiment on divergent paths. What should we watch for and where are the trading opportunities? We discuss this in the weekend Trading Video.

 top driver was risk trends. market is at above levels of activity.

 if sp500 drops then risk aversion kicks in.

 primary concern heading into next week is risk themes.

 jpy crosses should be paid particular attention should risk take over.

 usdjpy, eurjpy short.

 eurusd is good too due to situation because of monetary policies.

 euraud doesn't run on risk, but looks like it will be going down.

 gbpusd is his fav for pullback.

 look across different markets to get better and complete picture of sentiment.
  <2014-07-19 Sat>
***** [[http://www.dailyfx.com/forex/video/technical_analysis/2014/07/18/Strategy-Video-Starting-with-EURJPY-Planning-for-the-Yen-Crosses-.html?CMP%3DSFS-70160000000NbTmAAK][Starting with EURJPY, Planning for the Yen Crosses]]
 - Sentiment trend opportunities are beginning to grow imbalanced, and the Yen crosses offer direct exposure
 - With the BoJ capping its stimulus effort, pairs like USDJPY are hanging onto low volatility conditions
 - While there is definably opportunity in all the Yen crosses, I have started with EURJPY

 Though we have yet to see the turn in market sentiment, the balance between potential and probability is setting up tremendous trade opportunities. In FX, the most direct link to 'risk' are the Yen crosses. As the grab for return and yield matures, these carry currencies are presenting an earlier appreciation of the risk unwind than global equities and certainly the S&P 500. Yet, full commitment to such a prolific theme requires greater conviction, and that means more evidence of a shift. In this weekend Strategy Video, we discuss what to watch in sentiment trends, why the Yen crosses are prime opportunities for the theme and the trading approach I'm taking.

 best reflection of risk are jpy crosses. volatility are at record lows. in this imbalance, lies opportunity.

 he is short on eurjpy, but isn't convinced about it yet. jpy225 may break to the downside, which means risk aversion may bring currency strength?

 usdjpy is a good one below 101.
  <2014-07-19 Sat>
***** [[http://www.dailyfx.com/forex/video/daily_news_report/2014/07/18/07-18-2014-Trading-Video-A-Swell-In-Volatility-Threatens-Long-Overdue-Reversals.html?CMP%3DSFS-70160000000NbTmAAK][A Swell In Volatility Threatens Long Overdue Reversals]]
 - Volatility soared this past session as tensions in Ukraine and the Gaza Strip flared
 - A correction in equities, Yen crosses and other risk-bearing assets reflects the market's attention
 - Given a significant duration or scope, this could prove the catalyst for a systemic sentiment reversal

 Global headlines have generated a heavy swell in volatility, leading traders to run a threat assessment for a more systemic shift in speculative positioning. Market conditions are both durable and fragile. Complacency and contentedness has proven these past months and years the most enduring features of the financial system. However, the extremes of positioning (long risk, use of leverage) and severe lack of a safety net (hedging) poses an exceptional risk to the stability of the system. As this is a consideration of 'when' rather than 'if', news of a downed plane on the border between Ukraine and Russia and a ground offensive in the Gaza Strip can pose a greater risks to the financial markets than many suspect. I have taken a EURJPY short, but additional trades depends on the extent of the speculative turn. We discuss what to watch and trade opportunities in today's Trading Video.

 volatility jump has had little impact on sp500.

 eurusd is most liquid - others would follow its lead.

 usdjpy has great potential as does eurjpy which is more sensitive. jpy crosses should be examined. these are viewed as counters to trends that have builtup over years so we need solid confirmation.
  <2014-07-18 Fri>
***** [[http://www.dailyfx.com/forex/video/live_events/2014/07/17/Strategy-Video-Will-Yen-Cross-and-SPX-Traders-Jump-on-Volatility-Swell.html?CMP%3DSFS-70160000000NbTmAAK][Will Yen Cross and SPX Traders Jump on Volatility Swell?]]
 - The tragedy of a downed flight at Ukraine's border has raised geopolitical tensions and market fear
 - Short-term volatility swells are a common sight in 2014 and the market has frequently taken advantage
 - Whether or not traders 'buy the dip' or 'short vol' depends on confidence in status quo and returns

 A downed plane on the Ukraine-Russia border has escalated geopolitical tensions and sent a ripple of fear through the financial system. With this tragedy thrusting a global point of tension back into the spotlight, short-term volatility measures have swelled in a familiar pattern for 2014. We have seen this jump in volatility and pullback in 'risk' sensitive assets plenty of times before. And, consistently, it has encouraged short-term traders to jump in and squeeze the premium added to capital markets. But, this instance looks different. Not only are we rising from extreme/record lows on activity measures, but the increase itself has so far been restrained. Furthermore, the return potential for the adjustment is smaller than usual. What does this mean for the S&P 500, Yen crosses and broader financial markets? We discuss that in today's Strategy Video.

 sp500 is the leading edge of optimism - jumps in volatility when sp pulls back: sell vol or buy dips. however, despite being the 6 largest volatility spike this year, the pullback is minimal. difficult to keep going to the upside, because there seems to be no reason for it.

 jpy crosses are most risk sensitive, but these haven't done much - not even pulling back to the 100.75 support. so it is unclear if there is an opportunity. eurjpy seems to be doing a reversal though. nzdjpy has great potential if it clears the wedge.
  <2014-07-18 Fri>
***** [[http://www.dailyfx.com/forex/video/daily_news_report/2014/07/17/07-17-2014-Trading-Videoko-EURUSD-Back-to-13500-Dow-Closes-at-a-Record-High.html?CMP%3DSFS-70160000000NbTmAAK][EURUSD Back to 1.3500, Dow Closes at a Record High]]
 - A second day of Yellen testimony didn't bring surprise, but it did seem to foster a USD and risk rebound
 - Between a firmer dollar and easing of Euro-area fears, EURUSD has ended the day at key support: 1.3500
 - Despite heavy event risk which offered clear favor to the pound, GBPUSD refused to progress beyond 1.7200

 Despite a mix of data that offered a distinct favor for the sterling, GBPUSD failed to overtake 1.7200. Meanwhile, a more mixed picture for EURUSD wouldn't keep it from pulling into 1.3500. Both majors are at key technical levels that no doubt have FX traders projecting serious trend developments, but the analysis isn't adding up favorably. Scheduled event risk, underlying fundamental themes, general volatility conditions are not solidifying into the same mold that technicals alone seem to take. With a number of great looking technical opportunities on hand, we discuss the bigger picture for these trade setups in today's Trading Video.

 market conditions still tough. pressure on eur not that strong - need push from either eur or usd for eurusd to move. vv still very low, so breakout will not be self-generating.

 eurgbp, euraud, eurjpy at significant lows however, we need followthru confirmation.

 nzdjpy is likeable to rise so long as risk trends remain stationery.

 gbpusd didn't move and that may be a concern. similar concerns about gbpcad, gbpnzd and this puts a blackmark on gbp.
  <2014-07-17 Thu>
***** [[http://www.dailyfx.com/forex/video/live_events/2014/07/16/07-17-2014-Strategy-Video-Evaluating-EURUSD-GBPUSD-USDJPY-Breakout-Potential.html?CMP%3DSFS-70160000000NbTmAAK][Evaluating EURUSD, GBPUSD, USDJPY Breakout Potential]]
 - Many pairs - including EURUSD, GBPUSD and USDJPY - are close to technical breakouts
 - Not all of the scenarios look ideal through technical, fundamental and market condition analysis
 - EURUSD is a medium-term opportunity, GBPUSD will struggle but the Yen crosses have better mix

 There are a number of major currency pairs - and other asset benchmarks - that are close to bullish or bearish breakouts. Yet, are these technical patterns that are likely to play out? What is their potential for follow through? Is the risk/reward ratio and time frame adding up? In today's Strategy Video, we use a number of the concepts we have discussed recently (three analysis types, time frames, risk-reward, potential versus probability) and evaluate the trade potential for EURUSD, GBPUSD and the Yen crosses.

 eurusd may break below 1.3500 - technicals and fundamentals look great, but market conditions aren't and we need vv. not best time for longterm trades.

 gbpusd can't seem to break to the downside - unclear what it will do.

 jpy crosses are of great interest.
  <2014-07-17 Thu>
***** [[http://www.dailyfx.com/forex/video/daily_news_report/2014/07/16/Trading-Video-Volatility-Strikes-GBPUSD-Now-for-a-Trend.html?CMP%3DSFS-70160000000NbTmAAK][Volatility Strikes GBPUSD, Now for a Trend]]
 - As expected, UK CPI and Fed Chair Yellen's Testimony proved the most market-moving event risk
 - Yet, bullish outcomes for both woudl prevent GBPUSD from sparking a trend and clearing 1.7200
 - This pair is still in the crosshairs as Yellen testimony day 2 approaches and UK jobs are on top 

 Major event risk can stir volatility with a significant enough surprise. That was what happened for GBPUSD between Fed Chairwoman Janet Yellen's testimony and the UK inflation figures. The problem with this wave of event risk was that their respective outcomes would curb trend in both directions for the specific pair. Moving forward, there are plenty of opportunities presenting themselves for the pound-crosses (particularly EURGBP and GBPCAD) and the majors (EURUSD and USDJPY); but GBPUSD remains the center of potential. Meanwhile, risk bearings are starting to percolate and the room to run is substantial. We discuss GBPUSD and more in today's Trading Video.

 gbpcad,gbpnzd may be ranging.

 eurgbp has lowest potential for keeping downtrend.

 eurusd, eurjpy to watch

 lots of setups to examine.
  <2014-07-16 Wed>
***** [[http://www.dailyfx.com/forex/video/daily_technicals/2014/07/15/NeStrategy-Video-Setting-Reasonable-Objectives-for-EURUSD-GBPUSD-USDJPY.html?CMP%3DSFS-70160000000NbTmAAK][Setting Reasonable Objectives for EURUSD, GBPUSD, USDJPY]]
 - There's a cognitive bias - exaggerated expectation - that leads traders to expect too much from each trade
 - Filtering out good setups is only a first step, holding and exiting the trade is just as critical
 - We discuss how technicals, fundamentals and market conditons shape the setups for EURUSD and the majors

 How often do we see high order technical setups with thousands of pips in potential, and enter with the expectation to trade the entire breadth of the pattern? Trading is a probability game; and covering 100 percent of a range, reversing a full-scale trend or wringing every pip from an unaccounted fundamental theme is an exceptionally low probability. Continuing with some of the principles of yesterday's Strategy Video on 'potential' versus 'probability', we discuss establishing reasonable expectations and trading plans for individual opportunities. Then we apply this practice to EURUSD, GBPUSD, USDJPY and AUDUSD.

 optimism is not a strategy.

 eurusd reversal may be imminent due to fundamentals.

 interesting mechanical strategy shown for stops and limits. also shows some using fibonacci levels with eurusd, audusd. uses fundamentals for gbpusd. lots of potential with usdjpy which fits into a larger technical pattern
  <2014-07-16 Wed>
***** [[http://www.dailyfx.com/forex/video/daily_news_report/2014/07/15/Trading-Video-Yellen-Testimony-and-UK-CPI-Mark-GBPUSD-for-Volatility.html?CMP%3DSFS-70160000000NbTmAAK][Yellen Testimony and UK CPI Mark GBPUSD for Volatility]]
 - Equities, yen crosses and EURUSD bounced Monday; but the move seemed more anticipatory than committed
 - Event risk fills out starting with this sessions UK CPI, Fed Chair Yellen testimony and BoJ decision
 - There are a number of Dollar, Pound and risk-based opportunities; but impact depends on the scenario

 The new trading week opened with a measured correction to last week's broad retreat for risky assets. Yet, the true moves will likely be reserved for upcoming event risk. Looking to the economic docket, we have such heavy-hitting listings as Fed Chairwoman Janet Yellen's semi-annual testimony, UK CPI and the BoJ rate decision. These will have a certain impact on interest rate expectations for their respective currencies - and they may even tip the underlying balance between risk and reward. We discuss the upcoming event risks, the bearings for speculative appetite, gold's spat of volatility and trade opportunities in today's Trading Video.
  <2014-07-15 Tue>
***** [[http://www.dailyfx.com/forex/video/daily_technicals/2014/07/15/Strategy-Video-Dollar-Pound-and-SP-500-Probability-vs-Impact-through-Event-Risk.html?CMP%3DSFS-70160000000NbTmAAK][Dollar,Pound,SP500 Probability vs Impact through Event Risk]]
 - There is a slew of event risk coming out this week including today's Yellen testimony and UK CPI
 - Through positioning, the outcomes for these events can provide a very different impact
 - A lower probability but bigger potential would be for a Pound plunge, Dollar rally and S&P 500 collapse
  
 In a dense round of event risk through the immediate future, there are scenarios where the headlines can prove exceptionally market moving...or barely tipping the needle. Expectations build up behind certain themes and markets to minimize the impact of likely outcomes and amplify the reaction to the less likely. In today's Strategy Video, we revisit this scenario analysis between 'potential' and 'probability' for Fed Chairwoman Janet Yellen's testimony, UK CPI and the general lean of a busy docket against the Dollar, Pound and S&P 500.
  <2014-07-15 Tue>
***** [[http://www.dailyfx.com/forex/video/daily_news_report/2014/07/12/Trading-Video-Amid-China-GDP-Portugal-Fears-and-Yellen-EURUSD-My-Top-Trade.html?CMP%3DSFS-70160000000NbTmAAK][Amid China GDP, Portugal Fears and Yellen, EURUSD Top Trade]]
 - Though it may not play out in the opening hours of next week, EURUSD is my favorite setup going forward
 - Amid so many different indicators, tech patterns on crosses and themes; most scenarios align for EURUSD
 - Meanwhile, top event risk presents plenty of opportunity for the Dollar, Euro, Pound, Yen and Aussie

 There is plenty of short-term trade potential heading into the coming week, but scope still falls to the level of volatility in the financial system. Though there are more than a few themes and catalysts leveling their sights on complacency - a withdrawl of central bank stimulus, European financial system cracks, Chinese GDP, etc - we have seen too many false starts not to maintain composure and a health dose of skepticism. In this weekend Trading Video, we cover many of the top fundamental drivers currently on tap, the scenarios with the greatest market-moving potential and the best combination of technicals. Through it all, EURUSD still comes up as my favorite, medium-term opportunity.

 turn vix, but will it be a lasting one?

 eurusd medium forecast with great potential because of 
 - eur: vix, portugese problem, monetary policy, financial instability, risk aversion theme.
 - usd: vix has direct relationship, interest rates, speakers mainly hawkish.

 usdjpy is perfect technical pattern. those often give the most false breaks, so we need fundamentals to back these.
 eurjpy is even better possibility due to the eur fundamentals.

 gbpusd is good one too because gbp has been outpacing usd despite the latter's fundamentals. gbpjpy, gbpaud, gbpcad are all possibilities too.

 euraud good too due to eur problems and aud may be good in medium turn.
  <2014-07-12 Sat>
***** [[http://www.dailyfx.com/forex/video/daily_technicals/2014/07/11/Strategy-Video-Top-Themes-and-Catalysts-for-EURUSD-USDJPY-and-the-Majors.html?CMP%3DSFS-70160000000NbTmAAK][Top Themes and Catalysts for EURUSD, USDJPY and the Majors]]
 - There is plenty of event risk and appealing technical setups, but we should filter the best options
 - Starting with a view of the top themes - risk trends and rate forecasts - we can identify top potential
 - Between sentiment and monetary policy views, EURUSD, USDJPY, EURJPY and GBPUSD are my favorites

 With so many glaring technical setups and high-profile event risk on deck next week, there are too many opportunities to kepe track of. A better approach than working off the 'triggers' to a good setup would be to start with the major fundamental themes that can get markets moving and keep them moving. In this weekend's Strategy Video, we look to refine the search for great setups by starting from the big picture and working to the signals. On the top of my list are EURUSD, EURJPY, USDJPY and the S&P 500.

 start from fundamentals to explain technicals rather than the other way around.

 vix (risk appetite) above 12.00 for first time for a while particularly in equity.
 plenty of rate decision and monetary policy available.
 how do we know there are opportunities?

 risk trends
 eurusd best opp
 jpy crosses usdjpy,eurjpy great potential if break comes.

 interest rate expectations
 nzd is hawkish, but there is no change, so it's not taking off.

 eur good opp on monetary basis.
 gbp also, because there are key speakers this week. gpbusd may fall.
 usd is setting policy based on this week.
  <2014-07-12 Sat>
***** [[http://www.dailyfx.com/forex/video/daily_news_report/2014/07/11/Forex-Trading-Video-EURUSD-EURJPY-and-SPX-Ready-to-Cave-if-Risk-Collapses.html][EURUSD, EURJPY and SPX Ready to Cave if Risk Collapses]]
 - A building fear from European markets was amplified by troubles with a major Portuguese lender
 - Regional concerns are no longer finding an apathetic market as volatility lurched higher
 - For trends to develop, the next step needs to be elemental - the VIX, SPX and EURUSD will be barometers

 We finally seem to have found a pulse in the financial markets. Global equities slumped and volatility readings picked up this past session, helped along by fear and heavy selling pressure surrounding a large Portuguese lender. Alone, it may not be material enough to draw direct comparisions to the Eurozone crisis a few years ago; but this is not the first crack the market has noticed. The tipping point for broader market conditons however remains cross-asset volatility. Should this activity measure rise, it will be difficult to maintain the euphoric complacency that has carried us recently. Though there are many opportunities should the tides turn; our initial focus in this Trading Video are the S&P 500, EURUSD and EURJPY.

 fear in portugal may spread to other countries which is something to look for.

 sp 5yr trend is as resilient as it gets, so any pullback may be significant.

 nice jump to 13 on vix, suggesting we are getting some volatility (equities leading way).

 if lending were to seize up in the european markets, euro would collapse 500pt and there is some initial tension to that effect.

 eurusd, eurjpy both have real potential.

 event risk to prepare for next week.
  <2014-07-11 Fri>
***** [[http://www.dailyfx.com/forex/video/daily_technicals/2014/07/11/Strategy-Video-Euro-Has-Plenty-More-Issues-than-Just-Portugal.html?CMP%3DSFS-70160000000NbTmAAK][Euro Has Plenty More Issues than Just Portugal]]
 - The Euro and global capital markets slipped Thursday on news of a troubled Portuguese bank
 - There are a number of potential catalysts for the currency, and bearish scenarios carry far more weight
 - We look at the monetary policy, sovereign and financial risks the Euro faces going forward

 The Euro dropped against all of its major counterparts this past session. Yet, this move pales in comparison to the underlying troubles that threaten to rekindle selling pressure thought curbed two years ago. There are three main fundamental avenues of the concern that are necessary for the currency's and economy's stability - and unfortunately, all three carry far greater impact should they deteriorate. We have already seen monetary policy weigh on the currency, but a second wave is ahead. Portugal and Greece headlines have reminded of us lingering sovereign health issues. And, the most destructive and responsive consideration is a change in financial strength. There are issues brewing with all three, yet they are not fully realized and certainly not priced in. We discuss these three factors and their trade potential in today's Trading Video.

 3 things to watch with eur down development:
 - monetary policy dovish: by ecb has changed since may (but not proactive yet)
 - sovereign bond issue: confidence in countries portugal, greece 
 - financial issue: pullback on capital markets and change of financial strength

 likes eurusd below 1.3500, euraud below 1.4400, eurjpy 1.3750
  <2014-07-11 Fri>
***** [[http://www.dailyfx.com/forex/video/daily_news_report/2014/07/10/Forex-Trading-Video-EURUSD-Immune-to-Fed-and-ECB-Rate-Divergence.html?CMP%3DSFS-70160000000NbTmAAK][EURUSD Immune to Fed and ECB Rate Divergence?]]
 - The Fed's transcript of its last policy meeting reinforced a shift towards an eventual rate hike
 - Neither the modest hawkish shift nor concerns of complacency however triggered a dollar or risk reversal
 - 'Status quo' is a powerful market condition that supports risk appetite, congestion and certain trend 

 The Fed's shift away from subsidizing speculative appetite is clear...but perhaps not flagrant enough to turn the soaring equities market and turn the US Dollar to a new bull trend. The hurddle of overriding the market's state of 'status quo' is high. Quiet market conditions, short-term opportunities to sell risk premia (buy dips) and comfort in remaining all-in with the rest of the market is a strong opiate. The sense of drugged complacency certainly held the market through the Fed's minutes despite a firmed timely for QE3 to end, reinforcing a shift towards rate hikes and warning that markets are taking on too much risk. Volatility and risk remain the key to how we trade these markets. We look at these important environmental factors, upcoming event risk and active setups in today's Trading Video.

 significant shift in the risk themes, but didn't affect the market which are influenced by stimuli.

 speculators can't squeeze much out of the market when there is not much there.

 eurusd may just be chopping along for a while - ok for short term, but difficult to deal with in long/medium which offer greatest potential.

  <2014-07-10 Thu>
***** [[http://www.dailyfx.com/forex/video/technical_analysis/2014/07/09/Why-arent-fed-rate-forecasts-driving-the-dollar.html?CMP%3DSFS-70160000000NbTmAAK][Why Aren’t Fed Rate Forecasts Driving the Dollar?]]
 - The consensus amongst the FOMC is for a first Fed hike in 2015 and further tightening thereafter
 - Though the central bank's own rate forecasts outpace many counterparts, the markets aren't conforming
 - Another sign of complacency, we are looking at another well of untapped dollar potential 

 The FOMC minutes reinforced a forecast that will carry a lot of weight with global capital markets and the US Dollar: a transition to policy tightening and rate hikes. And yet, where was the risk aversion and dollar rally that we would expect to accompany this change in tides? The market is discounting its rate projections and the impact they would have in the markets in part due to the universal sense of complacency hanging over us like a fog. That said the potential energy stored up in this theme is substantial. We discuss rate forecasts and the dollar in today's Strategy Video.

 fundamental - what's important to the greatest number of people.

 why is fomc minutes not driving usd higher?
 imho, his idea of complacency seems to be a result of conflicting attitudes.
 he says many things are already priced in so status quo is merely maintained in a zombie-like fashion. things should pick-up when interest rates pick-up.

 the market is discounting even the fomc!
  <2014-07-10 Thu>
***** [[http://www.dailyfx.com/forex/video/daily_news_report/2014/07/08/Trading-Video-Equities-Threaten-a-turn-dollar-not-yet-impressed.html?CMP%3DSFS-70160000000NbTmAAK][Equities Threaten a Turn, Dollar Not Yet Impressed]]
  - Event risk put the focus on rate forecasts, but risk trends carried the greater weight
 - Global equities were fading - raising the threat level on a possible risk reversal
 - Meanwhile, tepid data from the UK and status quo from Fed speakers couldn't drive GBPUSD below 1.7000 

 Discontent is stirring amongst the contented speculators. Low volatility and an appetite for yield go hand-in-hand, but even die-hard bulls doubt its much longer lived. Given the breadth of opportunity, market participants are itching for the swell of trend and abundance of opportunity that comes along with a shift in speculative appetites. Yet, we have seen too many starts to be drawn in without confirmation. Global equities made the biggest contribution to a risk interest with heavy selling particularly in Europe. However, that is only the first level of a risk-derived move. Volatility measures, FX participation and fundamental moorings are necessary to alter such a remarkable trend. Will we finally find it? We discuss what to watch and what to trade in today's Trading Video.

 two themes in trading videos now: interest rates and risk trends.

 eurusd has great potential for decline, but needs fundamental backing which may be coming up on thu.

 risk trends taking backseat to interest rates.

 usdjpy good, but eurjpy better if risk aversion.

 eurusd would go down if risk aversion, but we need more consistency.

 lot of opportunity, but need to watch signals - we are in a lull right now.
***** [[http://www.dailyfx.com/forex/video/technical_analysis/2014/07/08/Strategy-Video-Volume-for-Risk-Analysis-to-EURUSD-Trade-Setups.html?CMP%3DSFS-70160000000NbTmAAK][Volume for Risk Analysis to EURUSD Trade Setups]]
 - The FX market is decentralized, meaning there is no market-wide volume measures
 - However, the FXCM Real Volume and Transaction indicators give a good measure of speculative activity
 - We can use volume as both an overview analysis technique and as an individual trade filter

 Some believe that most technical indicators are similar in that they are derived from the same thing: price. Volume, however, is a unique and separate appraisal of the market that can meaningfully improve our analysis of the market or individual trade opportunities. With the Real Volume indicator, we can bring volume analysis to our FX trading. In today's strategy video, we discuss how this information can be used to give us greater insight into broader market conditions as well as shape more distinct trade setups - with a reference to risk trends, the S&P 500, EURUSD, GBPUSD, USDJPY and others.

 low volume on a trend reflects low confidence that the trend will continue - so it may suggest a reversal is ahead.

 pick up in volume results from a pick up in volatility. 
***** [[http://www.dailyfx.com/forex/video/daily_news_report/2014/07/08/heavy-Event-risk-threatens-gdpusd-break.html?CMP%3DSFS-70160000000NbTmAAK][Heavy Event Risk Threatens GBPUSD Break]]
 - After last week's extremely volatility and volume lull, a seasonal/historical revival is proving slow
 - Activity and participation remain the top concern for traders and their approach going forward
 - In the meantime, event risks - like the FOMC speeches and UK data for GBPUSD - presents specific setups

 The first day back from last week's extreme volatility lull and we have yet to a comprehensive change in trading conditions. A sudden revival in volatility and participation is unlikely, but a systemic shift is likely from a seasonal and historical perspective. This assessment is at the root of what setups can be expected to play out, how to trade those opportunities and generally what strategies to use. With mind to the market backdrop, event risk picks up over the coming 24 hours. Of particular interest is the UK data as the market tends to its aggressive BoE rate forecasts and US Fed speakers who can reshape the timing of policy tightening. We look at the big picture and individual setups in today's Trading Video.

 no huge moves yet and volatility still low. activity levels crucial to trading.

 big opportunity should levels pick up.

 gbp crosses have great potential. gbpusd, eurgbp, gbpjpy, gbpaud, gbpnzd to watch over next 24 hrs depending on how fundamentals work out for gbp.

 same with usd crosses. audusd, usdjpy, nzdusd, usdcad need risk-based theme to break u/d.

 what can shake complacent market? difficult to say.
  <2014-07-08 Tue>
***** [[http://www.dailyfx.com/forex/video/daily_technicals/2014/07/08/Pound-Dollar-SPX-Pricing-in-Perfection.html?CMP%3DSFS-70160000000NbTmAAK][Pound, Dollar, SPX - Pricing in Perfection?]]
 - 'Pricing in Perfection' is a term that looks to label over/under-valued markets rather than tops/bottoms
 - True tops and bottoms seldom occur, but a trend can see its momentum fade if its premium is bloated
 - We weigh the claims of 'pricing in perfection' for the S&P 500, British Pound and US Dollar

 'This market is pricing in perfection.' This is a label applied to an instrument or asset class that has exhausted the potential in an underlying fundamental or systemic theme. In practice, that means the market doesn't have to put in a top/bottom and reverse immediately. Rather, it reflects a limitation for extending an existing trend via its premium, and a substantially greater potential in a reversal - if and when it occurs. We discuss this phrase and fundamental assessment - with a review of the S&P 500, British Pound and US Dollar - in today's Strategy Video.

 used in fundamental discussions - puts in a top/bottom.

 separate fundamentals from actual price action.

 gbp strength is already wrapped in its hawkish interest expectation, so a genuine bull trend would require even better interest expectation. there is a difficulty is driving the trend further up.

 usd may be in for bullish trend because rate expectations are high especially in longterm.
  <2014-07-08 Tue>
***** [[http://www.dailyfx.com/forex/video/daily_news_report/2014/07/03/Trading-EURUSD-through-ECB-decision-NFPs-and-Week-End.html?CMP%3DSFS-70160000000NbTmAAK][Trading EURUSD Through ECB Decision, NFPs and Week End]]
 - High level event risk in the form of the ECB rate decision and NFPs is due today
 - A volatility swell in calendar items will conflict with a seasonal and systemic volatility drain
 - The shift in market activity - coming perhaps as early as next week - is a key

 It looks like EURUSD traders will have an busy day ahead of them. Both the ECB rate decision and June US NFPs are due this session. And, given the interest in the dispirate monetary policy bearings between the two major central banks and currencies; the probability of a burst of volatility is high. That said, there is vast difference between a bout of volatility and a lasting build in participation that can feed a trend. Market conditions will work against against this event risk's ability to generate a larger shift from the dollar, euro and speculative appetites...at least through the end of the week. What should we expect from this clash between key event risk and record low volatility measures? We discuss that in today's Trading Video.

 usa goes offline and speculative initiatives are dampened. 
 vix used as a global parameter.

 market conditions should be more normal after jul4

 ecb introduced jun5 stimulus efforts which brought decline in eurusd, but it didn't last for eur. in beginning of may, ecb did nothing, but we had major decline. doing nothing had more of an influence kept people thinking that ecb was going to introduce stimulus. appetite for risk is more significant than monetary policy right now.

 nfp will likely make more of an impact, but will still conform to the overall market conditions. market reaction to nfp chart.

 two major drivers for usd are risk trends and interest expectations.
  <2014-07-03 Thu>
***** [[http://www.dailyfx.com/forex/video/technical_analysis/2014/07/03/Forex-Strategy-Video-Trades-Strategy-and-Market-Everything-Changes.html?CMP%3DSFS-70160000000NbTmAAK][Trades, Strategy and Markets - Everything Changes]]
 - After finding a good strategy - an 'edge' - traders will look to filter through the markets for setups
 - Yet, as we have seen market conditions change, which necessitate a change in our strategy and approach
 - On an even larger scale, the markets themselves inevitably change and we must adapt to thrive

 Over a long enough period, no strategy will go without losing trades. Yet, a robust approach to the market will prove profitable over time. That said, even the best strategy needs to be adapted as certain aspects of the marekt change. Fundamental event risk and technical developments are a short-term realization of this issue. On a larger time frame, more substantial changes in liquidity and participation (a few aspects of what we define as 'market conditions') require more substantial adjustments and maybe even a new strategy. Furthermore, those who have been in the market for a longer time or naturally have a bigger picture view further recognize that there are even larger change, systemic changes in the market - new assets, regulations, a rise or fall in popularity, etc. And those that recognize this grand scheme are often the best prepared and most profitable. We discuss this 'high-minded' topic in today's Strategy Video.

 markets change over period of time (bollinger said that too).

 volume/volatility are part of systemic changes that alter market. automated strategy exercise shows that a great one only works for a period of 5 years. we need to change with these alterations (vols, regulations, currencies etc). cnh is being introduced as a major currency.

 more participants may enter fx and that will cause the market to change.

 central bank entries may reduce volatility which will require changes in market.
  <2014-07-03 Thu>
***** [[http://www.dailyfx.com/forex/video/technical_analysis/2014/07/01/Forex-Trading-Video-AUDUSD-Breaks-GBPUSD-and-SP-500-Extend-Bull-Trends.html?CMP%3DSFS-70160000000NbTmAAK][AUDUSD Breaks, GBPUSD and S&P 500 Extend Bull Trends]]
 - The 'risk-appetite' and anti-dollar themes extended their reach this past session
 - AUDUSD put in for a key technical break and GBPUSD extended one of the majors' strongest trends
 - Liquidity and a focus on Thursday's NFPs will seriously change the market's landscape

 Two strong market themes have extended their run this past session: dollar selling and the bid underneath high profile 'risk' benchmarks. These drivers would see the USDollar Index slammed into the floor of a 16-month range with a remarkable break from AUDUSD, and the S&P 500 climb to a record high. Yet, as convincing as the technical moves are, the fundamental fuel to sustain the trends is spotty. More importantly, market conditions in the liquidity and volatility backdrop threaten to turn the tap off - regardless of theme and direction. With such alluring technical developments and major event risk not far ahead, we look at the market's general pace and individual opportunities in today's Trading Video.

 these 24 hrs just a wait before take off next week.

 sp500 is benchmark for speculative appetite.

 followthru is the real question! even great technicals will result in nothing unless there are suitable market conditions and we get big buildups for non-events.

 usd crosses will be affected by what happens at 16mon support.

 july sees return of volatility - biggest month of the year.

 audusd broke bullish, but may not sustain. better chance of doing so if it went bearish because then it would fit into the range pattern. easier to cover range than make new ground.

 usdcad bearish, but not confident about cad because of fundamentals. breakout of necessity present, but there may be no followthru.

 likes audusd, but wants it to be supported by fundamentals and triggered by technicals. doesn't like the break with low volatitily - prefers interest rate indications.

 there are attractive techs, but must be supported by fund and mc - that's where real opportunities lie.

 use restraint right now and look for followthru rationale.
  <2014-07-02 Wed>
***** [[http://www.dailyfx.com/forex/video/technical_analysis/2014/07/01/Strategy-Video-What-Will-Drive-the-USD-This-Week-and-Beyond.html?CMP%3DSFS-70160000000NbTmAAK][What Will Drive the USD This Week and Beyond]]
 - The USDollar Index has dropped back to 16-month range support on key EURUSD, AUDUSD, GBPUSD breaks
 - Market conditions this week are not conducive to follow through - for individual assets or themes
 - A focus on interest rates and risk theme put the greenback in a good position as long as activity rises

 The US Dollar has suffered critical breaks this week on EURUSD, GBPUSD and AUDUSD. These moves have not turned the tide for the USDollar Index, but it has driven the benchmark to a 16-month range support. Under pressure from a fading volatility backdrop (weighing against the currency's safe haven / liquidity appeal) and the market's stubborn doubt of the Fed's interest rate timetable, the fundamental tides are clearly against the currency. And yet, its losses have been contained to technical breaks in name only and little-to-no momentum. Status quo this week is unfavorable for the dollar, but market conditions are also constricting trend development. But, should market activity pick up the following week - either risk trends or monetary policy speculation are likely to breathe new interest into the greenback. We take a more critical look at the US Dollar in today's Strategy Video.

 market conditions override fundamentals and technicals.
 5 consecutive down days bringing usd to 16month floor.
 but we don't want to position for the huge bear trend given mc.
 there may be no followthru: need participation and liquidity.

 major pair developments 1407:
 eurusd made only a modest move.
 gbpusd made a better followthru, but still not strong.
 audusd seems to be doing better.
 usdjpy also bearish breakout.

 all these breakouts will have followthru??

 if usd is able to hold support in face of record low volatility, the negative implications are limited and the positives have much more scope. next week will be a period of transition. eurusd is likely to react strongly.

 interest rates are very important and the nfp on thu will be used by feds to determine movement there.

 usd needs activity and eurusd will be the thing to watch when that happens.

 market conditions dominate spectrum right now!
  <2014-07-02 Wed>
***** [[http://www.dailyfx.com/forex/video/daily_news_report/2014/07/01/EURUSD-ad-GBPUSD-break-higher-USDollar-at-critical-support.html?CMP%3DSFS-70160000000NbTmAAK][EURUSD and GBPUSD Break Higher, USDollar at Critical Support]]
 - EURUSD and GBPUSD put opened with tremendous moves for a week that typically sees liquidity drain rapidly
 - Despite the move from these majors, the USDollar is only not facing 16-month support
 - The BIS - central bank of the central bank - releases a serious warning on stimulus and financial markets 

 The FX market is doing its best to fight the seasonal liquidity drain's crash into historically low volatility measures. Both EURUSD and GBPUSD marked notable bullish breaks Monday. While the immediate follow through on the moves was limited, the former breaks against a prominent divergence in fundamental forecasts (monetary policy and interest rates) and the latter is now trading at level last seen since 2008. If these pairs are to gain a foothold, we will likely see the USDollar slip below support that has stood for 16-months - difficult in these conditions. There is plenty of event risk to make this a risk. In other news, the Bank of International Settlements (BIS) has issued the most prominent warning of complacency and financial market risk of any regulatory institution to this point. What does all of this mean for traders? We discuss that in today's Trading Video.

 jul is highest month for volatility after the 4th.
 when volatility rises usd does better.

 gbpaud good for short still.

 monetary policy is leading to a time of excessive risk taking.
 when volatility drops, people take greater risk.

 markets are prone to volatility, but not necessarily followthru.
  <2014-07-01 Tue>
***** [[http://www.dailyfx.com/forex/video/technical_analysis/2014/07/01/Forex-Strategy-Video-Central-Abnks-supporting-long-term-eurusd-bull-trend.html?CMP%3DSFS-70160000000NbTmAAK][Central Banks Supporting Long-Term EURUSD Bull Trend?]]
 - Beyond retail speculators, money managers and big banks; the biggest player in FX is central banks
 - Changing monetary policy for the local currency isn't the only way they can impact a currency
 - A rise or fall in reserve demand can direct long-term trends - and EURUSD and GBPUSD are great examples 

 Retail traders and large speculators stir short-term FX volatility. However, the bigger trends arguably fall under central bank efforts. Changing interest rates and stimulus programs has tremendous influence over the performance of currencies. Yet, there is another way central banks like the Fed, ECB and BoE can direct the long-term strength or weakness of currencies: reserve diversification. With the end of quarter, the IMF has released its COFER report showing the holdings of the different majors by global central banks. We look at what long-term trends are evolving from these large market participants' efforts and discuss how they add to trading picture alongside retail speculators and large money managers in today's Strategy Video.

 central banks can influence forex by changing monetary policy and they buy/sell currencies too.
  <2014-07-01 Tue>
***** [[http://www.dailyfx.com/forex/video/identifying_trades/2014/06/28/Trading-Video-Liquidity-Drain-Vs-NFPs-and-ECB-for-EURUSD-Next-Week.html?CMP%3DSFS-70160000000NbTmAAK][Liquidity Drain Vs NFPs and ECB for EURUSD Next Week]]
 - There is high level event risk scheduled for release next week including the NFPs and ECB decision
 - Market conditions, however, may prove an issue with the US market holiday further draining volatility
 - With pairs like EURUSD, GBPUSD and AUDUSD suggesting trade potential, we have to look at the big picture

 With US NFPs and an ECB rate decision scheduled for the same day, it would seem EURUSD is guaranteed a breakout and trend development next week. Yet, even with capable fundamentals and convincing technicals, market conditions are still a critical ingredient to market development. That will prove the deciding factor for how we approach the market over the immediate future. A US holiday liquidity drain will exacerbate an already anemic volatility backdrop. How should we approach the markets this week - and for that matter the week after when volatility historically sees a significant rebound? We discuss that in the weekend Trading Video.

 market conditions override fundamental and technical.

 eurusd should drop in the future.
 gbpusd should drop due to conflicting expectations for the pound?
 audusd should do something due to interest rate expectations and wedging.
 audnzd should likely go up due to contrast.
 usdcad should do something depending on whether we have floor/ceiling.
  <2014-06-28 Sat>
***** [[http://www.dailyfx.com/forex/video/technical_analysis/2014/06/27/Forex-Strategy-Video-Why-Volatility-May-Return-Sooner-Than-You-Think.html?CMP%3DSFS-70160000000NbTmAAK][Why Volatility May Return Sooner Than You Think]]
 - Already experiencing a historic slide in activity, we are coming on to the usual July 4 volatility slump
 - A drop in the VIX in the week lending into the holiday period is normal...but so is a surge afterwards
 - Not only does volatility usually rebound the week after the July 4th, July experiences the biggest jump

 Volatility, already extremely low by historical standards, is heading into the trough of the 'Summer Doldrums'. What does that mean for trading opportunities next week given an round of event risk that includes NFPs, an ECB rate decision and the quarter rollover? Though fundamentals and technicals will more often defer to market conditions, that doesn't mean activity has been immobilized for the foreseeable future. In fact, history suggests that the period following the Independence Day activity slump usually sees the biggest swell in market movement of any other time of the year. In the weekend Strategy Video we discuss whether the return of volatility is nigh.

 probably no 200 pt move depending on thur announcement, but more normal market conditions may return after holiday. jul is historically has highest vix, followed by sep, aug, oct, feb, may, mar, jun, jan, dec, nov.

 volume and volatility seem to have a direct relationship.

 volatility is basis for risk trades.
  <2014-06-28 Sat>
***** [[http://www.dailyfx.com/forex/video/daily_news_report/2014/06/27/Trading-Video-Growing-More-Difficult-to-Reverse-SP-500-Break-EURUSD.html?CMP%3DSFS-70160000000NbTmAAK][Growing More Difficult to Reverse S&P 500, Break EURUSD]]
 - A systemic drop in volatility is combining with the seasonal Summer activity slump to anchor the market
 - Market conditions will override breakout situations like that on EURUSD or the impact of next week's NFPs
 - Trade selection much be made with a mind to what moves and pairs can reasonably generate heat 

 EURUSD is working its way into a necessary breakout and GBPUSD has absorbed event risk that can further enforce a GBPUSD reversal on rate hopes. Yet, these moves are unlikely to play out through high-profile technical moves or even key event risk through the near future. Market Conditions - the third analysis type - is closing the market down with the hope of a reversal from extreme complacency and low volatility dampened by holiday trading conditions looming next week. Setting probabilities for good trades is even more important as 'happy accidents' are less likely to occur. We evaluate what setups look good given current market conditions and which are tempting traps in today's Trading Video.

 volume and volatility going down: don't expect reversals etc. stimulus lows volatility and risk.

 GBP crosses are providing range opportunities.
  <2014-06-27 Fri>
***** [[http://www.dailyfx.com/forex/video/technical_analysis/2014/06/27/Strategy-Video-When-Does-Monetary-Policy-Drive-EURUSD-GBPUSD-and-Others.html?CMP%3DSFS-70160000000NbTmAAK][When Does Monetary Policy Drive EURUSD, GBPUSD and Others?]]
 - Data and policy remarks this past session for the UK and US changed rate expectations, but not the GBPUSD
 - Speculation on interest rates and monetary policy is a key fundamental driver
 - The impact of any fundamental theme or update depends on how much it alters prevailing expectations

 Speculation of a BoE rate hike months ahead has led the pound to rally thousands of pips while expectations of an ECB rate cut reversed EURUSD from 1.4000. Yet, this past session, a policy move by the UK central bank and very hawkish comments made by Fed officials failed to generate much traction from the pound or dollar - much less GBPUSD. Monetary polish - from rate hike timing to speculation of stimulus upgrades - is one of the market's most influential fundamental themes. However, there are certain requirements that even the top themes need to meet to move markets. We discuss these conditions and the policy standings for the major currencies in today's Strategy Video.

 markets run on 2 primary themes: risk and interest rate expectations. NZD considered a major currency despite minor economy because of the high interest rate offered.

 volatility/risk chart.

 lots of opportunities with AUD if it goes hawkish.

 stimulus for JPY should provide movement, but no movement right now.
  <2014-06-27 Fri>
***** [[http://www.dailyfx.com/forex/video/daily_news_report/2014/06/26/Trading-Video-EURUSD-Breakout-Has-Problems-Pound-Trades-in-Focus-Again.html?CMP%3DSFS-70160000000NbTmAAK][EURUSD Breakout Has Problems, Pound Trades in Focus]]
 - EURUSD managed to break a short-term range, but follow through will struggle with the chosen direction
 - To overcome quiet market conditions, we need technical breaks that leverage fundamental trends
 - Ahead, the Pound has key event risk and appealing trade setups; while the Dollar and Yen face key data

 A short-term breakout - like that won by EURUSD this past session - fits the kind of market conditions we have been dealt with as of late...unless it is a break against the prevailing fundamental and technical trends. The benchmark currency pair managed to clear a 6-week trendline around 1.3625 to resolve a terminal range, but the difference between US and Eurozone monetary policy bearings present a serious headwind to generating follow through. This same technical versus fundamental mentality has sapped the drive out of the S&P 500's attempt at a reversal and GBPUSD's break above 1.7000. In today's Trading Video, we look at the key event risk ahead and work out the best scenarios alongside the technical picture for the best trade opportunities.

 first moves haven't developed into progressions due to market conditions. difficult to go against market conditions so EURUSD 2h break to upside fell back because the general situation appears bearish and EUR is not bullish. break below the bottom wedge line is more significant. USDJPY also broke because it ran out of room, but has gone nowhere.

 GBPAUD and GBPNZD due for a downside break that is likely to stay.

 EURAUD in downtrend too.

 AUDNZD good uptrend inside range.
  <2014-06-26 Thu>
***** [[http://www.dailyfx.com/forex/video/technical_analysis/2014/06/25/Strategy-Video-The-Strategy-of-Picking-Tops-for-GBPUSD-USDJPY-and-SP-500.html][The Strategy of Picking Tops for GBPUSD, USDJPY and S&P 500]]
 - Picking tops and bottoms is a low probability and high payout approach
 - Finding an equilibrium where the turn seems more likely and return within reach is critical
 - We discuss the requirements using examples of the S&P 500 (risk), GBPUSD and USDJPY

 Picking tops and bottoms is fraught with danger. There is a reason markets trend whether speculators are following technical trends, fundamentals are generating embalances or market conditions promote a 'status quo'. However, abrupt, seismic and gradual reversals do occur. Applying strategy that takes advantage of the prevailing trends is statistically-speaking the best policy, but the opportunity of a genuine turn in the markets often presents exceptional return potential. In today's Strategy Video, we discuss some of means for confirming tops and bottoms with a specific look at the S&P 500, GBPUSD and USDJPY.

 lack of volatility encourages riskier trades. USD, Dow SP500 in bull trends therefore, reversals are unlikely even when s/r broken. to offset probability of trend reversing, we need a greater risk to reward ie a strong downside eg 50pip etc depending on timeframe.

 difficult to generate trends in these market conditions and even more difficult to generate trends against the prevailing trend.

 a correction on the magnitude of the trend itself to justify accepting reversal.
  <2014-06-26 Thu>
***** [[http://www.dailyfx.com/forex/video/daily_news_report/2014/06/25/Trading-Video-Risk-Trends-Ease-EURUSD-Pressure-Builds.html?CMP%3DSFS-70160000000NbTmAAK][Risk Trends Ease, EURUSD Pressure Builds]]
 - The S&P 500 and other risk barometers edged back, but this is still far from a true reversal
 - EURUSD put in for a short-term break and a second - more substantial one - may soon follow up
 - Evidence that trend development is very difficult to engage, GBPUSD's 1.7000-Break falls apart

 US equities slipped and the VIX moved back above 12. To many market participants desperate for more substantive and durable trends, this looks like a long-awaited systemic reversal. However, both the reach on risk positions and the extent of complacency are far too substantial to be decided on a single day's correction. That means appealing setups like the S&P 500's trend, a terminal USDJPY wedge and GBPUSD drop back below 1.7000 are not certain bear trends in wait. Market conditions are still a critical aspect of trade identification, which limits some pairs and markets while reinforcing the potential in others. We look at market conditions and trade opportunities in today's Trading Video.

 how have risk trends been for the past week, month, 3 months: bullish! we shouldn't be so desparate for activity. watch intermediate trend levels.

 EURUSD break to the upside was capped. more opportunity to the downside because there is more room to move. risk aversion could be a catalyst. a risk aversion theme makes it much easier to trade within a range as in AUDUSD and USDJPY.

 thursday report is going to be important to determine strategy.
  <2014-06-25 Wed>
***** [[http://www.dailyfx.com/forex/video/technical_analysis/2014/06/24/Strategy-Video-EURUSD-AUDUSD-USDJPY---Which-Has-Short-Term-Trade-Potential.html?CMP%3DSFS-70160000000NbTmAAK][EURUSD,AUDUSD,USDJPY - Which Has Short-Term Trade Potential]]
 - Technicals, fundamentals and market conditions are each critical facets to defining trade opportunities
 - The proper combination can separate imminent opportunities from superficial technical setups
 - We break pairs like EURUSD, AUDUSD and USDJPY into imminent, medium-term and low probability brackets 

 Sometimes the best technical picture or high-level event risk fails to generate meaningful trades. A combination of fundamentals, technicals and market conditions filters out higher probability scenarios from setups that are deceptive with only surface level appeal. Using the approach to analyzing each opportunity in yesterday's video, we separate setups showing up on different traders' radars. Reviewing pairs like EURUSD, AUDUSD and USDJPY; we establish high probability and imminent, strong potential but lower probability, and tremendous profile but beset opportunities in today's Strategy Video.

 - market conditions to support moves
 - technicals to trigger the moves
 - fundamentals to help trigger and sustain these moves

 EURUSD has contained potential because market conditions aren't right so we'd expect only a stoic follow-thru. so look to short-term 2 hr and expect wedge to provide some downside (preferably) movement.

 NZDUSD d1 has tight range at top of larger range. movement will be due to fluctuations in the USD since NZD remains stable.

 NZDJPY d1 shows 4 days of tight range reflective of imminent breakout, but not necessarily a strong follow-thru.

 AUDNZD d1 again has a tight range at bottom of larger range. a breakout of necessitiy - running out of room!

 medium range provides bigger opportunities, but with lower probabilities at present.

 GBPUSD break above 1.70 and pullback.

 AUDUSD is in range with no conditions yet for big breakout.

 GBPAUD, EURAUD bigger movements look promising, but not continuations.

 longterm

 USDJPY and other jpy crosses move when risk trends move (sp500). technicals look good, but underlying conditions aren't.
  <2014-06-25 Wed>
***** [[http://www.dailyfx.com/forex/video/daily_news_report/2014/06/24/Trading-Video-EURUSD-a-Better-Trade-Opportunity-Despite-GBPUSD-Event-Risk.html?CMP%3DSFS-70160000000NbTmAAK][EURUSD a Better Trade Opportunity Despite GBPUSD Event Risk?]]
 - The balance between Market Conditions, Fundamentals and Technicals is shaping trade probabilities
 - Market conditions present better probabilities for a short-term EURUSD wedge than long-term GBPUSD run
 - Nevertheless, event risk for the Pound tops the docket today with the BoE talking forward guidance
 There are high-profile and long-term trade patterns shaping up in the FX market, but the more probable opportunities are the shorter-term range and breakouts. Market Conditions - as a third dimension to trade and systemic analysis - still favors short-term developments. That means a wedge formation from the EURUSD on the two-hour chart carries better potential than the high-profile GBPUSD break above 1.7000 or the pent up pressure for USDJPY in a multi-year technical pattern. With that in mind, we head into noteworthy event risk from the UK and key technical levels for a range of currencies with expectations for what is reasonable from the markets. We discuss this and more in today's Trading Video.

***** [[http://www.dailyfx.com/forex/video/technical_analysis/2014/06/24/Strategy-Video-Why-the-1-7000-GBPUSD-Break-Hasnt-Charged-Bulls.html?CMP%3DSFS-70160000000NbTmAAK][Why the 1.7000 GBPUSD Break Hasn’t Charged Bulls]]
 - GBPUSD broke major resistance at 1.7000 last week with virtually no follow through
 - Technical levels can be rendered impotent or amplify incredible moves depending on backdrop conditions
 - Fundamentals and Market Conditions are critical factors in deciding the impact of Technical levels 
 Why do breakouts and reversals around 'major' technical levels sometimes fail to generate strong market moves? Just this past week, GBPUSD broke above a 1.7000-level that has acted as a major turning and break point for the pair over the past two decades. Yet, there was little fanfare as the market found little follow through on the important event. Fundamentals and Market Conditions can dull or amplify the impact that Technical developments have. In this instance, a strong build up in BoE rate forecasts and market that struggles to produce trends curbed the otherwise remarkable development. We look at how to read the other two types of analysis to assess the impact of technical events and apply it to GBPUSD, EURUSD, AUDUSD and USDJPY in today's Strategy Video.

 s/r not responding due to market conditions eg 1.70000 with GBP/USD
 - technical: pullbacks
 - market: volume has dropped off too
 - fundamental: policy, inflation, perception in britain
 - choppy better for scalper not swing/trend trader

 s/r seems to be working with EUR/USD though as a correction
 - technical: r holds and swing is in place
 - market: ?
 - fundamental: EUR deflating

 jpy crosses very interesting - coiling for 15 yrs
 huge technical but market and fundamentals will need to come into p <2014-06-24 Tue>
***** [[http://www.dailyfx.com/forex/video/technical_analysis/2014/06/20/Trading-Video-EURUSD-Reversal-or-GBPUSD-Breakout.html][EURUSD Reversal or GBPUSD Breakout?]]
 - Low volatility and weak fundamental influence dampen trend development and defang major breakouts
 - EURUSD may be one of the best positioned majors as ECB policy offers an active compliment to dormant risk
 - The most prominent volatility risk/opportunity is the British pound as the BoE talks policy above 1.7000 

 It is healthy for there to be some measure of 'fear' in the market to encourage market participants to make prudent investment decisions. Yet, as the exposure to high-return assets and excessive use of leverage would insinuate, there seems to be little to no fear left. Volatility measures - good proxies for anxiety - further collapsed across most asset classes. However, nowhere was the complacency greater than in the FX market where short and medium-term measures hit record lows. Traders remain exasperartingly vigilant of a normalization in activity levels, sentiment and positioniong; but there is trading that can still be done in the meantime. EURUSD and GBPUSD are just two of the more interesting pairs. We discuss current conditions and trade options in today's Trading Video. 

 eur/usd minor trending, market conditions say low volume and volatility; will look for an entry next week.

 gbp/usd 1.70000 is key level as s/r break in either as with eur/gbp gbp/jpy this thu interesting due to boe talk

 usd/jpy monetary policies on thu; great potential on a tech basis in the channels, but serious breakout unlikely; lots of jpy crosses brokeout but didn't go anywhere, so better to range trade
  <2014-06-20 Fri> 

***** [[http://www.dailyfx.com/forex/video/technical_analysis/2014/06/20/Strategy-Video-When-Will-Volatility-Return.html][When Will Volatility Return?]]
 - Volatility readings continue to sink with FX and yields readings shrinking to record lows
 - Though an activity gauge, there is a distinct connection between volatility and risk positioning
 - With curb on further yield reach, we look at the factors and timing for a normalization in volatility 

 corrective moves may be eur/usd, jpy crosses, but may have to wait
 do shorter term trades using undervalued risk positives aud/usd, gbp/usd
 not sensitive to volatility aud/nzd, eur/aud <2014-06-20 Fri> 
**** articles
***** Is it a Good Time to Get Long USD versus JPY? [[http://www.dailyfx.com/forex/technical/article/special_report/2014/07/09/when-is-a-good-time-to-buy-the-dollar-versus-japanese-yen.html?CMP%3DSFS-70160000000NbT3AAK][see]] :que:cal:
 this is a good article showing mc overriding other things.
 - US Dollar trades near range lows versus the Japanese Yen
 - A look at real FX volume indicator highlights key levels worth watching
 - We’re waiting for a drop towards bigger support

 The USDJPY currently trades towards the bottom of its tiny trading range. In order to gauge whether a breakdown is possible we take a look at the most significant levels of trader interest—prices at which volume was highest.

 these are the levels which traders have traded most aggressively as the pair sticks to its narrow range. If there was significant selling interest as the pair pulled back from ¥102.15, for example, we might expect many of the same traders to sell once more if price approaches that level.

 It bears mention that there was no such spike in volume as the USDJPY traded into multi-month lows near ¥101.20.
***** Can SSI Improve Our Forex Trading Strategy? Collecting Data [[http://www.dailyfx.com/forex/education/trading_tips/post_of_the_day/2014/03/19/Can_SSI_Increase_Our_Forex_Trading_Edge_Part_1_Collecting_Data.html?CMP%3DSFS-70160000000Nc3gAAC][see]] :que:
 - Sentiment describes how the majority of traders view a currency pair.
 - The Speculative Sentiment Index from DailyFX tracks retail sentiment specifically.
 - Downloadable Historical SSI is available to backtest its effectiveness.

****** What is Sentiment?
 Why does this matter you ask? Because when the SSI moves to an extreme level, price usually moves in a predictable direction against the retail crowd.

 USDCHF illustration of logic:
 - Statistics show that most retail traders lose money. So if most retail traders were buying USDCHF, it might have been best to take the opposite trade.
 - If most people had already bought the USDCHF, there were not many people left that could join them. The sudden lack of new buyers could have meant the price would begin to fall.
 - If price did start to move against this group of buyers, one by one they would have begun to get stopped out. These stop orders would have then pushed price lower hitting a greater number of stops and could have created a cascade of sell orders.

***** Follow The Fractal Tool Toward Better Breakout Entries [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2014/06/03/Let-Fractals-Guide-You.html?CMP%3DSFS-70160000000Nc3RAAS][see]] :sys:que:cal:
 Many traders spend too much time looking for the best possible entry. However, the entry can be based on any number of technical indicators. For traders who are a fan of price-action, you could do no worse than finding triggers based on a fractal breakout in the direction of the trend.
****** Fractals Defined
 From a trading / market perspective, fractals are an indicator highlighting the chart's local highs and lows where the price movement reversed marking a 5-bar high or low. These reversal points are called respectively Fractal highs and lows.
****** How Traders Can Use Fractals
 One of the common triggers that volatility is in play is when a prior high or low is taken out and a new trend begins. Fractals can be applied to the chart so that you can see when a recent key level has broken which can lead to a price-action trading opportunity.
****** Real-Time Fractal Set-Up
    For purpose of review, fractals mark price changes or pivots in the market. For reasons known or unknown, they are reaction points that can help you spot key places to place an entry order or stop. From a trader's stand-point, they allow you to enter on a confirming view of your analysis vs. a hunch that a market is oversold or overbought and is time to enter like this trade set-up on the Australian Dollar.
***** Forex Strategy: The US Dollar Hedge [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2013/09/12/The_US_Dollar_Hedge.html?CMP%3DSFS-70160000000Nc3RAAS][see]] :sys:que:
 - Trading is much more than just picking a position and ‘hoping' that the trade works out.
 - Trading is about risk management, and looking to focus on the factors that we know.
 - This strategy focuses on capitalizing on US Dollar volatility, and using risk management to offer potentially advantageous setups in the market.
****** What is the USD Hedge?
 The USD hedge is a strategy that can be utilized in situations in which we know the US Dollar will probably see some volatility.

 In the USD hedge, we look to find opposing currency pairs to take off-setting stances in the US Dollar. So, we find one pair to buy the US Dollar; and a different pair to sell the US Dollar. This way, we offset a portion of the risk of both trades by ‘trading around the dollar.'
****** A note on hedging 
 In the Forex market, hedging is often thought of as going long and short on the same pair at the same time. This is disastrous, and an atrocity to the term ‘hedging'.

 The textbook definition of hedging, and this is what is taught in business schools around the world, is that a hedge is an investment that's intended to offset potential losses or gains that may be incurred by a companion investment.
****** What Allows the USD Hedge to Work?
 Quite simply, risk management; if we're fairly certain that we're going to see some US Dollar movement, we can use that in our approach to hypothesize that this movement may continue.

 By looking for a 1-to-2 risk-to-reward ratio or greater ($1 risked for every $2 sought), the trader can use this information to their advantage.
****** How to Make the Strategy Most Effective
 If I'm looking to buy the US Dollar, I want to do it against the currency that's shown me the most weakness against the dollar of recent. And further to that point  -  if I'm going to sell the US Dollar I want to do it in the pairing that has shown me the most strength against the greenback.

***** Becoming a Fearless Forex Trader [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2014/06/06/Fearless-Forex-Trader.html][see]] :att:pla:
 95% of the trading errors you are likely to make will stem from your attitudes about being wrong, losing money, missing out, and leaving money on the table  -  the four trading fears (Mark Douglas, Trading In the Zone) 
****** Must You Know What Will Happen Next?
 If you don't need to know what will happen next, what do you need?
 - A Clean Edge That You're Comfortable Entering A Trade On
 - A Well Defined Invalidation Point Where Your Trade Set-Up No Longer
 - A Potential Reversal Entry Point
 - An Appropriate Trade Size / Money Management
******  Is There a Better Way?
 Believe it or not, it's to approach the market, understanding how emotional markets can be and that it is best not to get tied up in the direction the market "has to go".
****** Strategies When You Know That You Don't Know
 There is one commonality with traders who can trade without fear. They build losing trades into their approach. It's similar to a gambit in chess and it takes away the edge and strong-hold that fear has on many traders.

***** Creating Synthetic SSI for Cross Currencies [[http://www.dailyfx.com/forex/education/trading_tips/post_of_the_day/2014/05/31/Creating-Synthetic-SSI-for-Cross-Currencies.html][see]] :que:
 - SSI tells us the ratio of long retail traders to short retail traders for major pairs.
 - Some cross currency pairs, like the NZDJPY, are left out of our SSI database.
 - We can combine major SSI values together to create synthetic SSI for these pairs.
****** Summary of SSI 
 SSI gives us a comparison between how many retail Forex traders are currently long and short on each major pair. We want to trade opposite of the retail trading crowd meaning it's a "contrarian" index.
****** Steps to Creating Synthetic SSI
 Examples show how this process works.
****** Synthetic Sentiment Opening the Door
 This advanced technique opens the door to sentiment trading on a large amount of pairs not otherwise available and can take your trading to next level. Rather than looking at only trading currencies against the USD, we can now pair together strong and weak sentiment currencies with each other for a sentiment trade stronger than their USD-pair counterparts.

***** Three Ways to Trade Support and Resistance [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2014/05/20/Three-Ways-to-Trade-Support-Resistance.html?CMP%3DSFS-70160000000Nc3MAAS][see]] :que:
 - Support and resistance can have numerous applications and can be identified in a multitude of ways.
 - Traders can use support/resistance identification for managing risk in a strategy.
 - Traders can also use support and resistance to grade market conditions, and enter positions.
****** Risk Management/Stop Placement
 Support and resistance can help traders to define their risk amounts for any individual position. This can also work for reversal plays.
****** Determining a Market's Condition
  What constitutes ‘high' and what constitutes ‘low?' After all, these are very relative matters, and low in a market today might be sky-high a week from now.

 This is where support and resistance come into play, and this is why finding strong, confluent levels can be so beneficial.
****** Enter Positions 
 Remember that future prices are unpredictable. Implementing support or resistance simply gives us the possibility that support or resistance may hold; and if it does in-fact hold, then traders can look for rewards or profits that are significantly larger than the amount they had to risk. Or put another way, traders can use this as an opportunity to turn around The Top Trading Mistake and get risk management working in their favor by looking for larger rewards using smaller amounts of risk.

 If a trader is looking to buy an up-trend, they want to look to do so cheaply. So they can simply wait for prices to retrace a portion of the up-trend until a support level comes in to the market. This support level can be a psychological level, or a Fibonacci retracement, or a pivot point; better yet, this support level can offer confluence from multiple types of support/resistance analysis. 

***** The Life Cycle of Markets [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2014/02/13/The_Life_Cycle_of_Markets.html?CMP%3DSFS-70160000000Nc3MAAS][see]] :que:man:att:
 - This is a good one with links to strategies of various sorts
 - The future is unpredictable, but analysis can help traders get probabilities in their favor.
 - Matching the appropriate strategy with the correct market condition can assist in this analysis.
 - Below, we explain the three primary conditions and how traders can approach each.
****** The Cycles of a Market
  It's the identification of these cycles and patterns that allow us to work with them. It's just as Charles Darwin said: "It's not the strongest, or the smartest of a species to survive. It's those that are most wiling to adapt."

 If you want to survive as a trader, you have to learn how to adapt. In this article, we're going to show you how to do that.

 Most markets will exhibit one of three predominant market conditions. It doesn't matter if you analyze a market fundamentally, or technically, or spiritually, or by consulting with the stars: Prices move in different types of patterns.

 But traders don't just want to identify these patterns; they want to use them. By identifying these patterns, or ‘states' of a market; the trader can more eloquently decide how to trade in that particular environment.
****** The Trend is Your Friend 
 By identifying a trend, and noticing a bias that has existed in the market recently, we may be able to jump on that theme so that if it continues we might be able to see some profitable trades.
****** Ranges
 But there are two ways to approach such situations 
 - work the range
 - look for breakouts 

****** The Breakout
 Breakouts are one of the more difficult market conditions to master, as the accompanying price movements can be volatile, violent, and extremely costly if we find ourselves on the wrong side of the move.

 The problem with breakouts is that it might take three or four breaks of resistance to actually catch the move.
***** What is the Number One Mistake Forex Traders Make? [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2011/12/08/What_is_the_Number_One_Mistake_Forex_Traders_Make.html][see]] :man:att:
 Traders are right more than 50% of the time, but lose more money on losing trades than they win on winning trades. Traders should use stops and limits to enforce a risk/reward ratio of 1:1 or higher.
****** Why Does the Average Forex Trader Do Wrong?
 They lose more money on their losing trades than they make on their winning trades.
****** Cut Your Losses Early, Let Your Profits Run
 When your trade goes against you, close it out. Take the small loss and then try again later, if appropriate.
****** How to Do It: Follow One Simple Rule
 You should always use a minimum 1:1 ratio.
****** Stick to Your Plan: Use Stops and Limits
 Set up your trade with Stop-Loss and Limit orders from the beginning.
****** Does This Rule Really Work?
 A risk/reward of 1-to-1 or higher was more profitable than one that was lower.
****** Game Plan: What Strategy Should I Use?
 You can certainly set your price target higher, and probably should aim for 1:2 or more when trend trading.
***** When is the Best Time of Day to Trade Forex? [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2011/12/12/When_is_the_Best_Time_of_Day_to_Trade_Forex.html][see]] :pla:
 For most forex traders, the best time of day to trade is the Asian trading session hours. European currency pairs such as EUR/USD show the best results.
****** Profitability by Time Frame
 Chart shows traders more profitable 11am - 3am pst
****** Do the Hours that I Trade Matter?
 By sticking to range trading only during the hours of 2pm to 6am, the typical trader would have hypothetically been far more successful over the past 10 years than the trader who ignored the time of day.
****** Game Plan: What Strategy Should I Use?
 Trade European currencies during the "Off Hours" using a range trading strategy.

***** Here is How to Trade Majors During Active Hours [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2011/12/15/Here_is_How_to_Trade_Forex_Majors_like_the_Euro_During_Active_Hours.html][se]]e :que:
 For traders who feel the need to be in the market during the more volatile times, here is some advice about how to do it.
****** What Strategy Can We Use to Trade the US Daytime?
 If trading during active hours, we believe breakout strategies are more likely to succeed.
****** How Can We Trade Breakouts?
 Breakout trading strategies buy the currency pair when it rallies above resistance and sell it when it breaks below support. These breakout trades work when price continues significantly higher or lower, and they perform poorly when currencies stick to well-defined trading ranges.
****** Sample Strategy: Donchian Channel Breakout
 # The strategy sells/buys the currency pair if the price breaks below/above the channel bottom/top. If price quickly reverses, it will be taken out of the trade at a loss - this trade system might work especially well during times of high volatility, when channels tend to be broken.
 # *** When Can We Look to Trade Breakouts?
 See technical analysis [[http://www.dailyfx.com/technical_analysis][page]] with volatility.
 our research shows that the strategy hypothetically improved noticeably when we apply filters.
****** Game Plan: What Strategy Can We Use?
 We believe that traders who feel the need to trade during times of high volatility should use a different strategy and look to trade breakouts rather than ranges. Breakout trading has historically shown superior risk-adjusted returns if limited to the most volatile trading days. 
***** How Much Capital Should I Trade Forex With? [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2011/12/22/how_much_capital_should_i_trade_forex_with.html][see]] :man:que:
 Research shows that the amount of capital in your trading account can affect your profitability. Traders with at least $5,000 of capital tend to utilize more conservative amounts of leverage. Traders should look to use an effective leverage of 10-to-1 or less.
 - percentage of profitable traders by equity graph
 - profitability by equity size graph
****** Game Plan: How much effective leverage should I use?
 We recommend trading with effective leverage of 10 to 1 or less and trading defensively. Most professional traders enter into trading opportunities focused on how much capital they stand to lose rather than how much capital they are looking to gain.
 - Adjusting the effective leverage to suit your risk tolerance graph~
****** DailyFX Resources for Successful Money Management
     - How to Determine Appropriate Effective Leverage [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2012/01/10/How_to_Determine_Appropriate_Effective_Leverage.html][see]]
     - Introduction to Money Management [[http://forexforums.dailyfx.com/dailyfx-education-videos-forex-trading-strategies/126485-dailyfx-money-management.html?cmp%3DSFS-70160000000NbUGAA0&visitor%3D2978D6F785162785-600001A4A01DF956][see]]
     - Controlling Leverage and Usable Margin [[http://www.fxcmexpo.com/videos/controlling-leverage-and-usable-margin-fxcm-expo-2011/?cmp%3DSFS-70160000000NbUGAA0&visitor%3D2978D6F785162785-600001A4A01DF956][see]]
     - Arriving at a Risk/Reward Ratio [[http://www.dailyfx.com/forex/education/trading_tips/post_of_the_day/2011/05/27/Arriving_at_a_Risk_Reward_Ratio.html][see]]
     - Would You Like to Increase Your Chances of Becoming a Successful Trader? [[http://www.dailyfx.com/forex/education/trading_tips/post_of_the_day/2011/12/06/Would_You_LIke_to_Increase_Your_Chances_of_Being_a_Successful_Trader.html][see]]
***** The Trader's Plan [[http://www.dailyfx.com/forex/education/trading_tips/post_of_the_day/2011/12/12/The_Traders_plan.html][see]] :pla:
****** Goals
 I recommend that new traders on the demo should look to be profitable, setting initial goals small and increasing as experience and comfort builds.
****** When am I going to trade?
 An important element of note is that the various trading sessions can exhibit different ‘characteristics,' around the way that prices move ...  movements in price can potentially be smaller during the Tokyo Trading session, and, as such, may be more accommodative for newer traders.
****** How much am I going to risk per trade?
 We propose a max of 5% at risk at any one point in time. 
****** How much profit will I seek on each trade taken?
 A minimum 1 to 1 ratio should always be used and for lower probability trades, such as trend trading strategies, a higher risk/reward ratio is recommended.
****** How am I going to enter trades?
 This will often be dictated by the trading strategy (or strategies) itself.
****** How am I going to exit trades?
 For each strategy have an exit planned. 
****** How am I going to manage my trade(s)?
 This should be highly customized based on the previous sections of the trading plan and also be built around the specific strategies or market conditions being traded.
***** How to Build a Four-Point Trading Plan [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2014/01/30/how_to_build_a_trading_strategy.html][see]] :pla:
 - Failing to plan is planning to fail; every trader needs a trading plan.
 - This article covers the what, how, when, and why that needs to be answered in the plan.
 - Sample strategies are referred for multiple trader types in the section for the how.

****** Various Trader Types and Characteristics of Each and Strategies
 |Scalper|Short-Term Momentum Scalping in the Forex Market|
 |Day|Three Strategies for Three Markets|
 |Swing|The Four-Hour Trader|
 |IntermediateTerm|Price Action with RSI|
 |LongTerm|The US Dollar Hedge|
 |Position|How to Scale In to Positions|
****** When to trade: Trading the World article [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2012/06/27/Trading_the_World.html][see]]
 The session being traded can have a massive impact on results so use suitable strategies for the time period
****** Know why you are trading
 This is where you write down your goals and reasons for becoming a trader.

***** How to Determine Appropriate Effective Leverage [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2012/01/10/How_to_Determine_Appropriate_Effective_Leverage.html][see]] :man:
****** What is leverage?
 Leverage refers to using a small amount of one thing to control a larger amount of something else.

****** How is Effective leverage calculated?
 To determine the amount of effective leverage used, simply divide the larger asset by the smaller instrument.

****** How do I know how much leverage to use?
 auto speed example

****** Why does FXCM encourage lower leverage?
 Trader A buys 50 lots of AUD/USD while Trader B buys 5 lots of AUD/USD.

***** Incorporating Profitability Statistics [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2012/01/03/Building_a_Better_Wheel.html][see]] :pla:
 - Most will come to find that such holy grails don't exist.
 - Trading is like many other things in life, where the more we do it, the more experience we gain  -  the better we can become.
 - The recent series of articles around Client profitability from DailyFX attempt to show traders that path, by analyzing ACTUAL results of live clients.
****** What is the Number One Mistake Forex Traders Make?
 - Traders are right more than 50% of the time, but lose more money on
   losing trades than they win on winning trades. Traders should use
   stops and limits to enforce a risk/reward ratio of 1:1 or higher.
 - When setting risk on a trade, always look for a profit AT LEAST as
   much as the amount you are risking. So, when entering a trade, if
   setting a 50 pip stop  -  look for a minimum of a 50 pip profit.
****** When is the Best Time of Day to Trade Forex?
 - For most forex traders, the best time of day to trade is Asian
   Hours. European currency pairs such as EUR/USD show the best
   results.
 - If your schedule is flexible and you can choose when to trade, the
   Asian trading session may be more accommodating as traders have
   previously shown a higher propensity for profitability. European
   currency pairs such as EUR/USD, GBP/USD, and USD/CHF have exhibited
   the best results for this period.
****** Here is How to Trade Forex Majors like the Euro During Active Hours
 - North American trading hours tend to be the most difficult to trade
   in due to the high level of volatility in the market. Breakout
   trading strategies tend to do relatively well in volatile
   environments, so if you plan to trade during these times, look to
   trade breakouts.
 - For traders speculating in the most active hours of the FX Market,
   which can be the most challenging periods of the day to be
   profitable; look to trade breakouts. The range of volatility during
   this period can be greater than that of other periods of the day,
   such as the Asian trading session, and these environments can often
   be served best by trading breakouts.
****** How Much Capital Should I Trade Forex With?
 - Research shows that the amount of capital in your trading account
   can affect your profitability. Traders with at least $5,000 of
   capital tend to utilize more conservative amounts of
   leverage. Traders should look to use an effective leverage of
   10-to-1 or less.
 - This should be the easiest of the rules to implement. One thing most
   FX traders know is that leverage can kill an account. The best
   traders in the world will rarely ever leverage more than 10 times
   their account value, yet new traders continue to enter the FX market
   with hopes and dreams of striking it rich by using leverage of 40 or
   50 times their account value.

***** Controlling Leverage and Margin [[http://www.dailyfx.com/forex/fundamental/article/special_report/2010/10/21/Forex_Trading_Controlling_Leverage_and_Margin.html][see]] :man:
****** Leverage with the Relative Strength Index (RSI) Trading Strategy
 We hope to show the benefit of using low leverage ratios in a bid to maximize profits and protect trading capital.
****** Protecting against Large Losers
 If we go back to our hypothetical strategy results, a leverage ratio of 5:1 would have protected against total capital loss but theoretically left us with healthy profits over the preceding year.
****** Trading with Lower Leverage
 The strategy finishes with respectable hypothetical gains, and even the worst drawdown through this stretch would not have wiped out our equity.
***** Trading the World [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2012/06/27/Trading_the_World.html][see]] :pla:
 Each major geographic market center can exhibit vastly unique traits and tendencies that may allow me to more effectively execute my strategies.
****** The Asian Session 2pm-12am pst  
 The logic that because of smaller hourly moves and the fact that support or resistance may hold with a greater degree of consistency, trading ranges and range-based strategies could be the operative mannerism of execution.
****** The London Session 12am-2pm pst  
 London is still very much considered the ‘heart' of the FX market with the largest portion of liquidity coming from this area.
****** The US Session 5am-2pm pst   
 The US Session is often considered to be the most dynamic, as it can take on flavors of the London session early in the day  -  but trade more similar to Asia towards the end of the session.
****** Noticing the Differences between Sessions
 For traders that do want to get more comfortable with the various trading sessions, the ‘Trade Sessions' indicator on Trading Station 2 is a big help.
***** The More Intelligent Trailing Stop [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2014/05/09/The-More-Intelligent-Trailing-Stop.html][see]] :cal:
 - Trailing Stops can reduce risk but increase the chances of being stopped out prematurely.
 - Manually trailing our stops each time there is a new swing high/low reduces this whipsaw effect.
 - An Asymmetrical Fractal can provide guidance on when to move our stop.
****** The Flaw in Trailing Stops
****** Manual Trailing Stop
****** The Asymmetrical Fractal
****** The Buck Stops Where?

***** How to Trade Short-Term [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2014/05/01/How-to-Day-Trade.html?CMP%3DSFS-70160000000Nc3MAAS][see]] :que:
 - While short-term trading is attractive, it can also be dangerous.
 - Short-term traders will often exercise poor risk management, and this can have very negative consequences.
 - We share a strategy that can be used to trade short-term momentum with a focus on risk.

***** The Three Keys to Day-Trading [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2014/05/08/Three-Keys-to-Day-Trading.html?CMP%3DSFS-70160000000Nc3MAAS][see]] :que:
 - Short-Term trading is not easy; traders need to plan their approaches.
 - Trading is not entertainment, and treating it as such could be a costly endeavor.
 - Trade management is extremely important to the short-term trader.

***** The Three Most Popular Indicators for Day-Trading [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2014/05/12/Three-most-popular-indicators.html?CMP%3DSFS-70160000000Nc3MAAS][see]] :cal:
 - This article is an extension of our previous two on the topic of short-term trading.
 - Price action is an extremely common tool for day-traders' (scalpers) risk management approaches.
 - Moving averages and psychological support and resistance can assist with entry and trade management.
****** Price Action
 The reason this is so popular is because price action removes technical indicators from the equation and instead focuses on price and price alone. Price action can be used to grade trends, identify support and resistance levels, and to show traders potential entry opportunities in markets.
****** Moving Averages
 Moving averages are commonly used for trend diagnoses, so that if prices are above the moving average the trend is diagnosed as being ‘up,' and if prices are below the trend is considered being ‘down.' This can work phenomenally with a multiple time frame approach in which trends are being graded on a longer-term chart (like the hourly or 4-hour), and entries performed on the shorter-term chart.
****** Support and Resistance via Psychological Whole Numbers, and Pivot Points
    There are numerous ways to identify support and resistance, and traders can use price action to validate any particular level; but this really only comes into play after-the-fact. Of particular interest to short-term traders are 'psychological whole numbers'.

***** The Hidden Patterns of Support and Resistance [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2014/05/13/Hidden-Support-and-Resistance.html?CMP%3DSFS-70160000000Nc3MAAS][see]] :cal:
 - There are numerous ways of identifying support and resistance, but many traders miss the values right in front of them.
 - Humans think in ‘round' figures and so do traders; price action can exhibit this phenomena.
 - In this article, we outline the ‘Major,' ‘Less-Major,' and ‘Minor' Psychological Support/Resistance Levels.
****** Human beings value simplicity
 traders are human, and just like human beings do in other facets of life; traders attempt to simplify by rounding to the nearest, rounded whole number.
****** The 'Major' Levels 500pip
 So the ‘Major' levels will catch quite a bit of interest, and can potentially increase the probability of a trend stalling or reversing.
****** The ‘Less-Major' Psychological Levels 100pip
 Notice how numerous reversals and swings take place when one of these levels gets hit.
****** The Minor Levels
 Within each 100-pip interval are 3 additional levels that are considered to be ‘minor' psychological support and resistance values. These levels are in 25-pip increments, and in the chart below we've moved into the hourly GBPUSD setup to look at the ‘minor psych' levels in the pair.
***** The Power of Confluence in the Forex Market [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2014/05/15/The-power-of-confluence.html?CMP%3DSFS-70160000000Nc3MAAS][see]] :que:
 - Psychological price levels can change trends and create swings within the market.
 - Traders can combine psychological levels with other forms of Support and Resistance to find which levels may have the most potential.
 - Areas of confluent support and resistance can offer entry potential for swings and new trends.

 Trends can be stopped dead in their tracks… and if the batch ‘sitting orders' are large enough, a full-on reversal may be afoot.  In this article, we're going to attempt to take this study a step further by helping traders to notice which of these levels may end up carrying more weight with future price action.
****** Support and Resistance Does Not Exist in a Vacuum
 Traders can attempt to see which prices may carry more power by aligning multiple permutations of support or resistance analysis, and looking for commonalities.
****** Why/How does confluence work?
 The bigger question to ask is why technical analysis might work?

 In the example below, we can see how the confluent level of .9750 in AUDUSD promulgated a strong reversal in the trend. Support and resistance levels are no different. As prices approach these levels, traders observe the potential for a reversal. And when multiple support or resistance levels exist in the same region or area, this is called 'confluence', and this confluence of support or resistance can offer traders multiple reasons for prices to reverse or stall; making potential trade ideas for swings or reversals even stronger than they might be otherwise.
****** How to Find Confluent Levels of Support and Resistance
 Price action can be used to validate which levels have been valuable, but traders can attempt to see which levels may offer a higher chance of exhibiting support or resistance in the future by applying multiple studies.  Longer-term pivot points (weekly and monthly) will usually generate considerable interest, and the same can be said for Fibonacci retracement levels within longer-term trends. Traders can also look to indicators.
****** How to Trade Support and Resistance Confluence
 Traders should keep in mind that there is no form of analysis that will predict future price movements. Instead, trading is about probabilities. And seeing an up-trend stall at resistance, or a down-trend pause during support simply shows us an area where a reversal in price may take place. 
****** Traders can use price action to signal entries
 You can use this in combination with multiple time frame analysis to trade retracements in ‘major' trends on longer-term charts; or you can even include additional indicators such as I do in my short-term momentum trading strategy. Provided traders are focusing on risk management and risk-efficient entries, there are numerous ways that support and resistance confluence can beneficially be integrated into a trader's approach. 
***** In-Trade Management [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2011/11/23/In-Trade_Management.html][see]] :man:
 - Many experienced traders will often be overcome with guilt, remorse, and dejection
****** Fluctuating emotions
 ... we enter a position that FINALLY seems to be moving in the direction that we want ... we experience the jubilation ... watch helplessly as our profit disappears before our very eyes ... we scour the news wires ...
****** One of the toughest situations for trader to handle
 there isn't one right or wrong way to go about trade management, as market moves are unpredictable ... the best way to handle the situation comes down to the individual trader
****** What one can control
 One cannot control price, momentum, the news, or any of the other million factors affecting my trade, but we can control risk; that is in our hands.
***** How to Analyze and Trade Ranges with Price Action [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2012/04/23/How_to_Trade_Ranges_with_Price_Action.html][see]] :que:cal:
 This article will walk through a simple mechanism by which traders can identify, and trade in ranges while focusing on what many traders to be the most important part of any approach: Risk management.
****** Identifying Support and Resistance via Price Action
 Notice that, on this hourly chart, there are quite a few swings back and forth. This exemplifies the fact that markets will often oscillate while trying to find an intrinsic value.

 When beginning to line up a range setup, the number of swings that might be available on the hourly chart may be too abundant. The longer time-frame charts, however, can offer quite a bit of information contained in each candle so that we can get more of a ‘birds-eye view’ on the market.
****** Risk Management decides our Entries
 Now that we’ve identified the prices at which we want to buy, the prices with which we want to sell, and maybe even more importantly than that – where we want to place our stops, we can now begin to decide when we want to enter the trade.

 And now that we know exactly where our stops should be placed, we can accurately calculate how much potential risk we are taking on.

***** A Simple Strategy For Ranging Markets [[http://www.dailyfx.com/forex/education/trading_tips/chart_of_the_day/2013/11/15/A_Simple_Strategy_For_Ranging_Markets.html][see]] :que:man:
 - Traders should have a plan of action, when Forex trends end.
 - Identify trading ranges by pinpointing swing highs and lows.
 - Oscillators such as RSI can use overbought and oversold levels for market
  entries.
****** Flexibility and Tools
 When trending, trade trends. When ranging, trade ranges. Often trending market traders will look to use indicators such as CCI, RSI, or MACD in conjuncture with support and resistance lines to trade market swings. The same philosophy can be used while range trading if you know what to look for.
****** Managing Risk
 Just like trends, ranges can abruptly come to an end and traders need to be prepared for that scenario. When trading ranges, stops should be kept out of the identified levels of support and resistance.

***** Scalping Guide, Part 1: Market Conditions [[http://www.dailyfx.com/forex/education/trading_tips/trend_of_the_day/2014/01/08/The_Definitive_Guide_to_Scalping_Part1..html][see]] :que:
 - Forex Scalpers should always identify market conditions before trading
 - Markets can be broken into three major environments. Trends, Ranges, and Breakouts
 - Once identified, traders can select the appropriate strategy that fits present price action.
****** Price Ranges
 The first step to finding a range is to identify support and resistance on your chart. As long as a range holds, scalpers can take a neutral market stance. This means they can look to take both buy positions near levels of support and sell look to sell levels or resistance.
****** Strategic Breakouts
 When market ranges end, we are most likely to encounter a breakout. The process of trading a breakout can be simplified through the use of an entry order.
****** Trending Markets
 The Forex market is known for its propensity to continue moving in a singular direction for an extended period of time, and once found scalpers can trade in the direction of the trend.

***** Scalping Guide, Part 2: Currency Pairs [[http://www.dailyfx.com/forex/education/trading_tips/trend_of_the_day/2014/01/15/The_Definitive_Guide_to_Scalping_Part2.html][see]] :que:
 - Forex Scalpers should always identify market conditions before trading
 - Factor in the spread to reduce transaction costs
 - Consider liquidity when trading to maximize trading
****** Spreads and Cost
 So throughout the trading year, to keep costs down scalpers should gravitate to pairs with lower spreads.
****** Liquidity
 Scalpers should value liquidity because it will ultimately coincide with the ease we enter and exit the market.
****** Currency Pairs
 Out of 56 different pairs offered at FXCM, traders should consider scalping pairs comprised of the G8 currencies shown above or one of the Forex Majors pictured below. These pairs are comprised of the most frequently traded currencies in the world which helps when it comes to factoring in both spreads and liquidity.
 eurusd usdjpy gbpusd usdchf audusd usdcad

***** Scalping Guide, Part 3: Time Frames [[http://www.dailyfx.com/forex/education/trading_tips/trend_of_the_day/2014/01/22/The_Definitive_Guide_to_Scalping_Part3.html][see]] :que:
 - It should be a top priority to determine the appropriate chart for your trading.
 - Reference a specific date range to begin your analytics
 - Finalize your execution by moving to a shorter term timeframe
****** A Frame of Reference 
 A frame of reference is specifically looking at how much data is displayed on your chart. This reference is designed for scalpers to find the short term trend while identifying key levels of support and resistance.

 Scalpers can begin by referencing 7 days' worth of data. This allows the trader to take in exactly one weeks' worth of pricing to establish short term market direction. Traders can then identify market swings and key levels of support and resistance for the week
****** The Execution Chart
 This graph should be the final chart that you use in accordance to your scalping trading plan. While this chart may be the reference chart mentioned above, more often than not, scalpers prefer moving into shorter time frames at this point.
***** Scalping Guide, Part 4: Support & Resistance [[http://www.dailyfx.com/forex/education/trading_tips/trend_of_the_day/2014/01/28/The_Definitive_Guide_to_Scalping_Part4.html][see]] :que:
 - Support and resistance levels are critical areas for scalpers to identify.
 - Price action, pivots, and moving averages can all be used to find these values.
 - Once identified, traders can then look to employ the strategy of their choosing.
****** Price Action
 Scalpers should become comfortable with finding swing highs and swing lows on their charts as they are natural areas of support and resistance.
****** Pivot Points
 These lines are drawn using a preset formula and are often favored by scalpers because they can be added to virtually any chart. Above is a great example of support in action on a EURGBP 30 minute chart using Camarilla Pivot Points. Once added, you can clearly see levels of support denoted by an "S" whereas lines of resistance are marked by an "R".
****** Moving Averages
 Most traders may be familiar with this average on longer period graphs, but is just as effective on shorter time frames such as the 30 minute and 5 minute charts. If price is above the average, traders can wait for dips and look to buy a currency pair.

***** Scalping Guide, Part 5: Scalping Ranges [[http://www.dailyfx.com/forex/education/trading_tips/trend_of_the_day/2014/02/05/The_Definitive_Guide_to_Scalping_Part5.html][see]] :que:
***** Scalping Guide, Part 6: Scalping Retracements [[http://www.dailyfx.com/forex/education/trading_tips/trend_of_the_day/2014/02/12/The_Definitive_Guide_to_Scalping_Part6.html][see]] :que:
***** Scalping Guide, Part 7: Scalping Breakouts [[http://www.dailyfx.com/forex/education/trading_tips/trend_of_the_day/2014/02/19/The_Definitive_Guide_to_Scalping_Part7.html][see]] :que:
***** Scalping Guide, Part 8: Risk Management [[http://www.dailyfx.com/forex/education/trading_tips/trend_of_the_day/2014/02/26/The_Definitive_Guide_to_Scalping_Part8.html][see]] :que:
***** Static Support and Resistance in the Forex Market [[http://cdn.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2014/06/11/Static-Support-Resistance.html][see]] :que:cal:
 - Traders can use support and resistance to grade market conditions, define trends, and enter positions.
 - We discuss ‘static' methods of support and resistance in the below article.
 - We delve into pivot points, and psychological support/resistance analysis.

 If price has hit a floor with which it may have difficulty breaking through (support) or a ceiling with which it may not be able to rise above (resistance); this can offer a plethora of trade ideas and setups.
****** Pivot Points
 So these floor traders developed a short-hand manner of getting support (cheap) and resistance (expensive) levels - pivot points use very basic math to find potential support and resistance levels.

 Pivot Points can be generated for a variety of time frames, and the longer-term pivots will often work best as more traders may be seeing and reacting to those levels. (this would explain why technical analysis works better in longer time frames)

 Pivot points of monthly and weekly flavors will often attract significant interest, and should be followed by traders even if using shorter-term hourly and four-hour charts.

****** Psychological Levels
 One of the most alluring aspects of technical analysis is the ability of statistics and mathematics to show patterns in human behavior. Nowhere is this more prominent than in the study of ‘psychological' levels in financial markets.

 Rounding will often happen in markets as well; as traders place their stops or entry orders at or around these levels.

 With psychological levels taking place every 500,100,25 pips, there are numerous opportunities for traders to ‘catch swings' in a market.

***** The Rabbit Hole of Fibonacci [[http://cdn.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2014/06/12/Looking-down-the-rabbit-hole.html][see]] :que:cal:
 - This article is an extension of our previous piece on Support and Resistance in the FX Market.
 - We look at the history and background of the mathematical concept known as ‘The Fibonacci Sequence'
 - We show you how traders can apply these mathematical studies to their trading.

 In this article, we’re going to look at a more subjective form of Support and Resistance analysis: We’re going to investigate Fibonacci.

****** Fibonacci
 Many believe the Fibonacci sequence to be the language of nature itself. The number of 1.618 is called ‘The Golden Ratio,’ and can be found in numerous applications within nature ranging from the spirals of a sea shell to leaf arrangements of a houseplant.

****** Trading with Fibonacci (and the Golden Ratio)
 Traders will often employ Fibonacci when looking to trade retracements in a trend, centering support and resistance levels around intervals defined by the Golden Ratio of 1.618.

 To use Fibonacci, a trader needs to merely identify a most recent ‘major move.’ This is where subjectivity comes in to play.

***** The Great Validator - Price Action [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2014/06/14/The-Great-Validator.html?CMP%3DSFS-70160000000Nc3MAAS][see]] :que:cal:
 - In our first piece, we examined Static Support and Resistance.
 - In our follow-up article, we looked down the Rabbit Hole of Fibonacci Analysis.
 - In this article, we show you how to validate these levels with what matters most: Price Action.
****** The Big Picture
 This is why price action matters so much; by analyzing how markets have reacted to particular price levels in the past we can draw assumptions towards how they may react to those same prices in the future. Otherwise, support and resistance is an esoteric shot-in-the-dark.

 Price action is the most basic study of supply and demand in a market.

****** How to Incorporate Price Action into an Analytical Approach
 A price action swing is, in-and-of-itself, a form of support or resistance. After all, this is the very essence of resistance (or support) since an actual reaction was seen at that specific price. This beats an esoteric mechanism of imagining potential levels that don’t actually elicit a reaction.

 Noticing a price swing at a support or resistance level serves as validation that traders have, in-fact, reacted to that price once it became traded in a market.

***** Pragmatic Usage of Support and Resistance [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2014/06/17/Pragmatic-Support-and-Resistance.html?CMP%3DSFS-70160000000Nc3MAAS][see]] :que:cal:
 - This article discusses using Support and Resistance levels for risk management.
 - Traders can incorporate Support/Resistance from a variety of studies to find ‘confluent’ levels.
 - These levels offer traders an opportunity to look for strong risk-reward ratios in their setups.
****** Using Support and Resistance
 The inherently risky part about trading support or resistance is that the prospect of buying support or selling resistance is, by nature, a counter-trend type of operation.
****** Support and Resistance with Risk Management
 With a strong system of support or resistance in the trader’s arsenal, risk management can be made very simple by placing a stop on the opposing side of the price level.
****** Place the Stop that’s Best Suited for You
 Traders are often best-served by placing the stop on the other sideof support so that the stop isn’t triggered unless the actual support level becomes violated.

 Conservative traders usually want to allow the trade more room to ‘work’ and would likely look at wider stops and levels that are further away from current price action; while more aggressive traders will usually opt for tighter stops placed around closer support and resistance levels.

 Most important is placing stops and managing risk in a manner that is comfortable and conducive for you: Because if you’re a conservative trader/investor and attempting to use aggressive risk management, you’ll likely see adverse results that won’t feel very comfortable while trying to improve your trading plan/strategy/approach.
***** Attack the Forex Market with Support and Resistance [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2014/06/19/attack-the-forex-market-sr.html][see]] :que:cal:
 - This is the fifth part of our support and resistance series.
 - In the first three parts, we looked at static support and resistance, Fibonacci, and price action.
 - In our last article, we examined stop placement and risk management with this analysis. 
****** Support/Resistance is Theoretical
 The big benefit of this analysis comes from the fact that these price levels give traders areas that they can look to for the placement of their stops; so that if a reversal doesn’t happen, they can mitigate the loss of the idea that didn’t work out. And if a reversal does, in-fact, take place, then they can potentially look to reap far more on the reward side than they would’ve lost if the idea didn’t work out.
****** Using Support and Resistance to Trigger and Initiate Positions
 The very fact that this long wick exposes a market’s reaction to a particular level can give the trader enough motivation to open (trigger) the position; in anticipation of that reaction to the support level turning into a new trend.

 But this can be taken a step further in price action analysis; looking for ‘formations’ that may exhibit reversal qualities.

 A pin bar requires a wick that is at least as large as the candle body, with the wick ‘sticking out’ from recent price action.
****** Triggering Positions with Indicators
 Traders can use indicators to time entries in the direction of those anticipated movements. Popular options for this job include Relative Strength (RSI), Stochastics, and Moving Average Convergence/Divergence (MACD).
****** Using Multiple Time Frames to be More Active
 A natural question that comes up after learning to use indicators for entries when support or resistance is met in a market is which time frame should be used for the entry indicator.

 To be more active, traders can implement multiple time frame analysis. This will enable the trader to dial down to a lower time frame once support or resistance gets hit in a market. This lower time frame can enable the indicator to be considerably more active, offering many more signals than what might be seen on the longer time frame. We covered the topic of Multiple Time Frame Analysis in the article, The Time Frames of Trading. 
***** Managing Forex Trades with Support and Resistance [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2014/06/23/Managing-Trades-with-SupportRes.html][see]] :que:cal:
 - Support and resistance can help traders decide when to open, close, or adjust their positions.
 - Traders can use support and resistance to build positions: using gains to finance additional lots.
 - Traders can also use support and resistance to ‘scale out’ of trades in an effort to capture as much gain as possible.
 ‘Be greedy when others are fearful and fearful when others are greedy.’ - Buffett
***** The Forex Trader’s Guide to Support and Resistance [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2014/06/26/Forex-Traders-Guide-to-SR.html?CMP%3DSFS-70160000000Nc3MAAS][see]] :que:cal:
 - This article is a capstone on the topic of support and resistance.
 - Below we discuss multiple subjects within the field of support and resistance, many of which offer more detailed information by clicking on the relevant link.

 There are a few very vital reasons for this, least of which is the fact that support and resistance have connotations for both technical and fundamental analysis.

 this is a good summary article.

***** The Forex Trader’s Guide to Price Action [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2012/05/01/The_Forex_Traders_Guide_to_Price_Action.html?CMP%3DSFS-70160000000Nc3MAAS][see]] :que:cal:
***** Four Simple Ways to Become a Better Price Action Trader [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2013/10/04/Four_Simple_Ways_to_Price_Action.html?CMP%3DSFS-70160000000Nc3MAAS][see]] :que:cal:
***** Price Action in the Forex Market [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2014/07/03/Price-Action-in-FX.html?CMP%3DSFS-70160000000Nc3MAAS][see]] :que:cal:
 - Price action is the study of price movements in a market.
 - Many traders look at and use price action because it’s the cleanest view of technical analysis in a market.
 - In this article, we discuss the most basic relationship at the center of price action: Supply and Demand.

 Price action is the study of price and price alone in a market, with no indicators required.

****** The Most Basic Relationship in Markets: Supply and Demand
 One of the best aspects of price action is that it offers traders a clean depiction of supply and demand at any one point in a market.
****** Relating Supply and Demand to Trend Identification
 For a trend to take place, we need progressively higher (or lower) prices to continue for a prolonged period of time.

 As you can see from the above charts, trend identification with price action is relatively simple, and maybe more importantly than that, it makes sense. Indicators can have a tendency to obscure the trend given the lag or disconnect involved, making them somewhat esoteric for many trader’s purposes.

 This is the conundrum of time frames, and brings up the old saying ‘if you want to find a trend, just change the time frame.’

 In the article, we shared that traders can look to utilize two time frames in an effort to both ‘see the bigger picture’ while focusing on a shorter-term chart that can allow entry possibilities in scope of the bigger-picture trends or moves.

 This would mean that if you’re looking to enter trades on the hourly chart, you can use the 4-hour chart to see the bigger picture trend. If you’re using the daily chart to enter positions, you can look to the weekly for trend analysis.
***** The Power of Wicks in the FX Mark et [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2014/07/07/The-Power-of-Wicks-in-FX.html?CMP%3DSFS-70160000000Nc3MAAS][see]] :que:cal:
 - This article is an extension in our series on the topic of Price Action.
 - In our last article, we saw how supply and demand can be seen via the study of price.
  - In this article, we take this a step further in looking at intra-candle dynamics.

 As we explained, price action can give traders a clear and concise view of supply and demand at any one point-in-time.
****** The Secret Messages of Price Action
 As prices rise, sellers are more incentivized to sell. This creates price swings in the market.

 This is the beauty of price action: It gives the trader an accurate depiction of supply and demand at any one point-in-time to offer the cleanest view of that particular market.
****** The Power of the Wick
 We can take these ‘messages’ via price action to the next logical step: locating points of emphasis within a single candlestick or a series of candlesticks to find areas of interest for potential trade entries.
****** Why are Wicks so Important?
 they show us potential price reversals at the very earliest stage, while also validating support and resistance levels in the market

 Long wicks validate support and resistance, and allow the trader to define their risk in any entries that may be taken in the market.
***** The Time Frames of Trading [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2012/06/18/The_Time_Frames_of_Trading.html?CMP%3DSFS-70160000000Nc3MAAS][see]] :que:cal:
 One of the most common questions from new traders is ‘What time frame works best?’

****** Use TimeFrames that Match Your Goals
 This can provide conflicting signals and counter-productive unrest in the trader’s mind as they are attempting to line up trades. For this reasons, it’s important for the trader to plan the time frames they want to trade as they build their strategies.

 Incorporating a longer time frame will allow the trader to see a ‘bigger picture’ of the currency pair so that they may get an idea of ‘general trends,’ or the sentiment that may exist; while the shorter time frame chart can be used for plotting the actual trade. This leads into a very popular permutation of technical analysis in which traders incorporate multiple time frames into their approach.

****** Multiple Time Frame Analysis 
 A common way of employing multiple time frame analysis is to use a longer-term chart to analyze the trend or general sentiment in the pair, and the shorter-term chart to enter into the trade.

****** Which TimeFrames Work Best (with each other?)
 We suggest a ratio of 1:4 to 1:6 between the trend and the entry chart

****** Building a Multiple Time Frame Strategy 
    Many traders are familiar with the term ‘the trend is your friend.’ One of the more effective ways of analyzing trends is using a longer time frame than the one being used to plot trades.

***** The Guiding Hand of Price Action [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2014/07/10/The-Guiding-Hand-of-Price-Action.html?CMP%3DSFS-70160000000Nc3MAAS][see]] :que:cal:
 - Price action analysis is a form of technical analysis involved with analyzing price, and price alone. 
 - Traders can use price action to determine trends and grade market conditions. 
 - Traders can adjust their approach to match the right strategy with the right condition.

 In this article, we’re going to attempt to show traders how they can look to define market condition with the study of price action so that they can, in-turn, decide on which types of strategies or systems to use in their approach to that particular type of market.

****** The Importance of ‘Condition-Identification’
 Imagine that the Euro-dollar has just dropped 250 pips over the past 4 hours. Do you buy? Do you sell? Do you stay flat?

 The only way to begin moving towards delivering an answer to this question is to ask another, perhaps more important question: Which condition is this market displaying?

 These types of conditions will display themselves on all time frames in pretty much every free market on the planet based on how traders, investors, and fund managers are approaching that particular environment.

 While we can’t predict what’s going to happen in Japan, or in the USDJPY – what we can project is that something eventually will change.

 when the range in USDJPY does eventually break that will lead to our third market condition which is probably the most difficult to wrangle; and that is the breakout.

 Many breakouts fail. Many times we’ll see prices break support or resistance only to reverse shortly thereafter. So while trend traders may look for a 40-50% success rate, and range traders looking for 50-60% success; breakout traders are often dealing with 20-30% winning percentages.

****** How to Use Price Action to Determine the Market’s Condition
 Is this market making higher-highs and higher-lows? Or in the case of a down-trend, is this market making lower-lows, and lower-highs?

  Do you want to trade the range-continuation, or do you want to trade the breakout?

****** Which Time Frame is the ‘Right’ Time Frame
 After learning to grade trends and market conditions, the next operable question is ‘which time frame should I use?’

***** How to Attack Trends Using Price Action [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2014/07/14/How-to-Attack-Trends.html?CMP%3DSFS-70160000000Nc3MAAS][see]] :que:cal:
 - In our previous three articles, we introduced price action, looked at the value of candlestick wicks, and learned how to grade market conditions with price action analysis.
 - In this article, we look at how traders can use price action analysis to trade in trending environments.

 there are three primary market conditions; all of which display unique characteristics and traits that traders can focus upon in an effort to most adequately fit their strategy into that specific environment.

****** Why Trends?
 Of the three possible market conditions, trends are often considered to be the most desirable for a few different reasons.

****** Threading the Needle with Multiple Time Frame Analysis
 traders can use multiple time frame analysis to get two different vantage points of a market; with the primary goal being to enter trades and trigger positions in terms of the ‘bigger picture’ trend.

 this is the advantage of price action; the premise of whether or not this is going to be a ‘higher-low’ can allow the trader to look for a risk-efficient entry.

****** Executing the Entry
 you’ll never know whether a higher-low has been set until after price action has proven that the trend will continue: But the hypothesis that a higher-low ‘may’ have been set is enough for traders to assimilate risk management of a potential position.

****** What allows this to Work – and why are Trends so desirable?
 this is simply a way for traders to look to get the probabilities of success on their side, if even just a little bit by getting the most clear and concise view of a market.

 What allows trend trading via price action to work so effectively for some traders is the fact that if and when they’re on the right side of the trade, they can reap far more than they had to risk to get into the position.

***** The Best Market Environment for Retail Forex Traders [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2014/07/15/The-Best-Environment-for-Retail-FX.html?CMP%3DSFS-70160000000Nc3MAAS][see]] :que:cal:
 - This article continues our series on the topic of price action analysis.
 - Previously, we had investigated the three different market conditions that will show up in markets.
 - In our last article, we looked at trading trends; in this article we investigate ranges.

 trends are the exception rather than the rule. By most accounts, markets spend a large portion of the time ranging back-and-forth

****** Why Traders Should Include a Range-Approach in their Arsenal
  Traders should, at the very least, learn to analyze ranges for one big reason: Consistency.

 The deviation was very pronounced, as the Asian trading session was far-and-away the most profitable time-of-day for retail FX Traders.

****** How to Trade Ranges
 The basis of a range-approach is support and resistance – and the ability to see prices move between those two boundaries.

 This is the great part about price action: It isn’t esoteric, nor is it ‘theoretical.’ Price action is simply noticing that buyers had entered the market at a certain price – thereby ‘supporting’ that market at that price level – or the fact that sellers had come in as a new, higher prices were offered, thereby ‘resisting’ in that market.

****** This is the Reason that Ranges can be So Beneficial to Traders
 And the best part about the range – there is no guesswork.

 The best part about trading the range is that risk is always defined.

 there is no guesswork with profit targets.

***** The Price Action Cheat Sheet [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2014/07/18/The-Price-Action-Cheat-Sheet.html?CMP%3DSFS-70160000000Nc3MAAS][see]] :que:cal:
 - This article is an extension of our series on the topic of price action analysis.
 - In this article, we look at characteristics of trading in each of the three primary market conditions.

 As we explained in The Guiding Hand of Price Action, markets will generally display one of three tonalities; and depending on which type of market environment is being displayed, traders should look to adjust their approaches and their strategies to most adequately address that overriding market condition.

****** Range
 The Range-bound market condition is most common condition that traders will see in most markets; and this is where price discovery takes place. The range-bound market is often considered the Best Market Condition for Retail Forex Traders; and this is backed up with statistics from the DailyFX Traits of Successful Traders series.

****** Breakout
 The transitory condition from a range to a new trend is a breakout. Breakouts often come around news events, data announcements, or geopolitical surprises. This new information gets priced into markets fairly quickly – as no traders want to be caught off-guard, market makers most definitely included.

****** Trend
 After prices have broken out from previously-defined support and/or resistance, if the movement is to continue, a new trend will form.

***** The Price Action Trader’s Plan [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2014/07/24/Price-action-traders-plan.html][see]] :que:cal:
 - This article is an extension in our series on the topic of Price Action Analysis.
 - In our last article, we looked at a ‘cheat sheet’ for trading in each of the three ‘conditions.’
 - In this piece, we’re going to integrate the cheat sheet with the nuances of an approach/strategy.

 The article where we can show you how to use price action to find trades and enter positions.

 And this is where price action comes into play. Just like fundamental analysis, or technical analysis – price action is not perfect (nor is it perfectly predictive). It’s simply the cleanest look at the chart and historical price patterns so that traders can get an idea for what may happen in the future.

****** Don’t Wake Up in a New World Every Morning and Don’t Fly by the Seat of Your Pants
 If you want an example of a trading plan, the article, The Four-Hour Trader, A Full Trading Plan shows an example of how price action can be used in a Trend-Trader’s ‘plan-of-attack.’
****** Go With the Flow – Pick the ‘Right’ Strategy for the ‘Right’ Market
 Well markets display distinct characteristics depending on which market condition is being displayed.
****** Use Time Frames to Define Stance
 Any discussion of strategy in this series has pointed to multiple time frame analysis. This is the use of more than one chart to decide how you want to trade in that market.
****** How to Catch Entries Once You’ve Diagnosed the Trend (or lack thereof)
 The future is unpredictable whether we’re talking the next tick, the next hour, or the next day. There is no such thing as a perfect entry.

 The beauty of the wick is that they show the early stages of a potential reversal. Further – it allows the trader to adequately define their risk.
**** texts
***** A Theory Of Intraday Patterns: Volume And Price Variability
***** 2004 Investment Risk Management [Chong]                       :que:pla:
***** Essential Technical Analysis                              :pla:que:ref:
***** How To Use The RSI                                                :que:
***** Combining Bollinger Bands and RSI                                 :que:
**** videos
***** 360 course
***** odvc
 course plan to go through all vids and then test some ideas on the tools which have the most appeal. the assignments are good guides as to how to analyze in preparation for a trade.
****** money management
 prepare to take losses intelligently with stops and limits
 make decisions on analysis
 5% rule
 most important aspect possibly in trading
 demonstration through backtesting with macd (worth contemplating)
 staying power can affect profit

 tl: emphasizes 1:2
 rk: pretrade prep and don't babysit, but can use pricealerts

 As you can imagine, there really is not set strategy for stop placement. A 50 pip stop on the AUD/NZD is not the same as a 50 pip stop on the GBP/JPY.
 [[http://www.dailyfx.com/forex_forum/money-management/178723-1-do-you-have-question-money-management-4.html][tom long answer]]

 another [[http://www.dailyfx.com/forex_forum/money-management/178724-2-money-management-assignment-place-trade.html?cmp%3DSFS-70160000000NbUGAA0][maria-o-ch]] and good item on trailing stops there too as well as tyler's: "My favorite Money Management Rule is to never average losses."

****** candlestick patterns
 relation btw open/close shows price action
 screens out noise
 market sentiment indication and reversals
 these patterns become relevant at certain times
 single patterns (consecutive strengthens plan)
 - dojis: market indecision, possible trend change
 - shooting stars
 - hanging man, hammer
 - spinning top: indecision
 multiple candles
 - morning/evening star
 - bullish/bearish engulfing
 - piercing/dark cloud
 - abandoned baby
 - 3 inside down
 - tristar
 continuation patterns
 - falling/rising 3 methods
 - bearish/bullish 3 line strike
 - 3 black crows, 3 white soldiers

 jw: looks for long wicks going with the trend
 rk: uses to identify changes in trend

 [[http://www.dailyfx.com/forex_forum/candlestick-charts-patterns/178005-2-candlesticks-assignment-place-trade.html?cmp%3DSFS-70160000000NbU1AAK][homework p1]]
 maria-o-ch #4

****** support and resistance
 some traders based entire plan on support/resistance
 yesterday's high/low can sometimes be r/s, prices 'bounce' off
 round numbers provide psycho points
 moving averages (20,50,200) can be s/r
 bollinger bands can be s/r (useful when ma doesn't work)
 oscilators can provide s/r (go in direction of trend though)
 fibonacci retracement levels can give s/r
 pivot points (last session h,l,c) can give s/r

 mr: channel idea for entry
 rk: look for respect s/r 3 times~

 [[http://www.dailyfx.com/forex_forum/support-resistance/178007-2-support-resistance-assignment-place-trade.html?cmp%3DSFS-70160000000NbUQAA0][homework p1]]
 maria-o-ch #2

****** trend trading
 go with trend and don't worry about entry so much
 look for clear trends in different currency pairs
 take advantage of many pairs being available
 recognize up,down,range
 use longer term to determine trend for shorter time frames
 look at forest before the trees
 4:1 to 6:1
 shorter offers more, but longer offer better
 trend determinators: 200ma,50ma,macd,rsi,bollinger bands
 best approach is to use the market itself
 some pairs show stronger trends
 daily best technical analysis and determining trends
 minimum of 100 candles

 tl: go through 1yr daily to find strongest trends
 rk: dailies and use 200ma and uses multiple timeframe analysis

 [[http://www.dailyfx.com/forex_forum/trend-trading/178742-1-do-you-have-question-identifying-trend-2.html][question p1]]

 [[http://www.dailyfx.com/forex_forum/trend-trading/178743-2-trend-trading-assignment-place-trade.html?cmp%3DSFS-70160000000NbUGAA0][homework p1]]
 maria-o-ch
 [[http://www.dailyfx.com/forex_forum/trend-trading/178743-2-trend-trading-assignment-place-trade-3.html][homework p3]]
 bigcou
****** range trading
 enter/exit as close to s/r as possible, but go for quartile
 3 points of confirmation
 stop should accommodate false breakouts
 good traders expect and prepare for the worse
 don't push a good trade into a dangerous risk situation
 basic rule is to seek 1:2 ratio
 watch for spillovers
 right pairs for range trading: 
 - look for tight interest rates
 - close trading partners
 - similar growth prospects
 - off business hours
 - holiday times
 - prior to news releases
 technical indicators
 - bollinger bands
 - adx
 - atr
 trade management for ranges
 - more forgiving entry strategy than for trend trading
 - ewe, bwe, fwe (probative entry guidelines)

 jw: bollinger bands to determine entry in picky way and for morale
 rk: middle of range not good entry also uses stochastics and rsi

 [[http://www.dailyfx.com/forex_forum/range-trading/178747-2-range-trading-assignment-place-trade.html?cmp%3DSFS-70160000000NbUGAA0][homework p1]]
 maria-o-ch

****** carry trade
 carry trades are longterm investments
 rollover rates provided as S/B
 go for strong trending move that support the interest rates
 time is your friend if you choose well
 nation offering higher interest rates attract more investments
 interest rate outlook analysis
 LRA not HRA for carry trade
 countries with high rates have further to fall
 RA shifts causes sharp changes
 carry trade index forecasts risk - where is it?
 volatility increases RA
 aud still a high yielder
 TED spread - check it out since we have it!
 good examples
 mm using manual trailing stop

 jw: conditions need to be right LRA (S&P); loose trailing stops
 tl: bank analogy; both things going for you!

 [[http://www.dailyfx.com/forex_forum/carry-trading/178744-1-do-you-have-question-carry-trading.html?cmp%3DSFS-70160000000NbUGAA0][questions p1]]
 rollover calendar and explanation
 interest payment explanation

 [[http://www.dailyfx.com/forex_forum/carry-trading/178745-2-carry-trading-assignment-place-trade.html?cmp%3DSFS-70160000000NbUGAA0][homework p1]]
 tiger and maria-o-ch

****** trading the news
 cause of extreme volatility
 example illustrating difficulty of trading at other prices
 keys to trading the news and benefitting from volatility 'other guy'
 usa news releases are best to follow
 offer most liquidity eg eur/usd
 trading the news report and others at [[http://www.dailyfx.com/forex_market_news][forex market news]]
 fxcm forecasts [[http://www.dailyfx.com/calendar][economic calendar]]
 straddle: preps for either b/s
 reversal:  enables getting into the market change with the pros
 pre-release: enter 5 min before nfp
 post-release: use s/r to determine entry after nfp
 dual spike: 3 candles; rationale for working well
 initial spike: enter in opposite direction of spike
 calm: scalp 12hr before release btw large orders creating s/r

 mr: 60min within channels and 5min wick caused by protection~
 jw: 1st week of month trade s/r btn news events

 [[http://www.dailyfx.com/forex_forum/trading-news/178748-1-do-you-have-question-trading-news.html?cmp%3DSFS-70160000000NbUGAA0][questions p1]]
 bank intervention
 news.lua post and file
 news release calendar and explanation post by mr
 [[http://www.dailyfx.com/forex_forum/trading-news/178748-1-do-you-have-question-trading-news-2.html][questions p2]]
 price movement opposite from news expectations sometimes by mr
 from rk [[http://www.dailyfx.com/calendar/bank-calendar.html][bank calendar]] to get announcements

****** moving averages
 2 guidelines for trading
 many tools for determining the trend - helps filter the noise
 can help identify support and resistance
 multiple ma can help determine the trending moves
 not useful in range and can lead to being whipsawed
 longer time frames are more reliable
 interesting that multiple ma crossed at same place in lesson2
 examples using ma with other indicators

 rk: 200ma on every chart; s/r use, crossovers
 tl: 200ma just for trend; scalping on 1min chart

 [[http://www.dailyfx.com/forex_forum/moving-averages/177969-3-moving-averages-assignment-place-trade-2.html][homework p2]]

****** macd
 from emas identifies changes in momentum
 how to look for trading opportunities
 entry when there is crossover ("fine tuned" ma crossings)
 +-divergences
 bullish signal when market moves down but macd doesn't 
 late signals can be a good thing because they keep trader out of a trade
 weakness with just ma is they lag - macd development rationale
 macd with multiple timeframe analyses
 histogram indicates changes in momentum
 can change short,long,signal values for more volatile markets
 can use to protect position based on reflection of momentum

 rk: indicator not the first thing; 4 check points and macd is a trigger
 mr: ways to mitigate weakness of delay - uses 3-5 bars on histogram

 [[http://www.dailyfx.com/forex_forum/moving-average-convergence-divergence-macd/177987-1-do-you-have-question-macd.html?cmp%3DSFS-70160000000NbUGAA0][questions p1]]
 not good with short term

 [[http://www.dailyfx.com/forex_forum/moving-average-convergence-divergence-macd/177988-2-macd-assignment-place-trade-3.html][homework p3]]
 maria-o-ch

****** stochastics
 an oscillator which can determine overbought >80 or oversold <20
 wait for candle to close
 can give second chance +-divergence
 short term more, long term more reliable
 fast and slow versions all using ma
 work with trends
 stochastics pop - take advantage of market momentum
 divergence is a key for many indicators
 full stochastics

 tl: helps time entry; 15,5,5; no real predictive value by themselves
 mr: macd/rsi as well to combine reliability with timeliness

 [[http://www.dailyfx.com/forex_forum/stochastics/177940-1-do-you-have-question-stochastics.html?cmp%3DSFS-70160000000NbUGAA0][questions p1]]
 jw macd,rsi,stochastics do basically the same thing
 warrenvan stochastics with fib
 tl post on macd,rsi,stochastics
 [[http://www.dailyfx.com/forex_forum/stochastics/177940-1-do-you-have-question-stochastics-2.html][question p2]]
 nurotic analysis

 [[http://www.dailyfx.com/forex_forum/stochastics/177941-2-stochastics-assignment-place-trade.html?cmp%3DSFS-70160000000NbUGAA0][homework p1]]
 pipstealer discussions
 maria-o-ch
 [[http://www.dailyfx.com/forex_forum/stochastics/177941-2-stochastics-assignment-place-trade-2.html][homework p2]]
 1601053957's stochastic trade post
 PeterPetrelli

****** bollinger bands
 a versatile indicator
 guidelines for trading: trend and timing
 ma indicator to help entry/exit
 blue/red candle shows buyers/sellers coming back to market
 close bands suggest future breakout
 daily offer better and shorter offer more
 a volatility filter
 trend and trade indicator
 - 15 guidelines by bollinger
 - rubbing the bands
 - sometimes you need to enter multiple times
 trendless environment
 - closeness of the sd bands indicate volatility
 - horizontal bands suggest ranging

 mr: 12pm-12am slowest time good for range situation and different periods
 jw: chart tabbing; spring idea for breakout; watch for headfake

 [[http://www.dailyfx.com/forex_forum/bollinger-bands/177985-1-do-you-have-question-bollinger-bands.html?cmp%3DSFS-70160000000NbUGAA0][questions p1]]
 jw bb on 5min chart
 jw bb settings for different situations
 maria-o-ch thinking about hedging
 [[http://www.dailyfx.com/forex_forum/bollinger-bands/177985-1-do-you-have-question-bollinger-bands-2.html][questions p2]]
 mojomani strength of hug and jw ADX
 [[http://www.dailyfx.com/forex_forum/bollinger-bands/177985-1-do-you-have-question-bollinger-bands-3.html][questions p3]]
 js comment on what technical indicators are really for
 ty multiple time frame analysis for trend entries
 ty answering michael on bb usage

 [[http://www.dailyfx.com/forex_forum/bollinger-bands/177986-2-bollinger-bands-assignment-place-trade.html?cmp%3DSFS-70160000000NbUGAA0][homework p1]]
 maria-o-ch
 [[http://www.dailyfx.com/forex_forum/bollinger-bands/177986-2-bollinger-bands-assignment-place-trade-3.html][homework p3]]
 travisKL and jw comment on where bb excel

****** rsi
 an oscillator which locates over bought/sold
 gives multiple chances note +-divergences
 daily better, shorter more
 can change the number of periods
 many ways
 - failure swing
 - pattern interpretation: rsi forms sooners than price patterns
 - s/r on rsi
 - 50 level
 - trend formations
 - range shift
 - range trading

 rk: chart 1st, osc 2nd; divergence; swing failure; range shift
 mr: osc with price specific indicators; interesting breakout using rsi

 [[http://www.dailyfx.com/forex_forum/relative-strength-index-rsi/177970-1-do-you-have-question-rsi-3.html][questions p3]]
 gm and dror following discussions may be useful
 [[http://www.dailyfx.com/forex_forum/relative-strength-index-rsi/177970-1-do-you-have-question-rsi-6.html][questions p6]]
 rk having more than one oscillator is redundant
 we [[http://www.dailyfx.com/forex/education/trading_tips/post_of_the_day/2013/01/25/Learn_Forex_Trade_Stochastics_With_Hidden_Divergence.html][hidden]] and [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2012/11/20/Learn_Forex_How_to_Trade_MACD_Divergence.html][traditional]] divergence

 [[bbdb:http://www.dailyfx.com/forex_forum/relative-strength-index-rsi/177971-2-rsi-assignment-place-trade.html?cmp%3DSFS-70160000000NbUGAA0][homework p1]]
 maria-o-ch swing failure

****** ssi
 works well as a contranian indicator in trending markets with large volumes
 2 things traders try to do
 some have access to market sentiment - difficult in non-centralized setup
 fxcm has speculative sentiment index due to its size
 contrarian
 sentiment indicators are not timing indicators
 extreme reading ssi can help determine whether to sell or buy
 bias strongest on a daily chart
 use in trending markets and look for >+2 <-2
 similar to cot in futures market
 roadmap
 - point of breakout is interesting and overlooked
 - support point is very interesting (support becomes resistance etc)
 - enter using technical analysis
 - try to follow repeated waves
 1:2 at least is good money management

 tl: look for extremes and work with the trend
 jw: boat idea and look for lots going against the trend excellent explanations

 [[http://www.dailyfx.com/forex_forum/speculative-sentiment-index-ssi/178752-1-do-you-have-question-using-ssi-speculative-sentiment-index.html?cmp%3DSFS-70160000000NbUGAA0][questions p1]]
 rk ssi as standalone, then look to technicals
 [[http://www.dailyfx.com/forex_forum/speculative-sentiment-index-ssi/178752-1-do-you-have-question-using-ssi-speculative-sentiment-index-2.html][questions p2]]
 js discussion on ssi
 mr ssi not so reliable when applied to crosses - redundant to view too much
 [[http://www.dailyfx.com/forex_forum/speculative-sentiment-index-ssi/178752-1-do-you-have-question-using-ssi-speculative-sentiment-index-3.html][questions p3]]
 rk on why/how ssi is useful and what make bulk of the traders
 [[http://www.dailyfx.com/forex_forum/speculative-sentiment-index-ssi/178752-1-do-you-have-question-using-ssi-speculative-sentiment-index-4.html][questions p4]]
 currencykid on extreme ssi and tyler's answer
 video with dr doing [[http://www.youtube.com/watch?v%3DVfr0n5rWqRU][trading with ssi]] part of fxcm expo series

 [[http://www.dailyfx.com/forex_forum/speculative-sentiment-index-ssi/178753-2-ssi-speculative-sentiment-index-assignment-place-trade.html?cmp%3DSFS-70160000000NbUGAA0][homework p1]]
 maria-o-ch

****** elliot wave
 use technical indicator or candle formation to enter trade
 trend usually holds
 rn elliot noted 5 wave series followed by 3 wave trend
 waves within waves
 these waves seem to happen fairly regularly so increases confidence
 usage of multiple time charts
 almost like a language recommended books
 cardinal rules, guidelines,application,corrective wave patterns
 many interpretations possible by the ignorant and this can be difficult
 motive 1,3,5 and corrective phases
 guidelines for entry/exit
 fibonnaci numbers played a large role in developing ewt
 excellent detailed illustration verifying ew
 easier to forecast 3,5
 excellent example illustrating fractal nature via smaller timeframes
 an art rather than a science
 double wave 3 entry!
 use second guideline to optimize exit
 watch price action around support lines eg "looking for wave 5" entry
 ties in several rationale on the GBP/JPY example
 use fractal nature of markets by examining various timeframes
 corrective waves not as clear but can be mastered after the basics
 4 corrective patterns

 jw: favtrade is 78.6% retracement anticipating wave 3
 mr: 2 techniques for non-experts on ewt

 [[http://www.dailyfx.com/forex_forum/elliott-wave-trading/178750-1-do-you-have-question-elliott-wave-trading-3.html][questions p3]]
 jw excellent post on jigsaw puzzle as relating to trading
 js link to [[http://www.dailyfx.com/forex/technical/article/forex_strategy_corner/2012/02/28/Euro_Reversal_is_Likely_Within_the_Next_Few_Days.html][euro reversal article]]
 js ewt and prediction holy grail

 [[http://www.dailyfx.com/forex_forum/elliott-wave-trading/178751-2-elliott-wave-assignment-place-trade.html?cmp%3DSFS-70160000000NbUGAA0][homework p1]]
 surreyhills analysis leading to good trading opportunity
 [[http://www.dailyfx.com/forex_forum/elliott-wave-trading/178751-2-elliott-wave-assignment-place-trade-2.html][homework p2]]
 maritza's well thought out though aggressive trade
 maria-o-ch daily and 4hr assignment
 [[http://www.dailyfx.com/forex_forum/elliott-wave-trading/178751-2-elliott-wave-assignment-place-trade-3.html][homework p3]]
 dktbk and jw reply
 [[http://www.dailyfx.com/forex_forum/elliott-wave-trading/178751-2-elliott-wave-assignment-place-trade-4.html][homework p4]]
 ty answering symphox showing smaller timeframe

***** archived videos
****** asian trading video - krivio
 <2014-04-23 Wed>
 8pm - 4am est
 less volatile
 levels of support and resistance hold better
 did better without aud,nzd,jpy -> trading own currency makes volatility
 range trading selection and examples
 ranges form after big movement?
 a test is when it pulls away from support or resistance
 1hr / 10da setup to find ranges
 /i don't like this so much because there should be a better way to find a range without waiting so long by making 3 tests/:timing:plan:                                :imp:plan
****** top mistake traders make:
 traits of successful traders doc
 the trader plan doc
 price action pin bars doc
 price action swings doc
 plan is needed - don't go in without one!
 price action can determine trends - know what to look for
 watching highs showing a downtrend with eur/usd example
 script out decision-making process!
 don't be married to currency pairs - treat as business
 volatility due to nobody knowing what is going to happen!
 range trading is good, but must have strategy!
 hope can be costly!
 don't throw good money after bad - ie don't increase stops (logic exists)
 money management takes care of everything!
 trading should be a marathon not a sprint
****** stocks to forex
 doesn't need volume since it is so high anyway
 tech analysis may actually be relevant because vol so high
 lever on moves you are confident on
 ranges are playable, because trends within ranges are playable
 have tool for every situation - then you can handle each
 risk/reward ratio is something to figure out for all trades
****** trading breakout on a budget
 10:1 leverage max - traders do better with lower leverage
 need to win more than lose - not win more often than lose
 breakouts best during high volatility - during london session
 keltner channel trading - 13% winning, but how right and how wrong
 9/10 were false breakouts - but big move when right
 /so how to win even when you are wrong?/
 risk:reward 1:3 or better
**** basic education ideas and resources
***** for peechpee reading
 [[file:Come%20Into%20My%20Trading%20Room%20A%20Complete%20Guide%20To%20Trading%20%5BAlexander%5D.pdf][come into my trading room]]
 [[file:The%20Five%20Minute%20Investor.pdf][five minute investor]]
 [[file:Trading%20As%20A%20Business.pdf][trading as a business]]

***** [[http://www.dailyfx.com/forex/education/trading_tips/daily_trading_lesson/2014/04/17/3-Forex-courses-to-help-you-trade-forex.html][3 courses of interest]]
 - trade like pro (looks like a beginner course and has certificate)
 - dailyfx plus (has lots of videos and live classroom efforts)
 - 360 (premium course showing you how to see trades with vision)
***** [[http://www.dailyfx.com/forex-education][forex trading university]]
 lots of info here via webpages
 well-organized too

***** [[http://www.dailyfx.com/how_to_trade_forex/course_trading_tips][power course forex trading tips]]
 new lessons each day

***** [[http://towardsfreedom.com/tfbb/viewtopic.php?pid%3D352][zach curriculum]]
****** Trading Station 2

 - FXCM live webinar schedules: http://www.fxcm.ca/calendar-of-events.jsp

 - The Trading Station 2 live walkthrough is titled: Trading Station Software Demonstration - Rob Pasche

 - Archived platform walkthrough webinars can be accessed here: http://www.fxcm.com/resources/daily-software-demonstrations/#recorded-events


 here's the one we can use too:
 http://www.youtube.com/watch?v=QaG43BhebeI

****** Education Resources:

 1. DailyFX+ live classroom- archived sessions : Forex 101

 2. DailyFX+ Video On-Demand : Review all of the videos to understand the indicators

 3. FX 360 course (deposit required) : Fundamental, technical, and risk management

 a. You will also receive access to the weekly recap webinar

 4. DailyFX+ live classroom - archived sessions: Boutros Scalping

 5. DailyFX+ live classroom - Michael Boutros weekly scalping webinars

 a. Also enroll in Michael Boutros mailing list: http://forms.aweber.com/form/63/1731135063.htm?CMP=SFS-70160000000NbU1AAK

 6. DailyFX on Demand registration for coverage during London and NY session

 a.      Please contact me before registering as you qualify for the Active Trader discount


 In addition, you also requested the contact information of my manager.  His name is Bryan Fletcher and you contact him via email at bfletcher@fxcm.com<mailto:bfletcher@fxcm.com>.

 I look forward to working with you, and have a great weekend.

 Zach Le
 Institutional Relations, Private Client Group
 Forex Capital Markets, LLC
 2701 Dallas Parkway, Suite 600 | Plano, TX 75093
 Tel:   (972) 535-9098
 Fax:   (877) 229-0004
 Email: zle@fxcm.com<mailto:zle@fxcm.com>
***** journal structure for trading clusters
****** intro
 - one file for each pair
 - the trade cluster should present a logical argument based on premises.
 - do this on calligra words because it seems to offer the easiest access to tools.

****** premises
 - technicals
   - price action (trends, ranges, support and resistance)
   - bollinger bands and rsi
 - fundamentals
   - specific economic bases for the price action
 - psychologicals
   - ssi (and possibly other contrarian indicators)
   - roundoff levels may assist in various ways

****** execution (with rationales):
 - intended strategy (trend, range etc)
 - go in (usually entry rather than market order) 
 - get out (stop and limit)
 - the open position row from trading station 2

****** conclusion
 - the closed position row from trading station 2
 - evaluation of trade
**** some good trade thoughts from the past
 look for trades - don't just wait till the experts provide them (but scan the experts' ideas and rationales). a good trade probably looks that way in multiple timeframes.

 when we get proficient at this, we will be able to enter the various opportunities that always seem to present themselves.

***** facilitated by technicals
 - the trade should flow from a desired technical basis
 - entry should have rationale eg trend, candlestick
 - s/r should be clearly marked out
***** supported by fundamentals
 - there must be economic/event rationale for the trade
***** risk:reward opportunities visible
 - it should be easily to set stops and limits
***** global trend matches local mostly
 - the big trend should be identified and be harmonious with the local trend though pullbacks are a good way to get in
***** retracement recognition and handling
 - should have a plan for identifying and dealing with retracements
 - s/r levels should be identified and prepared for
 - should also be ready for reversals
***** scraping works
 you have to be careful not to get caught in a trend on the wrong side. it can be what we are looking for in terms of exchanging time for money in a sense. better, get on the right side of a trend and it will work like a regular profitable trade.

*** some diary entries
**** day <2014-10-15 Wed>
 *tec*
 created the aware layout which gives half the screen to chart
 *fun*
 understood risk aversion and relation to usd and jpy
 *edu*
 macd and stochastic videos
 *act*
 yesterday went below 50000 after messing up the usual way and wondered if we lose big on usdjpy since we'd put a 80pip stop. thought that prices would go down even though top of range was pierced. found at 5:30am that we'd gotten to 50500 so came out expecting retracement. proceeded to mess that up UW and then prices plummetted.

 caught waiting order at bottom of range and we were making some money, but constantly worried about retracement and tried to scalp sinking again.

 despite all this somehow managed to stay in trade to 50983, but then messed up yet again! messing up was so common now that we wondered if we could do anything right. meanwhile the price had dropped into the 2nd hr plunge even bigger than first.

 took 2 in the 3rd hour and waited till limit getting to 51350 so got out and went back in with .5, but lost 200 due to retracement. hence, it was fortunate we did get out. there may be a technique in this. after a big move, get out and do SO in order to prevent the retracement from affecting capital gained.

 waited till retracement was over and got in again with .5 and also got in on nzdjpy because of jk waiting till price came up to desired level, but it kept going as did usdjpy in other direction so we did SO. also adjusted the stops and limits using technical analyzer.
**** day <2014-10-16 Thu>
 *tec*
 *fun*
 *edu*
 *act*
 nzdjpy came through to limit putting us nearly at 51400. came out of one usdjpy. also put mini entries for nzdjpy and eurgbp short.

 the idea shall be to keep and gain on the equity. so we will rethink things today before getting into trades.

 something to think about is whether yen crosses other than usdjpy will short better later on run as jk seemed to indicate.

 ordered samsung monitor for novo from futureshop.

 went into to another .5 usdjpy because it looked as though the rising might reverse near f.5 and 106.10  and figured we could pick up some pips. also, vecchio mentioned the 1.28 long for ssi while saettele said it was in consolidation mode and would likely go down further once the 105.40 support is broken. some usd data has been encouraging but only mildly so price hasn't moved much because of this. more data to come in around 5pm today for jpy. thinking about wimping out from this second usdjpy just in case, but that sort of defeats the point of going into it in the first place. is the trade sound according to the criteria laid out? yes.  is the risk reasonable? well not considering where we put our stops really, but that's in case it spikes and comes down ... which is actually unlikely given that there is very little news upcoming over the rest of the week. however, we came out anyway with 7.41 simply because we weren't sure about the situation and want to see how the stochastic indicator works ... so far it's been good on the buys, but bad on the sells (and it is presenting a sell right here). decided to bring the stop down to just above the resistance level as before.
**** day <2014-10-22 Wed>
 prices go against us from sun-wed even though mon night we could have come out with 50900 but chose to stay in. there seem to be mixed projections of what's going to happen with usdjpy, but the one we like is [[http://www.forexnews.com/blog/2014/10/20/top-trade-idea-october-20th-2014-usdjpy/][todd gordon's]] elliot wave analysis which we found quite interesting.

 we have been making money on various trades over the past few days, but mainly on micro though we did get a good eurjpy for 160, so we seem to be on the right side. we wonder if we are too invested in usdjpy and are not taking proper advantage of other opportunities.

 we will go throught trading chaos material and see how we can apply the ideas. so far it looks really good.

 missed a 100pip drop on nzdjpy because we thought the pair was going to stay in the upper range. we didn't check the news tosee that there was a nzd event of considerable significance. so we need to study and still be ready to take advantage of every news event.
**** day <2014-10-23 Thu>
 well todd's idea bombed out and ilya's short gbpjpy also did. so now we are at 48000, but still think that jpy will get stronger so we are trailing entries on gbpjpy, eurjpy, usdjpy. where is this so-called strong yen? even ilya writes that the weak eur will create risk aversion resulting in a demand for jpy.

 after some other trades we got up to 48300, but then fell to 47755. we are now attempting to reach 48800 using minis on gbpjpy, eurjpy, usdjpy. the difficulty is really interesting. i am so "gung-ho" on these going down that i don't even consider the opportunity when they go up. possibly, i've become visually attached to things coming down so much that i don't see there is no difference when they go up? the feeling that whatever we do is going to go against us gets strong at this point too even though there is no need for it. we have an opportunity to eliminate this feeling and trade purely rationally provided we can figure out just what to look for.

 we don't change our trade even when reality confronts us because we are so dependent upon the theoretical progress based on fundamentals, technicals and expert opinion. this inflexibility has cost us severely to the tune of 7000 over 3mo. i think adaptability to reality is required if we are going to do all this properly.
**** day <2014-10-27 Mon>
 after some minor wrong trades we are at 47359. we still haven't created a sensible approach to trading yet, though are attempting to do so.
**** day <2014-10-31 Fri>
 we missed out on the biggest move ever as the usdjpy went soaring up 300+ pips. we could have caught it had we realized the boj announcement was at 9pm when we were still up. in fact, had we gone into this with 5 lots as per breakout2, we would have not only recouped all our losses, we would have made enough money to see us through till the end of the year. there must be something internally incorrect with my attitude and approach about forex trading, since i seem to lose and lose out regularly.

 we never even looked at the pair because we were too busy looking at other things such as the system we are going to use. we are paying more attention to our techniques than the market - there may be a key in that! for instance, over the past weeks, we've regularly seen how the usdjpy is reluctant to go down. could that behavior have led us to conclude that there was going to be a huge surge up? can we find behavoral personalities in the currencies which could lead us to make intelligent choices and effective approaches? understanding the market's behavior may be more useful than fundamentals and technicals, perhaps, because then you are not removing yourself from the actuality of price movement. you become in phase with the market.

 we may need to develop a very image to manage this aspect, but possibly that is what we should really work on more rather than the other things we've been doing.

 ilya's eurusd came through overnight while his usdchf worked out yesterday. he missed the usdjpy, but had wanted to go long, so at least he got a moral victory there too!

 none of this is going to work unless we develop awareness and confidence. we need to understand the market much better and appreciate the possibilities it offers. we also have to stop nonsense like "i don't trust the yen" - this is no way to tune into what is happening. in fact, it seems the statement itself could have helped to predict the 300pip move. these things are all signals to the astute individual and if we do not cloud ourselves with expectations, we can use these signals effectively.

 it was particularly interesting that last weekend i had the idea that this week we'd be able to recoup all our losses. had i followed ilya with usdchf and eurusd we would have $4000 while if i had even gone in to usdjpy with a standard lot, we would have made $3000.

 so much of this seems to be coming down to trusting oneself and seeing the market ... both of which will require dealing with the ego as it is in so many other areas. while there are expectations, there is "I" and no room for the market. 
**** day <2014-11-04 Tue>
 since sunday we've managed to lose nearly $40 trading micros! this is particularly amazing when you think about the number of pips lost. all of this was done trying to do small, fast trades. what it shows is that we can consistently be on the wrong side of the market. if we could reverse this pattern, we could have been $40 up ... or more. we need to find out what it is that gives us the skill to be against the market so effectively!
**** day <2014-11-07 Fri>
 hastpi seems to be a system that may work effectively on 15m. we have been testing it and need to fine tune the rules with s/r. when near s/r (established earlier or sometimes on the go), we should be prepared for a bounce and adjust our next step accordingly.
**** day <2014-12-09 Tue> 
 lee anne helping with vps 
**** day <2017-01-17 Tue>
 trade from previous friday's dither eurusd3358481, usdjpy3358484
 improprieties:
 1. extended sltp without taking into account major trend and sentiment
 2. did not look for nu patterns wrt incline on usdjpy3366369 try again

 looking for turning points is very difficult, but we can still utilize contrarian ideas locally
*** trades of interest
**** nick cawley EURGBP 180510
 My Picks:  EURGBP - Pending Short as 200-dma Nears
 Expertise:  Technical and Fundamental Analysis
 Average Time Frame of Trades:  One day to two weeks
 the second quarter of 2018

 Update – Trade Opened on May @ 0.88315

 Our short EURGBP positioned was opened on May 10, just above the 200-day moving average. Our targets remain the same – see story below.

 EURGBP - Pending Short as 200-DMA Nears * Update*
 Original Story - - EURGBP Bounce Opening a Short Trade Opportunity

 Two weak currencies battling it out for dominance in a trading pair opens the door for a short-term trading opportunity, especially after a sharp move. Both the ECB and the BoE are currently unable to proceed with any kind of monetary tightening as inflation stymies policy normalization. While UK interest rates are being pushed further back – an August 0.25% rate hike is currently priced around 42.5% - and may not happen at all this year, the first interest rate hike in the Euro-Zone is not likely until mid-2019 at the earliest and even then, it is likely to be 0.10%. In addition, with Euro-Zone growth slowing down and inflation remaining stubbornly below target (near to 2%), the ECB are likely to extend their bond buying program when it ends at the end of September for at least three months, keeping monetary policy looser for longer.

 On the charts EURGBP is now nearing its most expensive level since September 2017 readings, according to the relative strength indicator and is nearing its 200-day moving average which it rejected twice in the last week.

 Looking at EURGBP, today’s sharp jump in the pair – after the BOE MPC meeting – may offer an opportunity to short EURGBP. We look to open the position just above the 200-day moving average, currently at 0.88315 and will place a stop just above the intersection with the short-term upward channel at 0.89000. Our first target is the recent double low at 0.86820 with our second target at the April 17 low at 0.86200.

 Chart: EURGBP Daily Price Chart (April 2017 – May 10, 2018)

 EURGBP - Pending Short as 200-DMA Nears * Update*
 Entry Point: 0.88315.

 Target 1: 0.86820 – Recent double low.

 Target 2: 0.86200 – April 17 low.

 Stop-Loss: 0.89000

 --- Written by Nick Cawley, Analyst
*** praDOCS
  this is all the google docs accummulated in the past for prader
  it is kept here so we can start a new prader docs
**** ToDo
  Use fxcm resources to learn python algo programming. There is much more there than just the tutorials as a result of many contributors. We can design things based on some of the work there and test on truefx data.

  Set up python forex analysis station

  Past trades

  Movements on donchian channel

  Determine various patterns such as nunu

  Convert tick data to various ohlc

  Three pair isolations

  Heiken Ashi meaning through analysis - or create your own candlestick

  Donchian channel analysis - bounsr or penesr frequency on the 3 lines. 

  Tick reader and analysis for truefx data - test ideas like frequency of pivot level bounces.

  Time pointer ma system with pandas

  Analyser with various indicators running continuously on demo for now to make decisions manually

  Alternation of bar colors vs maintaining same color.

  Is there pattern to distance travelled and retracement?

  Bull & Bear strength changing in shorter Time frames May indicate what the future will hold.

  What are tick, bidask patterns during movement?

  Reactive vs predictive implementations - former is doable with computer.

  Since most activity is ranging, bounsr should be more prevalent than penesr.

**** Plans
  HEIDON
  Uses Donchian Channel and Heiken Ashi (don't really need the latter)

  Set DON to 24 periods on h6 with middle line. That way we have a week’s maxmin.

  Set HEI.

  We try to trade from DON maxmin thereby using small sl (<30p) and large tp.

  Middle line, when used is first bounsr then penesr?

  HEI trend set after 3 candles.

  Trail the stop from prior maxmin?

  If ha is going towards maxmin, set entry close to maxmin.

  If ha is going away from maxmin, but near it, enter assuming you would have had you caught it earlier.

  If maxmin breached, ha should be touching it on every candle and we have a breakout that we can try getting into.

  Use ha doji and spinning tops to expect movement in either direction. A cot system may be setup for these.

  Look for even numbers and confirming dnc levels from the past.

  Use fib between maxmin to assist in determining entry points especially after large moves.

  When price stays at a level for extended period of time, it may rebound?

  Use ssi to confirm if appropriate.

**** Study
  Udacity (tucker) course with ML_Mitchell book
  Most useful course since it is ml specific to trading

  VanderPlas Datascience handbook
  Numpy
  Pandas (probably need to learn this really well)
  Matplotlib

  Joshi book because it has an excellent format
  Work through

  FXCM Api with python
  Get it to work to download data
  Convert to ohlc
  Get slines to work

  Figure out yves backtesting setup which uses log.
**** Projects
  SIPR - signals project. This would be very similar to pythonparseltongue’s forex system in that we use a large number of indicators to decide whether to enter a trade. We would want to set up forex trading signals with fxcmpy and then get autotrading to work using these in some way. This project could be particularly Suited using the liteForex strategies because they utilize indicators and provide the rules. Therefore it would be a simple matter to incorporate these and test them on the true FX data.

  PRO - pattern recognized outcomes. Develop pattern testing with data to understand repetitions properly. These should involve not only your own ideas, but various combinations of known indicators. Certain patterns like nunu are statistically reliable and there are likely several of these across various timeframes. We need to develop a recognizer and its outcome which may be a job for unsupervised learning.

  PPAM - pure price action martingaled. A version of this was to go in same/opposite direction after x points and switch with price action this idea led to huge profits when the spread was 2 pt and successful to 8pt (unfortunately we can't find that program any more, but have re-created it take key sr into account). PPAM simply doubles trade size at every turn. It actually worked surprisingly well as far as bidi was concerned. Both ideas have merit, though the martingaled version may possibly be shown to be mathematically superior for reasons unknown at this stage.

  DMA - double moving averages. Martingale strategy with two orders using moving averages.  This may be worth thinking about. This is actually a variation of PPAM - one of the very first ideas we had - go in one direction, but if negated, double in the opposite.The ‘negated’ concept is being implemented by a faster ma which produces double trades when in direction of slower ma, but minimizes losses when opposite to slower ma.

  CC - criss-cross. Instead of looking for patterns can we create a Criss-Cross of trades to utilize noise?

  TLINES
  tlines is a variation of slines using ticks instead of the 1m bars. the various slopes produced can be used to determine actions.
  the calculations don't need to come every tick though. they can be done every x ticks where x could be determined by volume possibly.
  tick densities in a sample can determine a concept similar to wicks, but possibly more relevant.
  step 1
  create mechanism for accepting ticks into an array for the purpose of calculation. 
  - a pointer system for queue should be preferable to copying array pieces.
  - have the ticks displayed probably on matplotlib as they come in.
  Check historical data to see which moving averages actually signal a trend change and for how long.

  ZZ
  Pivot point analysis on historical data. Apparently, pivot points work well in fx because they are liquid (Using Pivot Points In Forex Trading). The article seems to be a particularly good one with historical stats.

  Examine tick density development over time.

  Work out differences methods ppt.

  Used different lengths look backs overtime to see if they predict the same thing.

  Range breaking and unnumbered patterns??

  Use vast amounts of data to see how trading differs at different times. Being able to do this, may result in figuring out the best ways to create sample training data sets. In other words, if there is a pattern that holds consistent throughout the years, it is possible to have different models for different times of the year. The idea of a year of course is just an example. It should be possible to use other criteria than just time.

  Test wick success rate for various times and pairs.

  Daily chart Manual trading accompanied by minute chart computer trading of patterns?

  One issue is we get trailing stopped out and aren’t around to get back in. computer can monitor?

  Check out stats for candle patterns on historical data over the years. Has anything changed?

**** Pradata resources
  Andrew Ng
  Data Trees and Random Forests
  Sendex
  Pythonparseltongue
  Udacity (tucker)
  Kevin Davey webinar
  Soulas Shasha Online Machine Learning Algorithms For Currency Exchange Prediction
  WEKA
  Probably not immediately useful since we are going with python.

  May be helpful as a resource on the go at some point in time.

  Others
  Sentdex through pandas
  Fairly direct but slow going since Harrison simplifies for newbies

  No use of pandas as far as I know

  Still the ideas are worth examining


  Machine learning recipes josh gordon google developers

  Josh teaches well and is worth following up


  MLM crash course

  Possibly useful but too disjointed beyond his idea of small projects

  Imho it is sensible to learn the math rather than avoiding it


  HowardB, , , , BryanDowning

  Python for finance specifically algorithmic Trading

**** Zotes
  Optimization of optimization may be possible by
  Cross-validation taking samples of various sorts (kfold) from existing data
  Regularization
  Ensemble learning

  Pattern recognition through datasci understanding
  Testing with truefx data
  Yves webinar ideas
  Sentdex pattern store

  Pivot points
  If pivots conicide with other sr levels, a stronger case can be made. This is something  that can be tested using historical data quite readily.
  We can test how well pivot points hold up for contrary vs directional trading on longer tf.

  Not there at right time
  One of the difficulties with trading is not being there at the right time. sometimes you only know when the right time exist after the fact, but very often support resistance lines are breached clearly indicating what's the right time was. There seem to be two solutions to this problem. one is to map out sr lines and place pending orders. Another, would be to have prices being regularly monitored through a script. 

  Thots
  Explore DailyFX analyst picks, trading alerts etc
  Not too clear how they are doing anything
  Illogical to spend much time on these if we are setting up our own
  Dailyfx analyst picks are worth examination because logic is provided

  Retracements
  Smaller when with next level up trend
  Larger when against next level up trend
  Similar to spacings between ma of 2 periods
  Don't move stop too close when profits are coming in. Better to come right out or stay back at a safe logical distance.

  Tick progressions may show the way to raging moves
*** ga
  ga thots 2016-02-18 12:01:21.621

  idea of chromosomes producing best rules is good, provided we have a set of good rules to begin with possibly.

  however, we still aren't dealing with the basic idea that different rules will work better in different market situations.

  need to develop some parameters through which we can identify immediate mc and assume its durability.

  finish the atrsltp trailing idea.
  then work on figuring out how to determine the mc state using various tools available and created.

  mcs will have specific number of distinct values, though it may be useful to examine transitions. using optimization we should be able to develop ntrxit models that work for each mcs value.

  consider possibility of using optimization itself to determine mcs. using very simple ntrxit it may be possible to curve-fit to certain sections thereby identifying an mc.

  every x bars should be identifiable as a pattern with at least a beginning. therefore it should be possible to apply a process to each pattern to generate the most gain. idea similar to any pattern match like miimai or hathre.

  the pattern should be determined in context possibly through indicator combos rather than just bar information. see katz' ga and the idea becomes apparent.

  should we test pradoc using ses? how about using pseudo-random data? can the latter be used to determine mcs?


** initial sring theory ideas and research
 support resistance theory through pa examination.
*** formation and forms
 sr is formed whenever nu (spikes have visible nu in smaller tf)
 sr come in various forms:
 - horizontal which are most robust
 - angled which are formed through a series of horizontals which align:
   - channels
   - wedges (channels lines that narrow)
   - triangles (wedges lines that narrow to a point)
     - a/descending being most lucid
*** management of sr
 sr used for determining bounsr (80%) and penesr (20%)
 
 - major sr 
   - drawn on significant nu of weekly and daily charts in yellow
   - existence rules:
       if !penesr draw solid
         elif penesr=1 change to dashed
         elif penesr=2 remove

 - minor sr
   - these are nu on 4hr and 1hr charts in blue
   - they are likely shortlived and will often coincide with gridlines
   - can be used to maneuver sltp during trade

 - grid sr
   - exist at whole number levels 
   - they are everlasting sr since orders will always be drawn to them
   - use to maneuver sltp

*** enex

 EN
 - entry near sr
 - direction consistent with ma
 - screening from autochartist and candlestick
 EX
 - near sr unless momentum looks strong then use ts
 - if strong candle against trade re-evaluate

*** moving averages
 used to confirm trends on 4hr chart.
 maS: wma6 1da pa, helpful for momentum
 maM: ema36 1wk pa, establishes main direction
 maL sma216: pa over 200 periods, shows longterm movement
*** documentation codings
 - autochartist ac
 acac, acdc, acat, acdt, acar, acds, acbr, acbs
 a|dc a|descending, b - break,
 c channel, t triangle, w - wedge 
 r resistance, s support
 - candlestick cs
 -moving average ma
 maSML or just ma for all
 - other codes
 50r 50% retracement
 hh higher high, ll lower low
*** routine
 avoid placing trades btn 14:00-15:00 due to high spreads
 entry trade setups (23:00, 14:00) 1h before opening of east and west
 - ac, cs, remaining pairs
 - evaluate, terminate, initiate
 examine progress throughout day when convenient?
 may be possible to time with ac alerts?
*** TODO sr quality
*** TODO trend change
 something happens just before a new trend starts
 - compression: indecision
 - wicks: redecision
*** TODO understand what happens going against trend
*** TODO understand stalls
 these are possibly best observed in 1h or less.
 stalls will often go in the opposite direction of the coming big move, as though they are bending a plank before its release.
 also, wide nu will usually follow the curve.
*** TODO patterns
 nu,un - see if fib ratios can help
 sr brk pullbacks - sr brk, catch behind sr provided other elements support
 convex vs concave trends
 what is a nu? can nu in lower tf be used as entry?

